// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/entitymanager/v1/filter.pub.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "anduril/entitymanager/v1/geoentity.pub.pb.h"
#include "anduril/entitymanager/v1/location.pub.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
namespace anduril {
namespace entitymanager {
namespace v1 {
class AndOperation;
struct AndOperationDefaultTypeInternal;
extern AndOperationDefaultTypeInternal _AndOperation_default_instance_;
class BooleanType;
struct BooleanTypeDefaultTypeInternal;
extern BooleanTypeDefaultTypeInternal _BooleanType_default_instance_;
class BoundedShapeType;
struct BoundedShapeTypeDefaultTypeInternal;
extern BoundedShapeTypeDefaultTypeInternal _BoundedShapeType_default_instance_;
class EnumType;
struct EnumTypeDefaultTypeInternal;
extern EnumTypeDefaultTypeInternal _EnumType_default_instance_;
class HeadingType;
struct HeadingTypeDefaultTypeInternal;
extern HeadingTypeDefaultTypeInternal _HeadingType_default_instance_;
class ListOperation;
struct ListOperationDefaultTypeInternal;
extern ListOperationDefaultTypeInternal _ListOperation_default_instance_;
class ListType;
struct ListTypeDefaultTypeInternal;
extern ListTypeDefaultTypeInternal _ListType_default_instance_;
class NotOperation;
struct NotOperationDefaultTypeInternal;
extern NotOperationDefaultTypeInternal _NotOperation_default_instance_;
class NumericType;
struct NumericTypeDefaultTypeInternal;
extern NumericTypeDefaultTypeInternal _NumericType_default_instance_;
class OrOperation;
struct OrOperationDefaultTypeInternal;
extern OrOperationDefaultTypeInternal _OrOperation_default_instance_;
class PositionType;
struct PositionTypeDefaultTypeInternal;
extern PositionTypeDefaultTypeInternal _PositionType_default_instance_;
class Predicate;
struct PredicateDefaultTypeInternal;
extern PredicateDefaultTypeInternal _Predicate_default_instance_;
class PredicateSet;
struct PredicateSetDefaultTypeInternal;
extern PredicateSetDefaultTypeInternal _PredicateSet_default_instance_;
class RangeType;
struct RangeTypeDefaultTypeInternal;
extern RangeTypeDefaultTypeInternal _RangeType_default_instance_;
class Statement;
struct StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
class StatementSet;
struct StatementSetDefaultTypeInternal;
extern StatementSetDefaultTypeInternal _StatementSet_default_instance_;
class StringType;
struct StringTypeDefaultTypeInternal;
extern StringTypeDefaultTypeInternal _StringType_default_instance_;
class TimestampType;
struct TimestampTypeDefaultTypeInternal;
extern TimestampTypeDefaultTypeInternal _TimestampType_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace entitymanager {
namespace v1 {
enum Comparator : int {
  COMPARATOR_INVALID = 0,
  COMPARATOR_MATCH_ALL = 11,
  COMPARATOR_EQUALITY = 1,
  COMPARATOR_IN = 9,
  COMPARATOR_LESS_THAN = 2,
  COMPARATOR_GREATER_THAN = 3,
  COMPARATOR_LESS_THAN_EQUAL_TO = 4,
  COMPARATOR_GREATER_THAN_EQUAL_TO = 5,
  COMPARATOR_WITHIN = 6,
  COMPARATOR_EXISTS = 7,
  COMPARATOR_CASE_INSENSITIVE_EQUALITY = 8,
  COMPARATOR_CASE_INSENSITIVE_EQUALITY_IN = 10,
  COMPARATOR_RANGE_CLOSED = 12,
  Comparator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Comparator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Comparator_IsValid(int value);
extern const uint32_t Comparator_internal_data_[];
constexpr Comparator Comparator_MIN = static_cast<Comparator>(0);
constexpr Comparator Comparator_MAX = static_cast<Comparator>(12);
constexpr int Comparator_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
Comparator_descriptor();
template <typename T>
const std::string& Comparator_Name(T value) {
  static_assert(std::is_same<T, Comparator>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Comparator_Name().");
  return Comparator_Name(static_cast<Comparator>(value));
}
template <>
inline const std::string& Comparator_Name(Comparator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Comparator_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool Comparator_Parse(absl::string_view name, Comparator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Comparator>(
      Comparator_descriptor(), name, value);
}
enum ListComparator : int {
  LIST_COMPARATOR_INVALID = 0,
  LIST_COMPARATOR_ANY_OF = 1,
  ListComparator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ListComparator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ListComparator_IsValid(int value);
extern const uint32_t ListComparator_internal_data_[];
constexpr ListComparator ListComparator_MIN = static_cast<ListComparator>(0);
constexpr ListComparator ListComparator_MAX = static_cast<ListComparator>(1);
constexpr int ListComparator_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ListComparator_descriptor();
template <typename T>
const std::string& ListComparator_Name(T value) {
  static_assert(std::is_same<T, ListComparator>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ListComparator_Name().");
  return ListComparator_Name(static_cast<ListComparator>(value));
}
template <>
inline const std::string& ListComparator_Name(ListComparator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ListComparator_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ListComparator_Parse(absl::string_view name, ListComparator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ListComparator>(
      ListComparator_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class StringType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.StringType) */ {
 public:
  inline StringType() : StringType(nullptr) {}
  ~StringType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StringType(
      ::google::protobuf::internal::ConstantInitialized);

  inline StringType(const StringType& from) : StringType(nullptr, from) {}
  inline StringType(StringType&& from) noexcept
      : StringType(nullptr, std::move(from)) {}
  inline StringType& operator=(const StringType& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringType& operator=(StringType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringType& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringType* internal_default_instance() {
    return reinterpret_cast<const StringType*>(
        &_StringType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(StringType& a, StringType& b) { a.Swap(&b); }
  inline void Swap(StringType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<StringType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StringType& from) { StringType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StringType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.StringType"; }

 protected:
  explicit StringType(::google::protobuf::Arena* arena);
  StringType(::google::protobuf::Arena* arena, const StringType& from);
  StringType(::google::protobuf::Arena* arena, StringType&& from) noexcept
      : StringType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.StringType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      49, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StringType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StringType& from_msg);
    ::google::protobuf::internal::ArenaStringPtr value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class NumericType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.NumericType) */ {
 public:
  inline NumericType() : NumericType(nullptr) {}
  ~NumericType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NumericType(
      ::google::protobuf::internal::ConstantInitialized);

  inline NumericType(const NumericType& from) : NumericType(nullptr, from) {}
  inline NumericType(NumericType&& from) noexcept
      : NumericType(nullptr, std::move(from)) {}
  inline NumericType& operator=(const NumericType& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumericType& operator=(NumericType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumericType& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kDoubleValue = 1,
    kFloatValue = 2,
    kInt32Value = 3,
    kInt64Value = 4,
    kUint32Value = 5,
    kUint64Value = 6,
    VALUE_NOT_SET = 0,
  };
  static inline const NumericType* internal_default_instance() {
    return reinterpret_cast<const NumericType*>(
        &_NumericType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(NumericType& a, NumericType& b) { a.Swap(&b); }
  inline void Swap(NumericType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumericType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumericType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<NumericType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NumericType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NumericType& from) { NumericType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NumericType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.NumericType"; }

 protected:
  explicit NumericType(::google::protobuf::Arena* arena);
  NumericType(::google::protobuf::Arena* arena, const NumericType& from);
  NumericType(::google::protobuf::Arena* arena, NumericType&& from) noexcept
      : NumericType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDoubleValueFieldNumber = 1,
    kFloatValueFieldNumber = 2,
    kInt32ValueFieldNumber = 3,
    kInt64ValueFieldNumber = 4,
    kUint32ValueFieldNumber = 5,
    kUint64ValueFieldNumber = 6,
  };
  // double double_value = 1 [json_name = "doubleValue"];
  bool has_double_value() const;
  void clear_double_value() ;
  double double_value() const;
  void set_double_value(double value);

  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);

  public:
  // float float_value = 2 [json_name = "floatValue"];
  bool has_float_value() const;
  void clear_float_value() ;
  float float_value() const;
  void set_float_value(float value);

  private:
  float _internal_float_value() const;
  void _internal_set_float_value(float value);

  public:
  // int32 int32_value = 3 [json_name = "int32Value"];
  bool has_int32_value() const;
  void clear_int32_value() ;
  ::int32_t int32_value() const;
  void set_int32_value(::int32_t value);

  private:
  ::int32_t _internal_int32_value() const;
  void _internal_set_int32_value(::int32_t value);

  public:
  // int64 int64_value = 4 [json_name = "int64Value"];
  bool has_int64_value() const;
  void clear_int64_value() ;
  ::int64_t int64_value() const;
  void set_int64_value(::int64_t value);

  private:
  ::int64_t _internal_int64_value() const;
  void _internal_set_int64_value(::int64_t value);

  public:
  // uint32 uint32_value = 5 [json_name = "uint32Value"];
  bool has_uint32_value() const;
  void clear_uint32_value() ;
  ::uint32_t uint32_value() const;
  void set_uint32_value(::uint32_t value);

  private:
  ::uint32_t _internal_uint32_value() const;
  void _internal_set_uint32_value(::uint32_t value);

  public:
  // uint64 uint64_value = 6 [json_name = "uint64Value"];
  bool has_uint64_value() const;
  void clear_uint64_value() ;
  ::uint64_t uint64_value() const;
  void set_uint64_value(::uint64_t value);

  private:
  ::uint64_t _internal_uint64_value() const;
  void _internal_set_uint64_value(::uint64_t value);

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.NumericType)
 private:
  class _Internal;
  void set_has_double_value();
  void set_has_float_value();
  void set_has_int32_value();
  void set_has_int64_value();
  void set_has_uint32_value();
  void set_has_uint64_value();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 6, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NumericType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NumericType& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      double double_value_;
      float float_value_;
      ::int32_t int32_value_;
      ::int64_t int64_value_;
      ::uint32_t uint32_value_;
      ::uint64_t uint64_value_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class HeadingType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.HeadingType) */ {
 public:
  inline HeadingType() : HeadingType(nullptr) {}
  ~HeadingType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeadingType(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeadingType(const HeadingType& from) : HeadingType(nullptr, from) {}
  inline HeadingType(HeadingType&& from) noexcept
      : HeadingType(nullptr, std::move(from)) {}
  inline HeadingType& operator=(const HeadingType& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadingType& operator=(HeadingType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadingType& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadingType* internal_default_instance() {
    return reinterpret_cast<const HeadingType*>(
        &_HeadingType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(HeadingType& a, HeadingType& b) { a.Swap(&b); }
  inline void Swap(HeadingType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadingType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeadingType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<HeadingType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeadingType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeadingType& from) { HeadingType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeadingType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.HeadingType"; }

 protected:
  explicit HeadingType(::google::protobuf::Arena* arena);
  HeadingType(::google::protobuf::Arena* arena, const HeadingType& from);
  HeadingType(::google::protobuf::Arena* arena, HeadingType&& from) noexcept
      : HeadingType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 value = 1 [json_name = "value"];
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.HeadingType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HeadingType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HeadingType& from_msg);
    ::int32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class EnumType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.EnumType) */ {
 public:
  inline EnumType() : EnumType(nullptr) {}
  ~EnumType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EnumType(
      ::google::protobuf::internal::ConstantInitialized);

  inline EnumType(const EnumType& from) : EnumType(nullptr, from) {}
  inline EnumType(EnumType&& from) noexcept
      : EnumType(nullptr, std::move(from)) {}
  inline EnumType& operator=(const EnumType& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumType& operator=(EnumType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnumType& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnumType* internal_default_instance() {
    return reinterpret_cast<const EnumType*>(
        &_EnumType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(EnumType& a, EnumType& b) { a.Swap(&b); }
  inline void Swap(EnumType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnumType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<EnumType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EnumType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EnumType& from) { EnumType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EnumType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.EnumType"; }

 protected:
  explicit EnumType(::google::protobuf::Arena* arena);
  EnumType(::google::protobuf::Arena* arena, const EnumType& from);
  EnumType(::google::protobuf::Arena* arena, EnumType&& from) noexcept
      : EnumType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 value = 1 [json_name = "value"];
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.EnumType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EnumType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EnumType& from_msg);
    ::int32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class BooleanType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.BooleanType) */ {
 public:
  inline BooleanType() : BooleanType(nullptr) {}
  ~BooleanType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BooleanType(
      ::google::protobuf::internal::ConstantInitialized);

  inline BooleanType(const BooleanType& from) : BooleanType(nullptr, from) {}
  inline BooleanType(BooleanType&& from) noexcept
      : BooleanType(nullptr, std::move(from)) {}
  inline BooleanType& operator=(const BooleanType& from) {
    CopyFrom(from);
    return *this;
  }
  inline BooleanType& operator=(BooleanType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BooleanType& default_instance() {
    return *internal_default_instance();
  }
  static inline const BooleanType* internal_default_instance() {
    return reinterpret_cast<const BooleanType*>(
        &_BooleanType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(BooleanType& a, BooleanType& b) { a.Swap(&b); }
  inline void Swap(BooleanType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BooleanType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BooleanType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<BooleanType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BooleanType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BooleanType& from) { BooleanType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BooleanType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.BooleanType"; }

 protected:
  explicit BooleanType(::google::protobuf::Arena* arena);
  BooleanType(::google::protobuf::Arena* arena, const BooleanType& from);
  BooleanType(::google::protobuf::Arena* arena, BooleanType&& from) noexcept
      : BooleanType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1 [json_name = "value"];
  void clear_value() ;
  bool value() const;
  void set_value(bool value);

  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.BooleanType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_BooleanType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BooleanType& from_msg);
    bool value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class TimestampType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.TimestampType) */ {
 public:
  inline TimestampType() : TimestampType(nullptr) {}
  ~TimestampType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TimestampType(
      ::google::protobuf::internal::ConstantInitialized);

  inline TimestampType(const TimestampType& from) : TimestampType(nullptr, from) {}
  inline TimestampType(TimestampType&& from) noexcept
      : TimestampType(nullptr, std::move(from)) {}
  inline TimestampType& operator=(const TimestampType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimestampType& operator=(TimestampType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimestampType& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimestampType* internal_default_instance() {
    return reinterpret_cast<const TimestampType*>(
        &_TimestampType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(TimestampType& a, TimestampType& b) { a.Swap(&b); }
  inline void Swap(TimestampType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimestampType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimestampType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TimestampType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimestampType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TimestampType& from) { TimestampType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TimestampType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.TimestampType"; }

 protected:
  explicit TimestampType(::google::protobuf::Arena* arena);
  TimestampType(::google::protobuf::Arena* arena, const TimestampType& from);
  TimestampType(::google::protobuf::Arena* arena, TimestampType&& from) noexcept
      : TimestampType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .google.protobuf.Timestamp value = 1 [json_name = "value"];
  bool has_value() const;
  void clear_value() ;
  const ::google::protobuf::Timestamp& value() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_value();
  ::google::protobuf::Timestamp* mutable_value();
  void set_allocated_value(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_value(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_value();

  private:
  const ::google::protobuf::Timestamp& _internal_value() const;
  ::google::protobuf::Timestamp* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.TimestampType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TimestampType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TimestampType& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class RangeType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.RangeType) */ {
 public:
  inline RangeType() : RangeType(nullptr) {}
  ~RangeType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RangeType(
      ::google::protobuf::internal::ConstantInitialized);

  inline RangeType(const RangeType& from) : RangeType(nullptr, from) {}
  inline RangeType(RangeType&& from) noexcept
      : RangeType(nullptr, std::move(from)) {}
  inline RangeType& operator=(const RangeType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeType& operator=(RangeType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeType& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeType* internal_default_instance() {
    return reinterpret_cast<const RangeType*>(
        &_RangeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(RangeType& a, RangeType& b) { a.Swap(&b); }
  inline void Swap(RangeType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RangeType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RangeType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RangeType& from) { RangeType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RangeType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.RangeType"; }

 protected:
  explicit RangeType(::google::protobuf::Arena* arena);
  RangeType(::google::protobuf::Arena* arena, const RangeType& from);
  RangeType(::google::protobuf::Arena* arena, RangeType&& from) noexcept
      : RangeType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.NumericType start = 1 [json_name = "start"];
  bool has_start() const;
  void clear_start() ;
  const ::anduril::entitymanager::v1::NumericType& start() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::NumericType* release_start();
  ::anduril::entitymanager::v1::NumericType* mutable_start();
  void set_allocated_start(::anduril::entitymanager::v1::NumericType* value);
  void unsafe_arena_set_allocated_start(::anduril::entitymanager::v1::NumericType* value);
  ::anduril::entitymanager::v1::NumericType* unsafe_arena_release_start();

  private:
  const ::anduril::entitymanager::v1::NumericType& _internal_start() const;
  ::anduril::entitymanager::v1::NumericType* _internal_mutable_start();

  public:
  // .anduril.entitymanager.v1.NumericType end = 2 [json_name = "end"];
  bool has_end() const;
  void clear_end() ;
  const ::anduril::entitymanager::v1::NumericType& end() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::NumericType* release_end();
  ::anduril::entitymanager::v1::NumericType* mutable_end();
  void set_allocated_end(::anduril::entitymanager::v1::NumericType* value);
  void unsafe_arena_set_allocated_end(::anduril::entitymanager::v1::NumericType* value);
  ::anduril::entitymanager::v1::NumericType* unsafe_arena_release_end();

  private:
  const ::anduril::entitymanager::v1::NumericType& _internal_end() const;
  ::anduril::entitymanager::v1::NumericType* _internal_mutable_end();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.RangeType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RangeType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RangeType& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::NumericType* start_;
    ::anduril::entitymanager::v1::NumericType* end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class PositionType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.PositionType) */ {
 public:
  inline PositionType() : PositionType(nullptr) {}
  ~PositionType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionType(
      ::google::protobuf::internal::ConstantInitialized);

  inline PositionType(const PositionType& from) : PositionType(nullptr, from) {}
  inline PositionType(PositionType&& from) noexcept
      : PositionType(nullptr, std::move(from)) {}
  inline PositionType& operator=(const PositionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionType& operator=(PositionType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionType& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionType* internal_default_instance() {
    return reinterpret_cast<const PositionType*>(
        &_PositionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(PositionType& a, PositionType& b) { a.Swap(&b); }
  inline void Swap(PositionType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PositionType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionType& from) { PositionType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PositionType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.PositionType"; }

 protected:
  explicit PositionType(::google::protobuf::Arena* arena);
  PositionType(::google::protobuf::Arena* arena, const PositionType& from);
  PositionType(::google::protobuf::Arena* arena, PositionType&& from) noexcept
      : PositionType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .anduril.entitymanager.v1.Position value = 1 [json_name = "value"];
  bool has_value() const;
  void clear_value() ;
  const ::anduril::entitymanager::v1::Position& value() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Position* release_value();
  ::anduril::entitymanager::v1::Position* mutable_value();
  void set_allocated_value(::anduril::entitymanager::v1::Position* value);
  void unsafe_arena_set_allocated_value(::anduril::entitymanager::v1::Position* value);
  ::anduril::entitymanager::v1::Position* unsafe_arena_release_value();

  private:
  const ::anduril::entitymanager::v1::Position& _internal_value() const;
  ::anduril::entitymanager::v1::Position* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.PositionType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PositionType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PositionType& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Position* value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class BoundedShapeType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.BoundedShapeType) */ {
 public:
  inline BoundedShapeType() : BoundedShapeType(nullptr) {}
  ~BoundedShapeType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BoundedShapeType(
      ::google::protobuf::internal::ConstantInitialized);

  inline BoundedShapeType(const BoundedShapeType& from) : BoundedShapeType(nullptr, from) {}
  inline BoundedShapeType(BoundedShapeType&& from) noexcept
      : BoundedShapeType(nullptr, std::move(from)) {}
  inline BoundedShapeType& operator=(const BoundedShapeType& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundedShapeType& operator=(BoundedShapeType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoundedShapeType& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kPolygonValue = 1,
    VALUE_NOT_SET = 0,
  };
  static inline const BoundedShapeType* internal_default_instance() {
    return reinterpret_cast<const BoundedShapeType*>(
        &_BoundedShapeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(BoundedShapeType& a, BoundedShapeType& b) { a.Swap(&b); }
  inline void Swap(BoundedShapeType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoundedShapeType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoundedShapeType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<BoundedShapeType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoundedShapeType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BoundedShapeType& from) { BoundedShapeType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BoundedShapeType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.BoundedShapeType"; }

 protected:
  explicit BoundedShapeType(::google::protobuf::Arena* arena);
  BoundedShapeType(::google::protobuf::Arena* arena, const BoundedShapeType& from);
  BoundedShapeType(::google::protobuf::Arena* arena, BoundedShapeType&& from) noexcept
      : BoundedShapeType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPolygonValueFieldNumber = 1,
  };
  // .anduril.entitymanager.v1.GeoPolygon polygon_value = 1 [json_name = "polygonValue"];
  bool has_polygon_value() const;
  private:
  bool _internal_has_polygon_value() const;

  public:
  void clear_polygon_value() ;
  const ::anduril::entitymanager::v1::GeoPolygon& polygon_value() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoPolygon* release_polygon_value();
  ::anduril::entitymanager::v1::GeoPolygon* mutable_polygon_value();
  void set_allocated_polygon_value(::anduril::entitymanager::v1::GeoPolygon* value);
  void unsafe_arena_set_allocated_polygon_value(::anduril::entitymanager::v1::GeoPolygon* value);
  ::anduril::entitymanager::v1::GeoPolygon* unsafe_arena_release_polygon_value();

  private:
  const ::anduril::entitymanager::v1::GeoPolygon& _internal_polygon_value() const;
  ::anduril::entitymanager::v1::GeoPolygon* _internal_mutable_polygon_value();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.BoundedShapeType)
 private:
  class _Internal;
  void set_has_polygon_value();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_BoundedShapeType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BoundedShapeType& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::GeoPolygon* polygon_value_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class ListType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.ListType) */ {
 public:
  inline ListType() : ListType(nullptr) {}
  ~ListType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListType(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListType(const ListType& from) : ListType(nullptr, from) {}
  inline ListType(ListType&& from) noexcept
      : ListType(nullptr, std::move(from)) {}
  inline ListType& operator=(const ListType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListType& operator=(ListType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListType* internal_default_instance() {
    return reinterpret_cast<const ListType*>(
        &_ListType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ListType& a, ListType& b) { a.Swap(&b); }
  inline void Swap(ListType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ListType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListType& from) { ListType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.ListType"; }

 protected:
  explicit ListType(::google::protobuf::Arena* arena);
  ListType(::google::protobuf::Arena* arena, const ListType& from);
  ListType(::google::protobuf::Arena* arena, ListType&& from) noexcept
      : ListType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .anduril.entitymanager.v1.Value values = 1 [json_name = "values"];
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::anduril::entitymanager::v1::Value* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Value>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Value>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Value>* _internal_mutable_values();
  public:
  const ::anduril::entitymanager::v1::Value& values(int index) const;
  ::anduril::entitymanager::v1::Value* add_values();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Value>& values() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.ListType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ListType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListType& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Value > values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class Value final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Value(
      ::google::protobuf::internal::ConstantInitialized);

  inline Value(const Value& from) : Value(nullptr, from) {}
  inline Value(Value&& from) noexcept
      : Value(nullptr, std::move(from)) {}
  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kBooleanType = 1,
    kNumericType = 2,
    kStringType = 3,
    kEnumType = 4,
    kTimestampType = 5,
    kBoundedShapeType = 6,
    kPositionType = 7,
    kHeadingType = 8,
    kListType = 9,
    kRangeType = 10,
    TYPE_NOT_SET = 0,
  };
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
        &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Value& a, Value& b) { a.Swap(&b); }
  inline void Swap(Value* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Value>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Value& from) { Value::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Value* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Value"; }

 protected:
  explicit Value(::google::protobuf::Arena* arena);
  Value(::google::protobuf::Arena* arena, const Value& from);
  Value(::google::protobuf::Arena* arena, Value&& from) noexcept
      : Value(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBooleanTypeFieldNumber = 1,
    kNumericTypeFieldNumber = 2,
    kStringTypeFieldNumber = 3,
    kEnumTypeFieldNumber = 4,
    kTimestampTypeFieldNumber = 5,
    kBoundedShapeTypeFieldNumber = 6,
    kPositionTypeFieldNumber = 7,
    kHeadingTypeFieldNumber = 8,
    kListTypeFieldNumber = 9,
    kRangeTypeFieldNumber = 10,
  };
  // .anduril.entitymanager.v1.BooleanType boolean_type = 1 [json_name = "booleanType"];
  bool has_boolean_type() const;
  private:
  bool _internal_has_boolean_type() const;

  public:
  void clear_boolean_type() ;
  const ::anduril::entitymanager::v1::BooleanType& boolean_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::BooleanType* release_boolean_type();
  ::anduril::entitymanager::v1::BooleanType* mutable_boolean_type();
  void set_allocated_boolean_type(::anduril::entitymanager::v1::BooleanType* value);
  void unsafe_arena_set_allocated_boolean_type(::anduril::entitymanager::v1::BooleanType* value);
  ::anduril::entitymanager::v1::BooleanType* unsafe_arena_release_boolean_type();

  private:
  const ::anduril::entitymanager::v1::BooleanType& _internal_boolean_type() const;
  ::anduril::entitymanager::v1::BooleanType* _internal_mutable_boolean_type();

  public:
  // .anduril.entitymanager.v1.NumericType numeric_type = 2 [json_name = "numericType"];
  bool has_numeric_type() const;
  private:
  bool _internal_has_numeric_type() const;

  public:
  void clear_numeric_type() ;
  const ::anduril::entitymanager::v1::NumericType& numeric_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::NumericType* release_numeric_type();
  ::anduril::entitymanager::v1::NumericType* mutable_numeric_type();
  void set_allocated_numeric_type(::anduril::entitymanager::v1::NumericType* value);
  void unsafe_arena_set_allocated_numeric_type(::anduril::entitymanager::v1::NumericType* value);
  ::anduril::entitymanager::v1::NumericType* unsafe_arena_release_numeric_type();

  private:
  const ::anduril::entitymanager::v1::NumericType& _internal_numeric_type() const;
  ::anduril::entitymanager::v1::NumericType* _internal_mutable_numeric_type();

  public:
  // .anduril.entitymanager.v1.StringType string_type = 3 [json_name = "stringType"];
  bool has_string_type() const;
  private:
  bool _internal_has_string_type() const;

  public:
  void clear_string_type() ;
  const ::anduril::entitymanager::v1::StringType& string_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::StringType* release_string_type();
  ::anduril::entitymanager::v1::StringType* mutable_string_type();
  void set_allocated_string_type(::anduril::entitymanager::v1::StringType* value);
  void unsafe_arena_set_allocated_string_type(::anduril::entitymanager::v1::StringType* value);
  ::anduril::entitymanager::v1::StringType* unsafe_arena_release_string_type();

  private:
  const ::anduril::entitymanager::v1::StringType& _internal_string_type() const;
  ::anduril::entitymanager::v1::StringType* _internal_mutable_string_type();

  public:
  // .anduril.entitymanager.v1.EnumType enum_type = 4 [json_name = "enumType"];
  bool has_enum_type() const;
  private:
  bool _internal_has_enum_type() const;

  public:
  void clear_enum_type() ;
  const ::anduril::entitymanager::v1::EnumType& enum_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::EnumType* release_enum_type();
  ::anduril::entitymanager::v1::EnumType* mutable_enum_type();
  void set_allocated_enum_type(::anduril::entitymanager::v1::EnumType* value);
  void unsafe_arena_set_allocated_enum_type(::anduril::entitymanager::v1::EnumType* value);
  ::anduril::entitymanager::v1::EnumType* unsafe_arena_release_enum_type();

  private:
  const ::anduril::entitymanager::v1::EnumType& _internal_enum_type() const;
  ::anduril::entitymanager::v1::EnumType* _internal_mutable_enum_type();

  public:
  // .anduril.entitymanager.v1.TimestampType timestamp_type = 5 [json_name = "timestampType"];
  bool has_timestamp_type() const;
  private:
  bool _internal_has_timestamp_type() const;

  public:
  void clear_timestamp_type() ;
  const ::anduril::entitymanager::v1::TimestampType& timestamp_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::TimestampType* release_timestamp_type();
  ::anduril::entitymanager::v1::TimestampType* mutable_timestamp_type();
  void set_allocated_timestamp_type(::anduril::entitymanager::v1::TimestampType* value);
  void unsafe_arena_set_allocated_timestamp_type(::anduril::entitymanager::v1::TimestampType* value);
  ::anduril::entitymanager::v1::TimestampType* unsafe_arena_release_timestamp_type();

  private:
  const ::anduril::entitymanager::v1::TimestampType& _internal_timestamp_type() const;
  ::anduril::entitymanager::v1::TimestampType* _internal_mutable_timestamp_type();

  public:
  // .anduril.entitymanager.v1.BoundedShapeType bounded_shape_type = 6 [json_name = "boundedShapeType"];
  bool has_bounded_shape_type() const;
  private:
  bool _internal_has_bounded_shape_type() const;

  public:
  void clear_bounded_shape_type() ;
  const ::anduril::entitymanager::v1::BoundedShapeType& bounded_shape_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::BoundedShapeType* release_bounded_shape_type();
  ::anduril::entitymanager::v1::BoundedShapeType* mutable_bounded_shape_type();
  void set_allocated_bounded_shape_type(::anduril::entitymanager::v1::BoundedShapeType* value);
  void unsafe_arena_set_allocated_bounded_shape_type(::anduril::entitymanager::v1::BoundedShapeType* value);
  ::anduril::entitymanager::v1::BoundedShapeType* unsafe_arena_release_bounded_shape_type();

  private:
  const ::anduril::entitymanager::v1::BoundedShapeType& _internal_bounded_shape_type() const;
  ::anduril::entitymanager::v1::BoundedShapeType* _internal_mutable_bounded_shape_type();

  public:
  // .anduril.entitymanager.v1.PositionType position_type = 7 [json_name = "positionType"];
  bool has_position_type() const;
  private:
  bool _internal_has_position_type() const;

  public:
  void clear_position_type() ;
  const ::anduril::entitymanager::v1::PositionType& position_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::PositionType* release_position_type();
  ::anduril::entitymanager::v1::PositionType* mutable_position_type();
  void set_allocated_position_type(::anduril::entitymanager::v1::PositionType* value);
  void unsafe_arena_set_allocated_position_type(::anduril::entitymanager::v1::PositionType* value);
  ::anduril::entitymanager::v1::PositionType* unsafe_arena_release_position_type();

  private:
  const ::anduril::entitymanager::v1::PositionType& _internal_position_type() const;
  ::anduril::entitymanager::v1::PositionType* _internal_mutable_position_type();

  public:
  // .anduril.entitymanager.v1.HeadingType heading_type = 8 [json_name = "headingType"];
  bool has_heading_type() const;
  private:
  bool _internal_has_heading_type() const;

  public:
  void clear_heading_type() ;
  const ::anduril::entitymanager::v1::HeadingType& heading_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::HeadingType* release_heading_type();
  ::anduril::entitymanager::v1::HeadingType* mutable_heading_type();
  void set_allocated_heading_type(::anduril::entitymanager::v1::HeadingType* value);
  void unsafe_arena_set_allocated_heading_type(::anduril::entitymanager::v1::HeadingType* value);
  ::anduril::entitymanager::v1::HeadingType* unsafe_arena_release_heading_type();

  private:
  const ::anduril::entitymanager::v1::HeadingType& _internal_heading_type() const;
  ::anduril::entitymanager::v1::HeadingType* _internal_mutable_heading_type();

  public:
  // .anduril.entitymanager.v1.ListType list_type = 9 [json_name = "listType"];
  bool has_list_type() const;
  private:
  bool _internal_has_list_type() const;

  public:
  void clear_list_type() ;
  const ::anduril::entitymanager::v1::ListType& list_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::ListType* release_list_type();
  ::anduril::entitymanager::v1::ListType* mutable_list_type();
  void set_allocated_list_type(::anduril::entitymanager::v1::ListType* value);
  void unsafe_arena_set_allocated_list_type(::anduril::entitymanager::v1::ListType* value);
  ::anduril::entitymanager::v1::ListType* unsafe_arena_release_list_type();

  private:
  const ::anduril::entitymanager::v1::ListType& _internal_list_type() const;
  ::anduril::entitymanager::v1::ListType* _internal_mutable_list_type();

  public:
  // .anduril.entitymanager.v1.RangeType range_type = 10 [json_name = "rangeType"];
  bool has_range_type() const;
  private:
  bool _internal_has_range_type() const;

  public:
  void clear_range_type() ;
  const ::anduril::entitymanager::v1::RangeType& range_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::RangeType* release_range_type();
  ::anduril::entitymanager::v1::RangeType* mutable_range_type();
  void set_allocated_range_type(::anduril::entitymanager::v1::RangeType* value);
  void unsafe_arena_set_allocated_range_type(::anduril::entitymanager::v1::RangeType* value);
  ::anduril::entitymanager::v1::RangeType* unsafe_arena_release_range_type();

  private:
  const ::anduril::entitymanager::v1::RangeType& _internal_range_type() const;
  ::anduril::entitymanager::v1::RangeType* _internal_mutable_range_type();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Value)
 private:
  class _Internal;
  void set_has_boolean_type();
  void set_has_numeric_type();
  void set_has_string_type();
  void set_has_enum_type();
  void set_has_timestamp_type();
  void set_has_bounded_shape_type();
  void set_has_position_type();
  void set_has_heading_type();
  void set_has_list_type();
  void set_has_range_type();
  inline bool has_type() const;
  inline void clear_has_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 10, 10,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Value_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Value& from_msg);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::BooleanType* boolean_type_;
      ::anduril::entitymanager::v1::NumericType* numeric_type_;
      ::anduril::entitymanager::v1::StringType* string_type_;
      ::anduril::entitymanager::v1::EnumType* enum_type_;
      ::anduril::entitymanager::v1::TimestampType* timestamp_type_;
      ::anduril::entitymanager::v1::BoundedShapeType* bounded_shape_type_;
      ::anduril::entitymanager::v1::PositionType* position_type_;
      ::anduril::entitymanager::v1::HeadingType* heading_type_;
      ::anduril::entitymanager::v1::ListType* list_type_;
      ::anduril::entitymanager::v1::RangeType* range_type_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class Predicate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Predicate) */ {
 public:
  inline Predicate() : Predicate(nullptr) {}
  ~Predicate() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Predicate(
      ::google::protobuf::internal::ConstantInitialized);

  inline Predicate(const Predicate& from) : Predicate(nullptr, from) {}
  inline Predicate(Predicate&& from) noexcept
      : Predicate(nullptr, std::move(from)) {}
  inline Predicate& operator=(const Predicate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Predicate& operator=(Predicate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Predicate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Predicate* internal_default_instance() {
    return reinterpret_cast<const Predicate*>(
        &_Predicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Predicate& a, Predicate& b) { a.Swap(&b); }
  inline void Swap(Predicate* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Predicate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Predicate* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Predicate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Predicate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Predicate& from) { Predicate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Predicate* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Predicate"; }

 protected:
  explicit Predicate(::google::protobuf::Arena* arena);
  Predicate(::google::protobuf::Arena* arena, const Predicate& from);
  Predicate(::google::protobuf::Arena* arena, Predicate&& from) noexcept
      : Predicate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldPathFieldNumber = 1,
    kValueFieldNumber = 2,
    kComparatorFieldNumber = 3,
  };
  // string field_path = 1 [json_name = "fieldPath"];
  void clear_field_path() ;
  const std::string& field_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_field_path(Arg_&& arg, Args_... args);
  std::string* mutable_field_path();
  PROTOBUF_NODISCARD std::string* release_field_path();
  void set_allocated_field_path(std::string* value);

  private:
  const std::string& _internal_field_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_path(
      const std::string& value);
  std::string* _internal_mutable_field_path();

  public:
  // .anduril.entitymanager.v1.Value value = 2 [json_name = "value"];
  bool has_value() const;
  void clear_value() ;
  const ::anduril::entitymanager::v1::Value& value() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Value* release_value();
  ::anduril::entitymanager::v1::Value* mutable_value();
  void set_allocated_value(::anduril::entitymanager::v1::Value* value);
  void unsafe_arena_set_allocated_value(::anduril::entitymanager::v1::Value* value);
  ::anduril::entitymanager::v1::Value* unsafe_arena_release_value();

  private:
  const ::anduril::entitymanager::v1::Value& _internal_value() const;
  ::anduril::entitymanager::v1::Value* _internal_mutable_value();

  public:
  // .anduril.entitymanager.v1.Comparator comparator = 3 [json_name = "comparator"];
  void clear_comparator() ;
  ::anduril::entitymanager::v1::Comparator comparator() const;
  void set_comparator(::anduril::entitymanager::v1::Comparator value);

  private:
  ::anduril::entitymanager::v1::Comparator _internal_comparator() const;
  void _internal_set_comparator(::anduril::entitymanager::v1::Comparator value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Predicate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      53, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Predicate_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Predicate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr field_path_;
    ::anduril::entitymanager::v1::Value* value_;
    int comparator_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class PredicateSet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.PredicateSet) */ {
 public:
  inline PredicateSet() : PredicateSet(nullptr) {}
  ~PredicateSet() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PredicateSet(
      ::google::protobuf::internal::ConstantInitialized);

  inline PredicateSet(const PredicateSet& from) : PredicateSet(nullptr, from) {}
  inline PredicateSet(PredicateSet&& from) noexcept
      : PredicateSet(nullptr, std::move(from)) {}
  inline PredicateSet& operator=(const PredicateSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredicateSet& operator=(PredicateSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PredicateSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const PredicateSet* internal_default_instance() {
    return reinterpret_cast<const PredicateSet*>(
        &_PredicateSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(PredicateSet& a, PredicateSet& b) { a.Swap(&b); }
  inline void Swap(PredicateSet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredicateSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PredicateSet* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PredicateSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PredicateSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PredicateSet& from) { PredicateSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PredicateSet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.PredicateSet"; }

 protected:
  explicit PredicateSet(::google::protobuf::Arena* arena);
  PredicateSet(::google::protobuf::Arena* arena, const PredicateSet& from);
  PredicateSet(::google::protobuf::Arena* arena, PredicateSet&& from) noexcept
      : PredicateSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPredicatesFieldNumber = 1,
  };
  // repeated .anduril.entitymanager.v1.Predicate predicates = 1 [json_name = "predicates"];
  int predicates_size() const;
  private:
  int _internal_predicates_size() const;

  public:
  void clear_predicates() ;
  ::anduril::entitymanager::v1::Predicate* mutable_predicates(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Predicate>* mutable_predicates();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Predicate>& _internal_predicates() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Predicate>* _internal_mutable_predicates();
  public:
  const ::anduril::entitymanager::v1::Predicate& predicates(int index) const;
  ::anduril::entitymanager::v1::Predicate* add_predicates();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Predicate>& predicates() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.PredicateSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PredicateSet_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PredicateSet& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Predicate > predicates_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class AndOperation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.AndOperation) */ {
 public:
  inline AndOperation() : AndOperation(nullptr) {}
  ~AndOperation() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AndOperation(
      ::google::protobuf::internal::ConstantInitialized);

  inline AndOperation(const AndOperation& from) : AndOperation(nullptr, from) {}
  inline AndOperation(AndOperation&& from) noexcept
      : AndOperation(nullptr, std::move(from)) {}
  inline AndOperation& operator=(const AndOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AndOperation& operator=(AndOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AndOperation& default_instance() {
    return *internal_default_instance();
  }
  enum ChildrenCase {
    kPredicateSet = 1,
    kStatementSet = 2,
    CHILDREN_NOT_SET = 0,
  };
  static inline const AndOperation* internal_default_instance() {
    return reinterpret_cast<const AndOperation*>(
        &_AndOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(AndOperation& a, AndOperation& b) { a.Swap(&b); }
  inline void Swap(AndOperation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AndOperation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AndOperation* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AndOperation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AndOperation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AndOperation& from) { AndOperation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AndOperation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.AndOperation"; }

 protected:
  explicit AndOperation(::google::protobuf::Arena* arena);
  AndOperation(::google::protobuf::Arena* arena, const AndOperation& from);
  AndOperation(::google::protobuf::Arena* arena, AndOperation&& from) noexcept
      : AndOperation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPredicateSetFieldNumber = 1,
    kStatementSetFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.PredicateSet predicate_set = 1 [json_name = "predicateSet"];
  bool has_predicate_set() const;
  private:
  bool _internal_has_predicate_set() const;

  public:
  void clear_predicate_set() ;
  const ::anduril::entitymanager::v1::PredicateSet& predicate_set() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::PredicateSet* release_predicate_set();
  ::anduril::entitymanager::v1::PredicateSet* mutable_predicate_set();
  void set_allocated_predicate_set(::anduril::entitymanager::v1::PredicateSet* value);
  void unsafe_arena_set_allocated_predicate_set(::anduril::entitymanager::v1::PredicateSet* value);
  ::anduril::entitymanager::v1::PredicateSet* unsafe_arena_release_predicate_set();

  private:
  const ::anduril::entitymanager::v1::PredicateSet& _internal_predicate_set() const;
  ::anduril::entitymanager::v1::PredicateSet* _internal_mutable_predicate_set();

  public:
  // .anduril.entitymanager.v1.StatementSet statement_set = 2 [json_name = "statementSet"];
  bool has_statement_set() const;
  private:
  bool _internal_has_statement_set() const;

  public:
  void clear_statement_set() ;
  const ::anduril::entitymanager::v1::StatementSet& statement_set() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::StatementSet* release_statement_set();
  ::anduril::entitymanager::v1::StatementSet* mutable_statement_set();
  void set_allocated_statement_set(::anduril::entitymanager::v1::StatementSet* value);
  void unsafe_arena_set_allocated_statement_set(::anduril::entitymanager::v1::StatementSet* value);
  ::anduril::entitymanager::v1::StatementSet* unsafe_arena_release_statement_set();

  private:
  const ::anduril::entitymanager::v1::StatementSet& _internal_statement_set() const;
  ::anduril::entitymanager::v1::StatementSet* _internal_mutable_statement_set();

  public:
  void clear_children();
  ChildrenCase children_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.AndOperation)
 private:
  class _Internal;
  void set_has_predicate_set();
  void set_has_statement_set();
  inline bool has_children() const;
  inline void clear_has_children();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AndOperation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AndOperation& from_msg);
    union ChildrenUnion {
      constexpr ChildrenUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::PredicateSet* predicate_set_;
      ::anduril::entitymanager::v1::StatementSet* statement_set_;
    } children_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class ListOperation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.ListOperation) */ {
 public:
  inline ListOperation() : ListOperation(nullptr) {}
  ~ListOperation() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListOperation(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListOperation(const ListOperation& from) : ListOperation(nullptr, from) {}
  inline ListOperation(ListOperation&& from) noexcept
      : ListOperation(nullptr, std::move(from)) {}
  inline ListOperation& operator=(const ListOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOperation& operator=(ListOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOperation* internal_default_instance() {
    return reinterpret_cast<const ListOperation*>(
        &_ListOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ListOperation& a, ListOperation& b) { a.Swap(&b); }
  inline void Swap(ListOperation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOperation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOperation* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ListOperation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListOperation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListOperation& from) { ListOperation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListOperation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.ListOperation"; }

 protected:
  explicit ListOperation(::google::protobuf::Arena* arena);
  ListOperation(::google::protobuf::Arena* arena, const ListOperation& from);
  ListOperation(::google::protobuf::Arena* arena, ListOperation&& from) noexcept
      : ListOperation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kListPathFieldNumber = 1,
    kStatementFieldNumber = 3,
    kListComparatorFieldNumber = 2,
  };
  // string list_path = 1 [json_name = "listPath"];
  void clear_list_path() ;
  const std::string& list_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_list_path(Arg_&& arg, Args_... args);
  std::string* mutable_list_path();
  PROTOBUF_NODISCARD std::string* release_list_path();
  void set_allocated_list_path(std::string* value);

  private:
  const std::string& _internal_list_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_list_path(
      const std::string& value);
  std::string* _internal_mutable_list_path();

  public:
  // .anduril.entitymanager.v1.Statement statement = 3 [json_name = "statement"];
  bool has_statement() const;
  void clear_statement() ;
  const ::anduril::entitymanager::v1::Statement& statement() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Statement* release_statement();
  ::anduril::entitymanager::v1::Statement* mutable_statement();
  void set_allocated_statement(::anduril::entitymanager::v1::Statement* value);
  void unsafe_arena_set_allocated_statement(::anduril::entitymanager::v1::Statement* value);
  ::anduril::entitymanager::v1::Statement* unsafe_arena_release_statement();

  private:
  const ::anduril::entitymanager::v1::Statement& _internal_statement() const;
  ::anduril::entitymanager::v1::Statement* _internal_mutable_statement();

  public:
  // .anduril.entitymanager.v1.ListComparator list_comparator = 2 [json_name = "listComparator"];
  void clear_list_comparator() ;
  ::anduril::entitymanager::v1::ListComparator list_comparator() const;
  void set_list_comparator(::anduril::entitymanager::v1::ListComparator value);

  private:
  ::anduril::entitymanager::v1::ListComparator _internal_list_comparator() const;
  void _internal_set_list_comparator(::anduril::entitymanager::v1::ListComparator value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.ListOperation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      56, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ListOperation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListOperation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr list_path_;
    ::anduril::entitymanager::v1::Statement* statement_;
    int list_comparator_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class NotOperation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.NotOperation) */ {
 public:
  inline NotOperation() : NotOperation(nullptr) {}
  ~NotOperation() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotOperation(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotOperation(const NotOperation& from) : NotOperation(nullptr, from) {}
  inline NotOperation(NotOperation&& from) noexcept
      : NotOperation(nullptr, std::move(from)) {}
  inline NotOperation& operator=(const NotOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotOperation& operator=(NotOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotOperation& default_instance() {
    return *internal_default_instance();
  }
  enum ChildCase {
    kPredicate = 1,
    kStatement = 2,
    CHILD_NOT_SET = 0,
  };
  static inline const NotOperation* internal_default_instance() {
    return reinterpret_cast<const NotOperation*>(
        &_NotOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(NotOperation& a, NotOperation& b) { a.Swap(&b); }
  inline void Swap(NotOperation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotOperation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotOperation* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<NotOperation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotOperation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotOperation& from) { NotOperation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotOperation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.NotOperation"; }

 protected:
  explicit NotOperation(::google::protobuf::Arena* arena);
  NotOperation(::google::protobuf::Arena* arena, const NotOperation& from);
  NotOperation(::google::protobuf::Arena* arena, NotOperation&& from) noexcept
      : NotOperation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPredicateFieldNumber = 1,
    kStatementFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.Predicate predicate = 1 [json_name = "predicate"];
  bool has_predicate() const;
  private:
  bool _internal_has_predicate() const;

  public:
  void clear_predicate() ;
  const ::anduril::entitymanager::v1::Predicate& predicate() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Predicate* release_predicate();
  ::anduril::entitymanager::v1::Predicate* mutable_predicate();
  void set_allocated_predicate(::anduril::entitymanager::v1::Predicate* value);
  void unsafe_arena_set_allocated_predicate(::anduril::entitymanager::v1::Predicate* value);
  ::anduril::entitymanager::v1::Predicate* unsafe_arena_release_predicate();

  private:
  const ::anduril::entitymanager::v1::Predicate& _internal_predicate() const;
  ::anduril::entitymanager::v1::Predicate* _internal_mutable_predicate();

  public:
  // .anduril.entitymanager.v1.Statement statement = 2 [json_name = "statement"];
  bool has_statement() const;
  private:
  bool _internal_has_statement() const;

  public:
  void clear_statement() ;
  const ::anduril::entitymanager::v1::Statement& statement() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Statement* release_statement();
  ::anduril::entitymanager::v1::Statement* mutable_statement();
  void set_allocated_statement(::anduril::entitymanager::v1::Statement* value);
  void unsafe_arena_set_allocated_statement(::anduril::entitymanager::v1::Statement* value);
  ::anduril::entitymanager::v1::Statement* unsafe_arena_release_statement();

  private:
  const ::anduril::entitymanager::v1::Statement& _internal_statement() const;
  ::anduril::entitymanager::v1::Statement* _internal_mutable_statement();

  public:
  void clear_child();
  ChildCase child_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.NotOperation)
 private:
  class _Internal;
  void set_has_predicate();
  void set_has_statement();
  inline bool has_child() const;
  inline void clear_has_child();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NotOperation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NotOperation& from_msg);
    union ChildUnion {
      constexpr ChildUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::Predicate* predicate_;
      ::anduril::entitymanager::v1::Statement* statement_;
    } child_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class OrOperation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.OrOperation) */ {
 public:
  inline OrOperation() : OrOperation(nullptr) {}
  ~OrOperation() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrOperation(
      ::google::protobuf::internal::ConstantInitialized);

  inline OrOperation(const OrOperation& from) : OrOperation(nullptr, from) {}
  inline OrOperation(OrOperation&& from) noexcept
      : OrOperation(nullptr, std::move(from)) {}
  inline OrOperation& operator=(const OrOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrOperation& operator=(OrOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrOperation& default_instance() {
    return *internal_default_instance();
  }
  enum ChildrenCase {
    kPredicateSet = 1,
    kStatementSet = 2,
    CHILDREN_NOT_SET = 0,
  };
  static inline const OrOperation* internal_default_instance() {
    return reinterpret_cast<const OrOperation*>(
        &_OrOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(OrOperation& a, OrOperation& b) { a.Swap(&b); }
  inline void Swap(OrOperation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrOperation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrOperation* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<OrOperation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrOperation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OrOperation& from) { OrOperation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OrOperation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.OrOperation"; }

 protected:
  explicit OrOperation(::google::protobuf::Arena* arena);
  OrOperation(::google::protobuf::Arena* arena, const OrOperation& from);
  OrOperation(::google::protobuf::Arena* arena, OrOperation&& from) noexcept
      : OrOperation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPredicateSetFieldNumber = 1,
    kStatementSetFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.PredicateSet predicate_set = 1 [json_name = "predicateSet"];
  bool has_predicate_set() const;
  private:
  bool _internal_has_predicate_set() const;

  public:
  void clear_predicate_set() ;
  const ::anduril::entitymanager::v1::PredicateSet& predicate_set() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::PredicateSet* release_predicate_set();
  ::anduril::entitymanager::v1::PredicateSet* mutable_predicate_set();
  void set_allocated_predicate_set(::anduril::entitymanager::v1::PredicateSet* value);
  void unsafe_arena_set_allocated_predicate_set(::anduril::entitymanager::v1::PredicateSet* value);
  ::anduril::entitymanager::v1::PredicateSet* unsafe_arena_release_predicate_set();

  private:
  const ::anduril::entitymanager::v1::PredicateSet& _internal_predicate_set() const;
  ::anduril::entitymanager::v1::PredicateSet* _internal_mutable_predicate_set();

  public:
  // .anduril.entitymanager.v1.StatementSet statement_set = 2 [json_name = "statementSet"];
  bool has_statement_set() const;
  private:
  bool _internal_has_statement_set() const;

  public:
  void clear_statement_set() ;
  const ::anduril::entitymanager::v1::StatementSet& statement_set() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::StatementSet* release_statement_set();
  ::anduril::entitymanager::v1::StatementSet* mutable_statement_set();
  void set_allocated_statement_set(::anduril::entitymanager::v1::StatementSet* value);
  void unsafe_arena_set_allocated_statement_set(::anduril::entitymanager::v1::StatementSet* value);
  ::anduril::entitymanager::v1::StatementSet* unsafe_arena_release_statement_set();

  private:
  const ::anduril::entitymanager::v1::StatementSet& _internal_statement_set() const;
  ::anduril::entitymanager::v1::StatementSet* _internal_mutable_statement_set();

  public:
  void clear_children();
  ChildrenCase children_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.OrOperation)
 private:
  class _Internal;
  void set_has_predicate_set();
  void set_has_statement_set();
  inline bool has_children() const;
  inline void clear_has_children();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_OrOperation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OrOperation& from_msg);
    union ChildrenUnion {
      constexpr ChildrenUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::PredicateSet* predicate_set_;
      ::anduril::entitymanager::v1::StatementSet* statement_set_;
    } children_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class Statement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Statement) */ {
 public:
  inline Statement() : Statement(nullptr) {}
  ~Statement() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Statement(
      ::google::protobuf::internal::ConstantInitialized);

  inline Statement(const Statement& from) : Statement(nullptr, from) {}
  inline Statement(Statement&& from) noexcept
      : Statement(nullptr, std::move(from)) {}
  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement& operator=(Statement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statement& default_instance() {
    return *internal_default_instance();
  }
  enum OperationCase {
    kAnd = 1,
    kOr = 2,
    kNot = 3,
    kList = 4,
    kPredicate = 5,
    OPERATION_NOT_SET = 0,
  };
  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
        &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Statement& a, Statement& b) { a.Swap(&b); }
  inline void Swap(Statement* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statement* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Statement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Statement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Statement& from) { Statement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Statement* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Statement"; }

 protected:
  explicit Statement(::google::protobuf::Arena* arena);
  Statement(::google::protobuf::Arena* arena, const Statement& from);
  Statement(::google::protobuf::Arena* arena, Statement&& from) noexcept
      : Statement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAndFieldNumber = 1,
    kOrFieldNumber = 2,
    kNotFieldNumber = 3,
    kListFieldNumber = 4,
    kPredicateFieldNumber = 5,
  };
  // .anduril.entitymanager.v1.AndOperation and = 1 [json_name = "and"];
  bool has_and_() const;
  private:
  bool _internal_has_and_() const;

  public:
  void clear_and_() ;
  const ::anduril::entitymanager::v1::AndOperation& and_() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::AndOperation* release_and_();
  ::anduril::entitymanager::v1::AndOperation* mutable_and_();
  void set_allocated_and_(::anduril::entitymanager::v1::AndOperation* value);
  void unsafe_arena_set_allocated_and_(::anduril::entitymanager::v1::AndOperation* value);
  ::anduril::entitymanager::v1::AndOperation* unsafe_arena_release_and_();

  private:
  const ::anduril::entitymanager::v1::AndOperation& _internal_and_() const;
  ::anduril::entitymanager::v1::AndOperation* _internal_mutable_and_();

  public:
  // .anduril.entitymanager.v1.OrOperation or = 2 [json_name = "or"];
  bool has_or_() const;
  private:
  bool _internal_has_or_() const;

  public:
  void clear_or_() ;
  const ::anduril::entitymanager::v1::OrOperation& or_() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::OrOperation* release_or_();
  ::anduril::entitymanager::v1::OrOperation* mutable_or_();
  void set_allocated_or_(::anduril::entitymanager::v1::OrOperation* value);
  void unsafe_arena_set_allocated_or_(::anduril::entitymanager::v1::OrOperation* value);
  ::anduril::entitymanager::v1::OrOperation* unsafe_arena_release_or_();

  private:
  const ::anduril::entitymanager::v1::OrOperation& _internal_or_() const;
  ::anduril::entitymanager::v1::OrOperation* _internal_mutable_or_();

  public:
  // .anduril.entitymanager.v1.NotOperation not = 3 [json_name = "not"];
  bool has_not_() const;
  private:
  bool _internal_has_not_() const;

  public:
  void clear_not_() ;
  const ::anduril::entitymanager::v1::NotOperation& not_() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::NotOperation* release_not_();
  ::anduril::entitymanager::v1::NotOperation* mutable_not_();
  void set_allocated_not_(::anduril::entitymanager::v1::NotOperation* value);
  void unsafe_arena_set_allocated_not_(::anduril::entitymanager::v1::NotOperation* value);
  ::anduril::entitymanager::v1::NotOperation* unsafe_arena_release_not_();

  private:
  const ::anduril::entitymanager::v1::NotOperation& _internal_not_() const;
  ::anduril::entitymanager::v1::NotOperation* _internal_mutable_not_();

  public:
  // .anduril.entitymanager.v1.ListOperation list = 4 [json_name = "list"];
  bool has_list() const;
  private:
  bool _internal_has_list() const;

  public:
  void clear_list() ;
  const ::anduril::entitymanager::v1::ListOperation& list() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::ListOperation* release_list();
  ::anduril::entitymanager::v1::ListOperation* mutable_list();
  void set_allocated_list(::anduril::entitymanager::v1::ListOperation* value);
  void unsafe_arena_set_allocated_list(::anduril::entitymanager::v1::ListOperation* value);
  ::anduril::entitymanager::v1::ListOperation* unsafe_arena_release_list();

  private:
  const ::anduril::entitymanager::v1::ListOperation& _internal_list() const;
  ::anduril::entitymanager::v1::ListOperation* _internal_mutable_list();

  public:
  // .anduril.entitymanager.v1.Predicate predicate = 5 [json_name = "predicate"];
  bool has_predicate() const;
  private:
  bool _internal_has_predicate() const;

  public:
  void clear_predicate() ;
  const ::anduril::entitymanager::v1::Predicate& predicate() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Predicate* release_predicate();
  ::anduril::entitymanager::v1::Predicate* mutable_predicate();
  void set_allocated_predicate(::anduril::entitymanager::v1::Predicate* value);
  void unsafe_arena_set_allocated_predicate(::anduril::entitymanager::v1::Predicate* value);
  ::anduril::entitymanager::v1::Predicate* unsafe_arena_release_predicate();

  private:
  const ::anduril::entitymanager::v1::Predicate& _internal_predicate() const;
  ::anduril::entitymanager::v1::Predicate* _internal_mutable_predicate();

  public:
  void clear_operation();
  OperationCase operation_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Statement)
 private:
  class _Internal;
  void set_has_and_();
  void set_has_or_();
  void set_has_not_();
  void set_has_list();
  void set_has_predicate();
  inline bool has_operation() const;
  inline void clear_has_operation();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Statement_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Statement& from_msg);
    union OperationUnion {
      constexpr OperationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::AndOperation* and__;
      ::anduril::entitymanager::v1::OrOperation* or__;
      ::anduril::entitymanager::v1::NotOperation* not__;
      ::anduril::entitymanager::v1::ListOperation* list_;
      ::anduril::entitymanager::v1::Predicate* predicate_;
    } operation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};
// -------------------------------------------------------------------

class StatementSet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.StatementSet) */ {
 public:
  inline StatementSet() : StatementSet(nullptr) {}
  ~StatementSet() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StatementSet(
      ::google::protobuf::internal::ConstantInitialized);

  inline StatementSet(const StatementSet& from) : StatementSet(nullptr, from) {}
  inline StatementSet(StatementSet&& from) noexcept
      : StatementSet(nullptr, std::move(from)) {}
  inline StatementSet& operator=(const StatementSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatementSet& operator=(StatementSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatementSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatementSet* internal_default_instance() {
    return reinterpret_cast<const StatementSet*>(
        &_StatementSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(StatementSet& a, StatementSet& b) { a.Swap(&b); }
  inline void Swap(StatementSet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatementSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatementSet* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<StatementSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatementSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StatementSet& from) { StatementSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatementSet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.StatementSet"; }

 protected:
  explicit StatementSet(::google::protobuf::Arena* arena);
  StatementSet(::google::protobuf::Arena* arena, const StatementSet& from);
  StatementSet(::google::protobuf::Arena* arena, StatementSet&& from) noexcept
      : StatementSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatementsFieldNumber = 1,
  };
  // repeated .anduril.entitymanager.v1.Statement statements = 1 [json_name = "statements"];
  int statements_size() const;
  private:
  int _internal_statements_size() const;

  public:
  void clear_statements() ;
  ::anduril::entitymanager::v1::Statement* mutable_statements(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Statement>* mutable_statements();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Statement>& _internal_statements() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Statement>* _internal_mutable_statements();
  public:
  const ::anduril::entitymanager::v1::Statement& statements(int index) const;
  ::anduril::entitymanager::v1::Statement* add_statements();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Statement>& statements() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.StatementSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StatementSet_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StatementSet& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Statement > statements_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Statement

// .anduril.entitymanager.v1.AndOperation and = 1 [json_name = "and"];
inline bool Statement::has_and_() const {
  return operation_case() == kAnd;
}
inline bool Statement::_internal_has_and_() const {
  return operation_case() == kAnd;
}
inline void Statement::set_has_and_() {
  _impl_._oneof_case_[0] = kAnd;
}
inline void Statement::clear_and_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kAnd) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.and__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.and__);
    }
    clear_has_operation();
  }
}
inline ::anduril::entitymanager::v1::AndOperation* Statement::release_and_() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Statement.and)
  if (operation_case() == kAnd) {
    clear_has_operation();
    auto* temp = _impl_.operation_.and__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.and__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::AndOperation& Statement::_internal_and_() const {
  return operation_case() == kAnd ? *_impl_.operation_.and__ : reinterpret_cast<::anduril::entitymanager::v1::AndOperation&>(::anduril::entitymanager::v1::_AndOperation_default_instance_);
}
inline const ::anduril::entitymanager::v1::AndOperation& Statement::and_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Statement.and)
  return _internal_and_();
}
inline ::anduril::entitymanager::v1::AndOperation* Statement::unsafe_arena_release_and_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Statement.and)
  if (operation_case() == kAnd) {
    clear_has_operation();
    auto* temp = _impl_.operation_.and__;
    _impl_.operation_.and__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_and_(::anduril::entitymanager::v1::AndOperation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_and_();
    _impl_.operation_.and__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Statement.and)
}
inline ::anduril::entitymanager::v1::AndOperation* Statement::_internal_mutable_and_() {
  if (operation_case() != kAnd) {
    clear_operation();
    set_has_and_();
    _impl_.operation_.and__ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::AndOperation>(GetArena());
  }
  return _impl_.operation_.and__;
}
inline ::anduril::entitymanager::v1::AndOperation* Statement::mutable_and_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::AndOperation* _msg = _internal_mutable_and_();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Statement.and)
  return _msg;
}

// .anduril.entitymanager.v1.OrOperation or = 2 [json_name = "or"];
inline bool Statement::has_or_() const {
  return operation_case() == kOr;
}
inline bool Statement::_internal_has_or_() const {
  return operation_case() == kOr;
}
inline void Statement::set_has_or_() {
  _impl_._oneof_case_[0] = kOr;
}
inline void Statement::clear_or_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kOr) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.or__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.or__);
    }
    clear_has_operation();
  }
}
inline ::anduril::entitymanager::v1::OrOperation* Statement::release_or_() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Statement.or)
  if (operation_case() == kOr) {
    clear_has_operation();
    auto* temp = _impl_.operation_.or__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.or__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::OrOperation& Statement::_internal_or_() const {
  return operation_case() == kOr ? *_impl_.operation_.or__ : reinterpret_cast<::anduril::entitymanager::v1::OrOperation&>(::anduril::entitymanager::v1::_OrOperation_default_instance_);
}
inline const ::anduril::entitymanager::v1::OrOperation& Statement::or_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Statement.or)
  return _internal_or_();
}
inline ::anduril::entitymanager::v1::OrOperation* Statement::unsafe_arena_release_or_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Statement.or)
  if (operation_case() == kOr) {
    clear_has_operation();
    auto* temp = _impl_.operation_.or__;
    _impl_.operation_.or__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_or_(::anduril::entitymanager::v1::OrOperation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_or_();
    _impl_.operation_.or__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Statement.or)
}
inline ::anduril::entitymanager::v1::OrOperation* Statement::_internal_mutable_or_() {
  if (operation_case() != kOr) {
    clear_operation();
    set_has_or_();
    _impl_.operation_.or__ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::OrOperation>(GetArena());
  }
  return _impl_.operation_.or__;
}
inline ::anduril::entitymanager::v1::OrOperation* Statement::mutable_or_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::OrOperation* _msg = _internal_mutable_or_();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Statement.or)
  return _msg;
}

// .anduril.entitymanager.v1.NotOperation not = 3 [json_name = "not"];
inline bool Statement::has_not_() const {
  return operation_case() == kNot;
}
inline bool Statement::_internal_has_not_() const {
  return operation_case() == kNot;
}
inline void Statement::set_has_not_() {
  _impl_._oneof_case_[0] = kNot;
}
inline void Statement::clear_not_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kNot) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.not__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.not__);
    }
    clear_has_operation();
  }
}
inline ::anduril::entitymanager::v1::NotOperation* Statement::release_not_() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Statement.not)
  if (operation_case() == kNot) {
    clear_has_operation();
    auto* temp = _impl_.operation_.not__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.not__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::NotOperation& Statement::_internal_not_() const {
  return operation_case() == kNot ? *_impl_.operation_.not__ : reinterpret_cast<::anduril::entitymanager::v1::NotOperation&>(::anduril::entitymanager::v1::_NotOperation_default_instance_);
}
inline const ::anduril::entitymanager::v1::NotOperation& Statement::not_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Statement.not)
  return _internal_not_();
}
inline ::anduril::entitymanager::v1::NotOperation* Statement::unsafe_arena_release_not_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Statement.not)
  if (operation_case() == kNot) {
    clear_has_operation();
    auto* temp = _impl_.operation_.not__;
    _impl_.operation_.not__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_not_(::anduril::entitymanager::v1::NotOperation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_not_();
    _impl_.operation_.not__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Statement.not)
}
inline ::anduril::entitymanager::v1::NotOperation* Statement::_internal_mutable_not_() {
  if (operation_case() != kNot) {
    clear_operation();
    set_has_not_();
    _impl_.operation_.not__ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::NotOperation>(GetArena());
  }
  return _impl_.operation_.not__;
}
inline ::anduril::entitymanager::v1::NotOperation* Statement::mutable_not_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::NotOperation* _msg = _internal_mutable_not_();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Statement.not)
  return _msg;
}

// .anduril.entitymanager.v1.ListOperation list = 4 [json_name = "list"];
inline bool Statement::has_list() const {
  return operation_case() == kList;
}
inline bool Statement::_internal_has_list() const {
  return operation_case() == kList;
}
inline void Statement::set_has_list() {
  _impl_._oneof_case_[0] = kList;
}
inline void Statement::clear_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kList) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.list_);
    }
    clear_has_operation();
  }
}
inline ::anduril::entitymanager::v1::ListOperation* Statement::release_list() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Statement.list)
  if (operation_case() == kList) {
    clear_has_operation();
    auto* temp = _impl_.operation_.list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::ListOperation& Statement::_internal_list() const {
  return operation_case() == kList ? *_impl_.operation_.list_ : reinterpret_cast<::anduril::entitymanager::v1::ListOperation&>(::anduril::entitymanager::v1::_ListOperation_default_instance_);
}
inline const ::anduril::entitymanager::v1::ListOperation& Statement::list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Statement.list)
  return _internal_list();
}
inline ::anduril::entitymanager::v1::ListOperation* Statement::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Statement.list)
  if (operation_case() == kList) {
    clear_has_operation();
    auto* temp = _impl_.operation_.list_;
    _impl_.operation_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_list(::anduril::entitymanager::v1::ListOperation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_list();
    _impl_.operation_.list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Statement.list)
}
inline ::anduril::entitymanager::v1::ListOperation* Statement::_internal_mutable_list() {
  if (operation_case() != kList) {
    clear_operation();
    set_has_list();
    _impl_.operation_.list_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::ListOperation>(GetArena());
  }
  return _impl_.operation_.list_;
}
inline ::anduril::entitymanager::v1::ListOperation* Statement::mutable_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::ListOperation* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Statement.list)
  return _msg;
}

// .anduril.entitymanager.v1.Predicate predicate = 5 [json_name = "predicate"];
inline bool Statement::has_predicate() const {
  return operation_case() == kPredicate;
}
inline bool Statement::_internal_has_predicate() const {
  return operation_case() == kPredicate;
}
inline void Statement::set_has_predicate() {
  _impl_._oneof_case_[0] = kPredicate;
}
inline void Statement::clear_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (operation_case() == kPredicate) {
    if (GetArena() == nullptr) {
      delete _impl_.operation_.predicate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.operation_.predicate_);
    }
    clear_has_operation();
  }
}
inline ::anduril::entitymanager::v1::Predicate* Statement::release_predicate() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Statement.predicate)
  if (operation_case() == kPredicate) {
    clear_has_operation();
    auto* temp = _impl_.operation_.predicate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.operation_.predicate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::Predicate& Statement::_internal_predicate() const {
  return operation_case() == kPredicate ? *_impl_.operation_.predicate_ : reinterpret_cast<::anduril::entitymanager::v1::Predicate&>(::anduril::entitymanager::v1::_Predicate_default_instance_);
}
inline const ::anduril::entitymanager::v1::Predicate& Statement::predicate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Statement.predicate)
  return _internal_predicate();
}
inline ::anduril::entitymanager::v1::Predicate* Statement::unsafe_arena_release_predicate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Statement.predicate)
  if (operation_case() == kPredicate) {
    clear_has_operation();
    auto* temp = _impl_.operation_.predicate_;
    _impl_.operation_.predicate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_predicate(::anduril::entitymanager::v1::Predicate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_operation();
  if (value) {
    set_has_predicate();
    _impl_.operation_.predicate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Statement.predicate)
}
inline ::anduril::entitymanager::v1::Predicate* Statement::_internal_mutable_predicate() {
  if (operation_case() != kPredicate) {
    clear_operation();
    set_has_predicate();
    _impl_.operation_.predicate_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Predicate>(GetArena());
  }
  return _impl_.operation_.predicate_;
}
inline ::anduril::entitymanager::v1::Predicate* Statement::mutable_predicate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Predicate* _msg = _internal_mutable_predicate();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Statement.predicate)
  return _msg;
}

inline bool Statement::has_operation() const {
  return operation_case() != OPERATION_NOT_SET;
}
inline void Statement::clear_has_operation() {
  _impl_._oneof_case_[0] = OPERATION_NOT_SET;
}
inline Statement::OperationCase Statement::operation_case() const {
  return Statement::OperationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AndOperation

// .anduril.entitymanager.v1.PredicateSet predicate_set = 1 [json_name = "predicateSet"];
inline bool AndOperation::has_predicate_set() const {
  return children_case() == kPredicateSet;
}
inline bool AndOperation::_internal_has_predicate_set() const {
  return children_case() == kPredicateSet;
}
inline void AndOperation::set_has_predicate_set() {
  _impl_._oneof_case_[0] = kPredicateSet;
}
inline void AndOperation::clear_predicate_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (children_case() == kPredicateSet) {
    if (GetArena() == nullptr) {
      delete _impl_.children_.predicate_set_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.children_.predicate_set_);
    }
    clear_has_children();
  }
}
inline ::anduril::entitymanager::v1::PredicateSet* AndOperation::release_predicate_set() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.AndOperation.predicate_set)
  if (children_case() == kPredicateSet) {
    clear_has_children();
    auto* temp = _impl_.children_.predicate_set_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.children_.predicate_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::PredicateSet& AndOperation::_internal_predicate_set() const {
  return children_case() == kPredicateSet ? *_impl_.children_.predicate_set_ : reinterpret_cast<::anduril::entitymanager::v1::PredicateSet&>(::anduril::entitymanager::v1::_PredicateSet_default_instance_);
}
inline const ::anduril::entitymanager::v1::PredicateSet& AndOperation::predicate_set() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.AndOperation.predicate_set)
  return _internal_predicate_set();
}
inline ::anduril::entitymanager::v1::PredicateSet* AndOperation::unsafe_arena_release_predicate_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.AndOperation.predicate_set)
  if (children_case() == kPredicateSet) {
    clear_has_children();
    auto* temp = _impl_.children_.predicate_set_;
    _impl_.children_.predicate_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AndOperation::unsafe_arena_set_allocated_predicate_set(::anduril::entitymanager::v1::PredicateSet* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_children();
  if (value) {
    set_has_predicate_set();
    _impl_.children_.predicate_set_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.AndOperation.predicate_set)
}
inline ::anduril::entitymanager::v1::PredicateSet* AndOperation::_internal_mutable_predicate_set() {
  if (children_case() != kPredicateSet) {
    clear_children();
    set_has_predicate_set();
    _impl_.children_.predicate_set_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::PredicateSet>(GetArena());
  }
  return _impl_.children_.predicate_set_;
}
inline ::anduril::entitymanager::v1::PredicateSet* AndOperation::mutable_predicate_set() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::PredicateSet* _msg = _internal_mutable_predicate_set();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.AndOperation.predicate_set)
  return _msg;
}

// .anduril.entitymanager.v1.StatementSet statement_set = 2 [json_name = "statementSet"];
inline bool AndOperation::has_statement_set() const {
  return children_case() == kStatementSet;
}
inline bool AndOperation::_internal_has_statement_set() const {
  return children_case() == kStatementSet;
}
inline void AndOperation::set_has_statement_set() {
  _impl_._oneof_case_[0] = kStatementSet;
}
inline void AndOperation::clear_statement_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (children_case() == kStatementSet) {
    if (GetArena() == nullptr) {
      delete _impl_.children_.statement_set_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.children_.statement_set_);
    }
    clear_has_children();
  }
}
inline ::anduril::entitymanager::v1::StatementSet* AndOperation::release_statement_set() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.AndOperation.statement_set)
  if (children_case() == kStatementSet) {
    clear_has_children();
    auto* temp = _impl_.children_.statement_set_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.children_.statement_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::StatementSet& AndOperation::_internal_statement_set() const {
  return children_case() == kStatementSet ? *_impl_.children_.statement_set_ : reinterpret_cast<::anduril::entitymanager::v1::StatementSet&>(::anduril::entitymanager::v1::_StatementSet_default_instance_);
}
inline const ::anduril::entitymanager::v1::StatementSet& AndOperation::statement_set() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.AndOperation.statement_set)
  return _internal_statement_set();
}
inline ::anduril::entitymanager::v1::StatementSet* AndOperation::unsafe_arena_release_statement_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.AndOperation.statement_set)
  if (children_case() == kStatementSet) {
    clear_has_children();
    auto* temp = _impl_.children_.statement_set_;
    _impl_.children_.statement_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AndOperation::unsafe_arena_set_allocated_statement_set(::anduril::entitymanager::v1::StatementSet* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_children();
  if (value) {
    set_has_statement_set();
    _impl_.children_.statement_set_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.AndOperation.statement_set)
}
inline ::anduril::entitymanager::v1::StatementSet* AndOperation::_internal_mutable_statement_set() {
  if (children_case() != kStatementSet) {
    clear_children();
    set_has_statement_set();
    _impl_.children_.statement_set_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::StatementSet>(GetArena());
  }
  return _impl_.children_.statement_set_;
}
inline ::anduril::entitymanager::v1::StatementSet* AndOperation::mutable_statement_set() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::StatementSet* _msg = _internal_mutable_statement_set();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.AndOperation.statement_set)
  return _msg;
}

inline bool AndOperation::has_children() const {
  return children_case() != CHILDREN_NOT_SET;
}
inline void AndOperation::clear_has_children() {
  _impl_._oneof_case_[0] = CHILDREN_NOT_SET;
}
inline AndOperation::ChildrenCase AndOperation::children_case() const {
  return AndOperation::ChildrenCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OrOperation

// .anduril.entitymanager.v1.PredicateSet predicate_set = 1 [json_name = "predicateSet"];
inline bool OrOperation::has_predicate_set() const {
  return children_case() == kPredicateSet;
}
inline bool OrOperation::_internal_has_predicate_set() const {
  return children_case() == kPredicateSet;
}
inline void OrOperation::set_has_predicate_set() {
  _impl_._oneof_case_[0] = kPredicateSet;
}
inline void OrOperation::clear_predicate_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (children_case() == kPredicateSet) {
    if (GetArena() == nullptr) {
      delete _impl_.children_.predicate_set_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.children_.predicate_set_);
    }
    clear_has_children();
  }
}
inline ::anduril::entitymanager::v1::PredicateSet* OrOperation::release_predicate_set() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.OrOperation.predicate_set)
  if (children_case() == kPredicateSet) {
    clear_has_children();
    auto* temp = _impl_.children_.predicate_set_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.children_.predicate_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::PredicateSet& OrOperation::_internal_predicate_set() const {
  return children_case() == kPredicateSet ? *_impl_.children_.predicate_set_ : reinterpret_cast<::anduril::entitymanager::v1::PredicateSet&>(::anduril::entitymanager::v1::_PredicateSet_default_instance_);
}
inline const ::anduril::entitymanager::v1::PredicateSet& OrOperation::predicate_set() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.OrOperation.predicate_set)
  return _internal_predicate_set();
}
inline ::anduril::entitymanager::v1::PredicateSet* OrOperation::unsafe_arena_release_predicate_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.OrOperation.predicate_set)
  if (children_case() == kPredicateSet) {
    clear_has_children();
    auto* temp = _impl_.children_.predicate_set_;
    _impl_.children_.predicate_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OrOperation::unsafe_arena_set_allocated_predicate_set(::anduril::entitymanager::v1::PredicateSet* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_children();
  if (value) {
    set_has_predicate_set();
    _impl_.children_.predicate_set_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.OrOperation.predicate_set)
}
inline ::anduril::entitymanager::v1::PredicateSet* OrOperation::_internal_mutable_predicate_set() {
  if (children_case() != kPredicateSet) {
    clear_children();
    set_has_predicate_set();
    _impl_.children_.predicate_set_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::PredicateSet>(GetArena());
  }
  return _impl_.children_.predicate_set_;
}
inline ::anduril::entitymanager::v1::PredicateSet* OrOperation::mutable_predicate_set() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::PredicateSet* _msg = _internal_mutable_predicate_set();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.OrOperation.predicate_set)
  return _msg;
}

// .anduril.entitymanager.v1.StatementSet statement_set = 2 [json_name = "statementSet"];
inline bool OrOperation::has_statement_set() const {
  return children_case() == kStatementSet;
}
inline bool OrOperation::_internal_has_statement_set() const {
  return children_case() == kStatementSet;
}
inline void OrOperation::set_has_statement_set() {
  _impl_._oneof_case_[0] = kStatementSet;
}
inline void OrOperation::clear_statement_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (children_case() == kStatementSet) {
    if (GetArena() == nullptr) {
      delete _impl_.children_.statement_set_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.children_.statement_set_);
    }
    clear_has_children();
  }
}
inline ::anduril::entitymanager::v1::StatementSet* OrOperation::release_statement_set() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.OrOperation.statement_set)
  if (children_case() == kStatementSet) {
    clear_has_children();
    auto* temp = _impl_.children_.statement_set_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.children_.statement_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::StatementSet& OrOperation::_internal_statement_set() const {
  return children_case() == kStatementSet ? *_impl_.children_.statement_set_ : reinterpret_cast<::anduril::entitymanager::v1::StatementSet&>(::anduril::entitymanager::v1::_StatementSet_default_instance_);
}
inline const ::anduril::entitymanager::v1::StatementSet& OrOperation::statement_set() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.OrOperation.statement_set)
  return _internal_statement_set();
}
inline ::anduril::entitymanager::v1::StatementSet* OrOperation::unsafe_arena_release_statement_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.OrOperation.statement_set)
  if (children_case() == kStatementSet) {
    clear_has_children();
    auto* temp = _impl_.children_.statement_set_;
    _impl_.children_.statement_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OrOperation::unsafe_arena_set_allocated_statement_set(::anduril::entitymanager::v1::StatementSet* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_children();
  if (value) {
    set_has_statement_set();
    _impl_.children_.statement_set_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.OrOperation.statement_set)
}
inline ::anduril::entitymanager::v1::StatementSet* OrOperation::_internal_mutable_statement_set() {
  if (children_case() != kStatementSet) {
    clear_children();
    set_has_statement_set();
    _impl_.children_.statement_set_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::StatementSet>(GetArena());
  }
  return _impl_.children_.statement_set_;
}
inline ::anduril::entitymanager::v1::StatementSet* OrOperation::mutable_statement_set() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::StatementSet* _msg = _internal_mutable_statement_set();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.OrOperation.statement_set)
  return _msg;
}

inline bool OrOperation::has_children() const {
  return children_case() != CHILDREN_NOT_SET;
}
inline void OrOperation::clear_has_children() {
  _impl_._oneof_case_[0] = CHILDREN_NOT_SET;
}
inline OrOperation::ChildrenCase OrOperation::children_case() const {
  return OrOperation::ChildrenCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NotOperation

// .anduril.entitymanager.v1.Predicate predicate = 1 [json_name = "predicate"];
inline bool NotOperation::has_predicate() const {
  return child_case() == kPredicate;
}
inline bool NotOperation::_internal_has_predicate() const {
  return child_case() == kPredicate;
}
inline void NotOperation::set_has_predicate() {
  _impl_._oneof_case_[0] = kPredicate;
}
inline void NotOperation::clear_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (child_case() == kPredicate) {
    if (GetArena() == nullptr) {
      delete _impl_.child_.predicate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.child_.predicate_);
    }
    clear_has_child();
  }
}
inline ::anduril::entitymanager::v1::Predicate* NotOperation::release_predicate() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.NotOperation.predicate)
  if (child_case() == kPredicate) {
    clear_has_child();
    auto* temp = _impl_.child_.predicate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.child_.predicate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::Predicate& NotOperation::_internal_predicate() const {
  return child_case() == kPredicate ? *_impl_.child_.predicate_ : reinterpret_cast<::anduril::entitymanager::v1::Predicate&>(::anduril::entitymanager::v1::_Predicate_default_instance_);
}
inline const ::anduril::entitymanager::v1::Predicate& NotOperation::predicate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.NotOperation.predicate)
  return _internal_predicate();
}
inline ::anduril::entitymanager::v1::Predicate* NotOperation::unsafe_arena_release_predicate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.NotOperation.predicate)
  if (child_case() == kPredicate) {
    clear_has_child();
    auto* temp = _impl_.child_.predicate_;
    _impl_.child_.predicate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotOperation::unsafe_arena_set_allocated_predicate(::anduril::entitymanager::v1::Predicate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_child();
  if (value) {
    set_has_predicate();
    _impl_.child_.predicate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.NotOperation.predicate)
}
inline ::anduril::entitymanager::v1::Predicate* NotOperation::_internal_mutable_predicate() {
  if (child_case() != kPredicate) {
    clear_child();
    set_has_predicate();
    _impl_.child_.predicate_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Predicate>(GetArena());
  }
  return _impl_.child_.predicate_;
}
inline ::anduril::entitymanager::v1::Predicate* NotOperation::mutable_predicate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Predicate* _msg = _internal_mutable_predicate();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.NotOperation.predicate)
  return _msg;
}

// .anduril.entitymanager.v1.Statement statement = 2 [json_name = "statement"];
inline bool NotOperation::has_statement() const {
  return child_case() == kStatement;
}
inline bool NotOperation::_internal_has_statement() const {
  return child_case() == kStatement;
}
inline void NotOperation::set_has_statement() {
  _impl_._oneof_case_[0] = kStatement;
}
inline void NotOperation::clear_statement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (child_case() == kStatement) {
    if (GetArena() == nullptr) {
      delete _impl_.child_.statement_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.child_.statement_);
    }
    clear_has_child();
  }
}
inline ::anduril::entitymanager::v1::Statement* NotOperation::release_statement() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.NotOperation.statement)
  if (child_case() == kStatement) {
    clear_has_child();
    auto* temp = _impl_.child_.statement_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.child_.statement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::Statement& NotOperation::_internal_statement() const {
  return child_case() == kStatement ? *_impl_.child_.statement_ : reinterpret_cast<::anduril::entitymanager::v1::Statement&>(::anduril::entitymanager::v1::_Statement_default_instance_);
}
inline const ::anduril::entitymanager::v1::Statement& NotOperation::statement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.NotOperation.statement)
  return _internal_statement();
}
inline ::anduril::entitymanager::v1::Statement* NotOperation::unsafe_arena_release_statement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.NotOperation.statement)
  if (child_case() == kStatement) {
    clear_has_child();
    auto* temp = _impl_.child_.statement_;
    _impl_.child_.statement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotOperation::unsafe_arena_set_allocated_statement(::anduril::entitymanager::v1::Statement* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_child();
  if (value) {
    set_has_statement();
    _impl_.child_.statement_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.NotOperation.statement)
}
inline ::anduril::entitymanager::v1::Statement* NotOperation::_internal_mutable_statement() {
  if (child_case() != kStatement) {
    clear_child();
    set_has_statement();
    _impl_.child_.statement_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Statement>(GetArena());
  }
  return _impl_.child_.statement_;
}
inline ::anduril::entitymanager::v1::Statement* NotOperation::mutable_statement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Statement* _msg = _internal_mutable_statement();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.NotOperation.statement)
  return _msg;
}

inline bool NotOperation::has_child() const {
  return child_case() != CHILD_NOT_SET;
}
inline void NotOperation::clear_has_child() {
  _impl_._oneof_case_[0] = CHILD_NOT_SET;
}
inline NotOperation::ChildCase NotOperation::child_case() const {
  return NotOperation::ChildCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ListOperation

// string list_path = 1 [json_name = "listPath"];
inline void ListOperation::clear_list_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.list_path_.ClearToEmpty();
}
inline const std::string& ListOperation::list_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.ListOperation.list_path)
  return _internal_list_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListOperation::set_list_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.list_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.ListOperation.list_path)
}
inline std::string* ListOperation::mutable_list_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_list_path();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.ListOperation.list_path)
  return _s;
}
inline const std::string& ListOperation::_internal_list_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.list_path_.Get();
}
inline void ListOperation::_internal_set_list_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.list_path_.Set(value, GetArena());
}
inline std::string* ListOperation::_internal_mutable_list_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.list_path_.Mutable( GetArena());
}
inline std::string* ListOperation::release_list_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.ListOperation.list_path)
  return _impl_.list_path_.Release();
}
inline void ListOperation::set_allocated_list_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.list_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.list_path_.IsDefault()) {
          _impl_.list_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.ListOperation.list_path)
}

// .anduril.entitymanager.v1.ListComparator list_comparator = 2 [json_name = "listComparator"];
inline void ListOperation::clear_list_comparator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.list_comparator_ = 0;
}
inline ::anduril::entitymanager::v1::ListComparator ListOperation::list_comparator() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.ListOperation.list_comparator)
  return _internal_list_comparator();
}
inline void ListOperation::set_list_comparator(::anduril::entitymanager::v1::ListComparator value) {
  _internal_set_list_comparator(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.ListOperation.list_comparator)
}
inline ::anduril::entitymanager::v1::ListComparator ListOperation::_internal_list_comparator() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::ListComparator>(_impl_.list_comparator_);
}
inline void ListOperation::_internal_set_list_comparator(::anduril::entitymanager::v1::ListComparator value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.list_comparator_ = value;
}

// .anduril.entitymanager.v1.Statement statement = 3 [json_name = "statement"];
inline bool ListOperation::has_statement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.statement_ != nullptr);
  return value;
}
inline void ListOperation::clear_statement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.statement_ != nullptr) _impl_.statement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::Statement& ListOperation::_internal_statement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Statement* p = _impl_.statement_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Statement&>(::anduril::entitymanager::v1::_Statement_default_instance_);
}
inline const ::anduril::entitymanager::v1::Statement& ListOperation::statement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.ListOperation.statement)
  return _internal_statement();
}
inline void ListOperation::unsafe_arena_set_allocated_statement(::anduril::entitymanager::v1::Statement* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statement_);
  }
  _impl_.statement_ = reinterpret_cast<::anduril::entitymanager::v1::Statement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.ListOperation.statement)
}
inline ::anduril::entitymanager::v1::Statement* ListOperation::release_statement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Statement* released = _impl_.statement_;
  _impl_.statement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Statement* ListOperation::unsafe_arena_release_statement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.ListOperation.statement)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Statement* temp = _impl_.statement_;
  _impl_.statement_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Statement* ListOperation::_internal_mutable_statement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.statement_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Statement>(GetArena());
    _impl_.statement_ = reinterpret_cast<::anduril::entitymanager::v1::Statement*>(p);
  }
  return _impl_.statement_;
}
inline ::anduril::entitymanager::v1::Statement* ListOperation::mutable_statement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Statement* _msg = _internal_mutable_statement();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.ListOperation.statement)
  return _msg;
}
inline void ListOperation::set_allocated_statement(::anduril::entitymanager::v1::Statement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.statement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.statement_ = reinterpret_cast<::anduril::entitymanager::v1::Statement*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.ListOperation.statement)
}

// -------------------------------------------------------------------

// PredicateSet

// repeated .anduril.entitymanager.v1.Predicate predicates = 1 [json_name = "predicates"];
inline int PredicateSet::_internal_predicates_size() const {
  return _internal_predicates().size();
}
inline int PredicateSet::predicates_size() const {
  return _internal_predicates_size();
}
inline void PredicateSet::clear_predicates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.predicates_.Clear();
}
inline ::anduril::entitymanager::v1::Predicate* PredicateSet::mutable_predicates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.PredicateSet.predicates)
  return _internal_mutable_predicates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Predicate>* PredicateSet::mutable_predicates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.PredicateSet.predicates)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_predicates();
}
inline const ::anduril::entitymanager::v1::Predicate& PredicateSet::predicates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.PredicateSet.predicates)
  return _internal_predicates().Get(index);
}
inline ::anduril::entitymanager::v1::Predicate* PredicateSet::add_predicates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::Predicate* _add = _internal_mutable_predicates()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.PredicateSet.predicates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Predicate>& PredicateSet::predicates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.PredicateSet.predicates)
  return _internal_predicates();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Predicate>&
PredicateSet::_internal_predicates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.predicates_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Predicate>*
PredicateSet::_internal_mutable_predicates() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.predicates_;
}

// -------------------------------------------------------------------

// StatementSet

// repeated .anduril.entitymanager.v1.Statement statements = 1 [json_name = "statements"];
inline int StatementSet::_internal_statements_size() const {
  return _internal_statements().size();
}
inline int StatementSet::statements_size() const {
  return _internal_statements_size();
}
inline void StatementSet::clear_statements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statements_.Clear();
}
inline ::anduril::entitymanager::v1::Statement* StatementSet::mutable_statements(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.StatementSet.statements)
  return _internal_mutable_statements()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Statement>* StatementSet::mutable_statements()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.StatementSet.statements)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_statements();
}
inline const ::anduril::entitymanager::v1::Statement& StatementSet::statements(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.StatementSet.statements)
  return _internal_statements().Get(index);
}
inline ::anduril::entitymanager::v1::Statement* StatementSet::add_statements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::Statement* _add = _internal_mutable_statements()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.StatementSet.statements)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Statement>& StatementSet::statements() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.StatementSet.statements)
  return _internal_statements();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Statement>&
StatementSet::_internal_statements() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.statements_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Statement>*
StatementSet::_internal_mutable_statements() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.statements_;
}

// -------------------------------------------------------------------

// Predicate

// string field_path = 1 [json_name = "fieldPath"];
inline void Predicate::clear_field_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_path_.ClearToEmpty();
}
inline const std::string& Predicate::field_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Predicate.field_path)
  return _internal_field_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Predicate::set_field_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Predicate.field_path)
}
inline std::string* Predicate::mutable_field_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_field_path();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Predicate.field_path)
  return _s;
}
inline const std::string& Predicate::_internal_field_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_path_.Get();
}
inline void Predicate::_internal_set_field_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_path_.Set(value, GetArena());
}
inline std::string* Predicate::_internal_mutable_field_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.field_path_.Mutable( GetArena());
}
inline std::string* Predicate::release_field_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Predicate.field_path)
  return _impl_.field_path_.Release();
}
inline void Predicate::set_allocated_field_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.field_path_.IsDefault()) {
          _impl_.field_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Predicate.field_path)
}

// .anduril.entitymanager.v1.Value value = 2 [json_name = "value"];
inline bool Predicate::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void Predicate::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::Value& Predicate::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Value* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Value&>(::anduril::entitymanager::v1::_Value_default_instance_);
}
inline const ::anduril::entitymanager::v1::Value& Predicate::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Predicate.value)
  return _internal_value();
}
inline void Predicate::unsafe_arena_set_allocated_value(::anduril::entitymanager::v1::Value* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::anduril::entitymanager::v1::Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Predicate.value)
}
inline ::anduril::entitymanager::v1::Value* Predicate::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Value* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Value* Predicate::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Predicate.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Value* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Value* Predicate::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Value>(GetArena());
    _impl_.value_ = reinterpret_cast<::anduril::entitymanager::v1::Value*>(p);
  }
  return _impl_.value_;
}
inline ::anduril::entitymanager::v1::Value* Predicate::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Value* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Predicate.value)
  return _msg;
}
inline void Predicate::set_allocated_value(::anduril::entitymanager::v1::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::anduril::entitymanager::v1::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Predicate.value)
}

// .anduril.entitymanager.v1.Comparator comparator = 3 [json_name = "comparator"];
inline void Predicate::clear_comparator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comparator_ = 0;
}
inline ::anduril::entitymanager::v1::Comparator Predicate::comparator() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Predicate.comparator)
  return _internal_comparator();
}
inline void Predicate::set_comparator(::anduril::entitymanager::v1::Comparator value) {
  _internal_set_comparator(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Predicate.comparator)
}
inline ::anduril::entitymanager::v1::Comparator Predicate::_internal_comparator() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::Comparator>(_impl_.comparator_);
}
inline void Predicate::_internal_set_comparator(::anduril::entitymanager::v1::Comparator value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comparator_ = value;
}

// -------------------------------------------------------------------

// Value

// .anduril.entitymanager.v1.BooleanType boolean_type = 1 [json_name = "booleanType"];
inline bool Value::has_boolean_type() const {
  return type_case() == kBooleanType;
}
inline bool Value::_internal_has_boolean_type() const {
  return type_case() == kBooleanType;
}
inline void Value::set_has_boolean_type() {
  _impl_._oneof_case_[0] = kBooleanType;
}
inline void Value::clear_boolean_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kBooleanType) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.boolean_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.boolean_type_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::BooleanType* Value::release_boolean_type() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Value.boolean_type)
  if (type_case() == kBooleanType) {
    clear_has_type();
    auto* temp = _impl_.type_.boolean_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.boolean_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::BooleanType& Value::_internal_boolean_type() const {
  return type_case() == kBooleanType ? *_impl_.type_.boolean_type_ : reinterpret_cast<::anduril::entitymanager::v1::BooleanType&>(::anduril::entitymanager::v1::_BooleanType_default_instance_);
}
inline const ::anduril::entitymanager::v1::BooleanType& Value::boolean_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Value.boolean_type)
  return _internal_boolean_type();
}
inline ::anduril::entitymanager::v1::BooleanType* Value::unsafe_arena_release_boolean_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Value.boolean_type)
  if (type_case() == kBooleanType) {
    clear_has_type();
    auto* temp = _impl_.type_.boolean_type_;
    _impl_.type_.boolean_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_boolean_type(::anduril::entitymanager::v1::BooleanType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_boolean_type();
    _impl_.type_.boolean_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Value.boolean_type)
}
inline ::anduril::entitymanager::v1::BooleanType* Value::_internal_mutable_boolean_type() {
  if (type_case() != kBooleanType) {
    clear_type();
    set_has_boolean_type();
    _impl_.type_.boolean_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::BooleanType>(GetArena());
  }
  return _impl_.type_.boolean_type_;
}
inline ::anduril::entitymanager::v1::BooleanType* Value::mutable_boolean_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::BooleanType* _msg = _internal_mutable_boolean_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Value.boolean_type)
  return _msg;
}

// .anduril.entitymanager.v1.NumericType numeric_type = 2 [json_name = "numericType"];
inline bool Value::has_numeric_type() const {
  return type_case() == kNumericType;
}
inline bool Value::_internal_has_numeric_type() const {
  return type_case() == kNumericType;
}
inline void Value::set_has_numeric_type() {
  _impl_._oneof_case_[0] = kNumericType;
}
inline void Value::clear_numeric_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kNumericType) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.numeric_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.numeric_type_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::NumericType* Value::release_numeric_type() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Value.numeric_type)
  if (type_case() == kNumericType) {
    clear_has_type();
    auto* temp = _impl_.type_.numeric_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.numeric_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::NumericType& Value::_internal_numeric_type() const {
  return type_case() == kNumericType ? *_impl_.type_.numeric_type_ : reinterpret_cast<::anduril::entitymanager::v1::NumericType&>(::anduril::entitymanager::v1::_NumericType_default_instance_);
}
inline const ::anduril::entitymanager::v1::NumericType& Value::numeric_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Value.numeric_type)
  return _internal_numeric_type();
}
inline ::anduril::entitymanager::v1::NumericType* Value::unsafe_arena_release_numeric_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Value.numeric_type)
  if (type_case() == kNumericType) {
    clear_has_type();
    auto* temp = _impl_.type_.numeric_type_;
    _impl_.type_.numeric_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_numeric_type(::anduril::entitymanager::v1::NumericType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_numeric_type();
    _impl_.type_.numeric_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Value.numeric_type)
}
inline ::anduril::entitymanager::v1::NumericType* Value::_internal_mutable_numeric_type() {
  if (type_case() != kNumericType) {
    clear_type();
    set_has_numeric_type();
    _impl_.type_.numeric_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::NumericType>(GetArena());
  }
  return _impl_.type_.numeric_type_;
}
inline ::anduril::entitymanager::v1::NumericType* Value::mutable_numeric_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::NumericType* _msg = _internal_mutable_numeric_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Value.numeric_type)
  return _msg;
}

// .anduril.entitymanager.v1.StringType string_type = 3 [json_name = "stringType"];
inline bool Value::has_string_type() const {
  return type_case() == kStringType;
}
inline bool Value::_internal_has_string_type() const {
  return type_case() == kStringType;
}
inline void Value::set_has_string_type() {
  _impl_._oneof_case_[0] = kStringType;
}
inline void Value::clear_string_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kStringType) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.string_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.string_type_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::StringType* Value::release_string_type() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Value.string_type)
  if (type_case() == kStringType) {
    clear_has_type();
    auto* temp = _impl_.type_.string_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.string_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::StringType& Value::_internal_string_type() const {
  return type_case() == kStringType ? *_impl_.type_.string_type_ : reinterpret_cast<::anduril::entitymanager::v1::StringType&>(::anduril::entitymanager::v1::_StringType_default_instance_);
}
inline const ::anduril::entitymanager::v1::StringType& Value::string_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Value.string_type)
  return _internal_string_type();
}
inline ::anduril::entitymanager::v1::StringType* Value::unsafe_arena_release_string_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Value.string_type)
  if (type_case() == kStringType) {
    clear_has_type();
    auto* temp = _impl_.type_.string_type_;
    _impl_.type_.string_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_string_type(::anduril::entitymanager::v1::StringType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_string_type();
    _impl_.type_.string_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Value.string_type)
}
inline ::anduril::entitymanager::v1::StringType* Value::_internal_mutable_string_type() {
  if (type_case() != kStringType) {
    clear_type();
    set_has_string_type();
    _impl_.type_.string_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::StringType>(GetArena());
  }
  return _impl_.type_.string_type_;
}
inline ::anduril::entitymanager::v1::StringType* Value::mutable_string_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::StringType* _msg = _internal_mutable_string_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Value.string_type)
  return _msg;
}

// .anduril.entitymanager.v1.EnumType enum_type = 4 [json_name = "enumType"];
inline bool Value::has_enum_type() const {
  return type_case() == kEnumType;
}
inline bool Value::_internal_has_enum_type() const {
  return type_case() == kEnumType;
}
inline void Value::set_has_enum_type() {
  _impl_._oneof_case_[0] = kEnumType;
}
inline void Value::clear_enum_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kEnumType) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.enum_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.enum_type_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::EnumType* Value::release_enum_type() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Value.enum_type)
  if (type_case() == kEnumType) {
    clear_has_type();
    auto* temp = _impl_.type_.enum_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.enum_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::EnumType& Value::_internal_enum_type() const {
  return type_case() == kEnumType ? *_impl_.type_.enum_type_ : reinterpret_cast<::anduril::entitymanager::v1::EnumType&>(::anduril::entitymanager::v1::_EnumType_default_instance_);
}
inline const ::anduril::entitymanager::v1::EnumType& Value::enum_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Value.enum_type)
  return _internal_enum_type();
}
inline ::anduril::entitymanager::v1::EnumType* Value::unsafe_arena_release_enum_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Value.enum_type)
  if (type_case() == kEnumType) {
    clear_has_type();
    auto* temp = _impl_.type_.enum_type_;
    _impl_.type_.enum_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_enum_type(::anduril::entitymanager::v1::EnumType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_enum_type();
    _impl_.type_.enum_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Value.enum_type)
}
inline ::anduril::entitymanager::v1::EnumType* Value::_internal_mutable_enum_type() {
  if (type_case() != kEnumType) {
    clear_type();
    set_has_enum_type();
    _impl_.type_.enum_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::EnumType>(GetArena());
  }
  return _impl_.type_.enum_type_;
}
inline ::anduril::entitymanager::v1::EnumType* Value::mutable_enum_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::EnumType* _msg = _internal_mutable_enum_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Value.enum_type)
  return _msg;
}

// .anduril.entitymanager.v1.TimestampType timestamp_type = 5 [json_name = "timestampType"];
inline bool Value::has_timestamp_type() const {
  return type_case() == kTimestampType;
}
inline bool Value::_internal_has_timestamp_type() const {
  return type_case() == kTimestampType;
}
inline void Value::set_has_timestamp_type() {
  _impl_._oneof_case_[0] = kTimestampType;
}
inline void Value::clear_timestamp_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kTimestampType) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.timestamp_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.timestamp_type_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::TimestampType* Value::release_timestamp_type() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Value.timestamp_type)
  if (type_case() == kTimestampType) {
    clear_has_type();
    auto* temp = _impl_.type_.timestamp_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.timestamp_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::TimestampType& Value::_internal_timestamp_type() const {
  return type_case() == kTimestampType ? *_impl_.type_.timestamp_type_ : reinterpret_cast<::anduril::entitymanager::v1::TimestampType&>(::anduril::entitymanager::v1::_TimestampType_default_instance_);
}
inline const ::anduril::entitymanager::v1::TimestampType& Value::timestamp_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Value.timestamp_type)
  return _internal_timestamp_type();
}
inline ::anduril::entitymanager::v1::TimestampType* Value::unsafe_arena_release_timestamp_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Value.timestamp_type)
  if (type_case() == kTimestampType) {
    clear_has_type();
    auto* temp = _impl_.type_.timestamp_type_;
    _impl_.type_.timestamp_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_timestamp_type(::anduril::entitymanager::v1::TimestampType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_timestamp_type();
    _impl_.type_.timestamp_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Value.timestamp_type)
}
inline ::anduril::entitymanager::v1::TimestampType* Value::_internal_mutable_timestamp_type() {
  if (type_case() != kTimestampType) {
    clear_type();
    set_has_timestamp_type();
    _impl_.type_.timestamp_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::TimestampType>(GetArena());
  }
  return _impl_.type_.timestamp_type_;
}
inline ::anduril::entitymanager::v1::TimestampType* Value::mutable_timestamp_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::TimestampType* _msg = _internal_mutable_timestamp_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Value.timestamp_type)
  return _msg;
}

// .anduril.entitymanager.v1.BoundedShapeType bounded_shape_type = 6 [json_name = "boundedShapeType"];
inline bool Value::has_bounded_shape_type() const {
  return type_case() == kBoundedShapeType;
}
inline bool Value::_internal_has_bounded_shape_type() const {
  return type_case() == kBoundedShapeType;
}
inline void Value::set_has_bounded_shape_type() {
  _impl_._oneof_case_[0] = kBoundedShapeType;
}
inline void Value::clear_bounded_shape_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kBoundedShapeType) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.bounded_shape_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.bounded_shape_type_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::BoundedShapeType* Value::release_bounded_shape_type() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Value.bounded_shape_type)
  if (type_case() == kBoundedShapeType) {
    clear_has_type();
    auto* temp = _impl_.type_.bounded_shape_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.bounded_shape_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::BoundedShapeType& Value::_internal_bounded_shape_type() const {
  return type_case() == kBoundedShapeType ? *_impl_.type_.bounded_shape_type_ : reinterpret_cast<::anduril::entitymanager::v1::BoundedShapeType&>(::anduril::entitymanager::v1::_BoundedShapeType_default_instance_);
}
inline const ::anduril::entitymanager::v1::BoundedShapeType& Value::bounded_shape_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Value.bounded_shape_type)
  return _internal_bounded_shape_type();
}
inline ::anduril::entitymanager::v1::BoundedShapeType* Value::unsafe_arena_release_bounded_shape_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Value.bounded_shape_type)
  if (type_case() == kBoundedShapeType) {
    clear_has_type();
    auto* temp = _impl_.type_.bounded_shape_type_;
    _impl_.type_.bounded_shape_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_bounded_shape_type(::anduril::entitymanager::v1::BoundedShapeType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_bounded_shape_type();
    _impl_.type_.bounded_shape_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Value.bounded_shape_type)
}
inline ::anduril::entitymanager::v1::BoundedShapeType* Value::_internal_mutable_bounded_shape_type() {
  if (type_case() != kBoundedShapeType) {
    clear_type();
    set_has_bounded_shape_type();
    _impl_.type_.bounded_shape_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::BoundedShapeType>(GetArena());
  }
  return _impl_.type_.bounded_shape_type_;
}
inline ::anduril::entitymanager::v1::BoundedShapeType* Value::mutable_bounded_shape_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::BoundedShapeType* _msg = _internal_mutable_bounded_shape_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Value.bounded_shape_type)
  return _msg;
}

// .anduril.entitymanager.v1.PositionType position_type = 7 [json_name = "positionType"];
inline bool Value::has_position_type() const {
  return type_case() == kPositionType;
}
inline bool Value::_internal_has_position_type() const {
  return type_case() == kPositionType;
}
inline void Value::set_has_position_type() {
  _impl_._oneof_case_[0] = kPositionType;
}
inline void Value::clear_position_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kPositionType) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.position_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.position_type_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::PositionType* Value::release_position_type() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Value.position_type)
  if (type_case() == kPositionType) {
    clear_has_type();
    auto* temp = _impl_.type_.position_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.position_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::PositionType& Value::_internal_position_type() const {
  return type_case() == kPositionType ? *_impl_.type_.position_type_ : reinterpret_cast<::anduril::entitymanager::v1::PositionType&>(::anduril::entitymanager::v1::_PositionType_default_instance_);
}
inline const ::anduril::entitymanager::v1::PositionType& Value::position_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Value.position_type)
  return _internal_position_type();
}
inline ::anduril::entitymanager::v1::PositionType* Value::unsafe_arena_release_position_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Value.position_type)
  if (type_case() == kPositionType) {
    clear_has_type();
    auto* temp = _impl_.type_.position_type_;
    _impl_.type_.position_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_position_type(::anduril::entitymanager::v1::PositionType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_position_type();
    _impl_.type_.position_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Value.position_type)
}
inline ::anduril::entitymanager::v1::PositionType* Value::_internal_mutable_position_type() {
  if (type_case() != kPositionType) {
    clear_type();
    set_has_position_type();
    _impl_.type_.position_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::PositionType>(GetArena());
  }
  return _impl_.type_.position_type_;
}
inline ::anduril::entitymanager::v1::PositionType* Value::mutable_position_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::PositionType* _msg = _internal_mutable_position_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Value.position_type)
  return _msg;
}

// .anduril.entitymanager.v1.HeadingType heading_type = 8 [json_name = "headingType"];
inline bool Value::has_heading_type() const {
  return type_case() == kHeadingType;
}
inline bool Value::_internal_has_heading_type() const {
  return type_case() == kHeadingType;
}
inline void Value::set_has_heading_type() {
  _impl_._oneof_case_[0] = kHeadingType;
}
inline void Value::clear_heading_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kHeadingType) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.heading_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.heading_type_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::HeadingType* Value::release_heading_type() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Value.heading_type)
  if (type_case() == kHeadingType) {
    clear_has_type();
    auto* temp = _impl_.type_.heading_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.heading_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::HeadingType& Value::_internal_heading_type() const {
  return type_case() == kHeadingType ? *_impl_.type_.heading_type_ : reinterpret_cast<::anduril::entitymanager::v1::HeadingType&>(::anduril::entitymanager::v1::_HeadingType_default_instance_);
}
inline const ::anduril::entitymanager::v1::HeadingType& Value::heading_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Value.heading_type)
  return _internal_heading_type();
}
inline ::anduril::entitymanager::v1::HeadingType* Value::unsafe_arena_release_heading_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Value.heading_type)
  if (type_case() == kHeadingType) {
    clear_has_type();
    auto* temp = _impl_.type_.heading_type_;
    _impl_.type_.heading_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_heading_type(::anduril::entitymanager::v1::HeadingType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_heading_type();
    _impl_.type_.heading_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Value.heading_type)
}
inline ::anduril::entitymanager::v1::HeadingType* Value::_internal_mutable_heading_type() {
  if (type_case() != kHeadingType) {
    clear_type();
    set_has_heading_type();
    _impl_.type_.heading_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::HeadingType>(GetArena());
  }
  return _impl_.type_.heading_type_;
}
inline ::anduril::entitymanager::v1::HeadingType* Value::mutable_heading_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::HeadingType* _msg = _internal_mutable_heading_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Value.heading_type)
  return _msg;
}

// .anduril.entitymanager.v1.ListType list_type = 9 [json_name = "listType"];
inline bool Value::has_list_type() const {
  return type_case() == kListType;
}
inline bool Value::_internal_has_list_type() const {
  return type_case() == kListType;
}
inline void Value::set_has_list_type() {
  _impl_._oneof_case_[0] = kListType;
}
inline void Value::clear_list_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kListType) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.list_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.list_type_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::ListType* Value::release_list_type() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Value.list_type)
  if (type_case() == kListType) {
    clear_has_type();
    auto* temp = _impl_.type_.list_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.list_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::ListType& Value::_internal_list_type() const {
  return type_case() == kListType ? *_impl_.type_.list_type_ : reinterpret_cast<::anduril::entitymanager::v1::ListType&>(::anduril::entitymanager::v1::_ListType_default_instance_);
}
inline const ::anduril::entitymanager::v1::ListType& Value::list_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Value.list_type)
  return _internal_list_type();
}
inline ::anduril::entitymanager::v1::ListType* Value::unsafe_arena_release_list_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Value.list_type)
  if (type_case() == kListType) {
    clear_has_type();
    auto* temp = _impl_.type_.list_type_;
    _impl_.type_.list_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_list_type(::anduril::entitymanager::v1::ListType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_list_type();
    _impl_.type_.list_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Value.list_type)
}
inline ::anduril::entitymanager::v1::ListType* Value::_internal_mutable_list_type() {
  if (type_case() != kListType) {
    clear_type();
    set_has_list_type();
    _impl_.type_.list_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::ListType>(GetArena());
  }
  return _impl_.type_.list_type_;
}
inline ::anduril::entitymanager::v1::ListType* Value::mutable_list_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::ListType* _msg = _internal_mutable_list_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Value.list_type)
  return _msg;
}

// .anduril.entitymanager.v1.RangeType range_type = 10 [json_name = "rangeType"];
inline bool Value::has_range_type() const {
  return type_case() == kRangeType;
}
inline bool Value::_internal_has_range_type() const {
  return type_case() == kRangeType;
}
inline void Value::set_has_range_type() {
  _impl_._oneof_case_[0] = kRangeType;
}
inline void Value::clear_range_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kRangeType) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.range_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.range_type_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::RangeType* Value::release_range_type() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Value.range_type)
  if (type_case() == kRangeType) {
    clear_has_type();
    auto* temp = _impl_.type_.range_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.range_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::RangeType& Value::_internal_range_type() const {
  return type_case() == kRangeType ? *_impl_.type_.range_type_ : reinterpret_cast<::anduril::entitymanager::v1::RangeType&>(::anduril::entitymanager::v1::_RangeType_default_instance_);
}
inline const ::anduril::entitymanager::v1::RangeType& Value::range_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Value.range_type)
  return _internal_range_type();
}
inline ::anduril::entitymanager::v1::RangeType* Value::unsafe_arena_release_range_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Value.range_type)
  if (type_case() == kRangeType) {
    clear_has_type();
    auto* temp = _impl_.type_.range_type_;
    _impl_.type_.range_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_range_type(::anduril::entitymanager::v1::RangeType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_range_type();
    _impl_.type_.range_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Value.range_type)
}
inline ::anduril::entitymanager::v1::RangeType* Value::_internal_mutable_range_type() {
  if (type_case() != kRangeType) {
    clear_type();
    set_has_range_type();
    _impl_.type_.range_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::RangeType>(GetArena());
  }
  return _impl_.type_.range_type_;
}
inline ::anduril::entitymanager::v1::RangeType* Value::mutable_range_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::RangeType* _msg = _internal_mutable_range_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Value.range_type)
  return _msg;
}

inline bool Value::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Value::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Value::TypeCase Value::type_case() const {
  return Value::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BooleanType

// bool value = 1 [json_name = "value"];
inline void BooleanType::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = false;
}
inline bool BooleanType::value() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.BooleanType.value)
  return _internal_value();
}
inline void BooleanType::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.BooleanType.value)
}
inline bool BooleanType::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void BooleanType::_internal_set_value(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// NumericType

// double double_value = 1 [json_name = "doubleValue"];
inline bool NumericType::has_double_value() const {
  return value_case() == kDoubleValue;
}
inline void NumericType::set_has_double_value() {
  _impl_._oneof_case_[0] = kDoubleValue;
}
inline void NumericType::clear_double_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kDoubleValue) {
    _impl_.value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double NumericType::double_value() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.NumericType.double_value)
  return _internal_double_value();
}
inline void NumericType::set_double_value(double value) {
  if (value_case() != kDoubleValue) {
    clear_value();
    set_has_double_value();
  }
  _impl_.value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.NumericType.double_value)
}
inline double NumericType::_internal_double_value() const {
  if (value_case() == kDoubleValue) {
    return _impl_.value_.double_value_;
  }
  return 0;
}

// float float_value = 2 [json_name = "floatValue"];
inline bool NumericType::has_float_value() const {
  return value_case() == kFloatValue;
}
inline void NumericType::set_has_float_value() {
  _impl_._oneof_case_[0] = kFloatValue;
}
inline void NumericType::clear_float_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kFloatValue) {
    _impl_.value_.float_value_ = 0;
    clear_has_value();
  }
}
inline float NumericType::float_value() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.NumericType.float_value)
  return _internal_float_value();
}
inline void NumericType::set_float_value(float value) {
  if (value_case() != kFloatValue) {
    clear_value();
    set_has_float_value();
  }
  _impl_.value_.float_value_ = value;
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.NumericType.float_value)
}
inline float NumericType::_internal_float_value() const {
  if (value_case() == kFloatValue) {
    return _impl_.value_.float_value_;
  }
  return 0;
}

// int32 int32_value = 3 [json_name = "int32Value"];
inline bool NumericType::has_int32_value() const {
  return value_case() == kInt32Value;
}
inline void NumericType::set_has_int32_value() {
  _impl_._oneof_case_[0] = kInt32Value;
}
inline void NumericType::clear_int32_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kInt32Value) {
    _impl_.value_.int32_value_ = 0;
    clear_has_value();
  }
}
inline ::int32_t NumericType::int32_value() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.NumericType.int32_value)
  return _internal_int32_value();
}
inline void NumericType::set_int32_value(::int32_t value) {
  if (value_case() != kInt32Value) {
    clear_value();
    set_has_int32_value();
  }
  _impl_.value_.int32_value_ = value;
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.NumericType.int32_value)
}
inline ::int32_t NumericType::_internal_int32_value() const {
  if (value_case() == kInt32Value) {
    return _impl_.value_.int32_value_;
  }
  return 0;
}

// int64 int64_value = 4 [json_name = "int64Value"];
inline bool NumericType::has_int64_value() const {
  return value_case() == kInt64Value;
}
inline void NumericType::set_has_int64_value() {
  _impl_._oneof_case_[0] = kInt64Value;
}
inline void NumericType::clear_int64_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kInt64Value) {
    _impl_.value_.int64_value_ = ::int64_t{0};
    clear_has_value();
  }
}
inline ::int64_t NumericType::int64_value() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.NumericType.int64_value)
  return _internal_int64_value();
}
inline void NumericType::set_int64_value(::int64_t value) {
  if (value_case() != kInt64Value) {
    clear_value();
    set_has_int64_value();
  }
  _impl_.value_.int64_value_ = value;
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.NumericType.int64_value)
}
inline ::int64_t NumericType::_internal_int64_value() const {
  if (value_case() == kInt64Value) {
    return _impl_.value_.int64_value_;
  }
  return ::int64_t{0};
}

// uint32 uint32_value = 5 [json_name = "uint32Value"];
inline bool NumericType::has_uint32_value() const {
  return value_case() == kUint32Value;
}
inline void NumericType::set_has_uint32_value() {
  _impl_._oneof_case_[0] = kUint32Value;
}
inline void NumericType::clear_uint32_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kUint32Value) {
    _impl_.value_.uint32_value_ = 0u;
    clear_has_value();
  }
}
inline ::uint32_t NumericType::uint32_value() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.NumericType.uint32_value)
  return _internal_uint32_value();
}
inline void NumericType::set_uint32_value(::uint32_t value) {
  if (value_case() != kUint32Value) {
    clear_value();
    set_has_uint32_value();
  }
  _impl_.value_.uint32_value_ = value;
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.NumericType.uint32_value)
}
inline ::uint32_t NumericType::_internal_uint32_value() const {
  if (value_case() == kUint32Value) {
    return _impl_.value_.uint32_value_;
  }
  return 0u;
}

// uint64 uint64_value = 6 [json_name = "uint64Value"];
inline bool NumericType::has_uint64_value() const {
  return value_case() == kUint64Value;
}
inline void NumericType::set_has_uint64_value() {
  _impl_._oneof_case_[0] = kUint64Value;
}
inline void NumericType::clear_uint64_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kUint64Value) {
    _impl_.value_.uint64_value_ = ::uint64_t{0u};
    clear_has_value();
  }
}
inline ::uint64_t NumericType::uint64_value() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.NumericType.uint64_value)
  return _internal_uint64_value();
}
inline void NumericType::set_uint64_value(::uint64_t value) {
  if (value_case() != kUint64Value) {
    clear_value();
    set_has_uint64_value();
  }
  _impl_.value_.uint64_value_ = value;
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.NumericType.uint64_value)
}
inline ::uint64_t NumericType::_internal_uint64_value() const {
  if (value_case() == kUint64Value) {
    return _impl_.value_.uint64_value_;
  }
  return ::uint64_t{0u};
}

inline bool NumericType::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void NumericType::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline NumericType::ValueCase NumericType::value_case() const {
  return NumericType::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StringType

// string value = 1 [json_name = "value"];
inline void StringType::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& StringType::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.StringType.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringType::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.StringType.value)
}
inline std::string* StringType::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.StringType.value)
  return _s;
}
inline const std::string& StringType::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void StringType::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* StringType::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* StringType::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.StringType.value)
  return _impl_.value_.Release();
}
inline void StringType::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.StringType.value)
}

// -------------------------------------------------------------------

// EnumType

// int32 value = 1 [json_name = "value"];
inline void EnumType::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
}
inline ::int32_t EnumType::value() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.EnumType.value)
  return _internal_value();
}
inline void EnumType::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.EnumType.value)
}
inline ::int32_t EnumType::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void EnumType::_internal_set_value(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ListType

// repeated .anduril.entitymanager.v1.Value values = 1 [json_name = "values"];
inline int ListType::_internal_values_size() const {
  return _internal_values().size();
}
inline int ListType::values_size() const {
  return _internal_values_size();
}
inline void ListType::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::anduril::entitymanager::v1::Value* ListType::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.ListType.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Value>* ListType::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.ListType.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::anduril::entitymanager::v1::Value& ListType::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.ListType.values)
  return _internal_values().Get(index);
}
inline ::anduril::entitymanager::v1::Value* ListType::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::Value* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.ListType.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Value>& ListType::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.ListType.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Value>&
ListType::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Value>*
ListType::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// TimestampType

// .google.protobuf.Timestamp value = 1 [json_name = "value"];
inline bool TimestampType::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TimestampType::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampType::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.TimestampType.value)
  return _internal_value();
}
inline void TimestampType::unsafe_arena_set_allocated_value(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.TimestampType.value)
}
inline ::google::protobuf::Timestamp* TimestampType::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* TimestampType::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.TimestampType.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TimestampType::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.value_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.value_;
}
inline ::google::protobuf::Timestamp* TimestampType::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.TimestampType.value)
  return _msg;
}
inline void TimestampType::set_allocated_value(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.TimestampType.value)
}

// -------------------------------------------------------------------

// PositionType

// .anduril.entitymanager.v1.Position value = 1 [json_name = "value"];
inline bool PositionType::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Position& PositionType::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Position* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Position&>(::anduril::entitymanager::v1::_Position_default_instance_);
}
inline const ::anduril::entitymanager::v1::Position& PositionType::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.PositionType.value)
  return _internal_value();
}
inline void PositionType::unsafe_arena_set_allocated_value(::anduril::entitymanager::v1::Position* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.PositionType.value)
}
inline ::anduril::entitymanager::v1::Position* PositionType::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Position* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Position* PositionType::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.PositionType.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Position* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Position* PositionType::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Position>(GetArena());
    _impl_.value_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(p);
  }
  return _impl_.value_;
}
inline ::anduril::entitymanager::v1::Position* PositionType::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Position* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.PositionType.value)
  return _msg;
}
inline void PositionType::set_allocated_value(::anduril::entitymanager::v1::Position* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.PositionType.value)
}

// -------------------------------------------------------------------

// BoundedShapeType

// .anduril.entitymanager.v1.GeoPolygon polygon_value = 1 [json_name = "polygonValue"];
inline bool BoundedShapeType::has_polygon_value() const {
  return value_case() == kPolygonValue;
}
inline bool BoundedShapeType::_internal_has_polygon_value() const {
  return value_case() == kPolygonValue;
}
inline void BoundedShapeType::set_has_polygon_value() {
  _impl_._oneof_case_[0] = kPolygonValue;
}
inline ::anduril::entitymanager::v1::GeoPolygon* BoundedShapeType::release_polygon_value() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.BoundedShapeType.polygon_value)
  if (value_case() == kPolygonValue) {
    clear_has_value();
    auto* temp = _impl_.value_.polygon_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.polygon_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoPolygon& BoundedShapeType::_internal_polygon_value() const {
  return value_case() == kPolygonValue ? *_impl_.value_.polygon_value_ : reinterpret_cast<::anduril::entitymanager::v1::GeoPolygon&>(::anduril::entitymanager::v1::_GeoPolygon_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoPolygon& BoundedShapeType::polygon_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.BoundedShapeType.polygon_value)
  return _internal_polygon_value();
}
inline ::anduril::entitymanager::v1::GeoPolygon* BoundedShapeType::unsafe_arena_release_polygon_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.BoundedShapeType.polygon_value)
  if (value_case() == kPolygonValue) {
    clear_has_value();
    auto* temp = _impl_.value_.polygon_value_;
    _impl_.value_.polygon_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BoundedShapeType::unsafe_arena_set_allocated_polygon_value(::anduril::entitymanager::v1::GeoPolygon* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_polygon_value();
    _impl_.value_.polygon_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.BoundedShapeType.polygon_value)
}
inline ::anduril::entitymanager::v1::GeoPolygon* BoundedShapeType::_internal_mutable_polygon_value() {
  if (value_case() != kPolygonValue) {
    clear_value();
    set_has_polygon_value();
    _impl_.value_.polygon_value_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoPolygon>(GetArena());
  }
  return _impl_.value_.polygon_value_;
}
inline ::anduril::entitymanager::v1::GeoPolygon* BoundedShapeType::mutable_polygon_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoPolygon* _msg = _internal_mutable_polygon_value();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.BoundedShapeType.polygon_value)
  return _msg;
}

inline bool BoundedShapeType::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void BoundedShapeType::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline BoundedShapeType::ValueCase BoundedShapeType::value_case() const {
  return BoundedShapeType::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// HeadingType

// int32 value = 1 [json_name = "value"];
inline void HeadingType::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
}
inline ::int32_t HeadingType::value() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.HeadingType.value)
  return _internal_value();
}
inline void HeadingType::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.HeadingType.value)
}
inline ::int32_t HeadingType::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void HeadingType::_internal_set_value(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// RangeType

// .anduril.entitymanager.v1.NumericType start = 1 [json_name = "start"];
inline bool RangeType::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline void RangeType::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::NumericType& RangeType::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::NumericType* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::NumericType&>(::anduril::entitymanager::v1::_NumericType_default_instance_);
}
inline const ::anduril::entitymanager::v1::NumericType& RangeType::start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RangeType.start)
  return _internal_start();
}
inline void RangeType::unsafe_arena_set_allocated_start(::anduril::entitymanager::v1::NumericType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = reinterpret_cast<::anduril::entitymanager::v1::NumericType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RangeType.start)
}
inline ::anduril::entitymanager::v1::NumericType* RangeType::release_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::NumericType* released = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::NumericType* RangeType::unsafe_arena_release_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RangeType.start)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::NumericType* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::NumericType* RangeType::_internal_mutable_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::NumericType>(GetArena());
    _impl_.start_ = reinterpret_cast<::anduril::entitymanager::v1::NumericType*>(p);
  }
  return _impl_.start_;
}
inline ::anduril::entitymanager::v1::NumericType* RangeType::mutable_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::NumericType* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RangeType.start)
  return _msg;
}
inline void RangeType::set_allocated_start(::anduril::entitymanager::v1::NumericType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.start_ = reinterpret_cast<::anduril::entitymanager::v1::NumericType*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.RangeType.start)
}

// .anduril.entitymanager.v1.NumericType end = 2 [json_name = "end"];
inline bool RangeType::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline void RangeType::clear_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::entitymanager::v1::NumericType& RangeType::_internal_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::NumericType* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::NumericType&>(::anduril::entitymanager::v1::_NumericType_default_instance_);
}
inline const ::anduril::entitymanager::v1::NumericType& RangeType::end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RangeType.end)
  return _internal_end();
}
inline void RangeType::unsafe_arena_set_allocated_end(::anduril::entitymanager::v1::NumericType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = reinterpret_cast<::anduril::entitymanager::v1::NumericType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RangeType.end)
}
inline ::anduril::entitymanager::v1::NumericType* RangeType::release_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entitymanager::v1::NumericType* released = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::NumericType* RangeType::unsafe_arena_release_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RangeType.end)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entitymanager::v1::NumericType* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::NumericType* RangeType::_internal_mutable_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::NumericType>(GetArena());
    _impl_.end_ = reinterpret_cast<::anduril::entitymanager::v1::NumericType*>(p);
  }
  return _impl_.end_;
}
inline ::anduril::entitymanager::v1::NumericType* RangeType::mutable_end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::entitymanager::v1::NumericType* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RangeType.end)
  return _msg;
}
inline void RangeType::set_allocated_end(::anduril::entitymanager::v1::NumericType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.end_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.end_ = reinterpret_cast<::anduril::entitymanager::v1::NumericType*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.RangeType.end)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::anduril::entitymanager::v1::Comparator> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::Comparator>() {
  return ::anduril::entitymanager::v1::Comparator_descriptor();
}
template <>
struct is_proto_enum<::anduril::entitymanager::v1::ListComparator> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::ListComparator>() {
  return ::anduril::entitymanager::v1::ListComparator_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2ffilter_2epub_2eproto_2epb_2eh
