// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/entitymanager/v1/signal.pub.proto
// Protobuf C++ Version: 5.29.0

#ifndef anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto_2epb_2eh
#define anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "anduril/type/coords.pub.pb.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
namespace anduril {
namespace entitymanager {
namespace v1 {
class AngleOfArrival;
struct AngleOfArrivalDefaultTypeInternal;
extern AngleOfArrivalDefaultTypeInternal _AngleOfArrival_default_instance_;
class EmitterNotation;
struct EmitterNotationDefaultTypeInternal;
extern EmitterNotationDefaultTypeInternal _EmitterNotation_default_instance_;
class Fixed;
struct FixedDefaultTypeInternal;
extern FixedDefaultTypeInternal _Fixed_default_instance_;
class Frequency;
struct FrequencyDefaultTypeInternal;
extern FrequencyDefaultTypeInternal _Frequency_default_instance_;
class FrequencyRange;
struct FrequencyRangeDefaultTypeInternal;
extern FrequencyRangeDefaultTypeInternal _FrequencyRange_default_instance_;
class LineOfBearing;
struct LineOfBearingDefaultTypeInternal;
extern LineOfBearingDefaultTypeInternal _LineOfBearing_default_instance_;
class Measurement;
struct MeasurementDefaultTypeInternal;
extern MeasurementDefaultTypeInternal _Measurement_default_instance_;
class PulseRepetitionInterval;
struct PulseRepetitionIntervalDefaultTypeInternal;
extern PulseRepetitionIntervalDefaultTypeInternal _PulseRepetitionInterval_default_instance_;
class ScanCharacteristics;
struct ScanCharacteristicsDefaultTypeInternal;
extern ScanCharacteristicsDefaultTypeInternal _ScanCharacteristics_default_instance_;
class Signal;
struct SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace entitymanager {
namespace v1 {
enum ScanType : int {
  SCAN_TYPE_INVALID = 0,
  SCAN_TYPE_CIRCULAR = 1,
  SCAN_TYPE_BIDIRECTIONAL_HORIZONTAL_SECTOR = 2,
  SCAN_TYPE_BIDIRECTIONAL_VERTICAL_SECTOR = 3,
  SCAN_TYPE_NON_SCANNING = 4,
  SCAN_TYPE_IRREGULAR = 5,
  SCAN_TYPE_CONICAL = 6,
  SCAN_TYPE_LOBE_SWITCHING = 7,
  SCAN_TYPE_RASTER = 8,
  SCAN_TYPE_CIRCULAR_VERTICAL_SECTOR = 9,
  SCAN_TYPE_CIRCULAR_CONICAL = 10,
  SCAN_TYPE_SECTOR_CONICAL = 11,
  SCAN_TYPE_AGILE_BEAM = 12,
  SCAN_TYPE_UNIDIRECTIONAL_VERTICAL_SECTOR = 13,
  SCAN_TYPE_UNIDIRECTIONAL_HORIZONTAL_SECTOR = 14,
  SCAN_TYPE_UNIDIRECTIONAL_SECTOR = 15,
  SCAN_TYPE_BIDIRECTIONAL_SECTOR = 16,
  ScanType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ScanType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ScanType_IsValid(int value);
extern const uint32_t ScanType_internal_data_[];
constexpr ScanType ScanType_MIN = static_cast<ScanType>(0);
constexpr ScanType ScanType_MAX = static_cast<ScanType>(16);
constexpr int ScanType_ARRAYSIZE = 16 + 1;
const ::google::protobuf::EnumDescriptor*
ScanType_descriptor();
template <typename T>
const std::string& ScanType_Name(T value) {
  static_assert(std::is_same<T, ScanType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ScanType_Name().");
  return ScanType_Name(static_cast<ScanType>(value));
}
template <>
inline const std::string& ScanType_Name(ScanType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ScanType_descriptor,
                                                 0, 16>(
      static_cast<int>(value));
}
inline bool ScanType_Parse(absl::string_view name, ScanType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScanType>(
      ScanType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Fixed final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Fixed) */ {
 public:
  inline Fixed() : Fixed(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Fixed* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Fixed));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Fixed(
      ::google::protobuf::internal::ConstantInitialized);

  inline Fixed(const Fixed& from) : Fixed(nullptr, from) {}
  inline Fixed(Fixed&& from) noexcept
      : Fixed(nullptr, std::move(from)) {}
  inline Fixed& operator=(const Fixed& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed& operator=(Fixed&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fixed* internal_default_instance() {
    return reinterpret_cast<const Fixed*>(
        &_Fixed_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Fixed& a, Fixed& b) { a.Swap(&b); }
  inline void Swap(Fixed* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Fixed>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Fixed& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Fixed& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Fixed"; }

 protected:
  explicit Fixed(::google::protobuf::Arena* arena);
  Fixed(::google::protobuf::Arena* arena, const Fixed& from);
  Fixed(::google::protobuf::Arena* arena, Fixed&& from) noexcept
      : Fixed(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Fixed)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Fixed& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
};
// -------------------------------------------------------------------

class ScanCharacteristics final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.ScanCharacteristics) */ {
 public:
  inline ScanCharacteristics() : ScanCharacteristics(nullptr) {}
  ~ScanCharacteristics() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ScanCharacteristics* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ScanCharacteristics));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ScanCharacteristics(
      ::google::protobuf::internal::ConstantInitialized);

  inline ScanCharacteristics(const ScanCharacteristics& from) : ScanCharacteristics(nullptr, from) {}
  inline ScanCharacteristics(ScanCharacteristics&& from) noexcept
      : ScanCharacteristics(nullptr, std::move(from)) {}
  inline ScanCharacteristics& operator=(const ScanCharacteristics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanCharacteristics& operator=(ScanCharacteristics&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScanCharacteristics& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScanCharacteristics* internal_default_instance() {
    return reinterpret_cast<const ScanCharacteristics*>(
        &_ScanCharacteristics_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ScanCharacteristics& a, ScanCharacteristics& b) { a.Swap(&b); }
  inline void Swap(ScanCharacteristics* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScanCharacteristics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScanCharacteristics* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ScanCharacteristics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScanCharacteristics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ScanCharacteristics& from) { ScanCharacteristics::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ScanCharacteristics* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.ScanCharacteristics"; }

 protected:
  explicit ScanCharacteristics(::google::protobuf::Arena* arena);
  ScanCharacteristics(::google::protobuf::Arena* arena, const ScanCharacteristics& from);
  ScanCharacteristics(::google::protobuf::Arena* arena, ScanCharacteristics&& from) noexcept
      : ScanCharacteristics(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kScanPeriodSFieldNumber = 2,
    kScanTypeFieldNumber = 1,
  };
  // .google.protobuf.DoubleValue scan_period_s = 2 [json_name = "scanPeriodS"];
  bool has_scan_period_s() const;
  void clear_scan_period_s() ;
  const ::google::protobuf::DoubleValue& scan_period_s() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_scan_period_s();
  ::google::protobuf::DoubleValue* mutable_scan_period_s();
  void set_allocated_scan_period_s(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_scan_period_s(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_scan_period_s();

  private:
  const ::google::protobuf::DoubleValue& _internal_scan_period_s() const;
  ::google::protobuf::DoubleValue* _internal_mutable_scan_period_s();

  public:
  // .anduril.entitymanager.v1.ScanType scan_type = 1 [json_name = "scanType"];
  void clear_scan_type() ;
  ::anduril::entitymanager::v1::ScanType scan_type() const;
  void set_scan_type(::anduril::entitymanager::v1::ScanType value);

  private:
  ::anduril::entitymanager::v1::ScanType _internal_scan_type() const;
  void _internal_set_scan_type(::anduril::entitymanager::v1::ScanType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.ScanCharacteristics)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ScanCharacteristics& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::DoubleValue* scan_period_s_;
    int scan_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
};
// -------------------------------------------------------------------

class Measurement final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Measurement) */ {
 public:
  inline Measurement() : Measurement(nullptr) {}
  ~Measurement() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Measurement* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Measurement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Measurement(
      ::google::protobuf::internal::ConstantInitialized);

  inline Measurement(const Measurement& from) : Measurement(nullptr, from) {}
  inline Measurement(Measurement&& from) noexcept
      : Measurement(nullptr, std::move(from)) {}
  inline Measurement& operator=(const Measurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Measurement& operator=(Measurement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Measurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Measurement* internal_default_instance() {
    return reinterpret_cast<const Measurement*>(
        &_Measurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Measurement& a, Measurement& b) { a.Swap(&b); }
  inline void Swap(Measurement* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Measurement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Measurement* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Measurement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Measurement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Measurement& from) { Measurement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Measurement* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Measurement"; }

 protected:
  explicit Measurement(::google::protobuf::Arena* arena);
  Measurement(::google::protobuf::Arena* arena, const Measurement& from);
  Measurement(::google::protobuf::Arena* arena, Measurement&& from) noexcept
      : Measurement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kSigmaFieldNumber = 2,
  };
  // .google.protobuf.DoubleValue value = 1 [json_name = "value"];
  bool has_value() const;
  void clear_value() ;
  const ::google::protobuf::DoubleValue& value() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_value();
  ::google::protobuf::DoubleValue* mutable_value();
  void set_allocated_value(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_value(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_value();

  private:
  const ::google::protobuf::DoubleValue& _internal_value() const;
  ::google::protobuf::DoubleValue* _internal_mutable_value();

  public:
  // .google.protobuf.DoubleValue sigma = 2 [json_name = "sigma"];
  bool has_sigma() const;
  void clear_sigma() ;
  const ::google::protobuf::DoubleValue& sigma() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_sigma();
  ::google::protobuf::DoubleValue* mutable_sigma();
  void set_allocated_sigma(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_sigma(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_sigma();

  private:
  const ::google::protobuf::DoubleValue& _internal_sigma() const;
  ::google::protobuf::DoubleValue* _internal_mutable_sigma();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Measurement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Measurement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::DoubleValue* value_;
    ::google::protobuf::DoubleValue* sigma_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
};
// -------------------------------------------------------------------

class EmitterNotation final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.EmitterNotation) */ {
 public:
  inline EmitterNotation() : EmitterNotation(nullptr) {}
  ~EmitterNotation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EmitterNotation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EmitterNotation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EmitterNotation(
      ::google::protobuf::internal::ConstantInitialized);

  inline EmitterNotation(const EmitterNotation& from) : EmitterNotation(nullptr, from) {}
  inline EmitterNotation(EmitterNotation&& from) noexcept
      : EmitterNotation(nullptr, std::move(from)) {}
  inline EmitterNotation& operator=(const EmitterNotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmitterNotation& operator=(EmitterNotation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmitterNotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmitterNotation* internal_default_instance() {
    return reinterpret_cast<const EmitterNotation*>(
        &_EmitterNotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(EmitterNotation& a, EmitterNotation& b) { a.Swap(&b); }
  inline void Swap(EmitterNotation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmitterNotation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmitterNotation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EmitterNotation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmitterNotation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EmitterNotation& from) { EmitterNotation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EmitterNotation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.EmitterNotation"; }

 protected:
  explicit EmitterNotation(::google::protobuf::Arena* arena);
  EmitterNotation(::google::protobuf::Arena* arena, const EmitterNotation& from);
  EmitterNotation(::google::protobuf::Arena* arena, EmitterNotation&& from) noexcept
      : EmitterNotation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEmitterNotationFieldNumber = 1,
    kConfidenceFieldNumber = 2,
  };
  // string emitter_notation = 1 [json_name = "emitterNotation"];
  void clear_emitter_notation() ;
  const std::string& emitter_notation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_emitter_notation(Arg_&& arg, Args_... args);
  std::string* mutable_emitter_notation();
  PROTOBUF_NODISCARD std::string* release_emitter_notation();
  void set_allocated_emitter_notation(std::string* value);

  private:
  const std::string& _internal_emitter_notation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emitter_notation(
      const std::string& value);
  std::string* _internal_mutable_emitter_notation();

  public:
  // .google.protobuf.DoubleValue confidence = 2 [json_name = "confidence"];
  bool has_confidence() const;
  void clear_confidence() ;
  const ::google::protobuf::DoubleValue& confidence() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_confidence();
  ::google::protobuf::DoubleValue* mutable_confidence();
  void set_allocated_confidence(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_confidence(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_confidence();

  private:
  const ::google::protobuf::DoubleValue& _internal_confidence() const;
  ::google::protobuf::DoubleValue* _internal_mutable_confidence();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.EmitterNotation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EmitterNotation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr emitter_notation_;
    ::google::protobuf::DoubleValue* confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
};
// -------------------------------------------------------------------

class PulseRepetitionInterval final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.PulseRepetitionInterval) */ {
 public:
  inline PulseRepetitionInterval() : PulseRepetitionInterval(nullptr) {}
  ~PulseRepetitionInterval() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PulseRepetitionInterval* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PulseRepetitionInterval));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PulseRepetitionInterval(
      ::google::protobuf::internal::ConstantInitialized);

  inline PulseRepetitionInterval(const PulseRepetitionInterval& from) : PulseRepetitionInterval(nullptr, from) {}
  inline PulseRepetitionInterval(PulseRepetitionInterval&& from) noexcept
      : PulseRepetitionInterval(nullptr, std::move(from)) {}
  inline PulseRepetitionInterval& operator=(const PulseRepetitionInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline PulseRepetitionInterval& operator=(PulseRepetitionInterval&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PulseRepetitionInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const PulseRepetitionInterval* internal_default_instance() {
    return reinterpret_cast<const PulseRepetitionInterval*>(
        &_PulseRepetitionInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(PulseRepetitionInterval& a, PulseRepetitionInterval& b) { a.Swap(&b); }
  inline void Swap(PulseRepetitionInterval* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PulseRepetitionInterval* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PulseRepetitionInterval* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PulseRepetitionInterval>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PulseRepetitionInterval& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PulseRepetitionInterval& from) { PulseRepetitionInterval::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PulseRepetitionInterval* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.PulseRepetitionInterval"; }

 protected:
  explicit PulseRepetitionInterval(::google::protobuf::Arena* arena);
  PulseRepetitionInterval(::google::protobuf::Arena* arena, const PulseRepetitionInterval& from);
  PulseRepetitionInterval(::google::protobuf::Arena* arena, PulseRepetitionInterval&& from) noexcept
      : PulseRepetitionInterval(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPulseRepetitionIntervalSFieldNumber = 1,
  };
  // .anduril.entitymanager.v1.Measurement pulse_repetition_interval_s = 1 [json_name = "pulseRepetitionIntervalS"];
  bool has_pulse_repetition_interval_s() const;
  void clear_pulse_repetition_interval_s() ;
  const ::anduril::entitymanager::v1::Measurement& pulse_repetition_interval_s() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Measurement* release_pulse_repetition_interval_s();
  ::anduril::entitymanager::v1::Measurement* mutable_pulse_repetition_interval_s();
  void set_allocated_pulse_repetition_interval_s(::anduril::entitymanager::v1::Measurement* value);
  void unsafe_arena_set_allocated_pulse_repetition_interval_s(::anduril::entitymanager::v1::Measurement* value);
  ::anduril::entitymanager::v1::Measurement* unsafe_arena_release_pulse_repetition_interval_s();

  private:
  const ::anduril::entitymanager::v1::Measurement& _internal_pulse_repetition_interval_s() const;
  ::anduril::entitymanager::v1::Measurement* _internal_mutable_pulse_repetition_interval_s();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.PulseRepetitionInterval)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PulseRepetitionInterval& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Measurement* pulse_repetition_interval_s_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
};
// -------------------------------------------------------------------

class Frequency final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Frequency) */ {
 public:
  inline Frequency() : Frequency(nullptr) {}
  ~Frequency() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Frequency* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Frequency));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Frequency(
      ::google::protobuf::internal::ConstantInitialized);

  inline Frequency(const Frequency& from) : Frequency(nullptr, from) {}
  inline Frequency(Frequency&& from) noexcept
      : Frequency(nullptr, std::move(from)) {}
  inline Frequency& operator=(const Frequency& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frequency& operator=(Frequency&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frequency& default_instance() {
    return *internal_default_instance();
  }
  static inline const Frequency* internal_default_instance() {
    return reinterpret_cast<const Frequency*>(
        &_Frequency_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Frequency& a, Frequency& b) { a.Swap(&b); }
  inline void Swap(Frequency* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frequency* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frequency* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Frequency>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Frequency& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Frequency& from) { Frequency::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Frequency* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Frequency"; }

 protected:
  explicit Frequency(::google::protobuf::Arena* arena);
  Frequency(::google::protobuf::Arena* arena, const Frequency& from);
  Frequency(::google::protobuf::Arena* arena, Frequency&& from) noexcept
      : Frequency(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFrequencyHzFieldNumber = 1,
  };
  // .anduril.entitymanager.v1.Measurement frequency_hz = 1 [json_name = "frequencyHz"];
  bool has_frequency_hz() const;
  void clear_frequency_hz() ;
  const ::anduril::entitymanager::v1::Measurement& frequency_hz() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Measurement* release_frequency_hz();
  ::anduril::entitymanager::v1::Measurement* mutable_frequency_hz();
  void set_allocated_frequency_hz(::anduril::entitymanager::v1::Measurement* value);
  void unsafe_arena_set_allocated_frequency_hz(::anduril::entitymanager::v1::Measurement* value);
  ::anduril::entitymanager::v1::Measurement* unsafe_arena_release_frequency_hz();

  private:
  const ::anduril::entitymanager::v1::Measurement& _internal_frequency_hz() const;
  ::anduril::entitymanager::v1::Measurement* _internal_mutable_frequency_hz();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Frequency)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Frequency& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Measurement* frequency_hz_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
};
// -------------------------------------------------------------------

class AngleOfArrival final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.AngleOfArrival) */ {
 public:
  inline AngleOfArrival() : AngleOfArrival(nullptr) {}
  ~AngleOfArrival() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AngleOfArrival* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AngleOfArrival));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AngleOfArrival(
      ::google::protobuf::internal::ConstantInitialized);

  inline AngleOfArrival(const AngleOfArrival& from) : AngleOfArrival(nullptr, from) {}
  inline AngleOfArrival(AngleOfArrival&& from) noexcept
      : AngleOfArrival(nullptr, std::move(from)) {}
  inline AngleOfArrival& operator=(const AngleOfArrival& from) {
    CopyFrom(from);
    return *this;
  }
  inline AngleOfArrival& operator=(AngleOfArrival&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AngleOfArrival& default_instance() {
    return *internal_default_instance();
  }
  static inline const AngleOfArrival* internal_default_instance() {
    return reinterpret_cast<const AngleOfArrival*>(
        &_AngleOfArrival_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AngleOfArrival& a, AngleOfArrival& b) { a.Swap(&b); }
  inline void Swap(AngleOfArrival* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AngleOfArrival* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AngleOfArrival* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AngleOfArrival>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AngleOfArrival& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AngleOfArrival& from) { AngleOfArrival::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AngleOfArrival* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.AngleOfArrival"; }

 protected:
  explicit AngleOfArrival(::google::protobuf::Arena* arena);
  AngleOfArrival(::google::protobuf::Arena* arena, const AngleOfArrival& from);
  AngleOfArrival(::google::protobuf::Arena* arena, AngleOfArrival&& from) noexcept
      : AngleOfArrival(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRelativePoseFieldNumber = 1,
    kBearingElevationCovarianceRad2FieldNumber = 2,
  };
  // .anduril.type.Pose relative_pose = 1 [json_name = "relativePose"];
  bool has_relative_pose() const;
  void clear_relative_pose() ;
  const ::anduril::type::Pose& relative_pose() const;
  PROTOBUF_NODISCARD ::anduril::type::Pose* release_relative_pose();
  ::anduril::type::Pose* mutable_relative_pose();
  void set_allocated_relative_pose(::anduril::type::Pose* value);
  void unsafe_arena_set_allocated_relative_pose(::anduril::type::Pose* value);
  ::anduril::type::Pose* unsafe_arena_release_relative_pose();

  private:
  const ::anduril::type::Pose& _internal_relative_pose() const;
  ::anduril::type::Pose* _internal_mutable_relative_pose();

  public:
  // .anduril.type.TMat2 bearing_elevation_covariance_rad2 = 2 [json_name = "bearingElevationCovarianceRad2"];
  bool has_bearing_elevation_covariance_rad2() const;
  void clear_bearing_elevation_covariance_rad2() ;
  const ::anduril::type::TMat2& bearing_elevation_covariance_rad2() const;
  PROTOBUF_NODISCARD ::anduril::type::TMat2* release_bearing_elevation_covariance_rad2();
  ::anduril::type::TMat2* mutable_bearing_elevation_covariance_rad2();
  void set_allocated_bearing_elevation_covariance_rad2(::anduril::type::TMat2* value);
  void unsafe_arena_set_allocated_bearing_elevation_covariance_rad2(::anduril::type::TMat2* value);
  ::anduril::type::TMat2* unsafe_arena_release_bearing_elevation_covariance_rad2();

  private:
  const ::anduril::type::TMat2& _internal_bearing_elevation_covariance_rad2() const;
  ::anduril::type::TMat2* _internal_mutable_bearing_elevation_covariance_rad2();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.AngleOfArrival)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AngleOfArrival& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::type::Pose* relative_pose_;
    ::anduril::type::TMat2* bearing_elevation_covariance_rad2_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
};
// -------------------------------------------------------------------

class LineOfBearing final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.LineOfBearing) */ {
 public:
  inline LineOfBearing() : LineOfBearing(nullptr) {}
  ~LineOfBearing() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LineOfBearing* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LineOfBearing));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LineOfBearing(
      ::google::protobuf::internal::ConstantInitialized);

  inline LineOfBearing(const LineOfBearing& from) : LineOfBearing(nullptr, from) {}
  inline LineOfBearing(LineOfBearing&& from) noexcept
      : LineOfBearing(nullptr, std::move(from)) {}
  inline LineOfBearing& operator=(const LineOfBearing& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineOfBearing& operator=(LineOfBearing&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineOfBearing& default_instance() {
    return *internal_default_instance();
  }
  enum DetectionRangeCase {
    kRangeEstimateM = 4,
    kMaxRangeM = 5,
    DETECTION_RANGE_NOT_SET = 0,
  };
  static inline const LineOfBearing* internal_default_instance() {
    return reinterpret_cast<const LineOfBearing*>(
        &_LineOfBearing_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(LineOfBearing& a, LineOfBearing& b) { a.Swap(&b); }
  inline void Swap(LineOfBearing* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineOfBearing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineOfBearing* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LineOfBearing>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LineOfBearing& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LineOfBearing& from) { LineOfBearing::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LineOfBearing* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.LineOfBearing"; }

 protected:
  explicit LineOfBearing(::google::protobuf::Arena* arena);
  LineOfBearing(::google::protobuf::Arena* arena, const LineOfBearing& from);
  LineOfBearing(::google::protobuf::Arena* arena, LineOfBearing&& from) noexcept
      : LineOfBearing(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAngleOfArrivalFieldNumber = 3,
    kRangeEstimateMFieldNumber = 4,
    kMaxRangeMFieldNumber = 5,
  };
  // .anduril.entitymanager.v1.AngleOfArrival angle_of_arrival = 3 [json_name = "angleOfArrival"];
  bool has_angle_of_arrival() const;
  void clear_angle_of_arrival() ;
  const ::anduril::entitymanager::v1::AngleOfArrival& angle_of_arrival() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::AngleOfArrival* release_angle_of_arrival();
  ::anduril::entitymanager::v1::AngleOfArrival* mutable_angle_of_arrival();
  void set_allocated_angle_of_arrival(::anduril::entitymanager::v1::AngleOfArrival* value);
  void unsafe_arena_set_allocated_angle_of_arrival(::anduril::entitymanager::v1::AngleOfArrival* value);
  ::anduril::entitymanager::v1::AngleOfArrival* unsafe_arena_release_angle_of_arrival();

  private:
  const ::anduril::entitymanager::v1::AngleOfArrival& _internal_angle_of_arrival() const;
  ::anduril::entitymanager::v1::AngleOfArrival* _internal_mutable_angle_of_arrival();

  public:
  // .anduril.entitymanager.v1.Measurement range_estimate_m = 4 [json_name = "rangeEstimateM"];
  bool has_range_estimate_m() const;
  private:
  bool _internal_has_range_estimate_m() const;

  public:
  void clear_range_estimate_m() ;
  const ::anduril::entitymanager::v1::Measurement& range_estimate_m() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Measurement* release_range_estimate_m();
  ::anduril::entitymanager::v1::Measurement* mutable_range_estimate_m();
  void set_allocated_range_estimate_m(::anduril::entitymanager::v1::Measurement* value);
  void unsafe_arena_set_allocated_range_estimate_m(::anduril::entitymanager::v1::Measurement* value);
  ::anduril::entitymanager::v1::Measurement* unsafe_arena_release_range_estimate_m();

  private:
  const ::anduril::entitymanager::v1::Measurement& _internal_range_estimate_m() const;
  ::anduril::entitymanager::v1::Measurement* _internal_mutable_range_estimate_m();

  public:
  // .anduril.entitymanager.v1.Measurement max_range_m = 5 [json_name = "maxRangeM"];
  bool has_max_range_m() const;
  private:
  bool _internal_has_max_range_m() const;

  public:
  void clear_max_range_m() ;
  const ::anduril::entitymanager::v1::Measurement& max_range_m() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Measurement* release_max_range_m();
  ::anduril::entitymanager::v1::Measurement* mutable_max_range_m();
  void set_allocated_max_range_m(::anduril::entitymanager::v1::Measurement* value);
  void unsafe_arena_set_allocated_max_range_m(::anduril::entitymanager::v1::Measurement* value);
  ::anduril::entitymanager::v1::Measurement* unsafe_arena_release_max_range_m();

  private:
  const ::anduril::entitymanager::v1::Measurement& _internal_max_range_m() const;
  ::anduril::entitymanager::v1::Measurement* _internal_mutable_max_range_m();

  public:
  void clear_detection_range();
  DetectionRangeCase detection_range_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.LineOfBearing)
 private:
  class _Internal;
  void set_has_range_estimate_m();
  void set_has_max_range_m();
  inline bool has_detection_range() const;
  inline void clear_has_detection_range();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LineOfBearing& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::AngleOfArrival* angle_of_arrival_;
    union DetectionRangeUnion {
      constexpr DetectionRangeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::Measurement* range_estimate_m_;
      ::anduril::entitymanager::v1::Measurement* max_range_m_;
    } detection_range_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
};
// -------------------------------------------------------------------

class FrequencyRange final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.FrequencyRange) */ {
 public:
  inline FrequencyRange() : FrequencyRange(nullptr) {}
  ~FrequencyRange() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FrequencyRange* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FrequencyRange));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FrequencyRange(
      ::google::protobuf::internal::ConstantInitialized);

  inline FrequencyRange(const FrequencyRange& from) : FrequencyRange(nullptr, from) {}
  inline FrequencyRange(FrequencyRange&& from) noexcept
      : FrequencyRange(nullptr, std::move(from)) {}
  inline FrequencyRange& operator=(const FrequencyRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrequencyRange& operator=(FrequencyRange&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrequencyRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrequencyRange* internal_default_instance() {
    return reinterpret_cast<const FrequencyRange*>(
        &_FrequencyRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(FrequencyRange& a, FrequencyRange& b) { a.Swap(&b); }
  inline void Swap(FrequencyRange* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrequencyRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrequencyRange* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FrequencyRange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FrequencyRange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FrequencyRange& from) { FrequencyRange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FrequencyRange* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.FrequencyRange"; }

 protected:
  explicit FrequencyRange(::google::protobuf::Arena* arena);
  FrequencyRange(::google::protobuf::Arena* arena, const FrequencyRange& from);
  FrequencyRange(::google::protobuf::Arena* arena, FrequencyRange&& from) noexcept
      : FrequencyRange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMinimumFrequencyHzFieldNumber = 1,
    kMaximumFrequencyHzFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.Frequency minimum_frequency_hz = 1 [json_name = "minimumFrequencyHz"];
  bool has_minimum_frequency_hz() const;
  void clear_minimum_frequency_hz() ;
  const ::anduril::entitymanager::v1::Frequency& minimum_frequency_hz() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Frequency* release_minimum_frequency_hz();
  ::anduril::entitymanager::v1::Frequency* mutable_minimum_frequency_hz();
  void set_allocated_minimum_frequency_hz(::anduril::entitymanager::v1::Frequency* value);
  void unsafe_arena_set_allocated_minimum_frequency_hz(::anduril::entitymanager::v1::Frequency* value);
  ::anduril::entitymanager::v1::Frequency* unsafe_arena_release_minimum_frequency_hz();

  private:
  const ::anduril::entitymanager::v1::Frequency& _internal_minimum_frequency_hz() const;
  ::anduril::entitymanager::v1::Frequency* _internal_mutable_minimum_frequency_hz();

  public:
  // .anduril.entitymanager.v1.Frequency maximum_frequency_hz = 2 [json_name = "maximumFrequencyHz"];
  bool has_maximum_frequency_hz() const;
  void clear_maximum_frequency_hz() ;
  const ::anduril::entitymanager::v1::Frequency& maximum_frequency_hz() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Frequency* release_maximum_frequency_hz();
  ::anduril::entitymanager::v1::Frequency* mutable_maximum_frequency_hz();
  void set_allocated_maximum_frequency_hz(::anduril::entitymanager::v1::Frequency* value);
  void unsafe_arena_set_allocated_maximum_frequency_hz(::anduril::entitymanager::v1::Frequency* value);
  ::anduril::entitymanager::v1::Frequency* unsafe_arena_release_maximum_frequency_hz();

  private:
  const ::anduril::entitymanager::v1::Frequency& _internal_maximum_frequency_hz() const;
  ::anduril::entitymanager::v1::Frequency* _internal_mutable_maximum_frequency_hz();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.FrequencyRange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FrequencyRange& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Frequency* minimum_frequency_hz_;
    ::anduril::entitymanager::v1::Frequency* maximum_frequency_hz_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
};
// -------------------------------------------------------------------

class Signal final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Signal) */ {
 public:
  inline Signal() : Signal(nullptr) {}
  ~Signal() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Signal* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Signal));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Signal(
      ::google::protobuf::internal::ConstantInitialized);

  inline Signal(const Signal& from) : Signal(nullptr, from) {}
  inline Signal(Signal&& from) noexcept
      : Signal(nullptr, std::move(from)) {}
  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signal& operator=(Signal&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signal& default_instance() {
    return *internal_default_instance();
  }
  enum FrequencyMeasurementCase {
    kFrequencyCenter = 1,
    kFrequencyRange = 2,
    FREQUENCY_MEASUREMENT_NOT_SET = 0,
  };
  enum ReportCase {
    kLineOfBearing = 5,
    kFixed = 6,
    REPORT_NOT_SET = 0,
  };
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
        &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Signal& a, Signal& b) { a.Swap(&b); }
  inline void Swap(Signal* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Signal* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Signal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Signal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Signal& from) { Signal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Signal* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Signal"; }

 protected:
  explicit Signal(::google::protobuf::Arena* arena);
  Signal(::google::protobuf::Arena* arena, const Signal& from);
  Signal(::google::protobuf::Arena* arena, Signal&& from) noexcept
      : Signal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEmitterNotationsFieldNumber = 7,
    kBandwidthHzFieldNumber = 3,
    kSignalToNoiseRatioFieldNumber = 4,
    kPulseWidthSFieldNumber = 8,
    kPulseRepetitionIntervalFieldNumber = 9,
    kScanCharacteristicsFieldNumber = 11,
    kFrequencyCenterFieldNumber = 1,
    kFrequencyRangeFieldNumber = 2,
    kLineOfBearingFieldNumber = 5,
    kFixedFieldNumber = 6,
  };
  // repeated .anduril.entitymanager.v1.EmitterNotation emitter_notations = 7 [json_name = "emitterNotations"];
  int emitter_notations_size() const;
  private:
  int _internal_emitter_notations_size() const;

  public:
  void clear_emitter_notations() ;
  ::anduril::entitymanager::v1::EmitterNotation* mutable_emitter_notations(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::EmitterNotation>* mutable_emitter_notations();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::EmitterNotation>& _internal_emitter_notations() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::EmitterNotation>* _internal_mutable_emitter_notations();
  public:
  const ::anduril::entitymanager::v1::EmitterNotation& emitter_notations(int index) const;
  ::anduril::entitymanager::v1::EmitterNotation* add_emitter_notations();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::EmitterNotation>& emitter_notations() const;
  // .google.protobuf.DoubleValue bandwidth_hz = 3 [json_name = "bandwidthHz"];
  bool has_bandwidth_hz() const;
  void clear_bandwidth_hz() ;
  const ::google::protobuf::DoubleValue& bandwidth_hz() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_bandwidth_hz();
  ::google::protobuf::DoubleValue* mutable_bandwidth_hz();
  void set_allocated_bandwidth_hz(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_bandwidth_hz(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_bandwidth_hz();

  private:
  const ::google::protobuf::DoubleValue& _internal_bandwidth_hz() const;
  ::google::protobuf::DoubleValue* _internal_mutable_bandwidth_hz();

  public:
  // .google.protobuf.DoubleValue signal_to_noise_ratio = 4 [json_name = "signalToNoiseRatio"];
  bool has_signal_to_noise_ratio() const;
  void clear_signal_to_noise_ratio() ;
  const ::google::protobuf::DoubleValue& signal_to_noise_ratio() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_signal_to_noise_ratio();
  ::google::protobuf::DoubleValue* mutable_signal_to_noise_ratio();
  void set_allocated_signal_to_noise_ratio(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_signal_to_noise_ratio(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_signal_to_noise_ratio();

  private:
  const ::google::protobuf::DoubleValue& _internal_signal_to_noise_ratio() const;
  ::google::protobuf::DoubleValue* _internal_mutable_signal_to_noise_ratio();

  public:
  // .google.protobuf.DoubleValue pulse_width_s = 8 [json_name = "pulseWidthS"];
  bool has_pulse_width_s() const;
  void clear_pulse_width_s() ;
  const ::google::protobuf::DoubleValue& pulse_width_s() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_pulse_width_s();
  ::google::protobuf::DoubleValue* mutable_pulse_width_s();
  void set_allocated_pulse_width_s(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_pulse_width_s(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_pulse_width_s();

  private:
  const ::google::protobuf::DoubleValue& _internal_pulse_width_s() const;
  ::google::protobuf::DoubleValue* _internal_mutable_pulse_width_s();

  public:
  // .anduril.entitymanager.v1.PulseRepetitionInterval pulse_repetition_interval = 9 [json_name = "pulseRepetitionInterval"];
  bool has_pulse_repetition_interval() const;
  void clear_pulse_repetition_interval() ;
  const ::anduril::entitymanager::v1::PulseRepetitionInterval& pulse_repetition_interval() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::PulseRepetitionInterval* release_pulse_repetition_interval();
  ::anduril::entitymanager::v1::PulseRepetitionInterval* mutable_pulse_repetition_interval();
  void set_allocated_pulse_repetition_interval(::anduril::entitymanager::v1::PulseRepetitionInterval* value);
  void unsafe_arena_set_allocated_pulse_repetition_interval(::anduril::entitymanager::v1::PulseRepetitionInterval* value);
  ::anduril::entitymanager::v1::PulseRepetitionInterval* unsafe_arena_release_pulse_repetition_interval();

  private:
  const ::anduril::entitymanager::v1::PulseRepetitionInterval& _internal_pulse_repetition_interval() const;
  ::anduril::entitymanager::v1::PulseRepetitionInterval* _internal_mutable_pulse_repetition_interval();

  public:
  // .anduril.entitymanager.v1.ScanCharacteristics scan_characteristics = 11 [json_name = "scanCharacteristics"];
  bool has_scan_characteristics() const;
  void clear_scan_characteristics() ;
  const ::anduril::entitymanager::v1::ScanCharacteristics& scan_characteristics() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::ScanCharacteristics* release_scan_characteristics();
  ::anduril::entitymanager::v1::ScanCharacteristics* mutable_scan_characteristics();
  void set_allocated_scan_characteristics(::anduril::entitymanager::v1::ScanCharacteristics* value);
  void unsafe_arena_set_allocated_scan_characteristics(::anduril::entitymanager::v1::ScanCharacteristics* value);
  ::anduril::entitymanager::v1::ScanCharacteristics* unsafe_arena_release_scan_characteristics();

  private:
  const ::anduril::entitymanager::v1::ScanCharacteristics& _internal_scan_characteristics() const;
  ::anduril::entitymanager::v1::ScanCharacteristics* _internal_mutable_scan_characteristics();

  public:
  // .anduril.entitymanager.v1.Frequency frequency_center = 1 [json_name = "frequencyCenter"];
  bool has_frequency_center() const;
  private:
  bool _internal_has_frequency_center() const;

  public:
  void clear_frequency_center() ;
  const ::anduril::entitymanager::v1::Frequency& frequency_center() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Frequency* release_frequency_center();
  ::anduril::entitymanager::v1::Frequency* mutable_frequency_center();
  void set_allocated_frequency_center(::anduril::entitymanager::v1::Frequency* value);
  void unsafe_arena_set_allocated_frequency_center(::anduril::entitymanager::v1::Frequency* value);
  ::anduril::entitymanager::v1::Frequency* unsafe_arena_release_frequency_center();

  private:
  const ::anduril::entitymanager::v1::Frequency& _internal_frequency_center() const;
  ::anduril::entitymanager::v1::Frequency* _internal_mutable_frequency_center();

  public:
  // .anduril.entitymanager.v1.FrequencyRange frequency_range = 2 [json_name = "frequencyRange"];
  bool has_frequency_range() const;
  private:
  bool _internal_has_frequency_range() const;

  public:
  void clear_frequency_range() ;
  const ::anduril::entitymanager::v1::FrequencyRange& frequency_range() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::FrequencyRange* release_frequency_range();
  ::anduril::entitymanager::v1::FrequencyRange* mutable_frequency_range();
  void set_allocated_frequency_range(::anduril::entitymanager::v1::FrequencyRange* value);
  void unsafe_arena_set_allocated_frequency_range(::anduril::entitymanager::v1::FrequencyRange* value);
  ::anduril::entitymanager::v1::FrequencyRange* unsafe_arena_release_frequency_range();

  private:
  const ::anduril::entitymanager::v1::FrequencyRange& _internal_frequency_range() const;
  ::anduril::entitymanager::v1::FrequencyRange* _internal_mutable_frequency_range();

  public:
  // .anduril.entitymanager.v1.LineOfBearing line_of_bearing = 5 [json_name = "lineOfBearing"];
  bool has_line_of_bearing() const;
  private:
  bool _internal_has_line_of_bearing() const;

  public:
  void clear_line_of_bearing() ;
  const ::anduril::entitymanager::v1::LineOfBearing& line_of_bearing() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::LineOfBearing* release_line_of_bearing();
  ::anduril::entitymanager::v1::LineOfBearing* mutable_line_of_bearing();
  void set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value);
  void unsafe_arena_set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value);
  ::anduril::entitymanager::v1::LineOfBearing* unsafe_arena_release_line_of_bearing();

  private:
  const ::anduril::entitymanager::v1::LineOfBearing& _internal_line_of_bearing() const;
  ::anduril::entitymanager::v1::LineOfBearing* _internal_mutable_line_of_bearing();

  public:
  // .anduril.entitymanager.v1.Fixed fixed = 6 [json_name = "fixed"];
  bool has_fixed() const;
  private:
  bool _internal_has_fixed() const;

  public:
  void clear_fixed() ;
  const ::anduril::entitymanager::v1::Fixed& fixed() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Fixed* release_fixed();
  ::anduril::entitymanager::v1::Fixed* mutable_fixed();
  void set_allocated_fixed(::anduril::entitymanager::v1::Fixed* value);
  void unsafe_arena_set_allocated_fixed(::anduril::entitymanager::v1::Fixed* value);
  ::anduril::entitymanager::v1::Fixed* unsafe_arena_release_fixed();

  private:
  const ::anduril::entitymanager::v1::Fixed& _internal_fixed() const;
  ::anduril::entitymanager::v1::Fixed* _internal_mutable_fixed();

  public:
  void clear_frequency_measurement();
  FrequencyMeasurementCase frequency_measurement_case() const;
  void clear_report();
  ReportCase report_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Signal)
 private:
  class _Internal;
  void set_has_frequency_center();
  void set_has_frequency_range();
  void set_has_line_of_bearing();
  void set_has_fixed();
  inline bool has_frequency_measurement() const;
  inline void clear_has_frequency_measurement();
  inline bool has_report() const;
  inline void clear_has_report();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 10,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Signal& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::EmitterNotation > emitter_notations_;
    ::google::protobuf::DoubleValue* bandwidth_hz_;
    ::google::protobuf::DoubleValue* signal_to_noise_ratio_;
    ::google::protobuf::DoubleValue* pulse_width_s_;
    ::anduril::entitymanager::v1::PulseRepetitionInterval* pulse_repetition_interval_;
    ::anduril::entitymanager::v1::ScanCharacteristics* scan_characteristics_;
    union FrequencyMeasurementUnion {
      constexpr FrequencyMeasurementUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::Frequency* frequency_center_;
      ::anduril::entitymanager::v1::FrequencyRange* frequency_range_;
    } frequency_measurement_;
    union ReportUnion {
      constexpr ReportUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::LineOfBearing* line_of_bearing_;
      ::anduril::entitymanager::v1::Fixed* fixed_;
    } report_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Signal

// .anduril.entitymanager.v1.Frequency frequency_center = 1 [json_name = "frequencyCenter"];
inline bool Signal::has_frequency_center() const {
  return frequency_measurement_case() == kFrequencyCenter;
}
inline bool Signal::_internal_has_frequency_center() const {
  return frequency_measurement_case() == kFrequencyCenter;
}
inline void Signal::set_has_frequency_center() {
  _impl_._oneof_case_[0] = kFrequencyCenter;
}
inline void Signal::clear_frequency_center() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (frequency_measurement_case() == kFrequencyCenter) {
    if (GetArena() == nullptr) {
      delete _impl_.frequency_measurement_.frequency_center_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.frequency_measurement_.frequency_center_);
    }
    clear_has_frequency_measurement();
  }
}
inline ::anduril::entitymanager::v1::Frequency* Signal::release_frequency_center() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Signal.frequency_center)
  if (frequency_measurement_case() == kFrequencyCenter) {
    clear_has_frequency_measurement();
    auto* temp = _impl_.frequency_measurement_.frequency_center_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.frequency_measurement_.frequency_center_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::Frequency& Signal::_internal_frequency_center() const {
  return frequency_measurement_case() == kFrequencyCenter ? *_impl_.frequency_measurement_.frequency_center_ : reinterpret_cast<::anduril::entitymanager::v1::Frequency&>(::anduril::entitymanager::v1::_Frequency_default_instance_);
}
inline const ::anduril::entitymanager::v1::Frequency& Signal::frequency_center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Signal.frequency_center)
  return _internal_frequency_center();
}
inline ::anduril::entitymanager::v1::Frequency* Signal::unsafe_arena_release_frequency_center() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Signal.frequency_center)
  if (frequency_measurement_case() == kFrequencyCenter) {
    clear_has_frequency_measurement();
    auto* temp = _impl_.frequency_measurement_.frequency_center_;
    _impl_.frequency_measurement_.frequency_center_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Signal::unsafe_arena_set_allocated_frequency_center(::anduril::entitymanager::v1::Frequency* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_frequency_measurement();
  if (value) {
    set_has_frequency_center();
    _impl_.frequency_measurement_.frequency_center_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Signal.frequency_center)
}
inline ::anduril::entitymanager::v1::Frequency* Signal::_internal_mutable_frequency_center() {
  if (frequency_measurement_case() != kFrequencyCenter) {
    clear_frequency_measurement();
    set_has_frequency_center();
    _impl_.frequency_measurement_.frequency_center_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Frequency>(GetArena());
  }
  return _impl_.frequency_measurement_.frequency_center_;
}
inline ::anduril::entitymanager::v1::Frequency* Signal::mutable_frequency_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Frequency* _msg = _internal_mutable_frequency_center();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Signal.frequency_center)
  return _msg;
}

// .anduril.entitymanager.v1.FrequencyRange frequency_range = 2 [json_name = "frequencyRange"];
inline bool Signal::has_frequency_range() const {
  return frequency_measurement_case() == kFrequencyRange;
}
inline bool Signal::_internal_has_frequency_range() const {
  return frequency_measurement_case() == kFrequencyRange;
}
inline void Signal::set_has_frequency_range() {
  _impl_._oneof_case_[0] = kFrequencyRange;
}
inline void Signal::clear_frequency_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (frequency_measurement_case() == kFrequencyRange) {
    if (GetArena() == nullptr) {
      delete _impl_.frequency_measurement_.frequency_range_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.frequency_measurement_.frequency_range_);
    }
    clear_has_frequency_measurement();
  }
}
inline ::anduril::entitymanager::v1::FrequencyRange* Signal::release_frequency_range() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Signal.frequency_range)
  if (frequency_measurement_case() == kFrequencyRange) {
    clear_has_frequency_measurement();
    auto* temp = _impl_.frequency_measurement_.frequency_range_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.frequency_measurement_.frequency_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::FrequencyRange& Signal::_internal_frequency_range() const {
  return frequency_measurement_case() == kFrequencyRange ? *_impl_.frequency_measurement_.frequency_range_ : reinterpret_cast<::anduril::entitymanager::v1::FrequencyRange&>(::anduril::entitymanager::v1::_FrequencyRange_default_instance_);
}
inline const ::anduril::entitymanager::v1::FrequencyRange& Signal::frequency_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Signal.frequency_range)
  return _internal_frequency_range();
}
inline ::anduril::entitymanager::v1::FrequencyRange* Signal::unsafe_arena_release_frequency_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Signal.frequency_range)
  if (frequency_measurement_case() == kFrequencyRange) {
    clear_has_frequency_measurement();
    auto* temp = _impl_.frequency_measurement_.frequency_range_;
    _impl_.frequency_measurement_.frequency_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Signal::unsafe_arena_set_allocated_frequency_range(::anduril::entitymanager::v1::FrequencyRange* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_frequency_measurement();
  if (value) {
    set_has_frequency_range();
    _impl_.frequency_measurement_.frequency_range_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Signal.frequency_range)
}
inline ::anduril::entitymanager::v1::FrequencyRange* Signal::_internal_mutable_frequency_range() {
  if (frequency_measurement_case() != kFrequencyRange) {
    clear_frequency_measurement();
    set_has_frequency_range();
    _impl_.frequency_measurement_.frequency_range_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::FrequencyRange>(GetArena());
  }
  return _impl_.frequency_measurement_.frequency_range_;
}
inline ::anduril::entitymanager::v1::FrequencyRange* Signal::mutable_frequency_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::FrequencyRange* _msg = _internal_mutable_frequency_range();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Signal.frequency_range)
  return _msg;
}

// .google.protobuf.DoubleValue bandwidth_hz = 3 [json_name = "bandwidthHz"];
inline bool Signal::has_bandwidth_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bandwidth_hz_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& Signal::_internal_bandwidth_hz() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.bandwidth_hz_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& Signal::bandwidth_hz() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Signal.bandwidth_hz)
  return _internal_bandwidth_hz();
}
inline void Signal::unsafe_arena_set_allocated_bandwidth_hz(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bandwidth_hz_);
  }
  _impl_.bandwidth_hz_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Signal.bandwidth_hz)
}
inline ::google::protobuf::DoubleValue* Signal::release_bandwidth_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.bandwidth_hz_;
  _impl_.bandwidth_hz_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::DoubleValue* Signal::unsafe_arena_release_bandwidth_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Signal.bandwidth_hz)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.bandwidth_hz_;
  _impl_.bandwidth_hz_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* Signal::_internal_mutable_bandwidth_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bandwidth_hz_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.bandwidth_hz_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.bandwidth_hz_;
}
inline ::google::protobuf::DoubleValue* Signal::mutable_bandwidth_hz() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_bandwidth_hz();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Signal.bandwidth_hz)
  return _msg;
}
inline void Signal::set_allocated_bandwidth_hz(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bandwidth_hz_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bandwidth_hz_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Signal.bandwidth_hz)
}

// .google.protobuf.DoubleValue signal_to_noise_ratio = 4 [json_name = "signalToNoiseRatio"];
inline bool Signal::has_signal_to_noise_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.signal_to_noise_ratio_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& Signal::_internal_signal_to_noise_ratio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.signal_to_noise_ratio_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& Signal::signal_to_noise_ratio() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Signal.signal_to_noise_ratio)
  return _internal_signal_to_noise_ratio();
}
inline void Signal::unsafe_arena_set_allocated_signal_to_noise_ratio(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.signal_to_noise_ratio_);
  }
  _impl_.signal_to_noise_ratio_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Signal.signal_to_noise_ratio)
}
inline ::google::protobuf::DoubleValue* Signal::release_signal_to_noise_ratio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* released = _impl_.signal_to_noise_ratio_;
  _impl_.signal_to_noise_ratio_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::DoubleValue* Signal::unsafe_arena_release_signal_to_noise_ratio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Signal.signal_to_noise_ratio)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* temp = _impl_.signal_to_noise_ratio_;
  _impl_.signal_to_noise_ratio_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* Signal::_internal_mutable_signal_to_noise_ratio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.signal_to_noise_ratio_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.signal_to_noise_ratio_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.signal_to_noise_ratio_;
}
inline ::google::protobuf::DoubleValue* Signal::mutable_signal_to_noise_ratio() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_signal_to_noise_ratio();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Signal.signal_to_noise_ratio)
  return _msg;
}
inline void Signal::set_allocated_signal_to_noise_ratio(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.signal_to_noise_ratio_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.signal_to_noise_ratio_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Signal.signal_to_noise_ratio)
}

// .anduril.entitymanager.v1.LineOfBearing line_of_bearing = 5 [json_name = "lineOfBearing"];
inline bool Signal::has_line_of_bearing() const {
  return report_case() == kLineOfBearing;
}
inline bool Signal::_internal_has_line_of_bearing() const {
  return report_case() == kLineOfBearing;
}
inline void Signal::set_has_line_of_bearing() {
  _impl_._oneof_case_[1] = kLineOfBearing;
}
inline void Signal::clear_line_of_bearing() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (report_case() == kLineOfBearing) {
    if (GetArena() == nullptr) {
      delete _impl_.report_.line_of_bearing_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.report_.line_of_bearing_);
    }
    clear_has_report();
  }
}
inline ::anduril::entitymanager::v1::LineOfBearing* Signal::release_line_of_bearing() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Signal.line_of_bearing)
  if (report_case() == kLineOfBearing) {
    clear_has_report();
    auto* temp = _impl_.report_.line_of_bearing_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.report_.line_of_bearing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::LineOfBearing& Signal::_internal_line_of_bearing() const {
  return report_case() == kLineOfBearing ? *_impl_.report_.line_of_bearing_ : reinterpret_cast<::anduril::entitymanager::v1::LineOfBearing&>(::anduril::entitymanager::v1::_LineOfBearing_default_instance_);
}
inline const ::anduril::entitymanager::v1::LineOfBearing& Signal::line_of_bearing() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Signal.line_of_bearing)
  return _internal_line_of_bearing();
}
inline ::anduril::entitymanager::v1::LineOfBearing* Signal::unsafe_arena_release_line_of_bearing() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Signal.line_of_bearing)
  if (report_case() == kLineOfBearing) {
    clear_has_report();
    auto* temp = _impl_.report_.line_of_bearing_;
    _impl_.report_.line_of_bearing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Signal::unsafe_arena_set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_report();
  if (value) {
    set_has_line_of_bearing();
    _impl_.report_.line_of_bearing_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Signal.line_of_bearing)
}
inline ::anduril::entitymanager::v1::LineOfBearing* Signal::_internal_mutable_line_of_bearing() {
  if (report_case() != kLineOfBearing) {
    clear_report();
    set_has_line_of_bearing();
    _impl_.report_.line_of_bearing_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::LineOfBearing>(GetArena());
  }
  return _impl_.report_.line_of_bearing_;
}
inline ::anduril::entitymanager::v1::LineOfBearing* Signal::mutable_line_of_bearing() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::LineOfBearing* _msg = _internal_mutable_line_of_bearing();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Signal.line_of_bearing)
  return _msg;
}

// .anduril.entitymanager.v1.Fixed fixed = 6 [json_name = "fixed"];
inline bool Signal::has_fixed() const {
  return report_case() == kFixed;
}
inline bool Signal::_internal_has_fixed() const {
  return report_case() == kFixed;
}
inline void Signal::set_has_fixed() {
  _impl_._oneof_case_[1] = kFixed;
}
inline void Signal::clear_fixed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (report_case() == kFixed) {
    if (GetArena() == nullptr) {
      delete _impl_.report_.fixed_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.report_.fixed_);
    }
    clear_has_report();
  }
}
inline ::anduril::entitymanager::v1::Fixed* Signal::release_fixed() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Signal.fixed)
  if (report_case() == kFixed) {
    clear_has_report();
    auto* temp = _impl_.report_.fixed_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.report_.fixed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::Fixed& Signal::_internal_fixed() const {
  return report_case() == kFixed ? *_impl_.report_.fixed_ : reinterpret_cast<::anduril::entitymanager::v1::Fixed&>(::anduril::entitymanager::v1::_Fixed_default_instance_);
}
inline const ::anduril::entitymanager::v1::Fixed& Signal::fixed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Signal.fixed)
  return _internal_fixed();
}
inline ::anduril::entitymanager::v1::Fixed* Signal::unsafe_arena_release_fixed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Signal.fixed)
  if (report_case() == kFixed) {
    clear_has_report();
    auto* temp = _impl_.report_.fixed_;
    _impl_.report_.fixed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Signal::unsafe_arena_set_allocated_fixed(::anduril::entitymanager::v1::Fixed* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_report();
  if (value) {
    set_has_fixed();
    _impl_.report_.fixed_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Signal.fixed)
}
inline ::anduril::entitymanager::v1::Fixed* Signal::_internal_mutable_fixed() {
  if (report_case() != kFixed) {
    clear_report();
    set_has_fixed();
    _impl_.report_.fixed_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Fixed>(GetArena());
  }
  return _impl_.report_.fixed_;
}
inline ::anduril::entitymanager::v1::Fixed* Signal::mutable_fixed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Fixed* _msg = _internal_mutable_fixed();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Signal.fixed)
  return _msg;
}

// repeated .anduril.entitymanager.v1.EmitterNotation emitter_notations = 7 [json_name = "emitterNotations"];
inline int Signal::_internal_emitter_notations_size() const {
  return _internal_emitter_notations().size();
}
inline int Signal::emitter_notations_size() const {
  return _internal_emitter_notations_size();
}
inline void Signal::clear_emitter_notations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emitter_notations_.Clear();
}
inline ::anduril::entitymanager::v1::EmitterNotation* Signal::mutable_emitter_notations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Signal.emitter_notations)
  return _internal_mutable_emitter_notations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::EmitterNotation>* Signal::mutable_emitter_notations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.Signal.emitter_notations)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_emitter_notations();
}
inline const ::anduril::entitymanager::v1::EmitterNotation& Signal::emitter_notations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Signal.emitter_notations)
  return _internal_emitter_notations().Get(index);
}
inline ::anduril::entitymanager::v1::EmitterNotation* Signal::add_emitter_notations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::EmitterNotation* _add = _internal_mutable_emitter_notations()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.Signal.emitter_notations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::EmitterNotation>& Signal::emitter_notations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.Signal.emitter_notations)
  return _internal_emitter_notations();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::EmitterNotation>&
Signal::_internal_emitter_notations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.emitter_notations_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::EmitterNotation>*
Signal::_internal_mutable_emitter_notations() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.emitter_notations_;
}

// .google.protobuf.DoubleValue pulse_width_s = 8 [json_name = "pulseWidthS"];
inline bool Signal::has_pulse_width_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pulse_width_s_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& Signal::_internal_pulse_width_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.pulse_width_s_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& Signal::pulse_width_s() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Signal.pulse_width_s)
  return _internal_pulse_width_s();
}
inline void Signal::unsafe_arena_set_allocated_pulse_width_s(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pulse_width_s_);
  }
  _impl_.pulse_width_s_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Signal.pulse_width_s)
}
inline ::google::protobuf::DoubleValue* Signal::release_pulse_width_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::DoubleValue* released = _impl_.pulse_width_s_;
  _impl_.pulse_width_s_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::DoubleValue* Signal::unsafe_arena_release_pulse_width_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Signal.pulse_width_s)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::DoubleValue* temp = _impl_.pulse_width_s_;
  _impl_.pulse_width_s_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* Signal::_internal_mutable_pulse_width_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pulse_width_s_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.pulse_width_s_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.pulse_width_s_;
}
inline ::google::protobuf::DoubleValue* Signal::mutable_pulse_width_s() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_pulse_width_s();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Signal.pulse_width_s)
  return _msg;
}
inline void Signal::set_allocated_pulse_width_s(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pulse_width_s_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.pulse_width_s_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Signal.pulse_width_s)
}

// .anduril.entitymanager.v1.PulseRepetitionInterval pulse_repetition_interval = 9 [json_name = "pulseRepetitionInterval"];
inline bool Signal::has_pulse_repetition_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pulse_repetition_interval_ != nullptr);
  return value;
}
inline void Signal::clear_pulse_repetition_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pulse_repetition_interval_ != nullptr) _impl_.pulse_repetition_interval_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::anduril::entitymanager::v1::PulseRepetitionInterval& Signal::_internal_pulse_repetition_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::PulseRepetitionInterval* p = _impl_.pulse_repetition_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::PulseRepetitionInterval&>(::anduril::entitymanager::v1::_PulseRepetitionInterval_default_instance_);
}
inline const ::anduril::entitymanager::v1::PulseRepetitionInterval& Signal::pulse_repetition_interval() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Signal.pulse_repetition_interval)
  return _internal_pulse_repetition_interval();
}
inline void Signal::unsafe_arena_set_allocated_pulse_repetition_interval(::anduril::entitymanager::v1::PulseRepetitionInterval* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pulse_repetition_interval_);
  }
  _impl_.pulse_repetition_interval_ = reinterpret_cast<::anduril::entitymanager::v1::PulseRepetitionInterval*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Signal.pulse_repetition_interval)
}
inline ::anduril::entitymanager::v1::PulseRepetitionInterval* Signal::release_pulse_repetition_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::entitymanager::v1::PulseRepetitionInterval* released = _impl_.pulse_repetition_interval_;
  _impl_.pulse_repetition_interval_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::PulseRepetitionInterval* Signal::unsafe_arena_release_pulse_repetition_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Signal.pulse_repetition_interval)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::entitymanager::v1::PulseRepetitionInterval* temp = _impl_.pulse_repetition_interval_;
  _impl_.pulse_repetition_interval_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::PulseRepetitionInterval* Signal::_internal_mutable_pulse_repetition_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pulse_repetition_interval_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::PulseRepetitionInterval>(GetArena());
    _impl_.pulse_repetition_interval_ = reinterpret_cast<::anduril::entitymanager::v1::PulseRepetitionInterval*>(p);
  }
  return _impl_.pulse_repetition_interval_;
}
inline ::anduril::entitymanager::v1::PulseRepetitionInterval* Signal::mutable_pulse_repetition_interval() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::anduril::entitymanager::v1::PulseRepetitionInterval* _msg = _internal_mutable_pulse_repetition_interval();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Signal.pulse_repetition_interval)
  return _msg;
}
inline void Signal::set_allocated_pulse_repetition_interval(::anduril::entitymanager::v1::PulseRepetitionInterval* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pulse_repetition_interval_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.pulse_repetition_interval_ = reinterpret_cast<::anduril::entitymanager::v1::PulseRepetitionInterval*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Signal.pulse_repetition_interval)
}

// .anduril.entitymanager.v1.ScanCharacteristics scan_characteristics = 11 [json_name = "scanCharacteristics"];
inline bool Signal::has_scan_characteristics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scan_characteristics_ != nullptr);
  return value;
}
inline void Signal::clear_scan_characteristics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scan_characteristics_ != nullptr) _impl_.scan_characteristics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::anduril::entitymanager::v1::ScanCharacteristics& Signal::_internal_scan_characteristics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::ScanCharacteristics* p = _impl_.scan_characteristics_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::ScanCharacteristics&>(::anduril::entitymanager::v1::_ScanCharacteristics_default_instance_);
}
inline const ::anduril::entitymanager::v1::ScanCharacteristics& Signal::scan_characteristics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Signal.scan_characteristics)
  return _internal_scan_characteristics();
}
inline void Signal::unsafe_arena_set_allocated_scan_characteristics(::anduril::entitymanager::v1::ScanCharacteristics* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scan_characteristics_);
  }
  _impl_.scan_characteristics_ = reinterpret_cast<::anduril::entitymanager::v1::ScanCharacteristics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Signal.scan_characteristics)
}
inline ::anduril::entitymanager::v1::ScanCharacteristics* Signal::release_scan_characteristics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::anduril::entitymanager::v1::ScanCharacteristics* released = _impl_.scan_characteristics_;
  _impl_.scan_characteristics_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::ScanCharacteristics* Signal::unsafe_arena_release_scan_characteristics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Signal.scan_characteristics)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::anduril::entitymanager::v1::ScanCharacteristics* temp = _impl_.scan_characteristics_;
  _impl_.scan_characteristics_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::ScanCharacteristics* Signal::_internal_mutable_scan_characteristics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scan_characteristics_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::ScanCharacteristics>(GetArena());
    _impl_.scan_characteristics_ = reinterpret_cast<::anduril::entitymanager::v1::ScanCharacteristics*>(p);
  }
  return _impl_.scan_characteristics_;
}
inline ::anduril::entitymanager::v1::ScanCharacteristics* Signal::mutable_scan_characteristics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::anduril::entitymanager::v1::ScanCharacteristics* _msg = _internal_mutable_scan_characteristics();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Signal.scan_characteristics)
  return _msg;
}
inline void Signal::set_allocated_scan_characteristics(::anduril::entitymanager::v1::ScanCharacteristics* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.scan_characteristics_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.scan_characteristics_ = reinterpret_cast<::anduril::entitymanager::v1::ScanCharacteristics*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Signal.scan_characteristics)
}

inline bool Signal::has_frequency_measurement() const {
  return frequency_measurement_case() != FREQUENCY_MEASUREMENT_NOT_SET;
}
inline void Signal::clear_has_frequency_measurement() {
  _impl_._oneof_case_[0] = FREQUENCY_MEASUREMENT_NOT_SET;
}
inline bool Signal::has_report() const {
  return report_case() != REPORT_NOT_SET;
}
inline void Signal::clear_has_report() {
  _impl_._oneof_case_[1] = REPORT_NOT_SET;
}
inline Signal::FrequencyMeasurementCase Signal::frequency_measurement_case() const {
  return Signal::FrequencyMeasurementCase(_impl_._oneof_case_[0]);
}
inline Signal::ReportCase Signal::report_case() const {
  return Signal::ReportCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// EmitterNotation

// string emitter_notation = 1 [json_name = "emitterNotation"];
inline void EmitterNotation::clear_emitter_notation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emitter_notation_.ClearToEmpty();
}
inline const std::string& EmitterNotation::emitter_notation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.EmitterNotation.emitter_notation)
  return _internal_emitter_notation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EmitterNotation::set_emitter_notation(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emitter_notation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.EmitterNotation.emitter_notation)
}
inline std::string* EmitterNotation::mutable_emitter_notation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_emitter_notation();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.EmitterNotation.emitter_notation)
  return _s;
}
inline const std::string& EmitterNotation::_internal_emitter_notation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.emitter_notation_.Get();
}
inline void EmitterNotation::_internal_set_emitter_notation(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emitter_notation_.Set(value, GetArena());
}
inline std::string* EmitterNotation::_internal_mutable_emitter_notation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.emitter_notation_.Mutable( GetArena());
}
inline std::string* EmitterNotation::release_emitter_notation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.EmitterNotation.emitter_notation)
  return _impl_.emitter_notation_.Release();
}
inline void EmitterNotation::set_allocated_emitter_notation(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emitter_notation_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.emitter_notation_.IsDefault()) {
    _impl_.emitter_notation_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.EmitterNotation.emitter_notation)
}

// .google.protobuf.DoubleValue confidence = 2 [json_name = "confidence"];
inline bool EmitterNotation::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& EmitterNotation::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& EmitterNotation::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.EmitterNotation.confidence)
  return _internal_confidence();
}
inline void EmitterNotation::unsafe_arena_set_allocated_confidence(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.EmitterNotation.confidence)
}
inline ::google::protobuf::DoubleValue* EmitterNotation::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::DoubleValue* EmitterNotation::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.EmitterNotation.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* EmitterNotation::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.confidence_;
}
inline ::google::protobuf::DoubleValue* EmitterNotation::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.EmitterNotation.confidence)
  return _msg;
}
inline void EmitterNotation::set_allocated_confidence(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.EmitterNotation.confidence)
}

// -------------------------------------------------------------------

// Measurement

// .google.protobuf.DoubleValue value = 1 [json_name = "value"];
inline bool Measurement::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& Measurement::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& Measurement::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Measurement.value)
  return _internal_value();
}
inline void Measurement::unsafe_arena_set_allocated_value(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Measurement.value)
}
inline ::google::protobuf::DoubleValue* Measurement::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.value_;
  _impl_.value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::DoubleValue* Measurement::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Measurement.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* Measurement::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.value_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.value_;
}
inline ::google::protobuf::DoubleValue* Measurement::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Measurement.value)
  return _msg;
}
inline void Measurement::set_allocated_value(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Measurement.value)
}

// .google.protobuf.DoubleValue sigma = 2 [json_name = "sigma"];
inline bool Measurement::has_sigma() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sigma_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& Measurement::_internal_sigma() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.sigma_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& Measurement::sigma() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Measurement.sigma)
  return _internal_sigma();
}
inline void Measurement::unsafe_arena_set_allocated_sigma(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sigma_);
  }
  _impl_.sigma_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Measurement.sigma)
}
inline ::google::protobuf::DoubleValue* Measurement::release_sigma() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* released = _impl_.sigma_;
  _impl_.sigma_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::DoubleValue* Measurement::unsafe_arena_release_sigma() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Measurement.sigma)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* temp = _impl_.sigma_;
  _impl_.sigma_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* Measurement::_internal_mutable_sigma() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sigma_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.sigma_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.sigma_;
}
inline ::google::protobuf::DoubleValue* Measurement::mutable_sigma() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_sigma();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Measurement.sigma)
  return _msg;
}
inline void Measurement::set_allocated_sigma(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sigma_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.sigma_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Measurement.sigma)
}

// -------------------------------------------------------------------

// Frequency

// .anduril.entitymanager.v1.Measurement frequency_hz = 1 [json_name = "frequencyHz"];
inline bool Frequency::has_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.frequency_hz_ != nullptr);
  return value;
}
inline void Frequency::clear_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.frequency_hz_ != nullptr) _impl_.frequency_hz_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::Measurement& Frequency::_internal_frequency_hz() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Measurement* p = _impl_.frequency_hz_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Measurement&>(::anduril::entitymanager::v1::_Measurement_default_instance_);
}
inline const ::anduril::entitymanager::v1::Measurement& Frequency::frequency_hz() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Frequency.frequency_hz)
  return _internal_frequency_hz();
}
inline void Frequency::unsafe_arena_set_allocated_frequency_hz(::anduril::entitymanager::v1::Measurement* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.frequency_hz_);
  }
  _impl_.frequency_hz_ = reinterpret_cast<::anduril::entitymanager::v1::Measurement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Frequency.frequency_hz)
}
inline ::anduril::entitymanager::v1::Measurement* Frequency::release_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Measurement* released = _impl_.frequency_hz_;
  _impl_.frequency_hz_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Measurement* Frequency::unsafe_arena_release_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Frequency.frequency_hz)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Measurement* temp = _impl_.frequency_hz_;
  _impl_.frequency_hz_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Measurement* Frequency::_internal_mutable_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.frequency_hz_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Measurement>(GetArena());
    _impl_.frequency_hz_ = reinterpret_cast<::anduril::entitymanager::v1::Measurement*>(p);
  }
  return _impl_.frequency_hz_;
}
inline ::anduril::entitymanager::v1::Measurement* Frequency::mutable_frequency_hz() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Measurement* _msg = _internal_mutable_frequency_hz();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Frequency.frequency_hz)
  return _msg;
}
inline void Frequency::set_allocated_frequency_hz(::anduril::entitymanager::v1::Measurement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.frequency_hz_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.frequency_hz_ = reinterpret_cast<::anduril::entitymanager::v1::Measurement*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Frequency.frequency_hz)
}

// -------------------------------------------------------------------

// FrequencyRange

// .anduril.entitymanager.v1.Frequency minimum_frequency_hz = 1 [json_name = "minimumFrequencyHz"];
inline bool FrequencyRange::has_minimum_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minimum_frequency_hz_ != nullptr);
  return value;
}
inline void FrequencyRange::clear_minimum_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.minimum_frequency_hz_ != nullptr) _impl_.minimum_frequency_hz_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::Frequency& FrequencyRange::_internal_minimum_frequency_hz() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Frequency* p = _impl_.minimum_frequency_hz_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Frequency&>(::anduril::entitymanager::v1::_Frequency_default_instance_);
}
inline const ::anduril::entitymanager::v1::Frequency& FrequencyRange::minimum_frequency_hz() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.FrequencyRange.minimum_frequency_hz)
  return _internal_minimum_frequency_hz();
}
inline void FrequencyRange::unsafe_arena_set_allocated_minimum_frequency_hz(::anduril::entitymanager::v1::Frequency* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minimum_frequency_hz_);
  }
  _impl_.minimum_frequency_hz_ = reinterpret_cast<::anduril::entitymanager::v1::Frequency*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.FrequencyRange.minimum_frequency_hz)
}
inline ::anduril::entitymanager::v1::Frequency* FrequencyRange::release_minimum_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Frequency* released = _impl_.minimum_frequency_hz_;
  _impl_.minimum_frequency_hz_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Frequency* FrequencyRange::unsafe_arena_release_minimum_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.FrequencyRange.minimum_frequency_hz)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Frequency* temp = _impl_.minimum_frequency_hz_;
  _impl_.minimum_frequency_hz_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Frequency* FrequencyRange::_internal_mutable_minimum_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.minimum_frequency_hz_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Frequency>(GetArena());
    _impl_.minimum_frequency_hz_ = reinterpret_cast<::anduril::entitymanager::v1::Frequency*>(p);
  }
  return _impl_.minimum_frequency_hz_;
}
inline ::anduril::entitymanager::v1::Frequency* FrequencyRange::mutable_minimum_frequency_hz() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Frequency* _msg = _internal_mutable_minimum_frequency_hz();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.FrequencyRange.minimum_frequency_hz)
  return _msg;
}
inline void FrequencyRange::set_allocated_minimum_frequency_hz(::anduril::entitymanager::v1::Frequency* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.minimum_frequency_hz_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.minimum_frequency_hz_ = reinterpret_cast<::anduril::entitymanager::v1::Frequency*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.FrequencyRange.minimum_frequency_hz)
}

// .anduril.entitymanager.v1.Frequency maximum_frequency_hz = 2 [json_name = "maximumFrequencyHz"];
inline bool FrequencyRange::has_maximum_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maximum_frequency_hz_ != nullptr);
  return value;
}
inline void FrequencyRange::clear_maximum_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.maximum_frequency_hz_ != nullptr) _impl_.maximum_frequency_hz_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::entitymanager::v1::Frequency& FrequencyRange::_internal_maximum_frequency_hz() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Frequency* p = _impl_.maximum_frequency_hz_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Frequency&>(::anduril::entitymanager::v1::_Frequency_default_instance_);
}
inline const ::anduril::entitymanager::v1::Frequency& FrequencyRange::maximum_frequency_hz() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.FrequencyRange.maximum_frequency_hz)
  return _internal_maximum_frequency_hz();
}
inline void FrequencyRange::unsafe_arena_set_allocated_maximum_frequency_hz(::anduril::entitymanager::v1::Frequency* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maximum_frequency_hz_);
  }
  _impl_.maximum_frequency_hz_ = reinterpret_cast<::anduril::entitymanager::v1::Frequency*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.FrequencyRange.maximum_frequency_hz)
}
inline ::anduril::entitymanager::v1::Frequency* FrequencyRange::release_maximum_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entitymanager::v1::Frequency* released = _impl_.maximum_frequency_hz_;
  _impl_.maximum_frequency_hz_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Frequency* FrequencyRange::unsafe_arena_release_maximum_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.FrequencyRange.maximum_frequency_hz)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entitymanager::v1::Frequency* temp = _impl_.maximum_frequency_hz_;
  _impl_.maximum_frequency_hz_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Frequency* FrequencyRange::_internal_mutable_maximum_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.maximum_frequency_hz_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Frequency>(GetArena());
    _impl_.maximum_frequency_hz_ = reinterpret_cast<::anduril::entitymanager::v1::Frequency*>(p);
  }
  return _impl_.maximum_frequency_hz_;
}
inline ::anduril::entitymanager::v1::Frequency* FrequencyRange::mutable_maximum_frequency_hz() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::entitymanager::v1::Frequency* _msg = _internal_mutable_maximum_frequency_hz();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.FrequencyRange.maximum_frequency_hz)
  return _msg;
}
inline void FrequencyRange::set_allocated_maximum_frequency_hz(::anduril::entitymanager::v1::Frequency* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.maximum_frequency_hz_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.maximum_frequency_hz_ = reinterpret_cast<::anduril::entitymanager::v1::Frequency*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.FrequencyRange.maximum_frequency_hz)
}

// -------------------------------------------------------------------

// LineOfBearing

// .anduril.entitymanager.v1.AngleOfArrival angle_of_arrival = 3 [json_name = "angleOfArrival"];
inline bool LineOfBearing::has_angle_of_arrival() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.angle_of_arrival_ != nullptr);
  return value;
}
inline void LineOfBearing::clear_angle_of_arrival() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.angle_of_arrival_ != nullptr) _impl_.angle_of_arrival_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::AngleOfArrival& LineOfBearing::_internal_angle_of_arrival() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::AngleOfArrival* p = _impl_.angle_of_arrival_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::AngleOfArrival&>(::anduril::entitymanager::v1::_AngleOfArrival_default_instance_);
}
inline const ::anduril::entitymanager::v1::AngleOfArrival& LineOfBearing::angle_of_arrival() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.LineOfBearing.angle_of_arrival)
  return _internal_angle_of_arrival();
}
inline void LineOfBearing::unsafe_arena_set_allocated_angle_of_arrival(::anduril::entitymanager::v1::AngleOfArrival* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.angle_of_arrival_);
  }
  _impl_.angle_of_arrival_ = reinterpret_cast<::anduril::entitymanager::v1::AngleOfArrival*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.LineOfBearing.angle_of_arrival)
}
inline ::anduril::entitymanager::v1::AngleOfArrival* LineOfBearing::release_angle_of_arrival() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::AngleOfArrival* released = _impl_.angle_of_arrival_;
  _impl_.angle_of_arrival_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::AngleOfArrival* LineOfBearing::unsafe_arena_release_angle_of_arrival() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.LineOfBearing.angle_of_arrival)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::AngleOfArrival* temp = _impl_.angle_of_arrival_;
  _impl_.angle_of_arrival_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::AngleOfArrival* LineOfBearing::_internal_mutable_angle_of_arrival() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.angle_of_arrival_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::AngleOfArrival>(GetArena());
    _impl_.angle_of_arrival_ = reinterpret_cast<::anduril::entitymanager::v1::AngleOfArrival*>(p);
  }
  return _impl_.angle_of_arrival_;
}
inline ::anduril::entitymanager::v1::AngleOfArrival* LineOfBearing::mutable_angle_of_arrival() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::AngleOfArrival* _msg = _internal_mutable_angle_of_arrival();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.LineOfBearing.angle_of_arrival)
  return _msg;
}
inline void LineOfBearing::set_allocated_angle_of_arrival(::anduril::entitymanager::v1::AngleOfArrival* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.angle_of_arrival_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.angle_of_arrival_ = reinterpret_cast<::anduril::entitymanager::v1::AngleOfArrival*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.LineOfBearing.angle_of_arrival)
}

// .anduril.entitymanager.v1.Measurement range_estimate_m = 4 [json_name = "rangeEstimateM"];
inline bool LineOfBearing::has_range_estimate_m() const {
  return detection_range_case() == kRangeEstimateM;
}
inline bool LineOfBearing::_internal_has_range_estimate_m() const {
  return detection_range_case() == kRangeEstimateM;
}
inline void LineOfBearing::set_has_range_estimate_m() {
  _impl_._oneof_case_[0] = kRangeEstimateM;
}
inline void LineOfBearing::clear_range_estimate_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (detection_range_case() == kRangeEstimateM) {
    if (GetArena() == nullptr) {
      delete _impl_.detection_range_.range_estimate_m_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.detection_range_.range_estimate_m_);
    }
    clear_has_detection_range();
  }
}
inline ::anduril::entitymanager::v1::Measurement* LineOfBearing::release_range_estimate_m() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.LineOfBearing.range_estimate_m)
  if (detection_range_case() == kRangeEstimateM) {
    clear_has_detection_range();
    auto* temp = _impl_.detection_range_.range_estimate_m_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.detection_range_.range_estimate_m_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::Measurement& LineOfBearing::_internal_range_estimate_m() const {
  return detection_range_case() == kRangeEstimateM ? *_impl_.detection_range_.range_estimate_m_ : reinterpret_cast<::anduril::entitymanager::v1::Measurement&>(::anduril::entitymanager::v1::_Measurement_default_instance_);
}
inline const ::anduril::entitymanager::v1::Measurement& LineOfBearing::range_estimate_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.LineOfBearing.range_estimate_m)
  return _internal_range_estimate_m();
}
inline ::anduril::entitymanager::v1::Measurement* LineOfBearing::unsafe_arena_release_range_estimate_m() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.LineOfBearing.range_estimate_m)
  if (detection_range_case() == kRangeEstimateM) {
    clear_has_detection_range();
    auto* temp = _impl_.detection_range_.range_estimate_m_;
    _impl_.detection_range_.range_estimate_m_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LineOfBearing::unsafe_arena_set_allocated_range_estimate_m(::anduril::entitymanager::v1::Measurement* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_detection_range();
  if (value) {
    set_has_range_estimate_m();
    _impl_.detection_range_.range_estimate_m_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.LineOfBearing.range_estimate_m)
}
inline ::anduril::entitymanager::v1::Measurement* LineOfBearing::_internal_mutable_range_estimate_m() {
  if (detection_range_case() != kRangeEstimateM) {
    clear_detection_range();
    set_has_range_estimate_m();
    _impl_.detection_range_.range_estimate_m_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Measurement>(GetArena());
  }
  return _impl_.detection_range_.range_estimate_m_;
}
inline ::anduril::entitymanager::v1::Measurement* LineOfBearing::mutable_range_estimate_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Measurement* _msg = _internal_mutable_range_estimate_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.LineOfBearing.range_estimate_m)
  return _msg;
}

// .anduril.entitymanager.v1.Measurement max_range_m = 5 [json_name = "maxRangeM"];
inline bool LineOfBearing::has_max_range_m() const {
  return detection_range_case() == kMaxRangeM;
}
inline bool LineOfBearing::_internal_has_max_range_m() const {
  return detection_range_case() == kMaxRangeM;
}
inline void LineOfBearing::set_has_max_range_m() {
  _impl_._oneof_case_[0] = kMaxRangeM;
}
inline void LineOfBearing::clear_max_range_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (detection_range_case() == kMaxRangeM) {
    if (GetArena() == nullptr) {
      delete _impl_.detection_range_.max_range_m_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.detection_range_.max_range_m_);
    }
    clear_has_detection_range();
  }
}
inline ::anduril::entitymanager::v1::Measurement* LineOfBearing::release_max_range_m() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.LineOfBearing.max_range_m)
  if (detection_range_case() == kMaxRangeM) {
    clear_has_detection_range();
    auto* temp = _impl_.detection_range_.max_range_m_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.detection_range_.max_range_m_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::Measurement& LineOfBearing::_internal_max_range_m() const {
  return detection_range_case() == kMaxRangeM ? *_impl_.detection_range_.max_range_m_ : reinterpret_cast<::anduril::entitymanager::v1::Measurement&>(::anduril::entitymanager::v1::_Measurement_default_instance_);
}
inline const ::anduril::entitymanager::v1::Measurement& LineOfBearing::max_range_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.LineOfBearing.max_range_m)
  return _internal_max_range_m();
}
inline ::anduril::entitymanager::v1::Measurement* LineOfBearing::unsafe_arena_release_max_range_m() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.LineOfBearing.max_range_m)
  if (detection_range_case() == kMaxRangeM) {
    clear_has_detection_range();
    auto* temp = _impl_.detection_range_.max_range_m_;
    _impl_.detection_range_.max_range_m_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LineOfBearing::unsafe_arena_set_allocated_max_range_m(::anduril::entitymanager::v1::Measurement* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_detection_range();
  if (value) {
    set_has_max_range_m();
    _impl_.detection_range_.max_range_m_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.LineOfBearing.max_range_m)
}
inline ::anduril::entitymanager::v1::Measurement* LineOfBearing::_internal_mutable_max_range_m() {
  if (detection_range_case() != kMaxRangeM) {
    clear_detection_range();
    set_has_max_range_m();
    _impl_.detection_range_.max_range_m_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Measurement>(GetArena());
  }
  return _impl_.detection_range_.max_range_m_;
}
inline ::anduril::entitymanager::v1::Measurement* LineOfBearing::mutable_max_range_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Measurement* _msg = _internal_mutable_max_range_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.LineOfBearing.max_range_m)
  return _msg;
}

inline bool LineOfBearing::has_detection_range() const {
  return detection_range_case() != DETECTION_RANGE_NOT_SET;
}
inline void LineOfBearing::clear_has_detection_range() {
  _impl_._oneof_case_[0] = DETECTION_RANGE_NOT_SET;
}
inline LineOfBearing::DetectionRangeCase LineOfBearing::detection_range_case() const {
  return LineOfBearing::DetectionRangeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AngleOfArrival

// .anduril.type.Pose relative_pose = 1 [json_name = "relativePose"];
inline bool AngleOfArrival::has_relative_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relative_pose_ != nullptr);
  return value;
}
inline const ::anduril::type::Pose& AngleOfArrival::_internal_relative_pose() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::type::Pose* p = _impl_.relative_pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::type::Pose&>(::anduril::type::_Pose_default_instance_);
}
inline const ::anduril::type::Pose& AngleOfArrival::relative_pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.AngleOfArrival.relative_pose)
  return _internal_relative_pose();
}
inline void AngleOfArrival::unsafe_arena_set_allocated_relative_pose(::anduril::type::Pose* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relative_pose_);
  }
  _impl_.relative_pose_ = reinterpret_cast<::anduril::type::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.AngleOfArrival.relative_pose)
}
inline ::anduril::type::Pose* AngleOfArrival::release_relative_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::type::Pose* released = _impl_.relative_pose_;
  _impl_.relative_pose_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::type::Pose* AngleOfArrival::unsafe_arena_release_relative_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.AngleOfArrival.relative_pose)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::type::Pose* temp = _impl_.relative_pose_;
  _impl_.relative_pose_ = nullptr;
  return temp;
}
inline ::anduril::type::Pose* AngleOfArrival::_internal_mutable_relative_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.relative_pose_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::type::Pose>(GetArena());
    _impl_.relative_pose_ = reinterpret_cast<::anduril::type::Pose*>(p);
  }
  return _impl_.relative_pose_;
}
inline ::anduril::type::Pose* AngleOfArrival::mutable_relative_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::type::Pose* _msg = _internal_mutable_relative_pose();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.AngleOfArrival.relative_pose)
  return _msg;
}
inline void AngleOfArrival::set_allocated_relative_pose(::anduril::type::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relative_pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.relative_pose_ = reinterpret_cast<::anduril::type::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.AngleOfArrival.relative_pose)
}

// .anduril.type.TMat2 bearing_elevation_covariance_rad2 = 2 [json_name = "bearingElevationCovarianceRad2"];
inline bool AngleOfArrival::has_bearing_elevation_covariance_rad2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bearing_elevation_covariance_rad2_ != nullptr);
  return value;
}
inline const ::anduril::type::TMat2& AngleOfArrival::_internal_bearing_elevation_covariance_rad2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::type::TMat2* p = _impl_.bearing_elevation_covariance_rad2_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::type::TMat2&>(::anduril::type::_TMat2_default_instance_);
}
inline const ::anduril::type::TMat2& AngleOfArrival::bearing_elevation_covariance_rad2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.AngleOfArrival.bearing_elevation_covariance_rad2)
  return _internal_bearing_elevation_covariance_rad2();
}
inline void AngleOfArrival::unsafe_arena_set_allocated_bearing_elevation_covariance_rad2(::anduril::type::TMat2* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bearing_elevation_covariance_rad2_);
  }
  _impl_.bearing_elevation_covariance_rad2_ = reinterpret_cast<::anduril::type::TMat2*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.AngleOfArrival.bearing_elevation_covariance_rad2)
}
inline ::anduril::type::TMat2* AngleOfArrival::release_bearing_elevation_covariance_rad2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::type::TMat2* released = _impl_.bearing_elevation_covariance_rad2_;
  _impl_.bearing_elevation_covariance_rad2_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::type::TMat2* AngleOfArrival::unsafe_arena_release_bearing_elevation_covariance_rad2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.AngleOfArrival.bearing_elevation_covariance_rad2)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::type::TMat2* temp = _impl_.bearing_elevation_covariance_rad2_;
  _impl_.bearing_elevation_covariance_rad2_ = nullptr;
  return temp;
}
inline ::anduril::type::TMat2* AngleOfArrival::_internal_mutable_bearing_elevation_covariance_rad2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bearing_elevation_covariance_rad2_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::type::TMat2>(GetArena());
    _impl_.bearing_elevation_covariance_rad2_ = reinterpret_cast<::anduril::type::TMat2*>(p);
  }
  return _impl_.bearing_elevation_covariance_rad2_;
}
inline ::anduril::type::TMat2* AngleOfArrival::mutable_bearing_elevation_covariance_rad2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::type::TMat2* _msg = _internal_mutable_bearing_elevation_covariance_rad2();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.AngleOfArrival.bearing_elevation_covariance_rad2)
  return _msg;
}
inline void AngleOfArrival::set_allocated_bearing_elevation_covariance_rad2(::anduril::type::TMat2* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bearing_elevation_covariance_rad2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.bearing_elevation_covariance_rad2_ = reinterpret_cast<::anduril::type::TMat2*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.AngleOfArrival.bearing_elevation_covariance_rad2)
}

// -------------------------------------------------------------------

// Fixed

// -------------------------------------------------------------------

// PulseRepetitionInterval

// .anduril.entitymanager.v1.Measurement pulse_repetition_interval_s = 1 [json_name = "pulseRepetitionIntervalS"];
inline bool PulseRepetitionInterval::has_pulse_repetition_interval_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pulse_repetition_interval_s_ != nullptr);
  return value;
}
inline void PulseRepetitionInterval::clear_pulse_repetition_interval_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pulse_repetition_interval_s_ != nullptr) _impl_.pulse_repetition_interval_s_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::Measurement& PulseRepetitionInterval::_internal_pulse_repetition_interval_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Measurement* p = _impl_.pulse_repetition_interval_s_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Measurement&>(::anduril::entitymanager::v1::_Measurement_default_instance_);
}
inline const ::anduril::entitymanager::v1::Measurement& PulseRepetitionInterval::pulse_repetition_interval_s() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.PulseRepetitionInterval.pulse_repetition_interval_s)
  return _internal_pulse_repetition_interval_s();
}
inline void PulseRepetitionInterval::unsafe_arena_set_allocated_pulse_repetition_interval_s(::anduril::entitymanager::v1::Measurement* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pulse_repetition_interval_s_);
  }
  _impl_.pulse_repetition_interval_s_ = reinterpret_cast<::anduril::entitymanager::v1::Measurement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.PulseRepetitionInterval.pulse_repetition_interval_s)
}
inline ::anduril::entitymanager::v1::Measurement* PulseRepetitionInterval::release_pulse_repetition_interval_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Measurement* released = _impl_.pulse_repetition_interval_s_;
  _impl_.pulse_repetition_interval_s_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Measurement* PulseRepetitionInterval::unsafe_arena_release_pulse_repetition_interval_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.PulseRepetitionInterval.pulse_repetition_interval_s)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Measurement* temp = _impl_.pulse_repetition_interval_s_;
  _impl_.pulse_repetition_interval_s_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Measurement* PulseRepetitionInterval::_internal_mutable_pulse_repetition_interval_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pulse_repetition_interval_s_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Measurement>(GetArena());
    _impl_.pulse_repetition_interval_s_ = reinterpret_cast<::anduril::entitymanager::v1::Measurement*>(p);
  }
  return _impl_.pulse_repetition_interval_s_;
}
inline ::anduril::entitymanager::v1::Measurement* PulseRepetitionInterval::mutable_pulse_repetition_interval_s() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Measurement* _msg = _internal_mutable_pulse_repetition_interval_s();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.PulseRepetitionInterval.pulse_repetition_interval_s)
  return _msg;
}
inline void PulseRepetitionInterval::set_allocated_pulse_repetition_interval_s(::anduril::entitymanager::v1::Measurement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pulse_repetition_interval_s_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pulse_repetition_interval_s_ = reinterpret_cast<::anduril::entitymanager::v1::Measurement*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.PulseRepetitionInterval.pulse_repetition_interval_s)
}

// -------------------------------------------------------------------

// ScanCharacteristics

// .anduril.entitymanager.v1.ScanType scan_type = 1 [json_name = "scanType"];
inline void ScanCharacteristics::clear_scan_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_type_ = 0;
}
inline ::anduril::entitymanager::v1::ScanType ScanCharacteristics::scan_type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.ScanCharacteristics.scan_type)
  return _internal_scan_type();
}
inline void ScanCharacteristics::set_scan_type(::anduril::entitymanager::v1::ScanType value) {
  _internal_set_scan_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.ScanCharacteristics.scan_type)
}
inline ::anduril::entitymanager::v1::ScanType ScanCharacteristics::_internal_scan_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::ScanType>(_impl_.scan_type_);
}
inline void ScanCharacteristics::_internal_set_scan_type(::anduril::entitymanager::v1::ScanType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scan_type_ = value;
}

// .google.protobuf.DoubleValue scan_period_s = 2 [json_name = "scanPeriodS"];
inline bool ScanCharacteristics::has_scan_period_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scan_period_s_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& ScanCharacteristics::_internal_scan_period_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.scan_period_s_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& ScanCharacteristics::scan_period_s() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.ScanCharacteristics.scan_period_s)
  return _internal_scan_period_s();
}
inline void ScanCharacteristics::unsafe_arena_set_allocated_scan_period_s(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scan_period_s_);
  }
  _impl_.scan_period_s_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.ScanCharacteristics.scan_period_s)
}
inline ::google::protobuf::DoubleValue* ScanCharacteristics::release_scan_period_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.scan_period_s_;
  _impl_.scan_period_s_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::DoubleValue* ScanCharacteristics::unsafe_arena_release_scan_period_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.ScanCharacteristics.scan_period_s)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.scan_period_s_;
  _impl_.scan_period_s_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* ScanCharacteristics::_internal_mutable_scan_period_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scan_period_s_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.scan_period_s_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.scan_period_s_;
}
inline ::google::protobuf::DoubleValue* ScanCharacteristics::mutable_scan_period_s() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_scan_period_s();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.ScanCharacteristics.scan_period_s)
  return _msg;
}
inline void ScanCharacteristics::set_allocated_scan_period_s(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scan_period_s_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.scan_period_s_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.ScanCharacteristics.scan_period_s)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::anduril::entitymanager::v1::ScanType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::ScanType>() {
  return ::anduril::entitymanager::v1::ScanType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // anduril_2fentitymanager_2fv1_2fsignal_2epub_2eproto_2epb_2eh
