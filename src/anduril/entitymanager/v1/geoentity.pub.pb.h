// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/entitymanager/v1/geoentity.pub.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "anduril/entitymanager/v1/location.pub.pb.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
namespace anduril {
namespace entitymanager {
namespace v1 {
class GeoDetails;
struct GeoDetailsDefaultTypeInternal;
extern GeoDetailsDefaultTypeInternal _GeoDetails_default_instance_;
class GeoEllipse;
struct GeoEllipseDefaultTypeInternal;
extern GeoEllipseDefaultTypeInternal _GeoEllipse_default_instance_;
class GeoEllipsoid;
struct GeoEllipsoidDefaultTypeInternal;
extern GeoEllipsoidDefaultTypeInternal _GeoEllipsoid_default_instance_;
class GeoLine;
struct GeoLineDefaultTypeInternal;
extern GeoLineDefaultTypeInternal _GeoLine_default_instance_;
class GeoPoint;
struct GeoPointDefaultTypeInternal;
extern GeoPointDefaultTypeInternal _GeoPoint_default_instance_;
class GeoPolygon;
struct GeoPolygonDefaultTypeInternal;
extern GeoPolygonDefaultTypeInternal _GeoPolygon_default_instance_;
class GeoPolygonPosition;
struct GeoPolygonPositionDefaultTypeInternal;
extern GeoPolygonPositionDefaultTypeInternal _GeoPolygonPosition_default_instance_;
class GeoShape;
struct GeoShapeDefaultTypeInternal;
extern GeoShapeDefaultTypeInternal _GeoShape_default_instance_;
class LinearRing;
struct LinearRingDefaultTypeInternal;
extern LinearRingDefaultTypeInternal _LinearRing_default_instance_;
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace entitymanager {
namespace v1 {
enum GeoType : int {
  GEO_TYPE_INVALID = 0,
  GEO_TYPE_GENERAL = 1,
  GEO_TYPE_HAZARD = 2,
  GEO_TYPE_EMERGENCY = 3,
  GEO_TYPE_ENGAGEMENT_ZONE = 5,
  GEO_TYPE_CONTROL_AREA = 6,
  GEO_TYPE_BULLSEYE = 7,
  GeoType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GeoType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GeoType_IsValid(int value);
extern const uint32_t GeoType_internal_data_[];
constexpr GeoType GeoType_MIN = static_cast<GeoType>(0);
constexpr GeoType GeoType_MAX = static_cast<GeoType>(7);
constexpr int GeoType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
GeoType_descriptor();
template <typename T>
const std::string& GeoType_Name(T value) {
  static_assert(std::is_same<T, GeoType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GeoType_Name().");
  return GeoType_Name(static_cast<GeoType>(value));
}
template <>
inline const std::string& GeoType_Name(GeoType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GeoType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool GeoType_Parse(absl::string_view name, GeoType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeoType>(
      GeoType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class GeoDetails final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoDetails) */ {
 public:
  inline GeoDetails() : GeoDetails(nullptr) {}
  ~GeoDetails() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoDetails(const GeoDetails& from) : GeoDetails(nullptr, from) {}
  inline GeoDetails(GeoDetails&& from) noexcept
      : GeoDetails(nullptr, std::move(from)) {}
  inline GeoDetails& operator=(const GeoDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoDetails& operator=(GeoDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoDetails* internal_default_instance() {
    return reinterpret_cast<const GeoDetails*>(
        &_GeoDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(GeoDetails& a, GeoDetails& b) { a.Swap(&b); }
  inline void Swap(GeoDetails* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoDetails* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoDetails& from) { GeoDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoDetails* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoDetails"; }

 protected:
  explicit GeoDetails(::google::protobuf::Arena* arena);
  GeoDetails(::google::protobuf::Arena* arena, const GeoDetails& from);
  GeoDetails(::google::protobuf::Arena* arena, GeoDetails&& from) noexcept
      : GeoDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
  };
  // .anduril.entitymanager.v1.GeoType type = 1 [json_name = "type"];
  void clear_type() ;
  ::anduril::entitymanager::v1::GeoType type() const;
  void set_type(::anduril::entitymanager::v1::GeoType value);

  private:
  ::anduril::entitymanager::v1::GeoType _internal_type() const;
  void _internal_set_type(::anduril::entitymanager::v1::GeoType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoDetails_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoDetails& from_msg);
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoEllipsoid final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoEllipsoid) */ {
 public:
  inline GeoEllipsoid() : GeoEllipsoid(nullptr) {}
  ~GeoEllipsoid() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoEllipsoid(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoEllipsoid(const GeoEllipsoid& from) : GeoEllipsoid(nullptr, from) {}
  inline GeoEllipsoid(GeoEllipsoid&& from) noexcept
      : GeoEllipsoid(nullptr, std::move(from)) {}
  inline GeoEllipsoid& operator=(const GeoEllipsoid& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoEllipsoid& operator=(GeoEllipsoid&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoEllipsoid& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoEllipsoid* internal_default_instance() {
    return reinterpret_cast<const GeoEllipsoid*>(
        &_GeoEllipsoid_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(GeoEllipsoid& a, GeoEllipsoid& b) { a.Swap(&b); }
  inline void Swap(GeoEllipsoid* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoEllipsoid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoEllipsoid* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoEllipsoid>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoEllipsoid& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoEllipsoid& from) { GeoEllipsoid::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoEllipsoid* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoEllipsoid"; }

 protected:
  explicit GeoEllipsoid(::google::protobuf::Arena* arena);
  GeoEllipsoid(::google::protobuf::Arena* arena, const GeoEllipsoid& from);
  GeoEllipsoid(::google::protobuf::Arena* arena, GeoEllipsoid&& from) noexcept
      : GeoEllipsoid(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kForwardAxisMFieldNumber = 1,
    kSideAxisMFieldNumber = 2,
    kUpAxisMFieldNumber = 3,
  };
  // .google.protobuf.DoubleValue forward_axis_m = 1 [json_name = "forwardAxisM"];
  bool has_forward_axis_m() const;
  void clear_forward_axis_m() ;
  const ::google::protobuf::DoubleValue& forward_axis_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_forward_axis_m();
  ::google::protobuf::DoubleValue* mutable_forward_axis_m();
  void set_allocated_forward_axis_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_forward_axis_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_forward_axis_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_forward_axis_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_forward_axis_m();

  public:
  // .google.protobuf.DoubleValue side_axis_m = 2 [json_name = "sideAxisM"];
  bool has_side_axis_m() const;
  void clear_side_axis_m() ;
  const ::google::protobuf::DoubleValue& side_axis_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_side_axis_m();
  ::google::protobuf::DoubleValue* mutable_side_axis_m();
  void set_allocated_side_axis_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_side_axis_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_side_axis_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_side_axis_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_side_axis_m();

  public:
  // .google.protobuf.DoubleValue up_axis_m = 3 [json_name = "upAxisM"];
  bool has_up_axis_m() const;
  void clear_up_axis_m() ;
  const ::google::protobuf::DoubleValue& up_axis_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_up_axis_m();
  ::google::protobuf::DoubleValue* mutable_up_axis_m();
  void set_allocated_up_axis_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_up_axis_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_up_axis_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_up_axis_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_up_axis_m();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoEllipsoid)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoEllipsoid_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoEllipsoid& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::DoubleValue* forward_axis_m_;
    ::google::protobuf::DoubleValue* side_axis_m_;
    ::google::protobuf::DoubleValue* up_axis_m_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoEllipse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoEllipse) */ {
 public:
  inline GeoEllipse() : GeoEllipse(nullptr) {}
  ~GeoEllipse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoEllipse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoEllipse(const GeoEllipse& from) : GeoEllipse(nullptr, from) {}
  inline GeoEllipse(GeoEllipse&& from) noexcept
      : GeoEllipse(nullptr, std::move(from)) {}
  inline GeoEllipse& operator=(const GeoEllipse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoEllipse& operator=(GeoEllipse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoEllipse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoEllipse* internal_default_instance() {
    return reinterpret_cast<const GeoEllipse*>(
        &_GeoEllipse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(GeoEllipse& a, GeoEllipse& b) { a.Swap(&b); }
  inline void Swap(GeoEllipse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoEllipse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoEllipse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoEllipse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoEllipse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoEllipse& from) { GeoEllipse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoEllipse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoEllipse"; }

 protected:
  explicit GeoEllipse(::google::protobuf::Arena* arena);
  GeoEllipse(::google::protobuf::Arena* arena, const GeoEllipse& from);
  GeoEllipse(::google::protobuf::Arena* arena, GeoEllipse&& from) noexcept
      : GeoEllipse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSemiMajorAxisMFieldNumber = 2,
    kSemiMinorAxisMFieldNumber = 3,
    kOrientationDFieldNumber = 4,
    kHeightMFieldNumber = 5,
  };
  // .google.protobuf.DoubleValue semi_major_axis_m = 2 [json_name = "semiMajorAxisM"];
  bool has_semi_major_axis_m() const;
  void clear_semi_major_axis_m() ;
  const ::google::protobuf::DoubleValue& semi_major_axis_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_semi_major_axis_m();
  ::google::protobuf::DoubleValue* mutable_semi_major_axis_m();
  void set_allocated_semi_major_axis_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_semi_major_axis_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_semi_major_axis_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_semi_major_axis_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_semi_major_axis_m();

  public:
  // .google.protobuf.DoubleValue semi_minor_axis_m = 3 [json_name = "semiMinorAxisM"];
  bool has_semi_minor_axis_m() const;
  void clear_semi_minor_axis_m() ;
  const ::google::protobuf::DoubleValue& semi_minor_axis_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_semi_minor_axis_m();
  ::google::protobuf::DoubleValue* mutable_semi_minor_axis_m();
  void set_allocated_semi_minor_axis_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_semi_minor_axis_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_semi_minor_axis_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_semi_minor_axis_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_semi_minor_axis_m();

  public:
  // .google.protobuf.DoubleValue orientation_d = 4 [json_name = "orientationD"];
  bool has_orientation_d() const;
  void clear_orientation_d() ;
  const ::google::protobuf::DoubleValue& orientation_d() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_orientation_d();
  ::google::protobuf::DoubleValue* mutable_orientation_d();
  void set_allocated_orientation_d(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_orientation_d(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_orientation_d();

  private:
  const ::google::protobuf::DoubleValue& _internal_orientation_d() const;
  ::google::protobuf::DoubleValue* _internal_mutable_orientation_d();

  public:
  // .google.protobuf.DoubleValue height_m = 5 [json_name = "heightM"];
  bool has_height_m() const;
  void clear_height_m() ;
  const ::google::protobuf::DoubleValue& height_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_height_m();
  ::google::protobuf::DoubleValue* mutable_height_m();
  void set_allocated_height_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_height_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_height_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_height_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_height_m();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoEllipse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoEllipse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoEllipse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::DoubleValue* semi_major_axis_m_;
    ::google::protobuf::DoubleValue* semi_minor_axis_m_;
    ::google::protobuf::DoubleValue* orientation_d_;
    ::google::protobuf::DoubleValue* height_m_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoPolygonPosition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoPolygonPosition) */ {
 public:
  inline GeoPolygonPosition() : GeoPolygonPosition(nullptr) {}
  ~GeoPolygonPosition() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoPolygonPosition(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoPolygonPosition(const GeoPolygonPosition& from) : GeoPolygonPosition(nullptr, from) {}
  inline GeoPolygonPosition(GeoPolygonPosition&& from) noexcept
      : GeoPolygonPosition(nullptr, std::move(from)) {}
  inline GeoPolygonPosition& operator=(const GeoPolygonPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPolygonPosition& operator=(GeoPolygonPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoPolygonPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoPolygonPosition* internal_default_instance() {
    return reinterpret_cast<const GeoPolygonPosition*>(
        &_GeoPolygonPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GeoPolygonPosition& a, GeoPolygonPosition& b) { a.Swap(&b); }
  inline void Swap(GeoPolygonPosition* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPolygonPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoPolygonPosition* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoPolygonPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoPolygonPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoPolygonPosition& from) { GeoPolygonPosition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoPolygonPosition* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoPolygonPosition"; }

 protected:
  explicit GeoPolygonPosition(::google::protobuf::Arena* arena);
  GeoPolygonPosition(::google::protobuf::Arena* arena, const GeoPolygonPosition& from);
  GeoPolygonPosition(::google::protobuf::Arena* arena, GeoPolygonPosition&& from) noexcept
      : GeoPolygonPosition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kHeightMFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.Position position = 1 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::anduril::entitymanager::v1::Position& position() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Position* release_position();
  ::anduril::entitymanager::v1::Position* mutable_position();
  void set_allocated_position(::anduril::entitymanager::v1::Position* value);
  void unsafe_arena_set_allocated_position(::anduril::entitymanager::v1::Position* value);
  ::anduril::entitymanager::v1::Position* unsafe_arena_release_position();

  private:
  const ::anduril::entitymanager::v1::Position& _internal_position() const;
  ::anduril::entitymanager::v1::Position* _internal_mutable_position();

  public:
  // .google.protobuf.FloatValue height_m = 2 [json_name = "heightM"];
  bool has_height_m() const;
  void clear_height_m() ;
  const ::google::protobuf::FloatValue& height_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::FloatValue* release_height_m();
  ::google::protobuf::FloatValue* mutable_height_m();
  void set_allocated_height_m(::google::protobuf::FloatValue* value);
  void unsafe_arena_set_allocated_height_m(::google::protobuf::FloatValue* value);
  ::google::protobuf::FloatValue* unsafe_arena_release_height_m();

  private:
  const ::google::protobuf::FloatValue& _internal_height_m() const;
  ::google::protobuf::FloatValue* _internal_mutable_height_m();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoPolygonPosition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoPolygonPosition_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoPolygonPosition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Position* position_;
    ::google::protobuf::FloatValue* height_m_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoPoint) */ {
 public:
  inline GeoPoint() : GeoPoint(nullptr) {}
  ~GeoPoint() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoPoint(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoPoint(const GeoPoint& from) : GeoPoint(nullptr, from) {}
  inline GeoPoint(GeoPoint&& from) noexcept
      : GeoPoint(nullptr, std::move(from)) {}
  inline GeoPoint& operator=(const GeoPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPoint& operator=(GeoPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoPoint* internal_default_instance() {
    return reinterpret_cast<const GeoPoint*>(
        &_GeoPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(GeoPoint& a, GeoPoint& b) { a.Swap(&b); }
  inline void Swap(GeoPoint* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoPoint* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoPoint& from) { GeoPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoPoint* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoPoint"; }

 protected:
  explicit GeoPoint(::google::protobuf::Arena* arena);
  GeoPoint(::google::protobuf::Arena* arena, const GeoPoint& from);
  GeoPoint(::google::protobuf::Arena* arena, GeoPoint&& from) noexcept
      : GeoPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
  };
  // .anduril.entitymanager.v1.Position position = 1 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::anduril::entitymanager::v1::Position& position() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Position* release_position();
  ::anduril::entitymanager::v1::Position* mutable_position();
  void set_allocated_position(::anduril::entitymanager::v1::Position* value);
  void unsafe_arena_set_allocated_position(::anduril::entitymanager::v1::Position* value);
  ::anduril::entitymanager::v1::Position* unsafe_arena_release_position();

  private:
  const ::anduril::entitymanager::v1::Position& _internal_position() const;
  ::anduril::entitymanager::v1::Position* _internal_mutable_position();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoPoint_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Position* position_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoLine final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoLine) */ {
 public:
  inline GeoLine() : GeoLine(nullptr) {}
  ~GeoLine() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoLine(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoLine(const GeoLine& from) : GeoLine(nullptr, from) {}
  inline GeoLine(GeoLine&& from) noexcept
      : GeoLine(nullptr, std::move(from)) {}
  inline GeoLine& operator=(const GeoLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoLine& operator=(GeoLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoLine* internal_default_instance() {
    return reinterpret_cast<const GeoLine*>(
        &_GeoLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(GeoLine& a, GeoLine& b) { a.Swap(&b); }
  inline void Swap(GeoLine* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoLine* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoLine* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoLine>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoLine& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoLine& from) { GeoLine::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoLine* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoLine"; }

 protected:
  explicit GeoLine(::google::protobuf::Arena* arena);
  GeoLine(::google::protobuf::Arena* arena, const GeoLine& from);
  GeoLine(::google::protobuf::Arena* arena, GeoLine&& from) noexcept
      : GeoLine(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionsFieldNumber = 1,
  };
  // repeated .anduril.entitymanager.v1.Position positions = 1 [json_name = "positions"];
  int positions_size() const;
  private:
  int _internal_positions_size() const;

  public:
  void clear_positions() ;
  ::anduril::entitymanager::v1::Position* mutable_positions(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* mutable_positions();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& _internal_positions() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* _internal_mutable_positions();
  public:
  const ::anduril::entitymanager::v1::Position& positions(int index) const;
  ::anduril::entitymanager::v1::Position* add_positions();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& positions() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoLine)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoLine_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoLine& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Position > positions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class LinearRing final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.LinearRing) */ {
 public:
  inline LinearRing() : LinearRing(nullptr) {}
  ~LinearRing() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LinearRing(
      ::google::protobuf::internal::ConstantInitialized);

  inline LinearRing(const LinearRing& from) : LinearRing(nullptr, from) {}
  inline LinearRing(LinearRing&& from) noexcept
      : LinearRing(nullptr, std::move(from)) {}
  inline LinearRing& operator=(const LinearRing& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearRing& operator=(LinearRing&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearRing& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearRing* internal_default_instance() {
    return reinterpret_cast<const LinearRing*>(
        &_LinearRing_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(LinearRing& a, LinearRing& b) { a.Swap(&b); }
  inline void Swap(LinearRing* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearRing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearRing* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<LinearRing>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LinearRing& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LinearRing& from) { LinearRing::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LinearRing* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.LinearRing"; }

 protected:
  explicit LinearRing(::google::protobuf::Arena* arena);
  LinearRing(::google::protobuf::Arena* arena, const LinearRing& from);
  LinearRing(::google::protobuf::Arena* arena, LinearRing&& from) noexcept
      : LinearRing(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 1,
    kPositionsFieldNumber = 2,
  };
  // repeated .anduril.entitymanager.v1.Position points = 1 [json_name = "points", deprecated = true];
  [[deprecated]]  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  [[deprecated]]  void clear_points() ;
  [[deprecated]] ::anduril::entitymanager::v1::Position* mutable_points(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* mutable_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* _internal_mutable_points();
  public:
  [[deprecated]] const ::anduril::entitymanager::v1::Position& points(int index) const;
  [[deprecated]] ::anduril::entitymanager::v1::Position* add_points();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& points() const;
  // repeated .anduril.entitymanager.v1.GeoPolygonPosition positions = 2 [json_name = "positions"];
  int positions_size() const;
  private:
  int _internal_positions_size() const;

  public:
  void clear_positions() ;
  ::anduril::entitymanager::v1::GeoPolygonPosition* mutable_positions(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>* mutable_positions();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>& _internal_positions() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>* _internal_mutable_positions();
  public:
  const ::anduril::entitymanager::v1::GeoPolygonPosition& positions(int index) const;
  ::anduril::entitymanager::v1::GeoPolygonPosition* add_positions();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>& positions() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.LinearRing)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LinearRing_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LinearRing& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Position > points_;
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::GeoPolygonPosition > positions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoPolygon final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoPolygon) */ {
 public:
  inline GeoPolygon() : GeoPolygon(nullptr) {}
  ~GeoPolygon() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoPolygon(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoPolygon(const GeoPolygon& from) : GeoPolygon(nullptr, from) {}
  inline GeoPolygon(GeoPolygon&& from) noexcept
      : GeoPolygon(nullptr, std::move(from)) {}
  inline GeoPolygon& operator=(const GeoPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPolygon& operator=(GeoPolygon&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoPolygon& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoPolygon* internal_default_instance() {
    return reinterpret_cast<const GeoPolygon*>(
        &_GeoPolygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(GeoPolygon& a, GeoPolygon& b) { a.Swap(&b); }
  inline void Swap(GeoPolygon* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPolygon* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoPolygon* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoPolygon>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoPolygon& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoPolygon& from) { GeoPolygon::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoPolygon* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoPolygon"; }

 protected:
  explicit GeoPolygon(::google::protobuf::Arena* arena);
  GeoPolygon(::google::protobuf::Arena* arena, const GeoPolygon& from);
  GeoPolygon(::google::protobuf::Arena* arena, GeoPolygon&& from) noexcept
      : GeoPolygon(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRingsFieldNumber = 1,
    kIsRectangleFieldNumber = 2,
  };
  // repeated .anduril.entitymanager.v1.LinearRing rings = 1 [json_name = "rings"];
  int rings_size() const;
  private:
  int _internal_rings_size() const;

  public:
  void clear_rings() ;
  ::anduril::entitymanager::v1::LinearRing* mutable_rings(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>* mutable_rings();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>& _internal_rings() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>* _internal_mutable_rings();
  public:
  const ::anduril::entitymanager::v1::LinearRing& rings(int index) const;
  ::anduril::entitymanager::v1::LinearRing* add_rings();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>& rings() const;
  // bool is_rectangle = 2 [json_name = "isRectangle"];
  void clear_is_rectangle() ;
  bool is_rectangle() const;
  void set_is_rectangle(bool value);

  private:
  bool _internal_is_rectangle() const;
  void _internal_set_is_rectangle(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoPolygon)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoPolygon_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoPolygon& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::LinearRing > rings_;
    bool is_rectangle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoShape final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoShape) */ {
 public:
  inline GeoShape() : GeoShape(nullptr) {}
  ~GeoShape() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoShape(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoShape(const GeoShape& from) : GeoShape(nullptr, from) {}
  inline GeoShape(GeoShape&& from) noexcept
      : GeoShape(nullptr, std::move(from)) {}
  inline GeoShape& operator=(const GeoShape& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoShape& operator=(GeoShape&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoShape& default_instance() {
    return *internal_default_instance();
  }
  enum ShapeCase {
    kPoint = 1,
    kLine = 2,
    kPolygon = 3,
    kEllipse = 4,
    kEllipsoid = 5,
    SHAPE_NOT_SET = 0,
  };
  static inline const GeoShape* internal_default_instance() {
    return reinterpret_cast<const GeoShape*>(
        &_GeoShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(GeoShape& a, GeoShape& b) { a.Swap(&b); }
  inline void Swap(GeoShape* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoShape* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoShape* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoShape>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoShape& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoShape& from) { GeoShape::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoShape* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoShape"; }

 protected:
  explicit GeoShape(::google::protobuf::Arena* arena);
  GeoShape(::google::protobuf::Arena* arena, const GeoShape& from);
  GeoShape(::google::protobuf::Arena* arena, GeoShape&& from) noexcept
      : GeoShape(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointFieldNumber = 1,
    kLineFieldNumber = 2,
    kPolygonFieldNumber = 3,
    kEllipseFieldNumber = 4,
    kEllipsoidFieldNumber = 5,
  };
  // .anduril.entitymanager.v1.GeoPoint point = 1 [json_name = "point"];
  bool has_point() const;
  private:
  bool _internal_has_point() const;

  public:
  void clear_point() ;
  const ::anduril::entitymanager::v1::GeoPoint& point() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoPoint* release_point();
  ::anduril::entitymanager::v1::GeoPoint* mutable_point();
  void set_allocated_point(::anduril::entitymanager::v1::GeoPoint* value);
  void unsafe_arena_set_allocated_point(::anduril::entitymanager::v1::GeoPoint* value);
  ::anduril::entitymanager::v1::GeoPoint* unsafe_arena_release_point();

  private:
  const ::anduril::entitymanager::v1::GeoPoint& _internal_point() const;
  ::anduril::entitymanager::v1::GeoPoint* _internal_mutable_point();

  public:
  // .anduril.entitymanager.v1.GeoLine line = 2 [json_name = "line"];
  bool has_line() const;
  private:
  bool _internal_has_line() const;

  public:
  void clear_line() ;
  const ::anduril::entitymanager::v1::GeoLine& line() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoLine* release_line();
  ::anduril::entitymanager::v1::GeoLine* mutable_line();
  void set_allocated_line(::anduril::entitymanager::v1::GeoLine* value);
  void unsafe_arena_set_allocated_line(::anduril::entitymanager::v1::GeoLine* value);
  ::anduril::entitymanager::v1::GeoLine* unsafe_arena_release_line();

  private:
  const ::anduril::entitymanager::v1::GeoLine& _internal_line() const;
  ::anduril::entitymanager::v1::GeoLine* _internal_mutable_line();

  public:
  // .anduril.entitymanager.v1.GeoPolygon polygon = 3 [json_name = "polygon"];
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;

  public:
  void clear_polygon() ;
  const ::anduril::entitymanager::v1::GeoPolygon& polygon() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoPolygon* release_polygon();
  ::anduril::entitymanager::v1::GeoPolygon* mutable_polygon();
  void set_allocated_polygon(::anduril::entitymanager::v1::GeoPolygon* value);
  void unsafe_arena_set_allocated_polygon(::anduril::entitymanager::v1::GeoPolygon* value);
  ::anduril::entitymanager::v1::GeoPolygon* unsafe_arena_release_polygon();

  private:
  const ::anduril::entitymanager::v1::GeoPolygon& _internal_polygon() const;
  ::anduril::entitymanager::v1::GeoPolygon* _internal_mutable_polygon();

  public:
  // .anduril.entitymanager.v1.GeoEllipse ellipse = 4 [json_name = "ellipse"];
  bool has_ellipse() const;
  private:
  bool _internal_has_ellipse() const;

  public:
  void clear_ellipse() ;
  const ::anduril::entitymanager::v1::GeoEllipse& ellipse() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoEllipse* release_ellipse();
  ::anduril::entitymanager::v1::GeoEllipse* mutable_ellipse();
  void set_allocated_ellipse(::anduril::entitymanager::v1::GeoEllipse* value);
  void unsafe_arena_set_allocated_ellipse(::anduril::entitymanager::v1::GeoEllipse* value);
  ::anduril::entitymanager::v1::GeoEllipse* unsafe_arena_release_ellipse();

  private:
  const ::anduril::entitymanager::v1::GeoEllipse& _internal_ellipse() const;
  ::anduril::entitymanager::v1::GeoEllipse* _internal_mutable_ellipse();

  public:
  // .anduril.entitymanager.v1.GeoEllipsoid ellipsoid = 5 [json_name = "ellipsoid"];
  bool has_ellipsoid() const;
  private:
  bool _internal_has_ellipsoid() const;

  public:
  void clear_ellipsoid() ;
  const ::anduril::entitymanager::v1::GeoEllipsoid& ellipsoid() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoEllipsoid* release_ellipsoid();
  ::anduril::entitymanager::v1::GeoEllipsoid* mutable_ellipsoid();
  void set_allocated_ellipsoid(::anduril::entitymanager::v1::GeoEllipsoid* value);
  void unsafe_arena_set_allocated_ellipsoid(::anduril::entitymanager::v1::GeoEllipsoid* value);
  ::anduril::entitymanager::v1::GeoEllipsoid* unsafe_arena_release_ellipsoid();

  private:
  const ::anduril::entitymanager::v1::GeoEllipsoid& _internal_ellipsoid() const;
  ::anduril::entitymanager::v1::GeoEllipsoid* _internal_mutable_ellipsoid();

  public:
  void clear_shape();
  ShapeCase shape_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoShape)
 private:
  class _Internal;
  void set_has_point();
  void set_has_line();
  void set_has_polygon();
  void set_has_ellipse();
  void set_has_ellipsoid();
  inline bool has_shape() const;
  inline void clear_has_shape();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoShape_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoShape& from_msg);
    union ShapeUnion {
      constexpr ShapeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::GeoPoint* point_;
      ::anduril::entitymanager::v1::GeoLine* line_;
      ::anduril::entitymanager::v1::GeoPolygon* polygon_;
      ::anduril::entitymanager::v1::GeoEllipse* ellipse_;
      ::anduril::entitymanager::v1::GeoEllipsoid* ellipsoid_;
    } shape_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GeoDetails

// .anduril.entitymanager.v1.GeoType type = 1 [json_name = "type"];
inline void GeoDetails::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::anduril::entitymanager::v1::GeoType GeoDetails::type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoDetails.type)
  return _internal_type();
}
inline void GeoDetails::set_type(::anduril::entitymanager::v1::GeoType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.GeoDetails.type)
}
inline ::anduril::entitymanager::v1::GeoType GeoDetails::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::GeoType>(_impl_.type_);
}
inline void GeoDetails::_internal_set_type(::anduril::entitymanager::v1::GeoType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// GeoShape

// .anduril.entitymanager.v1.GeoPoint point = 1 [json_name = "point"];
inline bool GeoShape::has_point() const {
  return shape_case() == kPoint;
}
inline bool GeoShape::_internal_has_point() const {
  return shape_case() == kPoint;
}
inline void GeoShape::set_has_point() {
  _impl_._oneof_case_[0] = kPoint;
}
inline void GeoShape::clear_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (shape_case() == kPoint) {
    if (GetArena() == nullptr) {
      delete _impl_.shape_.point_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.shape_.point_);
    }
    clear_has_shape();
  }
}
inline ::anduril::entitymanager::v1::GeoPoint* GeoShape::release_point() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoShape.point)
  if (shape_case() == kPoint) {
    clear_has_shape();
    auto* temp = _impl_.shape_.point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoPoint& GeoShape::_internal_point() const {
  return shape_case() == kPoint ? *_impl_.shape_.point_ : reinterpret_cast<::anduril::entitymanager::v1::GeoPoint&>(::anduril::entitymanager::v1::_GeoPoint_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoPoint& GeoShape::point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoShape.point)
  return _internal_point();
}
inline ::anduril::entitymanager::v1::GeoPoint* GeoShape::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoShape.point)
  if (shape_case() == kPoint) {
    clear_has_shape();
    auto* temp = _impl_.shape_.point_;
    _impl_.shape_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoShape::unsafe_arena_set_allocated_point(::anduril::entitymanager::v1::GeoPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_shape();
  if (value) {
    set_has_point();
    _impl_.shape_.point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoShape.point)
}
inline ::anduril::entitymanager::v1::GeoPoint* GeoShape::_internal_mutable_point() {
  if (shape_case() != kPoint) {
    clear_shape();
    set_has_point();
    _impl_.shape_.point_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoPoint>(GetArena());
  }
  return _impl_.shape_.point_;
}
inline ::anduril::entitymanager::v1::GeoPoint* GeoShape::mutable_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoPoint* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoShape.point)
  return _msg;
}

// .anduril.entitymanager.v1.GeoLine line = 2 [json_name = "line"];
inline bool GeoShape::has_line() const {
  return shape_case() == kLine;
}
inline bool GeoShape::_internal_has_line() const {
  return shape_case() == kLine;
}
inline void GeoShape::set_has_line() {
  _impl_._oneof_case_[0] = kLine;
}
inline void GeoShape::clear_line() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (shape_case() == kLine) {
    if (GetArena() == nullptr) {
      delete _impl_.shape_.line_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.shape_.line_);
    }
    clear_has_shape();
  }
}
inline ::anduril::entitymanager::v1::GeoLine* GeoShape::release_line() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoShape.line)
  if (shape_case() == kLine) {
    clear_has_shape();
    auto* temp = _impl_.shape_.line_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoLine& GeoShape::_internal_line() const {
  return shape_case() == kLine ? *_impl_.shape_.line_ : reinterpret_cast<::anduril::entitymanager::v1::GeoLine&>(::anduril::entitymanager::v1::_GeoLine_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoLine& GeoShape::line() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoShape.line)
  return _internal_line();
}
inline ::anduril::entitymanager::v1::GeoLine* GeoShape::unsafe_arena_release_line() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoShape.line)
  if (shape_case() == kLine) {
    clear_has_shape();
    auto* temp = _impl_.shape_.line_;
    _impl_.shape_.line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoShape::unsafe_arena_set_allocated_line(::anduril::entitymanager::v1::GeoLine* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_shape();
  if (value) {
    set_has_line();
    _impl_.shape_.line_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoShape.line)
}
inline ::anduril::entitymanager::v1::GeoLine* GeoShape::_internal_mutable_line() {
  if (shape_case() != kLine) {
    clear_shape();
    set_has_line();
    _impl_.shape_.line_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoLine>(GetArena());
  }
  return _impl_.shape_.line_;
}
inline ::anduril::entitymanager::v1::GeoLine* GeoShape::mutable_line() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoLine* _msg = _internal_mutable_line();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoShape.line)
  return _msg;
}

// .anduril.entitymanager.v1.GeoPolygon polygon = 3 [json_name = "polygon"];
inline bool GeoShape::has_polygon() const {
  return shape_case() == kPolygon;
}
inline bool GeoShape::_internal_has_polygon() const {
  return shape_case() == kPolygon;
}
inline void GeoShape::set_has_polygon() {
  _impl_._oneof_case_[0] = kPolygon;
}
inline void GeoShape::clear_polygon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (shape_case() == kPolygon) {
    if (GetArena() == nullptr) {
      delete _impl_.shape_.polygon_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.shape_.polygon_);
    }
    clear_has_shape();
  }
}
inline ::anduril::entitymanager::v1::GeoPolygon* GeoShape::release_polygon() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoShape.polygon)
  if (shape_case() == kPolygon) {
    clear_has_shape();
    auto* temp = _impl_.shape_.polygon_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoPolygon& GeoShape::_internal_polygon() const {
  return shape_case() == kPolygon ? *_impl_.shape_.polygon_ : reinterpret_cast<::anduril::entitymanager::v1::GeoPolygon&>(::anduril::entitymanager::v1::_GeoPolygon_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoPolygon& GeoShape::polygon() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoShape.polygon)
  return _internal_polygon();
}
inline ::anduril::entitymanager::v1::GeoPolygon* GeoShape::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoShape.polygon)
  if (shape_case() == kPolygon) {
    clear_has_shape();
    auto* temp = _impl_.shape_.polygon_;
    _impl_.shape_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoShape::unsafe_arena_set_allocated_polygon(::anduril::entitymanager::v1::GeoPolygon* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_shape();
  if (value) {
    set_has_polygon();
    _impl_.shape_.polygon_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoShape.polygon)
}
inline ::anduril::entitymanager::v1::GeoPolygon* GeoShape::_internal_mutable_polygon() {
  if (shape_case() != kPolygon) {
    clear_shape();
    set_has_polygon();
    _impl_.shape_.polygon_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoPolygon>(GetArena());
  }
  return _impl_.shape_.polygon_;
}
inline ::anduril::entitymanager::v1::GeoPolygon* GeoShape::mutable_polygon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoPolygon* _msg = _internal_mutable_polygon();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoShape.polygon)
  return _msg;
}

// .anduril.entitymanager.v1.GeoEllipse ellipse = 4 [json_name = "ellipse"];
inline bool GeoShape::has_ellipse() const {
  return shape_case() == kEllipse;
}
inline bool GeoShape::_internal_has_ellipse() const {
  return shape_case() == kEllipse;
}
inline void GeoShape::set_has_ellipse() {
  _impl_._oneof_case_[0] = kEllipse;
}
inline void GeoShape::clear_ellipse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (shape_case() == kEllipse) {
    if (GetArena() == nullptr) {
      delete _impl_.shape_.ellipse_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.shape_.ellipse_);
    }
    clear_has_shape();
  }
}
inline ::anduril::entitymanager::v1::GeoEllipse* GeoShape::release_ellipse() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoShape.ellipse)
  if (shape_case() == kEllipse) {
    clear_has_shape();
    auto* temp = _impl_.shape_.ellipse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.ellipse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoEllipse& GeoShape::_internal_ellipse() const {
  return shape_case() == kEllipse ? *_impl_.shape_.ellipse_ : reinterpret_cast<::anduril::entitymanager::v1::GeoEllipse&>(::anduril::entitymanager::v1::_GeoEllipse_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoEllipse& GeoShape::ellipse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoShape.ellipse)
  return _internal_ellipse();
}
inline ::anduril::entitymanager::v1::GeoEllipse* GeoShape::unsafe_arena_release_ellipse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoShape.ellipse)
  if (shape_case() == kEllipse) {
    clear_has_shape();
    auto* temp = _impl_.shape_.ellipse_;
    _impl_.shape_.ellipse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoShape::unsafe_arena_set_allocated_ellipse(::anduril::entitymanager::v1::GeoEllipse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_shape();
  if (value) {
    set_has_ellipse();
    _impl_.shape_.ellipse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoShape.ellipse)
}
inline ::anduril::entitymanager::v1::GeoEllipse* GeoShape::_internal_mutable_ellipse() {
  if (shape_case() != kEllipse) {
    clear_shape();
    set_has_ellipse();
    _impl_.shape_.ellipse_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoEllipse>(GetArena());
  }
  return _impl_.shape_.ellipse_;
}
inline ::anduril::entitymanager::v1::GeoEllipse* GeoShape::mutable_ellipse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoEllipse* _msg = _internal_mutable_ellipse();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoShape.ellipse)
  return _msg;
}

// .anduril.entitymanager.v1.GeoEllipsoid ellipsoid = 5 [json_name = "ellipsoid"];
inline bool GeoShape::has_ellipsoid() const {
  return shape_case() == kEllipsoid;
}
inline bool GeoShape::_internal_has_ellipsoid() const {
  return shape_case() == kEllipsoid;
}
inline void GeoShape::set_has_ellipsoid() {
  _impl_._oneof_case_[0] = kEllipsoid;
}
inline void GeoShape::clear_ellipsoid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (shape_case() == kEllipsoid) {
    if (GetArena() == nullptr) {
      delete _impl_.shape_.ellipsoid_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.shape_.ellipsoid_);
    }
    clear_has_shape();
  }
}
inline ::anduril::entitymanager::v1::GeoEllipsoid* GeoShape::release_ellipsoid() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoShape.ellipsoid)
  if (shape_case() == kEllipsoid) {
    clear_has_shape();
    auto* temp = _impl_.shape_.ellipsoid_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.ellipsoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoEllipsoid& GeoShape::_internal_ellipsoid() const {
  return shape_case() == kEllipsoid ? *_impl_.shape_.ellipsoid_ : reinterpret_cast<::anduril::entitymanager::v1::GeoEllipsoid&>(::anduril::entitymanager::v1::_GeoEllipsoid_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoEllipsoid& GeoShape::ellipsoid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoShape.ellipsoid)
  return _internal_ellipsoid();
}
inline ::anduril::entitymanager::v1::GeoEllipsoid* GeoShape::unsafe_arena_release_ellipsoid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoShape.ellipsoid)
  if (shape_case() == kEllipsoid) {
    clear_has_shape();
    auto* temp = _impl_.shape_.ellipsoid_;
    _impl_.shape_.ellipsoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoShape::unsafe_arena_set_allocated_ellipsoid(::anduril::entitymanager::v1::GeoEllipsoid* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_shape();
  if (value) {
    set_has_ellipsoid();
    _impl_.shape_.ellipsoid_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoShape.ellipsoid)
}
inline ::anduril::entitymanager::v1::GeoEllipsoid* GeoShape::_internal_mutable_ellipsoid() {
  if (shape_case() != kEllipsoid) {
    clear_shape();
    set_has_ellipsoid();
    _impl_.shape_.ellipsoid_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoEllipsoid>(GetArena());
  }
  return _impl_.shape_.ellipsoid_;
}
inline ::anduril::entitymanager::v1::GeoEllipsoid* GeoShape::mutable_ellipsoid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoEllipsoid* _msg = _internal_mutable_ellipsoid();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoShape.ellipsoid)
  return _msg;
}

inline bool GeoShape::has_shape() const {
  return shape_case() != SHAPE_NOT_SET;
}
inline void GeoShape::clear_has_shape() {
  _impl_._oneof_case_[0] = SHAPE_NOT_SET;
}
inline GeoShape::ShapeCase GeoShape::shape_case() const {
  return GeoShape::ShapeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GeoPoint

// .anduril.entitymanager.v1.Position position = 1 [json_name = "position"];
inline bool GeoPoint::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Position& GeoPoint::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Position&>(::anduril::entitymanager::v1::_Position_default_instance_);
}
inline const ::anduril::entitymanager::v1::Position& GeoPoint::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoPoint.position)
  return _internal_position();
}
inline void GeoPoint::unsafe_arena_set_allocated_position(::anduril::entitymanager::v1::Position* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoPoint.position)
}
inline ::anduril::entitymanager::v1::Position* GeoPoint::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Position* GeoPoint::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoPoint.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Position* GeoPoint::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::anduril::entitymanager::v1::Position* GeoPoint::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoPoint.position)
  return _msg;
}
inline void GeoPoint::set_allocated_position(::anduril::entitymanager::v1::Position* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoPoint.position)
}

// -------------------------------------------------------------------

// GeoLine

// repeated .anduril.entitymanager.v1.Position positions = 1 [json_name = "positions"];
inline int GeoLine::_internal_positions_size() const {
  return _internal_positions().size();
}
inline int GeoLine::positions_size() const {
  return _internal_positions_size();
}
inline ::anduril::entitymanager::v1::Position* GeoLine::mutable_positions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoLine.positions)
  return _internal_mutable_positions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* GeoLine::mutable_positions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.GeoLine.positions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positions();
}
inline const ::anduril::entitymanager::v1::Position& GeoLine::positions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoLine.positions)
  return _internal_positions().Get(index);
}
inline ::anduril::entitymanager::v1::Position* GeoLine::add_positions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::Position* _add = _internal_mutable_positions()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.GeoLine.positions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& GeoLine::positions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.GeoLine.positions)
  return _internal_positions();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>&
GeoLine::_internal_positions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positions_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>*
GeoLine::_internal_mutable_positions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positions_;
}

// -------------------------------------------------------------------

// GeoPolygon

// repeated .anduril.entitymanager.v1.LinearRing rings = 1 [json_name = "rings"];
inline int GeoPolygon::_internal_rings_size() const {
  return _internal_rings().size();
}
inline int GeoPolygon::rings_size() const {
  return _internal_rings_size();
}
inline void GeoPolygon::clear_rings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rings_.Clear();
}
inline ::anduril::entitymanager::v1::LinearRing* GeoPolygon::mutable_rings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoPolygon.rings)
  return _internal_mutable_rings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>* GeoPolygon::mutable_rings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.GeoPolygon.rings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_rings();
}
inline const ::anduril::entitymanager::v1::LinearRing& GeoPolygon::rings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoPolygon.rings)
  return _internal_rings().Get(index);
}
inline ::anduril::entitymanager::v1::LinearRing* GeoPolygon::add_rings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::LinearRing* _add = _internal_mutable_rings()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.GeoPolygon.rings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>& GeoPolygon::rings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.GeoPolygon.rings)
  return _internal_rings();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>&
GeoPolygon::_internal_rings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rings_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>*
GeoPolygon::_internal_mutable_rings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.rings_;
}

// bool is_rectangle = 2 [json_name = "isRectangle"];
inline void GeoPolygon::clear_is_rectangle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_rectangle_ = false;
}
inline bool GeoPolygon::is_rectangle() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoPolygon.is_rectangle)
  return _internal_is_rectangle();
}
inline void GeoPolygon::set_is_rectangle(bool value) {
  _internal_set_is_rectangle(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.GeoPolygon.is_rectangle)
}
inline bool GeoPolygon::_internal_is_rectangle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_rectangle_;
}
inline void GeoPolygon::_internal_set_is_rectangle(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_rectangle_ = value;
}

// -------------------------------------------------------------------

// GeoEllipse

// .google.protobuf.DoubleValue semi_major_axis_m = 2 [json_name = "semiMajorAxisM"];
inline bool GeoEllipse::has_semi_major_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.semi_major_axis_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::_internal_semi_major_axis_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.semi_major_axis_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::semi_major_axis_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipse.semi_major_axis_m)
  return _internal_semi_major_axis_m();
}
inline void GeoEllipse::unsafe_arena_set_allocated_semi_major_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.semi_major_axis_m_);
  }
  _impl_.semi_major_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipse.semi_major_axis_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipse::release_semi_major_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.semi_major_axis_m_;
  _impl_.semi_major_axis_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::unsafe_arena_release_semi_major_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipse.semi_major_axis_m)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.semi_major_axis_m_;
  _impl_.semi_major_axis_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::_internal_mutable_semi_major_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.semi_major_axis_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.semi_major_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.semi_major_axis_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::mutable_semi_major_axis_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_semi_major_axis_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipse.semi_major_axis_m)
  return _msg;
}
inline void GeoEllipse::set_allocated_semi_major_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.semi_major_axis_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.semi_major_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipse.semi_major_axis_m)
}

// .google.protobuf.DoubleValue semi_minor_axis_m = 3 [json_name = "semiMinorAxisM"];
inline bool GeoEllipse::has_semi_minor_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.semi_minor_axis_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::_internal_semi_minor_axis_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.semi_minor_axis_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::semi_minor_axis_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipse.semi_minor_axis_m)
  return _internal_semi_minor_axis_m();
}
inline void GeoEllipse::unsafe_arena_set_allocated_semi_minor_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.semi_minor_axis_m_);
  }
  _impl_.semi_minor_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipse.semi_minor_axis_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipse::release_semi_minor_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* released = _impl_.semi_minor_axis_m_;
  _impl_.semi_minor_axis_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::unsafe_arena_release_semi_minor_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipse.semi_minor_axis_m)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* temp = _impl_.semi_minor_axis_m_;
  _impl_.semi_minor_axis_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::_internal_mutable_semi_minor_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.semi_minor_axis_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.semi_minor_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.semi_minor_axis_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::mutable_semi_minor_axis_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_semi_minor_axis_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipse.semi_minor_axis_m)
  return _msg;
}
inline void GeoEllipse::set_allocated_semi_minor_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.semi_minor_axis_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.semi_minor_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipse.semi_minor_axis_m)
}

// .google.protobuf.DoubleValue orientation_d = 4 [json_name = "orientationD"];
inline bool GeoEllipse::has_orientation_d() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_d_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::_internal_orientation_d() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.orientation_d_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::orientation_d() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipse.orientation_d)
  return _internal_orientation_d();
}
inline void GeoEllipse::unsafe_arena_set_allocated_orientation_d(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_d_);
  }
  _impl_.orientation_d_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipse.orientation_d)
}
inline ::google::protobuf::DoubleValue* GeoEllipse::release_orientation_d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::DoubleValue* released = _impl_.orientation_d_;
  _impl_.orientation_d_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::unsafe_arena_release_orientation_d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipse.orientation_d)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::DoubleValue* temp = _impl_.orientation_d_;
  _impl_.orientation_d_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::_internal_mutable_orientation_d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_d_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.orientation_d_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.orientation_d_;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::mutable_orientation_d() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_orientation_d();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipse.orientation_d)
  return _msg;
}
inline void GeoEllipse::set_allocated_orientation_d(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_d_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.orientation_d_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipse.orientation_d)
}

// .google.protobuf.DoubleValue height_m = 5 [json_name = "heightM"];
inline bool GeoEllipse::has_height_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.height_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::_internal_height_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.height_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::height_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipse.height_m)
  return _internal_height_m();
}
inline void GeoEllipse::unsafe_arena_set_allocated_height_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_m_);
  }
  _impl_.height_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipse.height_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipse::release_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::DoubleValue* released = _impl_.height_m_;
  _impl_.height_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::unsafe_arena_release_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipse.height_m)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::DoubleValue* temp = _impl_.height_m_;
  _impl_.height_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::_internal_mutable_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.height_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.height_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.height_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::mutable_height_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_height_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipse.height_m)
  return _msg;
}
inline void GeoEllipse::set_allocated_height_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.height_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipse.height_m)
}

// -------------------------------------------------------------------

// GeoEllipsoid

// .google.protobuf.DoubleValue forward_axis_m = 1 [json_name = "forwardAxisM"];
inline bool GeoEllipsoid::has_forward_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_axis_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::_internal_forward_axis_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.forward_axis_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::forward_axis_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipsoid.forward_axis_m)
  return _internal_forward_axis_m();
}
inline void GeoEllipsoid::unsafe_arena_set_allocated_forward_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_axis_m_);
  }
  _impl_.forward_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.forward_axis_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::release_forward_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.forward_axis_m_;
  _impl_.forward_axis_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::unsafe_arena_release_forward_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipsoid.forward_axis_m)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.forward_axis_m_;
  _impl_.forward_axis_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::_internal_mutable_forward_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.forward_axis_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.forward_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.forward_axis_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::mutable_forward_axis_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_forward_axis_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipsoid.forward_axis_m)
  return _msg;
}
inline void GeoEllipsoid::set_allocated_forward_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_axis_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.forward_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.forward_axis_m)
}

// .google.protobuf.DoubleValue side_axis_m = 2 [json_name = "sideAxisM"];
inline bool GeoEllipsoid::has_side_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.side_axis_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::_internal_side_axis_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.side_axis_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::side_axis_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipsoid.side_axis_m)
  return _internal_side_axis_m();
}
inline void GeoEllipsoid::unsafe_arena_set_allocated_side_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.side_axis_m_);
  }
  _impl_.side_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.side_axis_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::release_side_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* released = _impl_.side_axis_m_;
  _impl_.side_axis_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::unsafe_arena_release_side_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipsoid.side_axis_m)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* temp = _impl_.side_axis_m_;
  _impl_.side_axis_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::_internal_mutable_side_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.side_axis_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.side_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.side_axis_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::mutable_side_axis_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_side_axis_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipsoid.side_axis_m)
  return _msg;
}
inline void GeoEllipsoid::set_allocated_side_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.side_axis_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.side_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.side_axis_m)
}

// .google.protobuf.DoubleValue up_axis_m = 3 [json_name = "upAxisM"];
inline bool GeoEllipsoid::has_up_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.up_axis_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::_internal_up_axis_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.up_axis_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::up_axis_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipsoid.up_axis_m)
  return _internal_up_axis_m();
}
inline void GeoEllipsoid::unsafe_arena_set_allocated_up_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.up_axis_m_);
  }
  _impl_.up_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.up_axis_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::release_up_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::DoubleValue* released = _impl_.up_axis_m_;
  _impl_.up_axis_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::unsafe_arena_release_up_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipsoid.up_axis_m)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::DoubleValue* temp = _impl_.up_axis_m_;
  _impl_.up_axis_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::_internal_mutable_up_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.up_axis_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.up_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.up_axis_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::mutable_up_axis_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_up_axis_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipsoid.up_axis_m)
  return _msg;
}
inline void GeoEllipsoid::set_allocated_up_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.up_axis_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.up_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.up_axis_m)
}

// -------------------------------------------------------------------

// LinearRing

// repeated .anduril.entitymanager.v1.Position points = 1 [json_name = "points", deprecated = true];
inline int LinearRing::_internal_points_size() const {
  return _internal_points().size();
}
inline int LinearRing::points_size() const {
  return _internal_points_size();
}
inline ::anduril::entitymanager::v1::Position* LinearRing::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.LinearRing.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* LinearRing::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.LinearRing.points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_points();
}
inline const ::anduril::entitymanager::v1::Position& LinearRing::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.LinearRing.points)
  return _internal_points().Get(index);
}
inline ::anduril::entitymanager::v1::Position* LinearRing::add_points() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::Position* _add = _internal_mutable_points()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.LinearRing.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& LinearRing::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.LinearRing.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>&
LinearRing::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>*
LinearRing::_internal_mutable_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.points_;
}

// repeated .anduril.entitymanager.v1.GeoPolygonPosition positions = 2 [json_name = "positions"];
inline int LinearRing::_internal_positions_size() const {
  return _internal_positions().size();
}
inline int LinearRing::positions_size() const {
  return _internal_positions_size();
}
inline void LinearRing::clear_positions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positions_.Clear();
}
inline ::anduril::entitymanager::v1::GeoPolygonPosition* LinearRing::mutable_positions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.LinearRing.positions)
  return _internal_mutable_positions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>* LinearRing::mutable_positions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.LinearRing.positions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positions();
}
inline const ::anduril::entitymanager::v1::GeoPolygonPosition& LinearRing::positions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.LinearRing.positions)
  return _internal_positions().Get(index);
}
inline ::anduril::entitymanager::v1::GeoPolygonPosition* LinearRing::add_positions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::GeoPolygonPosition* _add = _internal_mutable_positions()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.LinearRing.positions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>& LinearRing::positions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.LinearRing.positions)
  return _internal_positions();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>&
LinearRing::_internal_positions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positions_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>*
LinearRing::_internal_mutable_positions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positions_;
}

// -------------------------------------------------------------------

// GeoPolygonPosition

// .anduril.entitymanager.v1.Position position = 1 [json_name = "position"];
inline bool GeoPolygonPosition::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Position& GeoPolygonPosition::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Position&>(::anduril::entitymanager::v1::_Position_default_instance_);
}
inline const ::anduril::entitymanager::v1::Position& GeoPolygonPosition::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoPolygonPosition.position)
  return _internal_position();
}
inline void GeoPolygonPosition::unsafe_arena_set_allocated_position(::anduril::entitymanager::v1::Position* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoPolygonPosition.position)
}
inline ::anduril::entitymanager::v1::Position* GeoPolygonPosition::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Position* GeoPolygonPosition::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoPolygonPosition.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Position* GeoPolygonPosition::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::anduril::entitymanager::v1::Position* GeoPolygonPosition::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoPolygonPosition.position)
  return _msg;
}
inline void GeoPolygonPosition::set_allocated_position(::anduril::entitymanager::v1::Position* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoPolygonPosition.position)
}

// .google.protobuf.FloatValue height_m = 2 [json_name = "heightM"];
inline bool GeoPolygonPosition::has_height_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.height_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::FloatValue& GeoPolygonPosition::_internal_height_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FloatValue* p = _impl_.height_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FloatValue&>(::google::protobuf::_FloatValue_default_instance_);
}
inline const ::google::protobuf::FloatValue& GeoPolygonPosition::height_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoPolygonPosition.height_m)
  return _internal_height_m();
}
inline void GeoPolygonPosition::unsafe_arena_set_allocated_height_m(::google::protobuf::FloatValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_m_);
  }
  _impl_.height_m_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoPolygonPosition.height_m)
}
inline ::google::protobuf::FloatValue* GeoPolygonPosition::release_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FloatValue* released = _impl_.height_m_;
  _impl_.height_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FloatValue* GeoPolygonPosition::unsafe_arena_release_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoPolygonPosition.height_m)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FloatValue* temp = _impl_.height_m_;
  _impl_.height_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* GeoPolygonPosition::_internal_mutable_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.height_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FloatValue>(GetArena());
    _impl_.height_m_ = reinterpret_cast<::google::protobuf::FloatValue*>(p);
  }
  return _impl_.height_m_;
}
inline ::google::protobuf::FloatValue* GeoPolygonPosition::mutable_height_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::FloatValue* _msg = _internal_mutable_height_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoPolygonPosition.height_m)
  return _msg;
}
inline void GeoPolygonPosition::set_allocated_height_m(::google::protobuf::FloatValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.height_m_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoPolygonPosition.height_m)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::anduril::entitymanager::v1::GeoType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::GeoType>() {
  return ::anduril::entitymanager::v1::GeoType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto_2epb_2eh
