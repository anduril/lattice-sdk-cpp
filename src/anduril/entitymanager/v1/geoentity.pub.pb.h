// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/entitymanager/v1/geoentity.pub.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "anduril/entitymanager/v1/location.pub.pb.h"
#include "anduril/type/color.pub.pb.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
namespace anduril {
namespace entitymanager {
namespace v1 {
class ACMDetails;
struct ACMDetailsDefaultTypeInternal;
extern ACMDetailsDefaultTypeInternal _ACMDetails_default_instance_;
class ControlAreaDetails;
struct ControlAreaDetailsDefaultTypeInternal;
extern ControlAreaDetailsDefaultTypeInternal _ControlAreaDetails_default_instance_;
class EmergencyDetails;
struct EmergencyDetailsDefaultTypeInternal;
extern EmergencyDetailsDefaultTypeInternal _EmergencyDetails_default_instance_;
class FSCMDetails;
struct FSCMDetailsDefaultTypeInternal;
extern FSCMDetailsDefaultTypeInternal _FSCMDetails_default_instance_;
class FiringAuthority;
struct FiringAuthorityDefaultTypeInternal;
extern FiringAuthorityDefaultTypeInternal _FiringAuthority_default_instance_;
class GeoDetails;
struct GeoDetailsDefaultTypeInternal;
extern GeoDetailsDefaultTypeInternal _GeoDetails_default_instance_;
class GeoEllipse;
struct GeoEllipseDefaultTypeInternal;
extern GeoEllipseDefaultTypeInternal _GeoEllipse_default_instance_;
class GeoEllipsoid;
struct GeoEllipsoidDefaultTypeInternal;
extern GeoEllipsoidDefaultTypeInternal _GeoEllipsoid_default_instance_;
class GeoLine;
struct GeoLineDefaultTypeInternal;
extern GeoLineDefaultTypeInternal _GeoLine_default_instance_;
class GeoPoint;
struct GeoPointDefaultTypeInternal;
extern GeoPointDefaultTypeInternal _GeoPoint_default_instance_;
class GeoPolygon;
struct GeoPolygonDefaultTypeInternal;
extern GeoPolygonDefaultTypeInternal _GeoPolygon_default_instance_;
class GeoPolygonPosition;
struct GeoPolygonPositionDefaultTypeInternal;
extern GeoPolygonPositionDefaultTypeInternal _GeoPolygonPosition_default_instance_;
class GeoShape;
struct GeoShapeDefaultTypeInternal;
extern GeoShapeDefaultTypeInternal _GeoShape_default_instance_;
class GeoVisualDetails;
struct GeoVisualDetailsDefaultTypeInternal;
extern GeoVisualDetailsDefaultTypeInternal _GeoVisualDetails_default_instance_;
class LinearRing;
struct LinearRingDefaultTypeInternal;
extern LinearRingDefaultTypeInternal _LinearRing_default_instance_;
class MCMDetails;
struct MCMDetailsDefaultTypeInternal;
extern MCMDetailsDefaultTypeInternal _MCMDetails_default_instance_;
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace entitymanager {
namespace v1 {
enum GeoType : int {
  GEO_TYPE_INVALID = 0,
  GEO_TYPE_GENERAL = 1,
  GEO_TYPE_HAZARD = 2,
  GEO_TYPE_EMERGENCY = 3,
  GEO_TYPE_FSCM = 4,
  GEO_TYPE_ENGAGEMENT_ZONE = 5,
  GEO_TYPE_CONTROL_AREA = 6,
  GEO_TYPE_BULLSEYE = 7,
  GEO_TYPE_ACM = 8,
  GEO_TYPE_MCM = 9,
  GeoType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GeoType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GeoType_IsValid(int value);
extern const uint32_t GeoType_internal_data_[];
constexpr GeoType GeoType_MIN = static_cast<GeoType>(0);
constexpr GeoType GeoType_MAX = static_cast<GeoType>(9);
constexpr int GeoType_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
GeoType_descriptor();
template <typename T>
const std::string& GeoType_Name(T value) {
  static_assert(std::is_same<T, GeoType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GeoType_Name().");
  return GeoType_Name(static_cast<GeoType>(value));
}
template <>
inline const std::string& GeoType_Name(GeoType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GeoType_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool GeoType_Parse(absl::string_view name, GeoType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeoType>(
      GeoType_descriptor(), name, value);
}
enum EmergencyType : int {
  EMERGENCY_TYPE_INVALID = 0,
  EMERGENCY_TYPE_DOWN_AIRCRAFT = 1,
  EMERGENCY_TYPE_MAN_IN_WATER = 2,
  EMERGENCY_TYPE_DITCHING = 3,
  EMERGENCY_TYPE_BAILOUT = 4,
  EMERGENCY_TYPE_DISTRESSED_VEHICLE = 5,
  EMERGENCY_TYPE_GROUND_INCIDENT = 6,
  EMERGENCY_TYPE_MEDICAL = 7,
  EMERGENCY_TYPE_ISOLATED_PERSON = 8,
  EmergencyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EmergencyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EmergencyType_IsValid(int value);
extern const uint32_t EmergencyType_internal_data_[];
constexpr EmergencyType EmergencyType_MIN = static_cast<EmergencyType>(0);
constexpr EmergencyType EmergencyType_MAX = static_cast<EmergencyType>(8);
constexpr int EmergencyType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
EmergencyType_descriptor();
template <typename T>
const std::string& EmergencyType_Name(T value) {
  static_assert(std::is_same<T, EmergencyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EmergencyType_Name().");
  return EmergencyType_Name(static_cast<EmergencyType>(value));
}
template <>
inline const std::string& EmergencyType_Name(EmergencyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EmergencyType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool EmergencyType_Parse(absl::string_view name, EmergencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmergencyType>(
      EmergencyType_descriptor(), name, value);
}
enum ControlAreaType : int {
  CONTROL_AREA_TYPE_INVALID = 0,
  CONTROL_AREA_TYPE_KEEP_IN_ZONE = 1,
  CONTROL_AREA_TYPE_KEEP_OUT_ZONE = 2,
  CONTROL_AREA_TYPE_DITCH_ZONE = 3,
  CONTROL_AREA_TYPE_OBSERVATION_EXCLUSION = 4,
  CONTROL_AREA_TYPE_OBSERVATION_INCLUSION = 5,
  CONTROL_AREA_TYPE_OBSERVATION_PRIORITY = 6,
  ControlAreaType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ControlAreaType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ControlAreaType_IsValid(int value);
extern const uint32_t ControlAreaType_internal_data_[];
constexpr ControlAreaType ControlAreaType_MIN = static_cast<ControlAreaType>(0);
constexpr ControlAreaType ControlAreaType_MAX = static_cast<ControlAreaType>(6);
constexpr int ControlAreaType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ControlAreaType_descriptor();
template <typename T>
const std::string& ControlAreaType_Name(T value) {
  static_assert(std::is_same<T, ControlAreaType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ControlAreaType_Name().");
  return ControlAreaType_Name(static_cast<ControlAreaType>(value));
}
template <>
inline const std::string& ControlAreaType_Name(ControlAreaType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ControlAreaType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ControlAreaType_Parse(absl::string_view name, ControlAreaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlAreaType>(
      ControlAreaType_descriptor(), name, value);
}
enum FSCMDetailType : int {
  FSCM_DETAIL_TYPE_INVALID = 0,
  FSCM_DETAIL_TYPE_DEAD_SPACE_AREA = 1,
  FSCM_DETAIL_TYPE_NO_FIRE_AREA = 2,
  FSCM_DETAIL_TYPE_FREE_FIRE_AREA = 3,
  FSCM_DETAIL_TYPE_RESTRICTIVE_FIRE_AREA = 4,
  FSCM_DETAIL_TYPE_SAFE_FIRE_AREA = 5,
  FSCM_DETAIL_TYPE_AIRSPACE_COORDINATION_AREA = 6,
  FSCM_DETAIL_TYPE_FORWARD_EDGE_OF_THE_BATTLE_AREA = 7,
  FSCM_DETAIL_TYPE_FIRE_SUPPORT_AREA = 8,
  FSCM_DETAIL_TYPE_PATROL_RECONNAISSANCE = 9,
  FSCM_DETAIL_TYPE_ZONE_OF_RESPONSIBILITY = 10,
  FSCM_DETAIL_TYPE_PRIORITY_CALL_FOR_FIRE_ZONE = 11,
  FSCM_DETAIL_TYPE_CENSORED_ZONE = 12,
  FSCM_DETAIL_TYPE_ZONE_OF_ACTION = 13,
  FSCM_DETAIL_TYPE_CRITICAL_FRIENDLY_ZONE = 14,
  FSCM_DETAIL_TYPE_PLATOON_AREA_HAZARD = 15,
  FSCM_DETAIL_TYPE_TARGET_AREA_HAZARD = 16,
  FSCM_DETAIL_TYPE_RESTRICTED_OPERATIONS_ZONE = 17,
  FSCM_DETAIL_TYPE_AIR_CORRIDOR = 18,
  FSCM_DETAIL_TYPE_RESTRICTIVE_FIRE_LINE = 19,
  FSCM_DETAIL_TYPE_COORDINATED_FIRE_LINE_NO_FIRE_LINE = 20,
  FSCM_DETAIL_TYPE_BOUNDARY_LINE = 21,
  FSCM_DETAIL_TYPE_FORWARD_LINE = 22,
  FSCM_DETAIL_TYPE_FIRE_SUPPORT_LINE = 23,
  FSCM_DETAIL_TYPE_LINE_OF_DEPARTURE = 24,
  FSCM_DETAIL_TYPE_LINE_OF_CONTACT = 25,
  FSCM_DETAIL_TYPE_LINE_OF_DEPARTURE_LINE_OF_CONTACT = 26,
  FSCM_DETAIL_TYPE_ZONE_OF_FIRE = 27,
  FSCMDetailType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FSCMDetailType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FSCMDetailType_IsValid(int value);
extern const uint32_t FSCMDetailType_internal_data_[];
constexpr FSCMDetailType FSCMDetailType_MIN = static_cast<FSCMDetailType>(0);
constexpr FSCMDetailType FSCMDetailType_MAX = static_cast<FSCMDetailType>(27);
constexpr int FSCMDetailType_ARRAYSIZE = 27 + 1;
const ::google::protobuf::EnumDescriptor*
FSCMDetailType_descriptor();
template <typename T>
const std::string& FSCMDetailType_Name(T value) {
  static_assert(std::is_same<T, FSCMDetailType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FSCMDetailType_Name().");
  return FSCMDetailType_Name(static_cast<FSCMDetailType>(value));
}
template <>
inline const std::string& FSCMDetailType_Name(FSCMDetailType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FSCMDetailType_descriptor,
                                                 0, 27>(
      static_cast<int>(value));
}
inline bool FSCMDetailType_Parse(absl::string_view name, FSCMDetailType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FSCMDetailType>(
      FSCMDetailType_descriptor(), name, value);
}
enum ACMDetailType : int {
  ACM_DETAIL_TYPE_INVALID = 0,
  ACM_DETAIL_TYPE_AIR_CORRIDOR = 1,
  ACM_DETAIL_TYPE_MINIMUM_RISK_ROUTE = 2,
  ACM_DETAIL_TYPE_TEMPORARY_MINIMUM_RISK_ROUTE = 3,
  ACM_DETAIL_TYPE_TRANSIT_ROUTE = 4,
  ACM_DETAIL_TYPE_LOW_LEVEL_TRANSIT_ROUTE = 5,
  ACM_DETAIL_TYPE_SPECIAL_CORRIDOR = 6,
  ACM_DETAIL_TYPE_STANDARD_USE_ARMY_AIRCRAFT_FLIGHT_ROUTE = 7,
  ACM_DETAIL_TYPE_RESTRICTED_OPERATIONS_ZONE = 8,
  ACM_DETAIL_TYPE_AIR_TO_AIR_REFUELING_AREA = 9,
  ACM_DETAIL_TYPE_AIRBORNE_COMMAND_AND_CONTROL_AREA = 10,
  ACM_DETAIL_TYPE_AIRBORNE_EARLY_WARNING_AREA = 11,
  ACM_DETAIL_TYPE_CLOSE_AIR_SUPPORT_AREA = 12,
  ACM_DETAIL_TYPE_COMBAT_AIR_PATROL = 13,
  ACM_DETAIL_TYPE_DROP_ZONE = 14,
  ACM_DETAIL_TYPE_ELECTRONIC_COMBAT = 15,
  ACM_DETAIL_TYPE_LANDING_ZONE = 16,
  ACM_DETAIL_TYPE_PICKUP_ZONE = 17,
  ACM_DETAIL_TYPE_RECONNAISSANCE_AREA = 18,
  ACM_DETAIL_TYPE_SPECIAL_OPERATIONS_FORCE_AREA = 19,
  ACM_DETAIL_TYPE_SURFACE_TO_SURFACE_MISSILE_SYSTEM = 20,
  ACM_DETAIL_TYPE_SURFACE_TO_SURFACE_MUNITIONS = 21,
  ACM_DETAIL_TYPE_UNMANNED_AIRCRAFT_AREA = 22,
  ACM_DETAIL_TYPE_COORDINATING_ALTITUDE = 23,
  ACM_DETAIL_TYPE_COORDINATION_LEVEL = 24,
  ACM_DETAIL_TYPE_HIGH_DENSITY_AIRSPACE_CONTROL_ZONE = 25,
  ACM_DETAIL_TYPE_NO_FLY_AREA = 26,
  ACM_DETAIL_TYPE_TRANSIT_CORRIDOR = 27,
  ACM_DETAIL_TYPE_RETURN_TO_FORCE = 28,
  ACMDetailType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ACMDetailType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ACMDetailType_IsValid(int value);
extern const uint32_t ACMDetailType_internal_data_[];
constexpr ACMDetailType ACMDetailType_MIN = static_cast<ACMDetailType>(0);
constexpr ACMDetailType ACMDetailType_MAX = static_cast<ACMDetailType>(28);
constexpr int ACMDetailType_ARRAYSIZE = 28 + 1;
const ::google::protobuf::EnumDescriptor*
ACMDetailType_descriptor();
template <typename T>
const std::string& ACMDetailType_Name(T value) {
  static_assert(std::is_same<T, ACMDetailType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ACMDetailType_Name().");
  return ACMDetailType_Name(static_cast<ACMDetailType>(value));
}
template <>
inline const std::string& ACMDetailType_Name(ACMDetailType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ACMDetailType_descriptor,
                                                 0, 28>(
      static_cast<int>(value));
}
inline bool ACMDetailType_Parse(absl::string_view name, ACMDetailType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACMDetailType>(
      ACMDetailType_descriptor(), name, value);
}
enum AmmoRestrictionType : int {
  AMMO_RESTRICTION_TYPE_INVALID = 0,
  AMMO_RESTRICTION_TYPE_HIGH_EXPLOSIVE_MUNITIONS = 1,
  AMMO_RESTRICTION_TYPE_IMPROVED_CONVENTIONAL_MUNITIONS = 2,
  AMMO_RESTRICTION_TYPE_CHEMICAL_MUNITIONS = 3,
  AMMO_RESTRICTION_TYPE_NUCLEAR_MUNITIONS = 4,
  AMMO_RESTRICTION_TYPE_WHITE_PHOSPHORUS_MUNITIONS = 5,
  AMMO_RESTRICTION_TYPE_ILLUMINATION_MUNITIONS = 6,
  AMMO_RESTRICTION_TYPE_TERMINAL_HOMING_MUNITIONS = 7,
  AMMO_RESTRICTION_TYPE_FASCAM_MUNITIONS = 8,
  AMMO_RESTRICTION_TYPE_SMOKE_MUNITIONS = 9,
  AMMO_RESTRICTION_TYPE_ALL_MUNITIONS = 10,
  AmmoRestrictionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AmmoRestrictionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AmmoRestrictionType_IsValid(int value);
extern const uint32_t AmmoRestrictionType_internal_data_[];
constexpr AmmoRestrictionType AmmoRestrictionType_MIN = static_cast<AmmoRestrictionType>(0);
constexpr AmmoRestrictionType AmmoRestrictionType_MAX = static_cast<AmmoRestrictionType>(10);
constexpr int AmmoRestrictionType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
AmmoRestrictionType_descriptor();
template <typename T>
const std::string& AmmoRestrictionType_Name(T value) {
  static_assert(std::is_same<T, AmmoRestrictionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AmmoRestrictionType_Name().");
  return AmmoRestrictionType_Name(static_cast<AmmoRestrictionType>(value));
}
template <>
inline const std::string& AmmoRestrictionType_Name(AmmoRestrictionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AmmoRestrictionType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool AmmoRestrictionType_Parse(absl::string_view name, AmmoRestrictionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AmmoRestrictionType>(
      AmmoRestrictionType_descriptor(), name, value);
}
enum RestrictiveMeasureType : int {
  RESTRICTIVE_MEASURE_TYPE_INVALID = 0,
  RESTRICTIVE_MEASURE_TYPE_STAY_INSIDE_AREA = 1,
  RESTRICTIVE_MEASURE_TYPE_STAY_OUTSIDE_AREA = 2,
  RESTRICTIVE_MEASURE_TYPE_STAY_ABOVE_AREA = 3,
  RESTRICTIVE_MEASURE_TYPE_STAY_BELOW_AREA = 4,
  RESTRICTIVE_MEASURE_TYPE_STAY_NORTH_OF_LINE = 5,
  RESTRICTIVE_MEASURE_TYPE_STAY_EAST_OF_LINE = 6,
  RESTRICTIVE_MEASURE_TYPE_STAY_SOUTH_OF_LINE = 7,
  RESTRICTIVE_MEASURE_TYPE_STAY_WEST_OF_LINE = 8,
  RestrictiveMeasureType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RestrictiveMeasureType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RestrictiveMeasureType_IsValid(int value);
extern const uint32_t RestrictiveMeasureType_internal_data_[];
constexpr RestrictiveMeasureType RestrictiveMeasureType_MIN = static_cast<RestrictiveMeasureType>(0);
constexpr RestrictiveMeasureType RestrictiveMeasureType_MAX = static_cast<RestrictiveMeasureType>(8);
constexpr int RestrictiveMeasureType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
RestrictiveMeasureType_descriptor();
template <typename T>
const std::string& RestrictiveMeasureType_Name(T value) {
  static_assert(std::is_same<T, RestrictiveMeasureType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RestrictiveMeasureType_Name().");
  return RestrictiveMeasureType_Name(static_cast<RestrictiveMeasureType>(value));
}
template <>
inline const std::string& RestrictiveMeasureType_Name(RestrictiveMeasureType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RestrictiveMeasureType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool RestrictiveMeasureType_Parse(absl::string_view name, RestrictiveMeasureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RestrictiveMeasureType>(
      RestrictiveMeasureType_descriptor(), name, value);
}
enum MCMDetailType : int {
  MCM_DETAIL_TYPE_INVALID = 0,
  MCM_DETAIL_TYPE_NAMED_AREA_OF_INTEREST = 1,
  MCM_DETAIL_TYPE_TARGET_AREA_OF_INTEREST = 2,
  MCMDetailType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MCMDetailType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MCMDetailType_IsValid(int value);
extern const uint32_t MCMDetailType_internal_data_[];
constexpr MCMDetailType MCMDetailType_MIN = static_cast<MCMDetailType>(0);
constexpr MCMDetailType MCMDetailType_MAX = static_cast<MCMDetailType>(2);
constexpr int MCMDetailType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
MCMDetailType_descriptor();
template <typename T>
const std::string& MCMDetailType_Name(T value) {
  static_assert(std::is_same<T, MCMDetailType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MCMDetailType_Name().");
  return MCMDetailType_Name(static_cast<MCMDetailType>(value));
}
template <>
inline const std::string& MCMDetailType_Name(MCMDetailType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MCMDetailType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool MCMDetailType_Parse(absl::string_view name, MCMDetailType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MCMDetailType>(
      MCMDetailType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class MCMDetails final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.MCMDetails) */ {
 public:
  inline MCMDetails() : MCMDetails(nullptr) {}
  ~MCMDetails() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MCMDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline MCMDetails(const MCMDetails& from) : MCMDetails(nullptr, from) {}
  inline MCMDetails(MCMDetails&& from) noexcept
      : MCMDetails(nullptr, std::move(from)) {}
  inline MCMDetails& operator=(const MCMDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline MCMDetails& operator=(MCMDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MCMDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const MCMDetails* internal_default_instance() {
    return reinterpret_cast<const MCMDetails*>(
        &_MCMDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(MCMDetails& a, MCMDetails& b) { a.Swap(&b); }
  inline void Swap(MCMDetails* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MCMDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MCMDetails* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MCMDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MCMDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MCMDetails& from) { MCMDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MCMDetails* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.MCMDetails"; }

 protected:
  explicit MCMDetails(::google::protobuf::Arena* arena);
  MCMDetails(::google::protobuf::Arena* arena, const MCMDetails& from);
  MCMDetails(::google::protobuf::Arena* arena, MCMDetails&& from) noexcept
      : MCMDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMcmDescriptionFieldNumber = 2,
    kMcmTypeFieldNumber = 1,
  };
  // string mcm_description = 2 [json_name = "mcmDescription"];
  void clear_mcm_description() ;
  const std::string& mcm_description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mcm_description(Arg_&& arg, Args_... args);
  std::string* mutable_mcm_description();
  PROTOBUF_NODISCARD std::string* release_mcm_description();
  void set_allocated_mcm_description(std::string* value);

  private:
  const std::string& _internal_mcm_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcm_description(
      const std::string& value);
  std::string* _internal_mutable_mcm_description();

  public:
  // .anduril.entitymanager.v1.MCMDetailType mcm_type = 1 [json_name = "mcmType"];
  void clear_mcm_type() ;
  ::anduril::entitymanager::v1::MCMDetailType mcm_type() const;
  void set_mcm_type(::anduril::entitymanager::v1::MCMDetailType value);

  private:
  ::anduril::entitymanager::v1::MCMDetailType _internal_mcm_type() const;
  void _internal_set_mcm_type(::anduril::entitymanager::v1::MCMDetailType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.MCMDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      59, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MCMDetails_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MCMDetails& from_msg);
    ::google::protobuf::internal::ArenaStringPtr mcm_description_;
    int mcm_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class FiringAuthority final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.FiringAuthority) */ {
 public:
  inline FiringAuthority() : FiringAuthority(nullptr) {}
  ~FiringAuthority() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FiringAuthority(
      ::google::protobuf::internal::ConstantInitialized);

  inline FiringAuthority(const FiringAuthority& from) : FiringAuthority(nullptr, from) {}
  inline FiringAuthority(FiringAuthority&& from) noexcept
      : FiringAuthority(nullptr, std::move(from)) {}
  inline FiringAuthority& operator=(const FiringAuthority& from) {
    CopyFrom(from);
    return *this;
  }
  inline FiringAuthority& operator=(FiringAuthority&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FiringAuthority& default_instance() {
    return *internal_default_instance();
  }
  static inline const FiringAuthority* internal_default_instance() {
    return reinterpret_cast<const FiringAuthority*>(
        &_FiringAuthority_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(FiringAuthority& a, FiringAuthority& b) { a.Swap(&b); }
  inline void Swap(FiringAuthority* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FiringAuthority* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FiringAuthority* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<FiringAuthority>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FiringAuthority& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FiringAuthority& from) { FiringAuthority::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FiringAuthority* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.FiringAuthority"; }

 protected:
  explicit FiringAuthority(::google::protobuf::Arena* arena);
  FiringAuthority(::google::protobuf::Arena* arena, const FiringAuthority& from);
  FiringAuthority(::google::protobuf::Arena* arena, FiringAuthority&& from) noexcept
      : FiringAuthority(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdsFieldNumber = 1,
  };
  // repeated string entity_ids = 1 [json_name = "entityIds"];
  int entity_ids_size() const;
  private:
  int _internal_entity_ids_size() const;

  public:
  void clear_entity_ids() ;
  const std::string& entity_ids(int index) const;
  std::string* mutable_entity_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_ids(int index, Arg_&& value, Args_... args);
  std::string* add_entity_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_entity_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& entity_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_entity_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_entity_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_entity_ids();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.FiringAuthority)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      59, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FiringAuthority_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FiringAuthority& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> entity_ids_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class EmergencyDetails final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.EmergencyDetails) */ {
 public:
  inline EmergencyDetails() : EmergencyDetails(nullptr) {}
  ~EmergencyDetails() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EmergencyDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline EmergencyDetails(const EmergencyDetails& from) : EmergencyDetails(nullptr, from) {}
  inline EmergencyDetails(EmergencyDetails&& from) noexcept
      : EmergencyDetails(nullptr, std::move(from)) {}
  inline EmergencyDetails& operator=(const EmergencyDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmergencyDetails& operator=(EmergencyDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmergencyDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmergencyDetails* internal_default_instance() {
    return reinterpret_cast<const EmergencyDetails*>(
        &_EmergencyDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(EmergencyDetails& a, EmergencyDetails& b) { a.Swap(&b); }
  inline void Swap(EmergencyDetails* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmergencyDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmergencyDetails* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<EmergencyDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmergencyDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EmergencyDetails& from) { EmergencyDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EmergencyDetails* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.EmergencyDetails"; }

 protected:
  explicit EmergencyDetails(::google::protobuf::Arena* arena);
  EmergencyDetails(::google::protobuf::Arena* arena, const EmergencyDetails& from);
  EmergencyDetails(::google::protobuf::Arena* arena, EmergencyDetails&& from) noexcept
      : EmergencyDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEmergencyTypeFieldNumber = 1,
    kPersonnelInvolvedFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.EmergencyType emergency_type = 1 [json_name = "emergencyType"];
  void clear_emergency_type() ;
  ::anduril::entitymanager::v1::EmergencyType emergency_type() const;
  void set_emergency_type(::anduril::entitymanager::v1::EmergencyType value);

  private:
  ::anduril::entitymanager::v1::EmergencyType _internal_emergency_type() const;
  void _internal_set_emergency_type(::anduril::entitymanager::v1::EmergencyType value);

  public:
  // uint32 personnel_involved = 2 [json_name = "personnelInvolved"];
  void clear_personnel_involved() ;
  ::uint32_t personnel_involved() const;
  void set_personnel_involved(::uint32_t value);

  private:
  ::uint32_t _internal_personnel_involved() const;
  void _internal_set_personnel_involved(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.EmergencyDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EmergencyDetails_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EmergencyDetails& from_msg);
    int emergency_type_;
    ::uint32_t personnel_involved_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class ControlAreaDetails final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.ControlAreaDetails) */ {
 public:
  inline ControlAreaDetails() : ControlAreaDetails(nullptr) {}
  ~ControlAreaDetails() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControlAreaDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline ControlAreaDetails(const ControlAreaDetails& from) : ControlAreaDetails(nullptr, from) {}
  inline ControlAreaDetails(ControlAreaDetails&& from) noexcept
      : ControlAreaDetails(nullptr, std::move(from)) {}
  inline ControlAreaDetails& operator=(const ControlAreaDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlAreaDetails& operator=(ControlAreaDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlAreaDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlAreaDetails* internal_default_instance() {
    return reinterpret_cast<const ControlAreaDetails*>(
        &_ControlAreaDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ControlAreaDetails& a, ControlAreaDetails& b) { a.Swap(&b); }
  inline void Swap(ControlAreaDetails* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlAreaDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlAreaDetails* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ControlAreaDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControlAreaDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ControlAreaDetails& from) { ControlAreaDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControlAreaDetails* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.ControlAreaDetails"; }

 protected:
  explicit ControlAreaDetails(::google::protobuf::Arena* arena);
  ControlAreaDetails(::google::protobuf::Arena* arena, const ControlAreaDetails& from);
  ControlAreaDetails(::google::protobuf::Arena* arena, ControlAreaDetails&& from) noexcept
      : ControlAreaDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
  };
  // .anduril.entitymanager.v1.ControlAreaType type = 1 [json_name = "type"];
  void clear_type() ;
  ::anduril::entitymanager::v1::ControlAreaType type() const;
  void set_type(::anduril::entitymanager::v1::ControlAreaType value);

  private:
  ::anduril::entitymanager::v1::ControlAreaType _internal_type() const;
  void _internal_set_type(::anduril::entitymanager::v1::ControlAreaType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.ControlAreaDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ControlAreaDetails_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ControlAreaDetails& from_msg);
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class ACMDetails final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.ACMDetails) */ {
 public:
  inline ACMDetails() : ACMDetails(nullptr) {}
  ~ACMDetails() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ACMDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline ACMDetails(const ACMDetails& from) : ACMDetails(nullptr, from) {}
  inline ACMDetails(ACMDetails&& from) noexcept
      : ACMDetails(nullptr, std::move(from)) {}
  inline ACMDetails& operator=(const ACMDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACMDetails& operator=(ACMDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACMDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACMDetails* internal_default_instance() {
    return reinterpret_cast<const ACMDetails*>(
        &_ACMDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ACMDetails& a, ACMDetails& b) { a.Swap(&b); }
  inline void Swap(ACMDetails* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACMDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACMDetails* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ACMDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ACMDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ACMDetails& from) { ACMDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ACMDetails* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.ACMDetails"; }

 protected:
  explicit ACMDetails(::google::protobuf::Arena* arena);
  ACMDetails(::google::protobuf::Arena* arena, const ACMDetails& from);
  ACMDetails(::google::protobuf::Arena* arena, ACMDetails&& from) noexcept
      : ACMDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAcmDescriptionFieldNumber = 2,
    kAcmTypeFieldNumber = 1,
  };
  // string acm_description = 2 [json_name = "acmDescription"];
  void clear_acm_description() ;
  const std::string& acm_description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_acm_description(Arg_&& arg, Args_... args);
  std::string* mutable_acm_description();
  PROTOBUF_NODISCARD std::string* release_acm_description();
  void set_allocated_acm_description(std::string* value);

  private:
  const std::string& _internal_acm_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_acm_description(
      const std::string& value);
  std::string* _internal_mutable_acm_description();

  public:
  // .anduril.entitymanager.v1.ACMDetailType acm_type = 1 [json_name = "acmType"];
  void clear_acm_type() ;
  ::anduril::entitymanager::v1::ACMDetailType acm_type() const;
  void set_acm_type(::anduril::entitymanager::v1::ACMDetailType value);

  private:
  ::anduril::entitymanager::v1::ACMDetailType _internal_acm_type() const;
  void _internal_set_acm_type(::anduril::entitymanager::v1::ACMDetailType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.ACMDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      59, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ACMDetails_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ACMDetails& from_msg);
    ::google::protobuf::internal::ArenaStringPtr acm_description_;
    int acm_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoEllipsoid final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoEllipsoid) */ {
 public:
  inline GeoEllipsoid() : GeoEllipsoid(nullptr) {}
  ~GeoEllipsoid() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoEllipsoid(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoEllipsoid(const GeoEllipsoid& from) : GeoEllipsoid(nullptr, from) {}
  inline GeoEllipsoid(GeoEllipsoid&& from) noexcept
      : GeoEllipsoid(nullptr, std::move(from)) {}
  inline GeoEllipsoid& operator=(const GeoEllipsoid& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoEllipsoid& operator=(GeoEllipsoid&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoEllipsoid& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoEllipsoid* internal_default_instance() {
    return reinterpret_cast<const GeoEllipsoid*>(
        &_GeoEllipsoid_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(GeoEllipsoid& a, GeoEllipsoid& b) { a.Swap(&b); }
  inline void Swap(GeoEllipsoid* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoEllipsoid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoEllipsoid* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoEllipsoid>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoEllipsoid& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoEllipsoid& from) { GeoEllipsoid::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoEllipsoid* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoEllipsoid"; }

 protected:
  explicit GeoEllipsoid(::google::protobuf::Arena* arena);
  GeoEllipsoid(::google::protobuf::Arena* arena, const GeoEllipsoid& from);
  GeoEllipsoid(::google::protobuf::Arena* arena, GeoEllipsoid&& from) noexcept
      : GeoEllipsoid(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kForwardAxisMFieldNumber = 1,
    kSideAxisMFieldNumber = 2,
    kUpAxisMFieldNumber = 3,
  };
  // .google.protobuf.DoubleValue forward_axis_m = 1 [json_name = "forwardAxisM"];
  bool has_forward_axis_m() const;
  void clear_forward_axis_m() ;
  const ::google::protobuf::DoubleValue& forward_axis_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_forward_axis_m();
  ::google::protobuf::DoubleValue* mutable_forward_axis_m();
  void set_allocated_forward_axis_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_forward_axis_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_forward_axis_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_forward_axis_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_forward_axis_m();

  public:
  // .google.protobuf.DoubleValue side_axis_m = 2 [json_name = "sideAxisM"];
  bool has_side_axis_m() const;
  void clear_side_axis_m() ;
  const ::google::protobuf::DoubleValue& side_axis_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_side_axis_m();
  ::google::protobuf::DoubleValue* mutable_side_axis_m();
  void set_allocated_side_axis_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_side_axis_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_side_axis_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_side_axis_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_side_axis_m();

  public:
  // .google.protobuf.DoubleValue up_axis_m = 3 [json_name = "upAxisM"];
  bool has_up_axis_m() const;
  void clear_up_axis_m() ;
  const ::google::protobuf::DoubleValue& up_axis_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_up_axis_m();
  ::google::protobuf::DoubleValue* mutable_up_axis_m();
  void set_allocated_up_axis_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_up_axis_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_up_axis_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_up_axis_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_up_axis_m();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoEllipsoid)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoEllipsoid_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoEllipsoid& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::DoubleValue* forward_axis_m_;
    ::google::protobuf::DoubleValue* side_axis_m_;
    ::google::protobuf::DoubleValue* up_axis_m_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoEllipse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoEllipse) */ {
 public:
  inline GeoEllipse() : GeoEllipse(nullptr) {}
  ~GeoEllipse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoEllipse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoEllipse(const GeoEllipse& from) : GeoEllipse(nullptr, from) {}
  inline GeoEllipse(GeoEllipse&& from) noexcept
      : GeoEllipse(nullptr, std::move(from)) {}
  inline GeoEllipse& operator=(const GeoEllipse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoEllipse& operator=(GeoEllipse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoEllipse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoEllipse* internal_default_instance() {
    return reinterpret_cast<const GeoEllipse*>(
        &_GeoEllipse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(GeoEllipse& a, GeoEllipse& b) { a.Swap(&b); }
  inline void Swap(GeoEllipse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoEllipse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoEllipse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoEllipse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoEllipse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoEllipse& from) { GeoEllipse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoEllipse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoEllipse"; }

 protected:
  explicit GeoEllipse(::google::protobuf::Arena* arena);
  GeoEllipse(::google::protobuf::Arena* arena, const GeoEllipse& from);
  GeoEllipse(::google::protobuf::Arena* arena, GeoEllipse&& from) noexcept
      : GeoEllipse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSemiMajorAxisMFieldNumber = 2,
    kSemiMinorAxisMFieldNumber = 3,
    kOrientationDFieldNumber = 4,
    kHeightMFieldNumber = 5,
  };
  // .google.protobuf.DoubleValue semi_major_axis_m = 2 [json_name = "semiMajorAxisM"];
  bool has_semi_major_axis_m() const;
  void clear_semi_major_axis_m() ;
  const ::google::protobuf::DoubleValue& semi_major_axis_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_semi_major_axis_m();
  ::google::protobuf::DoubleValue* mutable_semi_major_axis_m();
  void set_allocated_semi_major_axis_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_semi_major_axis_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_semi_major_axis_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_semi_major_axis_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_semi_major_axis_m();

  public:
  // .google.protobuf.DoubleValue semi_minor_axis_m = 3 [json_name = "semiMinorAxisM"];
  bool has_semi_minor_axis_m() const;
  void clear_semi_minor_axis_m() ;
  const ::google::protobuf::DoubleValue& semi_minor_axis_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_semi_minor_axis_m();
  ::google::protobuf::DoubleValue* mutable_semi_minor_axis_m();
  void set_allocated_semi_minor_axis_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_semi_minor_axis_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_semi_minor_axis_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_semi_minor_axis_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_semi_minor_axis_m();

  public:
  // .google.protobuf.DoubleValue orientation_d = 4 [json_name = "orientationD"];
  bool has_orientation_d() const;
  void clear_orientation_d() ;
  const ::google::protobuf::DoubleValue& orientation_d() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_orientation_d();
  ::google::protobuf::DoubleValue* mutable_orientation_d();
  void set_allocated_orientation_d(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_orientation_d(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_orientation_d();

  private:
  const ::google::protobuf::DoubleValue& _internal_orientation_d() const;
  ::google::protobuf::DoubleValue* _internal_mutable_orientation_d();

  public:
  // .google.protobuf.DoubleValue height_m = 5 [json_name = "heightM"];
  bool has_height_m() const;
  void clear_height_m() ;
  const ::google::protobuf::DoubleValue& height_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_height_m();
  ::google::protobuf::DoubleValue* mutable_height_m();
  void set_allocated_height_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_height_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_height_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_height_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_height_m();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoEllipse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoEllipse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoEllipse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::DoubleValue* semi_major_axis_m_;
    ::google::protobuf::DoubleValue* semi_minor_axis_m_;
    ::google::protobuf::DoubleValue* orientation_d_;
    ::google::protobuf::DoubleValue* height_m_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class FSCMDetails final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.FSCMDetails) */ {
 public:
  inline FSCMDetails() : FSCMDetails(nullptr) {}
  ~FSCMDetails() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FSCMDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline FSCMDetails(const FSCMDetails& from) : FSCMDetails(nullptr, from) {}
  inline FSCMDetails(FSCMDetails&& from) noexcept
      : FSCMDetails(nullptr, std::move(from)) {}
  inline FSCMDetails& operator=(const FSCMDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline FSCMDetails& operator=(FSCMDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FSCMDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const FSCMDetails* internal_default_instance() {
    return reinterpret_cast<const FSCMDetails*>(
        &_FSCMDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(FSCMDetails& a, FSCMDetails& b) { a.Swap(&b); }
  inline void Swap(FSCMDetails* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FSCMDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FSCMDetails* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<FSCMDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FSCMDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FSCMDetails& from) { FSCMDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FSCMDetails* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.FSCMDetails"; }

 protected:
  explicit FSCMDetails(::google::protobuf::Arena* arena);
  FSCMDetails(::google::protobuf::Arena* arena, const FSCMDetails& from);
  FSCMDetails(::google::protobuf::Arena* arena, FSCMDetails&& from) noexcept
      : FSCMDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAmmoRestrictTypesFieldNumber = 6,
    kFscmDescriptionFieldNumber = 2,
    kFiringAuthorityFieldNumber = 3,
    kFscmTypeFieldNumber = 1,
    kAmmoRestrictionTypeFieldNumber = 4,
    kRestrictiveMeasureTypeFieldNumber = 5,
    kIsGroundFieldNumber = 7,
  };
  // repeated .anduril.entitymanager.v1.AmmoRestrictionType ammo_restrict_types = 6 [json_name = "ammoRestrictTypes"];
  int ammo_restrict_types_size() const;
  private:
  int _internal_ammo_restrict_types_size() const;

  public:
  void clear_ammo_restrict_types() ;
  public:
  ::anduril::entitymanager::v1::AmmoRestrictionType ammo_restrict_types(int index) const;
  void set_ammo_restrict_types(int index, ::anduril::entitymanager::v1::AmmoRestrictionType value);
  void add_ammo_restrict_types(::anduril::entitymanager::v1::AmmoRestrictionType value);
  const ::google::protobuf::RepeatedField<int>& ammo_restrict_types() const;
  ::google::protobuf::RepeatedField<int>* mutable_ammo_restrict_types();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_ammo_restrict_types() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_ammo_restrict_types();

  public:
  // string fscm_description = 2 [json_name = "fscmDescription"];
  void clear_fscm_description() ;
  const std::string& fscm_description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fscm_description(Arg_&& arg, Args_... args);
  std::string* mutable_fscm_description();
  PROTOBUF_NODISCARD std::string* release_fscm_description();
  void set_allocated_fscm_description(std::string* value);

  private:
  const std::string& _internal_fscm_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fscm_description(
      const std::string& value);
  std::string* _internal_mutable_fscm_description();

  public:
  // .anduril.entitymanager.v1.FiringAuthority firing_authority = 3 [json_name = "firingAuthority"];
  bool has_firing_authority() const;
  void clear_firing_authority() ;
  const ::anduril::entitymanager::v1::FiringAuthority& firing_authority() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::FiringAuthority* release_firing_authority();
  ::anduril::entitymanager::v1::FiringAuthority* mutable_firing_authority();
  void set_allocated_firing_authority(::anduril::entitymanager::v1::FiringAuthority* value);
  void unsafe_arena_set_allocated_firing_authority(::anduril::entitymanager::v1::FiringAuthority* value);
  ::anduril::entitymanager::v1::FiringAuthority* unsafe_arena_release_firing_authority();

  private:
  const ::anduril::entitymanager::v1::FiringAuthority& _internal_firing_authority() const;
  ::anduril::entitymanager::v1::FiringAuthority* _internal_mutable_firing_authority();

  public:
  // .anduril.entitymanager.v1.FSCMDetailType fscm_type = 1 [json_name = "fscmType"];
  void clear_fscm_type() ;
  ::anduril::entitymanager::v1::FSCMDetailType fscm_type() const;
  void set_fscm_type(::anduril::entitymanager::v1::FSCMDetailType value);

  private:
  ::anduril::entitymanager::v1::FSCMDetailType _internal_fscm_type() const;
  void _internal_set_fscm_type(::anduril::entitymanager::v1::FSCMDetailType value);

  public:
  // .anduril.entitymanager.v1.AmmoRestrictionType ammo_restriction_type = 4 [json_name = "ammoRestrictionType", deprecated = true];
  [[deprecated]]  void clear_ammo_restriction_type() ;
  [[deprecated]] ::anduril::entitymanager::v1::AmmoRestrictionType ammo_restriction_type() const;
  [[deprecated]] void set_ammo_restriction_type(::anduril::entitymanager::v1::AmmoRestrictionType value);

  private:
  ::anduril::entitymanager::v1::AmmoRestrictionType _internal_ammo_restriction_type() const;
  void _internal_set_ammo_restriction_type(::anduril::entitymanager::v1::AmmoRestrictionType value);

  public:
  // .anduril.entitymanager.v1.RestrictiveMeasureType restrictive_measure_type = 5 [json_name = "restrictiveMeasureType"];
  void clear_restrictive_measure_type() ;
  ::anduril::entitymanager::v1::RestrictiveMeasureType restrictive_measure_type() const;
  void set_restrictive_measure_type(::anduril::entitymanager::v1::RestrictiveMeasureType value);

  private:
  ::anduril::entitymanager::v1::RestrictiveMeasureType _internal_restrictive_measure_type() const;
  void _internal_set_restrictive_measure_type(::anduril::entitymanager::v1::RestrictiveMeasureType value);

  public:
  // bool is_ground = 7 [json_name = "isGround"];
  void clear_is_ground() ;
  bool is_ground() const;
  void set_is_ground(bool value);

  private:
  bool _internal_is_ground() const;
  void _internal_set_is_ground(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.FSCMDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      61, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FSCMDetails_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FSCMDetails& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> ammo_restrict_types_;
    mutable ::google::protobuf::internal::CachedSize _ammo_restrict_types_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr fscm_description_;
    ::anduril::entitymanager::v1::FiringAuthority* firing_authority_;
    int fscm_type_;
    int ammo_restriction_type_;
    int restrictive_measure_type_;
    bool is_ground_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoVisualDetails final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoVisualDetails) */ {
 public:
  inline GeoVisualDetails() : GeoVisualDetails(nullptr) {}
  ~GeoVisualDetails() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoVisualDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoVisualDetails(const GeoVisualDetails& from) : GeoVisualDetails(nullptr, from) {}
  inline GeoVisualDetails(GeoVisualDetails&& from) noexcept
      : GeoVisualDetails(nullptr, std::move(from)) {}
  inline GeoVisualDetails& operator=(const GeoVisualDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoVisualDetails& operator=(GeoVisualDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoVisualDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoVisualDetails* internal_default_instance() {
    return reinterpret_cast<const GeoVisualDetails*>(
        &_GeoVisualDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(GeoVisualDetails& a, GeoVisualDetails& b) { a.Swap(&b); }
  inline void Swap(GeoVisualDetails* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoVisualDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoVisualDetails* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoVisualDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoVisualDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoVisualDetails& from) { GeoVisualDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoVisualDetails* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoVisualDetails"; }

 protected:
  explicit GeoVisualDetails(::google::protobuf::Arena* arena);
  GeoVisualDetails(::google::protobuf::Arena* arena, const GeoVisualDetails& from);
  GeoVisualDetails(::google::protobuf::Arena* arena, GeoVisualDetails&& from) noexcept
      : GeoVisualDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFillColorFieldNumber = 1,
    kLineColorFieldNumber = 2,
  };
  // .anduril.type.Color fill_color = 1 [json_name = "fillColor"];
  bool has_fill_color() const;
  void clear_fill_color() ;
  const ::anduril::type::Color& fill_color() const;
  PROTOBUF_NODISCARD ::anduril::type::Color* release_fill_color();
  ::anduril::type::Color* mutable_fill_color();
  void set_allocated_fill_color(::anduril::type::Color* value);
  void unsafe_arena_set_allocated_fill_color(::anduril::type::Color* value);
  ::anduril::type::Color* unsafe_arena_release_fill_color();

  private:
  const ::anduril::type::Color& _internal_fill_color() const;
  ::anduril::type::Color* _internal_mutable_fill_color();

  public:
  // .anduril.type.Color line_color = 2 [json_name = "lineColor"];
  bool has_line_color() const;
  void clear_line_color() ;
  const ::anduril::type::Color& line_color() const;
  PROTOBUF_NODISCARD ::anduril::type::Color* release_line_color();
  ::anduril::type::Color* mutable_line_color();
  void set_allocated_line_color(::anduril::type::Color* value);
  void unsafe_arena_set_allocated_line_color(::anduril::type::Color* value);
  ::anduril::type::Color* unsafe_arena_release_line_color();

  private:
  const ::anduril::type::Color& _internal_line_color() const;
  ::anduril::type::Color* _internal_mutable_line_color();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoVisualDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoVisualDetails_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoVisualDetails& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::type::Color* fill_color_;
    ::anduril::type::Color* line_color_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoPolygonPosition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoPolygonPosition) */ {
 public:
  inline GeoPolygonPosition() : GeoPolygonPosition(nullptr) {}
  ~GeoPolygonPosition() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoPolygonPosition(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoPolygonPosition(const GeoPolygonPosition& from) : GeoPolygonPosition(nullptr, from) {}
  inline GeoPolygonPosition(GeoPolygonPosition&& from) noexcept
      : GeoPolygonPosition(nullptr, std::move(from)) {}
  inline GeoPolygonPosition& operator=(const GeoPolygonPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPolygonPosition& operator=(GeoPolygonPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoPolygonPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoPolygonPosition* internal_default_instance() {
    return reinterpret_cast<const GeoPolygonPosition*>(
        &_GeoPolygonPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GeoPolygonPosition& a, GeoPolygonPosition& b) { a.Swap(&b); }
  inline void Swap(GeoPolygonPosition* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPolygonPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoPolygonPosition* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoPolygonPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoPolygonPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoPolygonPosition& from) { GeoPolygonPosition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoPolygonPosition* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoPolygonPosition"; }

 protected:
  explicit GeoPolygonPosition(::google::protobuf::Arena* arena);
  GeoPolygonPosition(::google::protobuf::Arena* arena, const GeoPolygonPosition& from);
  GeoPolygonPosition(::google::protobuf::Arena* arena, GeoPolygonPosition&& from) noexcept
      : GeoPolygonPosition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kHeightMFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.Position position = 1 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::anduril::entitymanager::v1::Position& position() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Position* release_position();
  ::anduril::entitymanager::v1::Position* mutable_position();
  void set_allocated_position(::anduril::entitymanager::v1::Position* value);
  void unsafe_arena_set_allocated_position(::anduril::entitymanager::v1::Position* value);
  ::anduril::entitymanager::v1::Position* unsafe_arena_release_position();

  private:
  const ::anduril::entitymanager::v1::Position& _internal_position() const;
  ::anduril::entitymanager::v1::Position* _internal_mutable_position();

  public:
  // .google.protobuf.FloatValue height_m = 2 [json_name = "heightM"];
  bool has_height_m() const;
  void clear_height_m() ;
  const ::google::protobuf::FloatValue& height_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::FloatValue* release_height_m();
  ::google::protobuf::FloatValue* mutable_height_m();
  void set_allocated_height_m(::google::protobuf::FloatValue* value);
  void unsafe_arena_set_allocated_height_m(::google::protobuf::FloatValue* value);
  ::google::protobuf::FloatValue* unsafe_arena_release_height_m();

  private:
  const ::google::protobuf::FloatValue& _internal_height_m() const;
  ::google::protobuf::FloatValue* _internal_mutable_height_m();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoPolygonPosition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoPolygonPosition_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoPolygonPosition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Position* position_;
    ::google::protobuf::FloatValue* height_m_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoPoint) */ {
 public:
  inline GeoPoint() : GeoPoint(nullptr) {}
  ~GeoPoint() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoPoint(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoPoint(const GeoPoint& from) : GeoPoint(nullptr, from) {}
  inline GeoPoint(GeoPoint&& from) noexcept
      : GeoPoint(nullptr, std::move(from)) {}
  inline GeoPoint& operator=(const GeoPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPoint& operator=(GeoPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoPoint* internal_default_instance() {
    return reinterpret_cast<const GeoPoint*>(
        &_GeoPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(GeoPoint& a, GeoPoint& b) { a.Swap(&b); }
  inline void Swap(GeoPoint* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoPoint* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoPoint& from) { GeoPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoPoint* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoPoint"; }

 protected:
  explicit GeoPoint(::google::protobuf::Arena* arena);
  GeoPoint(::google::protobuf::Arena* arena, const GeoPoint& from);
  GeoPoint(::google::protobuf::Arena* arena, GeoPoint&& from) noexcept
      : GeoPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
  };
  // .anduril.entitymanager.v1.Position position = 1 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::anduril::entitymanager::v1::Position& position() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Position* release_position();
  ::anduril::entitymanager::v1::Position* mutable_position();
  void set_allocated_position(::anduril::entitymanager::v1::Position* value);
  void unsafe_arena_set_allocated_position(::anduril::entitymanager::v1::Position* value);
  ::anduril::entitymanager::v1::Position* unsafe_arena_release_position();

  private:
  const ::anduril::entitymanager::v1::Position& _internal_position() const;
  ::anduril::entitymanager::v1::Position* _internal_mutable_position();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoPoint_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Position* position_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoLine final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoLine) */ {
 public:
  inline GeoLine() : GeoLine(nullptr) {}
  ~GeoLine() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoLine(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoLine(const GeoLine& from) : GeoLine(nullptr, from) {}
  inline GeoLine(GeoLine&& from) noexcept
      : GeoLine(nullptr, std::move(from)) {}
  inline GeoLine& operator=(const GeoLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoLine& operator=(GeoLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoLine* internal_default_instance() {
    return reinterpret_cast<const GeoLine*>(
        &_GeoLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(GeoLine& a, GeoLine& b) { a.Swap(&b); }
  inline void Swap(GeoLine* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoLine* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoLine* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoLine>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoLine& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoLine& from) { GeoLine::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoLine* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoLine"; }

 protected:
  explicit GeoLine(::google::protobuf::Arena* arena);
  GeoLine(::google::protobuf::Arena* arena, const GeoLine& from);
  GeoLine(::google::protobuf::Arena* arena, GeoLine&& from) noexcept
      : GeoLine(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionsFieldNumber = 1,
  };
  // repeated .anduril.entitymanager.v1.Position positions = 1 [json_name = "positions"];
  int positions_size() const;
  private:
  int _internal_positions_size() const;

  public:
  void clear_positions() ;
  ::anduril::entitymanager::v1::Position* mutable_positions(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* mutable_positions();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& _internal_positions() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* _internal_mutable_positions();
  public:
  const ::anduril::entitymanager::v1::Position& positions(int index) const;
  ::anduril::entitymanager::v1::Position* add_positions();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& positions() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoLine)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoLine_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoLine& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Position > positions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class LinearRing final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.LinearRing) */ {
 public:
  inline LinearRing() : LinearRing(nullptr) {}
  ~LinearRing() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LinearRing(
      ::google::protobuf::internal::ConstantInitialized);

  inline LinearRing(const LinearRing& from) : LinearRing(nullptr, from) {}
  inline LinearRing(LinearRing&& from) noexcept
      : LinearRing(nullptr, std::move(from)) {}
  inline LinearRing& operator=(const LinearRing& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearRing& operator=(LinearRing&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearRing& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearRing* internal_default_instance() {
    return reinterpret_cast<const LinearRing*>(
        &_LinearRing_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(LinearRing& a, LinearRing& b) { a.Swap(&b); }
  inline void Swap(LinearRing* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearRing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearRing* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<LinearRing>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LinearRing& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LinearRing& from) { LinearRing::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LinearRing* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.LinearRing"; }

 protected:
  explicit LinearRing(::google::protobuf::Arena* arena);
  LinearRing(::google::protobuf::Arena* arena, const LinearRing& from);
  LinearRing(::google::protobuf::Arena* arena, LinearRing&& from) noexcept
      : LinearRing(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 1,
    kPositionsFieldNumber = 2,
  };
  // repeated .anduril.entitymanager.v1.Position points = 1 [json_name = "points", deprecated = true];
  [[deprecated]]  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  [[deprecated]]  void clear_points() ;
  [[deprecated]] ::anduril::entitymanager::v1::Position* mutable_points(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* mutable_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* _internal_mutable_points();
  public:
  [[deprecated]] const ::anduril::entitymanager::v1::Position& points(int index) const;
  [[deprecated]] ::anduril::entitymanager::v1::Position* add_points();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& points() const;
  // repeated .anduril.entitymanager.v1.GeoPolygonPosition positions = 2 [json_name = "positions"];
  int positions_size() const;
  private:
  int _internal_positions_size() const;

  public:
  void clear_positions() ;
  ::anduril::entitymanager::v1::GeoPolygonPosition* mutable_positions(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>* mutable_positions();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>& _internal_positions() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>* _internal_mutable_positions();
  public:
  const ::anduril::entitymanager::v1::GeoPolygonPosition& positions(int index) const;
  ::anduril::entitymanager::v1::GeoPolygonPosition* add_positions();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>& positions() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.LinearRing)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LinearRing_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LinearRing& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Position > points_;
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::GeoPolygonPosition > positions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoDetails final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoDetails) */ {
 public:
  inline GeoDetails() : GeoDetails(nullptr) {}
  ~GeoDetails() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoDetails(const GeoDetails& from) : GeoDetails(nullptr, from) {}
  inline GeoDetails(GeoDetails&& from) noexcept
      : GeoDetails(nullptr, std::move(from)) {}
  inline GeoDetails& operator=(const GeoDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoDetails& operator=(GeoDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoDetails& default_instance() {
    return *internal_default_instance();
  }
  enum TypeDetailsCase {
    kEmergency = 2,
    kFscm = 4,
    kControlArea = 5,
    kAcm = 6,
    kMcm = 7,
    TYPE_DETAILS_NOT_SET = 0,
  };
  static inline const GeoDetails* internal_default_instance() {
    return reinterpret_cast<const GeoDetails*>(
        &_GeoDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(GeoDetails& a, GeoDetails& b) { a.Swap(&b); }
  inline void Swap(GeoDetails* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoDetails* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoDetails& from) { GeoDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoDetails* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoDetails"; }

 protected:
  explicit GeoDetails(::google::protobuf::Arena* arena);
  GeoDetails(::google::protobuf::Arena* arena, const GeoDetails& from);
  GeoDetails(::google::protobuf::Arena* arena, GeoDetails&& from) noexcept
      : GeoDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVisualDetailsFieldNumber = 3,
    kTypeFieldNumber = 1,
    kEmergencyFieldNumber = 2,
    kFscmFieldNumber = 4,
    kControlAreaFieldNumber = 5,
    kAcmFieldNumber = 6,
    kMcmFieldNumber = 7,
  };
  // .anduril.entitymanager.v1.GeoVisualDetails visual_details = 3 [json_name = "visualDetails"];
  bool has_visual_details() const;
  void clear_visual_details() ;
  const ::anduril::entitymanager::v1::GeoVisualDetails& visual_details() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoVisualDetails* release_visual_details();
  ::anduril::entitymanager::v1::GeoVisualDetails* mutable_visual_details();
  void set_allocated_visual_details(::anduril::entitymanager::v1::GeoVisualDetails* value);
  void unsafe_arena_set_allocated_visual_details(::anduril::entitymanager::v1::GeoVisualDetails* value);
  ::anduril::entitymanager::v1::GeoVisualDetails* unsafe_arena_release_visual_details();

  private:
  const ::anduril::entitymanager::v1::GeoVisualDetails& _internal_visual_details() const;
  ::anduril::entitymanager::v1::GeoVisualDetails* _internal_mutable_visual_details();

  public:
  // .anduril.entitymanager.v1.GeoType type = 1 [json_name = "type"];
  void clear_type() ;
  ::anduril::entitymanager::v1::GeoType type() const;
  void set_type(::anduril::entitymanager::v1::GeoType value);

  private:
  ::anduril::entitymanager::v1::GeoType _internal_type() const;
  void _internal_set_type(::anduril::entitymanager::v1::GeoType value);

  public:
  // .anduril.entitymanager.v1.EmergencyDetails emergency = 2 [json_name = "emergency"];
  bool has_emergency() const;
  private:
  bool _internal_has_emergency() const;

  public:
  void clear_emergency() ;
  const ::anduril::entitymanager::v1::EmergencyDetails& emergency() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::EmergencyDetails* release_emergency();
  ::anduril::entitymanager::v1::EmergencyDetails* mutable_emergency();
  void set_allocated_emergency(::anduril::entitymanager::v1::EmergencyDetails* value);
  void unsafe_arena_set_allocated_emergency(::anduril::entitymanager::v1::EmergencyDetails* value);
  ::anduril::entitymanager::v1::EmergencyDetails* unsafe_arena_release_emergency();

  private:
  const ::anduril::entitymanager::v1::EmergencyDetails& _internal_emergency() const;
  ::anduril::entitymanager::v1::EmergencyDetails* _internal_mutable_emergency();

  public:
  // .anduril.entitymanager.v1.FSCMDetails fscm = 4 [json_name = "fscm"];
  bool has_fscm() const;
  private:
  bool _internal_has_fscm() const;

  public:
  void clear_fscm() ;
  const ::anduril::entitymanager::v1::FSCMDetails& fscm() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::FSCMDetails* release_fscm();
  ::anduril::entitymanager::v1::FSCMDetails* mutable_fscm();
  void set_allocated_fscm(::anduril::entitymanager::v1::FSCMDetails* value);
  void unsafe_arena_set_allocated_fscm(::anduril::entitymanager::v1::FSCMDetails* value);
  ::anduril::entitymanager::v1::FSCMDetails* unsafe_arena_release_fscm();

  private:
  const ::anduril::entitymanager::v1::FSCMDetails& _internal_fscm() const;
  ::anduril::entitymanager::v1::FSCMDetails* _internal_mutable_fscm();

  public:
  // .anduril.entitymanager.v1.ControlAreaDetails control_area = 5 [json_name = "controlArea"];
  bool has_control_area() const;
  private:
  bool _internal_has_control_area() const;

  public:
  void clear_control_area() ;
  const ::anduril::entitymanager::v1::ControlAreaDetails& control_area() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::ControlAreaDetails* release_control_area();
  ::anduril::entitymanager::v1::ControlAreaDetails* mutable_control_area();
  void set_allocated_control_area(::anduril::entitymanager::v1::ControlAreaDetails* value);
  void unsafe_arena_set_allocated_control_area(::anduril::entitymanager::v1::ControlAreaDetails* value);
  ::anduril::entitymanager::v1::ControlAreaDetails* unsafe_arena_release_control_area();

  private:
  const ::anduril::entitymanager::v1::ControlAreaDetails& _internal_control_area() const;
  ::anduril::entitymanager::v1::ControlAreaDetails* _internal_mutable_control_area();

  public:
  // .anduril.entitymanager.v1.ACMDetails acm = 6 [json_name = "acm"];
  bool has_acm() const;
  private:
  bool _internal_has_acm() const;

  public:
  void clear_acm() ;
  const ::anduril::entitymanager::v1::ACMDetails& acm() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::ACMDetails* release_acm();
  ::anduril::entitymanager::v1::ACMDetails* mutable_acm();
  void set_allocated_acm(::anduril::entitymanager::v1::ACMDetails* value);
  void unsafe_arena_set_allocated_acm(::anduril::entitymanager::v1::ACMDetails* value);
  ::anduril::entitymanager::v1::ACMDetails* unsafe_arena_release_acm();

  private:
  const ::anduril::entitymanager::v1::ACMDetails& _internal_acm() const;
  ::anduril::entitymanager::v1::ACMDetails* _internal_mutable_acm();

  public:
  // .anduril.entitymanager.v1.MCMDetails mcm = 7 [json_name = "mcm"];
  bool has_mcm() const;
  private:
  bool _internal_has_mcm() const;

  public:
  void clear_mcm() ;
  const ::anduril::entitymanager::v1::MCMDetails& mcm() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::MCMDetails* release_mcm();
  ::anduril::entitymanager::v1::MCMDetails* mutable_mcm();
  void set_allocated_mcm(::anduril::entitymanager::v1::MCMDetails* value);
  void unsafe_arena_set_allocated_mcm(::anduril::entitymanager::v1::MCMDetails* value);
  ::anduril::entitymanager::v1::MCMDetails* unsafe_arena_release_mcm();

  private:
  const ::anduril::entitymanager::v1::MCMDetails& _internal_mcm() const;
  ::anduril::entitymanager::v1::MCMDetails* _internal_mutable_mcm();

  public:
  void clear_type_details();
  TypeDetailsCase type_details_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoDetails)
 private:
  class _Internal;
  void set_has_emergency();
  void set_has_fscm();
  void set_has_control_area();
  void set_has_acm();
  void set_has_mcm();
  inline bool has_type_details() const;
  inline void clear_has_type_details();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 7, 6,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoDetails_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoDetails& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::GeoVisualDetails* visual_details_;
    int type_;
    union TypeDetailsUnion {
      constexpr TypeDetailsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::EmergencyDetails* emergency_;
      ::anduril::entitymanager::v1::FSCMDetails* fscm_;
      ::anduril::entitymanager::v1::ControlAreaDetails* control_area_;
      ::anduril::entitymanager::v1::ACMDetails* acm_;
      ::anduril::entitymanager::v1::MCMDetails* mcm_;
    } type_details_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoPolygon final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoPolygon) */ {
 public:
  inline GeoPolygon() : GeoPolygon(nullptr) {}
  ~GeoPolygon() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoPolygon(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoPolygon(const GeoPolygon& from) : GeoPolygon(nullptr, from) {}
  inline GeoPolygon(GeoPolygon&& from) noexcept
      : GeoPolygon(nullptr, std::move(from)) {}
  inline GeoPolygon& operator=(const GeoPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPolygon& operator=(GeoPolygon&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoPolygon& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoPolygon* internal_default_instance() {
    return reinterpret_cast<const GeoPolygon*>(
        &_GeoPolygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(GeoPolygon& a, GeoPolygon& b) { a.Swap(&b); }
  inline void Swap(GeoPolygon* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPolygon* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoPolygon* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoPolygon>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoPolygon& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoPolygon& from) { GeoPolygon::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoPolygon* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoPolygon"; }

 protected:
  explicit GeoPolygon(::google::protobuf::Arena* arena);
  GeoPolygon(::google::protobuf::Arena* arena, const GeoPolygon& from);
  GeoPolygon(::google::protobuf::Arena* arena, GeoPolygon&& from) noexcept
      : GeoPolygon(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRingsFieldNumber = 1,
    kIsRectangleFieldNumber = 2,
  };
  // repeated .anduril.entitymanager.v1.LinearRing rings = 1 [json_name = "rings"];
  int rings_size() const;
  private:
  int _internal_rings_size() const;

  public:
  void clear_rings() ;
  ::anduril::entitymanager::v1::LinearRing* mutable_rings(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>* mutable_rings();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>& _internal_rings() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>* _internal_mutable_rings();
  public:
  const ::anduril::entitymanager::v1::LinearRing& rings(int index) const;
  ::anduril::entitymanager::v1::LinearRing* add_rings();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>& rings() const;
  // bool is_rectangle = 2 [json_name = "isRectangle"];
  void clear_is_rectangle() ;
  bool is_rectangle() const;
  void set_is_rectangle(bool value);

  private:
  bool _internal_is_rectangle() const;
  void _internal_set_is_rectangle(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoPolygon)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoPolygon_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoPolygon& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::LinearRing > rings_;
    bool is_rectangle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class GeoShape final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GeoShape) */ {
 public:
  inline GeoShape() : GeoShape(nullptr) {}
  ~GeoShape() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeoShape(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeoShape(const GeoShape& from) : GeoShape(nullptr, from) {}
  inline GeoShape(GeoShape&& from) noexcept
      : GeoShape(nullptr, std::move(from)) {}
  inline GeoShape& operator=(const GeoShape& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoShape& operator=(GeoShape&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoShape& default_instance() {
    return *internal_default_instance();
  }
  enum ShapeCase {
    kPoint = 1,
    kLine = 2,
    kPolygon = 3,
    kEllipse = 4,
    kEllipsoid = 5,
    SHAPE_NOT_SET = 0,
  };
  static inline const GeoShape* internal_default_instance() {
    return reinterpret_cast<const GeoShape*>(
        &_GeoShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(GeoShape& a, GeoShape& b) { a.Swap(&b); }
  inline void Swap(GeoShape* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoShape* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoShape* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GeoShape>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoShape& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeoShape& from) { GeoShape::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoShape* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GeoShape"; }

 protected:
  explicit GeoShape(::google::protobuf::Arena* arena);
  GeoShape(::google::protobuf::Arena* arena, const GeoShape& from);
  GeoShape(::google::protobuf::Arena* arena, GeoShape&& from) noexcept
      : GeoShape(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointFieldNumber = 1,
    kLineFieldNumber = 2,
    kPolygonFieldNumber = 3,
    kEllipseFieldNumber = 4,
    kEllipsoidFieldNumber = 5,
  };
  // .anduril.entitymanager.v1.GeoPoint point = 1 [json_name = "point"];
  bool has_point() const;
  private:
  bool _internal_has_point() const;

  public:
  void clear_point() ;
  const ::anduril::entitymanager::v1::GeoPoint& point() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoPoint* release_point();
  ::anduril::entitymanager::v1::GeoPoint* mutable_point();
  void set_allocated_point(::anduril::entitymanager::v1::GeoPoint* value);
  void unsafe_arena_set_allocated_point(::anduril::entitymanager::v1::GeoPoint* value);
  ::anduril::entitymanager::v1::GeoPoint* unsafe_arena_release_point();

  private:
  const ::anduril::entitymanager::v1::GeoPoint& _internal_point() const;
  ::anduril::entitymanager::v1::GeoPoint* _internal_mutable_point();

  public:
  // .anduril.entitymanager.v1.GeoLine line = 2 [json_name = "line"];
  bool has_line() const;
  private:
  bool _internal_has_line() const;

  public:
  void clear_line() ;
  const ::anduril::entitymanager::v1::GeoLine& line() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoLine* release_line();
  ::anduril::entitymanager::v1::GeoLine* mutable_line();
  void set_allocated_line(::anduril::entitymanager::v1::GeoLine* value);
  void unsafe_arena_set_allocated_line(::anduril::entitymanager::v1::GeoLine* value);
  ::anduril::entitymanager::v1::GeoLine* unsafe_arena_release_line();

  private:
  const ::anduril::entitymanager::v1::GeoLine& _internal_line() const;
  ::anduril::entitymanager::v1::GeoLine* _internal_mutable_line();

  public:
  // .anduril.entitymanager.v1.GeoPolygon polygon = 3 [json_name = "polygon"];
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;

  public:
  void clear_polygon() ;
  const ::anduril::entitymanager::v1::GeoPolygon& polygon() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoPolygon* release_polygon();
  ::anduril::entitymanager::v1::GeoPolygon* mutable_polygon();
  void set_allocated_polygon(::anduril::entitymanager::v1::GeoPolygon* value);
  void unsafe_arena_set_allocated_polygon(::anduril::entitymanager::v1::GeoPolygon* value);
  ::anduril::entitymanager::v1::GeoPolygon* unsafe_arena_release_polygon();

  private:
  const ::anduril::entitymanager::v1::GeoPolygon& _internal_polygon() const;
  ::anduril::entitymanager::v1::GeoPolygon* _internal_mutable_polygon();

  public:
  // .anduril.entitymanager.v1.GeoEllipse ellipse = 4 [json_name = "ellipse"];
  bool has_ellipse() const;
  private:
  bool _internal_has_ellipse() const;

  public:
  void clear_ellipse() ;
  const ::anduril::entitymanager::v1::GeoEllipse& ellipse() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoEllipse* release_ellipse();
  ::anduril::entitymanager::v1::GeoEllipse* mutable_ellipse();
  void set_allocated_ellipse(::anduril::entitymanager::v1::GeoEllipse* value);
  void unsafe_arena_set_allocated_ellipse(::anduril::entitymanager::v1::GeoEllipse* value);
  ::anduril::entitymanager::v1::GeoEllipse* unsafe_arena_release_ellipse();

  private:
  const ::anduril::entitymanager::v1::GeoEllipse& _internal_ellipse() const;
  ::anduril::entitymanager::v1::GeoEllipse* _internal_mutable_ellipse();

  public:
  // .anduril.entitymanager.v1.GeoEllipsoid ellipsoid = 5 [json_name = "ellipsoid"];
  bool has_ellipsoid() const;
  private:
  bool _internal_has_ellipsoid() const;

  public:
  void clear_ellipsoid() ;
  const ::anduril::entitymanager::v1::GeoEllipsoid& ellipsoid() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoEllipsoid* release_ellipsoid();
  ::anduril::entitymanager::v1::GeoEllipsoid* mutable_ellipsoid();
  void set_allocated_ellipsoid(::anduril::entitymanager::v1::GeoEllipsoid* value);
  void unsafe_arena_set_allocated_ellipsoid(::anduril::entitymanager::v1::GeoEllipsoid* value);
  ::anduril::entitymanager::v1::GeoEllipsoid* unsafe_arena_release_ellipsoid();

  private:
  const ::anduril::entitymanager::v1::GeoEllipsoid& _internal_ellipsoid() const;
  ::anduril::entitymanager::v1::GeoEllipsoid* _internal_mutable_ellipsoid();

  public:
  void clear_shape();
  ShapeCase shape_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GeoShape)
 private:
  class _Internal;
  void set_has_point();
  void set_has_line();
  void set_has_polygon();
  void set_has_ellipse();
  void set_has_ellipsoid();
  inline bool has_shape() const;
  inline void clear_has_shape();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GeoShape_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeoShape& from_msg);
    union ShapeUnion {
      constexpr ShapeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::GeoPoint* point_;
      ::anduril::entitymanager::v1::GeoLine* line_;
      ::anduril::entitymanager::v1::GeoPolygon* polygon_;
      ::anduril::entitymanager::v1::GeoEllipse* ellipse_;
      ::anduril::entitymanager::v1::GeoEllipsoid* ellipsoid_;
    } shape_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GeoDetails

// .anduril.entitymanager.v1.GeoType type = 1 [json_name = "type"];
inline void GeoDetails::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::anduril::entitymanager::v1::GeoType GeoDetails::type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoDetails.type)
  return _internal_type();
}
inline void GeoDetails::set_type(::anduril::entitymanager::v1::GeoType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.GeoDetails.type)
}
inline ::anduril::entitymanager::v1::GeoType GeoDetails::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::GeoType>(_impl_.type_);
}
inline void GeoDetails::_internal_set_type(::anduril::entitymanager::v1::GeoType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .anduril.entitymanager.v1.EmergencyDetails emergency = 2 [json_name = "emergency"];
inline bool GeoDetails::has_emergency() const {
  return type_details_case() == kEmergency;
}
inline bool GeoDetails::_internal_has_emergency() const {
  return type_details_case() == kEmergency;
}
inline void GeoDetails::set_has_emergency() {
  _impl_._oneof_case_[0] = kEmergency;
}
inline void GeoDetails::clear_emergency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_details_case() == kEmergency) {
    if (GetArena() == nullptr) {
      delete _impl_.type_details_.emergency_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_details_.emergency_);
    }
    clear_has_type_details();
  }
}
inline ::anduril::entitymanager::v1::EmergencyDetails* GeoDetails::release_emergency() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoDetails.emergency)
  if (type_details_case() == kEmergency) {
    clear_has_type_details();
    auto* temp = _impl_.type_details_.emergency_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_details_.emergency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::EmergencyDetails& GeoDetails::_internal_emergency() const {
  return type_details_case() == kEmergency ? *_impl_.type_details_.emergency_ : reinterpret_cast<::anduril::entitymanager::v1::EmergencyDetails&>(::anduril::entitymanager::v1::_EmergencyDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::EmergencyDetails& GeoDetails::emergency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoDetails.emergency)
  return _internal_emergency();
}
inline ::anduril::entitymanager::v1::EmergencyDetails* GeoDetails::unsafe_arena_release_emergency() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoDetails.emergency)
  if (type_details_case() == kEmergency) {
    clear_has_type_details();
    auto* temp = _impl_.type_details_.emergency_;
    _impl_.type_details_.emergency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoDetails::unsafe_arena_set_allocated_emergency(::anduril::entitymanager::v1::EmergencyDetails* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type_details();
  if (value) {
    set_has_emergency();
    _impl_.type_details_.emergency_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoDetails.emergency)
}
inline ::anduril::entitymanager::v1::EmergencyDetails* GeoDetails::_internal_mutable_emergency() {
  if (type_details_case() != kEmergency) {
    clear_type_details();
    set_has_emergency();
    _impl_.type_details_.emergency_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::EmergencyDetails>(GetArena());
  }
  return _impl_.type_details_.emergency_;
}
inline ::anduril::entitymanager::v1::EmergencyDetails* GeoDetails::mutable_emergency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::EmergencyDetails* _msg = _internal_mutable_emergency();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoDetails.emergency)
  return _msg;
}

// .anduril.entitymanager.v1.FSCMDetails fscm = 4 [json_name = "fscm"];
inline bool GeoDetails::has_fscm() const {
  return type_details_case() == kFscm;
}
inline bool GeoDetails::_internal_has_fscm() const {
  return type_details_case() == kFscm;
}
inline void GeoDetails::set_has_fscm() {
  _impl_._oneof_case_[0] = kFscm;
}
inline void GeoDetails::clear_fscm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_details_case() == kFscm) {
    if (GetArena() == nullptr) {
      delete _impl_.type_details_.fscm_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_details_.fscm_);
    }
    clear_has_type_details();
  }
}
inline ::anduril::entitymanager::v1::FSCMDetails* GeoDetails::release_fscm() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoDetails.fscm)
  if (type_details_case() == kFscm) {
    clear_has_type_details();
    auto* temp = _impl_.type_details_.fscm_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_details_.fscm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::FSCMDetails& GeoDetails::_internal_fscm() const {
  return type_details_case() == kFscm ? *_impl_.type_details_.fscm_ : reinterpret_cast<::anduril::entitymanager::v1::FSCMDetails&>(::anduril::entitymanager::v1::_FSCMDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::FSCMDetails& GeoDetails::fscm() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoDetails.fscm)
  return _internal_fscm();
}
inline ::anduril::entitymanager::v1::FSCMDetails* GeoDetails::unsafe_arena_release_fscm() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoDetails.fscm)
  if (type_details_case() == kFscm) {
    clear_has_type_details();
    auto* temp = _impl_.type_details_.fscm_;
    _impl_.type_details_.fscm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoDetails::unsafe_arena_set_allocated_fscm(::anduril::entitymanager::v1::FSCMDetails* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type_details();
  if (value) {
    set_has_fscm();
    _impl_.type_details_.fscm_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoDetails.fscm)
}
inline ::anduril::entitymanager::v1::FSCMDetails* GeoDetails::_internal_mutable_fscm() {
  if (type_details_case() != kFscm) {
    clear_type_details();
    set_has_fscm();
    _impl_.type_details_.fscm_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::FSCMDetails>(GetArena());
  }
  return _impl_.type_details_.fscm_;
}
inline ::anduril::entitymanager::v1::FSCMDetails* GeoDetails::mutable_fscm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::FSCMDetails* _msg = _internal_mutable_fscm();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoDetails.fscm)
  return _msg;
}

// .anduril.entitymanager.v1.ControlAreaDetails control_area = 5 [json_name = "controlArea"];
inline bool GeoDetails::has_control_area() const {
  return type_details_case() == kControlArea;
}
inline bool GeoDetails::_internal_has_control_area() const {
  return type_details_case() == kControlArea;
}
inline void GeoDetails::set_has_control_area() {
  _impl_._oneof_case_[0] = kControlArea;
}
inline void GeoDetails::clear_control_area() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_details_case() == kControlArea) {
    if (GetArena() == nullptr) {
      delete _impl_.type_details_.control_area_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_details_.control_area_);
    }
    clear_has_type_details();
  }
}
inline ::anduril::entitymanager::v1::ControlAreaDetails* GeoDetails::release_control_area() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoDetails.control_area)
  if (type_details_case() == kControlArea) {
    clear_has_type_details();
    auto* temp = _impl_.type_details_.control_area_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_details_.control_area_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::ControlAreaDetails& GeoDetails::_internal_control_area() const {
  return type_details_case() == kControlArea ? *_impl_.type_details_.control_area_ : reinterpret_cast<::anduril::entitymanager::v1::ControlAreaDetails&>(::anduril::entitymanager::v1::_ControlAreaDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::ControlAreaDetails& GeoDetails::control_area() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoDetails.control_area)
  return _internal_control_area();
}
inline ::anduril::entitymanager::v1::ControlAreaDetails* GeoDetails::unsafe_arena_release_control_area() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoDetails.control_area)
  if (type_details_case() == kControlArea) {
    clear_has_type_details();
    auto* temp = _impl_.type_details_.control_area_;
    _impl_.type_details_.control_area_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoDetails::unsafe_arena_set_allocated_control_area(::anduril::entitymanager::v1::ControlAreaDetails* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type_details();
  if (value) {
    set_has_control_area();
    _impl_.type_details_.control_area_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoDetails.control_area)
}
inline ::anduril::entitymanager::v1::ControlAreaDetails* GeoDetails::_internal_mutable_control_area() {
  if (type_details_case() != kControlArea) {
    clear_type_details();
    set_has_control_area();
    _impl_.type_details_.control_area_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::ControlAreaDetails>(GetArena());
  }
  return _impl_.type_details_.control_area_;
}
inline ::anduril::entitymanager::v1::ControlAreaDetails* GeoDetails::mutable_control_area() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::ControlAreaDetails* _msg = _internal_mutable_control_area();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoDetails.control_area)
  return _msg;
}

// .anduril.entitymanager.v1.ACMDetails acm = 6 [json_name = "acm"];
inline bool GeoDetails::has_acm() const {
  return type_details_case() == kAcm;
}
inline bool GeoDetails::_internal_has_acm() const {
  return type_details_case() == kAcm;
}
inline void GeoDetails::set_has_acm() {
  _impl_._oneof_case_[0] = kAcm;
}
inline void GeoDetails::clear_acm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_details_case() == kAcm) {
    if (GetArena() == nullptr) {
      delete _impl_.type_details_.acm_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_details_.acm_);
    }
    clear_has_type_details();
  }
}
inline ::anduril::entitymanager::v1::ACMDetails* GeoDetails::release_acm() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoDetails.acm)
  if (type_details_case() == kAcm) {
    clear_has_type_details();
    auto* temp = _impl_.type_details_.acm_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_details_.acm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::ACMDetails& GeoDetails::_internal_acm() const {
  return type_details_case() == kAcm ? *_impl_.type_details_.acm_ : reinterpret_cast<::anduril::entitymanager::v1::ACMDetails&>(::anduril::entitymanager::v1::_ACMDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::ACMDetails& GeoDetails::acm() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoDetails.acm)
  return _internal_acm();
}
inline ::anduril::entitymanager::v1::ACMDetails* GeoDetails::unsafe_arena_release_acm() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoDetails.acm)
  if (type_details_case() == kAcm) {
    clear_has_type_details();
    auto* temp = _impl_.type_details_.acm_;
    _impl_.type_details_.acm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoDetails::unsafe_arena_set_allocated_acm(::anduril::entitymanager::v1::ACMDetails* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type_details();
  if (value) {
    set_has_acm();
    _impl_.type_details_.acm_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoDetails.acm)
}
inline ::anduril::entitymanager::v1::ACMDetails* GeoDetails::_internal_mutable_acm() {
  if (type_details_case() != kAcm) {
    clear_type_details();
    set_has_acm();
    _impl_.type_details_.acm_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::ACMDetails>(GetArena());
  }
  return _impl_.type_details_.acm_;
}
inline ::anduril::entitymanager::v1::ACMDetails* GeoDetails::mutable_acm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::ACMDetails* _msg = _internal_mutable_acm();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoDetails.acm)
  return _msg;
}

// .anduril.entitymanager.v1.MCMDetails mcm = 7 [json_name = "mcm"];
inline bool GeoDetails::has_mcm() const {
  return type_details_case() == kMcm;
}
inline bool GeoDetails::_internal_has_mcm() const {
  return type_details_case() == kMcm;
}
inline void GeoDetails::set_has_mcm() {
  _impl_._oneof_case_[0] = kMcm;
}
inline void GeoDetails::clear_mcm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_details_case() == kMcm) {
    if (GetArena() == nullptr) {
      delete _impl_.type_details_.mcm_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_details_.mcm_);
    }
    clear_has_type_details();
  }
}
inline ::anduril::entitymanager::v1::MCMDetails* GeoDetails::release_mcm() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoDetails.mcm)
  if (type_details_case() == kMcm) {
    clear_has_type_details();
    auto* temp = _impl_.type_details_.mcm_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_details_.mcm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::MCMDetails& GeoDetails::_internal_mcm() const {
  return type_details_case() == kMcm ? *_impl_.type_details_.mcm_ : reinterpret_cast<::anduril::entitymanager::v1::MCMDetails&>(::anduril::entitymanager::v1::_MCMDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::MCMDetails& GeoDetails::mcm() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoDetails.mcm)
  return _internal_mcm();
}
inline ::anduril::entitymanager::v1::MCMDetails* GeoDetails::unsafe_arena_release_mcm() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoDetails.mcm)
  if (type_details_case() == kMcm) {
    clear_has_type_details();
    auto* temp = _impl_.type_details_.mcm_;
    _impl_.type_details_.mcm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoDetails::unsafe_arena_set_allocated_mcm(::anduril::entitymanager::v1::MCMDetails* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type_details();
  if (value) {
    set_has_mcm();
    _impl_.type_details_.mcm_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoDetails.mcm)
}
inline ::anduril::entitymanager::v1::MCMDetails* GeoDetails::_internal_mutable_mcm() {
  if (type_details_case() != kMcm) {
    clear_type_details();
    set_has_mcm();
    _impl_.type_details_.mcm_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::MCMDetails>(GetArena());
  }
  return _impl_.type_details_.mcm_;
}
inline ::anduril::entitymanager::v1::MCMDetails* GeoDetails::mutable_mcm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::MCMDetails* _msg = _internal_mutable_mcm();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoDetails.mcm)
  return _msg;
}

// .anduril.entitymanager.v1.GeoVisualDetails visual_details = 3 [json_name = "visualDetails"];
inline bool GeoDetails::has_visual_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.visual_details_ != nullptr);
  return value;
}
inline void GeoDetails::clear_visual_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.visual_details_ != nullptr) _impl_.visual_details_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::GeoVisualDetails& GeoDetails::_internal_visual_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::GeoVisualDetails* p = _impl_.visual_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::GeoVisualDetails&>(::anduril::entitymanager::v1::_GeoVisualDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoVisualDetails& GeoDetails::visual_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoDetails.visual_details)
  return _internal_visual_details();
}
inline void GeoDetails::unsafe_arena_set_allocated_visual_details(::anduril::entitymanager::v1::GeoVisualDetails* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.visual_details_);
  }
  _impl_.visual_details_ = reinterpret_cast<::anduril::entitymanager::v1::GeoVisualDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoDetails.visual_details)
}
inline ::anduril::entitymanager::v1::GeoVisualDetails* GeoDetails::release_visual_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::GeoVisualDetails* released = _impl_.visual_details_;
  _impl_.visual_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::GeoVisualDetails* GeoDetails::unsafe_arena_release_visual_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoDetails.visual_details)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::GeoVisualDetails* temp = _impl_.visual_details_;
  _impl_.visual_details_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::GeoVisualDetails* GeoDetails::_internal_mutable_visual_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.visual_details_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoVisualDetails>(GetArena());
    _impl_.visual_details_ = reinterpret_cast<::anduril::entitymanager::v1::GeoVisualDetails*>(p);
  }
  return _impl_.visual_details_;
}
inline ::anduril::entitymanager::v1::GeoVisualDetails* GeoDetails::mutable_visual_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::GeoVisualDetails* _msg = _internal_mutable_visual_details();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoDetails.visual_details)
  return _msg;
}
inline void GeoDetails::set_allocated_visual_details(::anduril::entitymanager::v1::GeoVisualDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.visual_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.visual_details_ = reinterpret_cast<::anduril::entitymanager::v1::GeoVisualDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoDetails.visual_details)
}

inline bool GeoDetails::has_type_details() const {
  return type_details_case() != TYPE_DETAILS_NOT_SET;
}
inline void GeoDetails::clear_has_type_details() {
  _impl_._oneof_case_[0] = TYPE_DETAILS_NOT_SET;
}
inline GeoDetails::TypeDetailsCase GeoDetails::type_details_case() const {
  return GeoDetails::TypeDetailsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EmergencyDetails

// .anduril.entitymanager.v1.EmergencyType emergency_type = 1 [json_name = "emergencyType"];
inline void EmergencyDetails::clear_emergency_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emergency_type_ = 0;
}
inline ::anduril::entitymanager::v1::EmergencyType EmergencyDetails::emergency_type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.EmergencyDetails.emergency_type)
  return _internal_emergency_type();
}
inline void EmergencyDetails::set_emergency_type(::anduril::entitymanager::v1::EmergencyType value) {
  _internal_set_emergency_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.EmergencyDetails.emergency_type)
}
inline ::anduril::entitymanager::v1::EmergencyType EmergencyDetails::_internal_emergency_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::EmergencyType>(_impl_.emergency_type_);
}
inline void EmergencyDetails::_internal_set_emergency_type(::anduril::entitymanager::v1::EmergencyType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emergency_type_ = value;
}

// uint32 personnel_involved = 2 [json_name = "personnelInvolved"];
inline void EmergencyDetails::clear_personnel_involved() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.personnel_involved_ = 0u;
}
inline ::uint32_t EmergencyDetails::personnel_involved() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.EmergencyDetails.personnel_involved)
  return _internal_personnel_involved();
}
inline void EmergencyDetails::set_personnel_involved(::uint32_t value) {
  _internal_set_personnel_involved(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.EmergencyDetails.personnel_involved)
}
inline ::uint32_t EmergencyDetails::_internal_personnel_involved() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.personnel_involved_;
}
inline void EmergencyDetails::_internal_set_personnel_involved(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.personnel_involved_ = value;
}

// -------------------------------------------------------------------

// GeoShape

// .anduril.entitymanager.v1.GeoPoint point = 1 [json_name = "point"];
inline bool GeoShape::has_point() const {
  return shape_case() == kPoint;
}
inline bool GeoShape::_internal_has_point() const {
  return shape_case() == kPoint;
}
inline void GeoShape::set_has_point() {
  _impl_._oneof_case_[0] = kPoint;
}
inline void GeoShape::clear_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (shape_case() == kPoint) {
    if (GetArena() == nullptr) {
      delete _impl_.shape_.point_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.shape_.point_);
    }
    clear_has_shape();
  }
}
inline ::anduril::entitymanager::v1::GeoPoint* GeoShape::release_point() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoShape.point)
  if (shape_case() == kPoint) {
    clear_has_shape();
    auto* temp = _impl_.shape_.point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoPoint& GeoShape::_internal_point() const {
  return shape_case() == kPoint ? *_impl_.shape_.point_ : reinterpret_cast<::anduril::entitymanager::v1::GeoPoint&>(::anduril::entitymanager::v1::_GeoPoint_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoPoint& GeoShape::point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoShape.point)
  return _internal_point();
}
inline ::anduril::entitymanager::v1::GeoPoint* GeoShape::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoShape.point)
  if (shape_case() == kPoint) {
    clear_has_shape();
    auto* temp = _impl_.shape_.point_;
    _impl_.shape_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoShape::unsafe_arena_set_allocated_point(::anduril::entitymanager::v1::GeoPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_shape();
  if (value) {
    set_has_point();
    _impl_.shape_.point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoShape.point)
}
inline ::anduril::entitymanager::v1::GeoPoint* GeoShape::_internal_mutable_point() {
  if (shape_case() != kPoint) {
    clear_shape();
    set_has_point();
    _impl_.shape_.point_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoPoint>(GetArena());
  }
  return _impl_.shape_.point_;
}
inline ::anduril::entitymanager::v1::GeoPoint* GeoShape::mutable_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoPoint* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoShape.point)
  return _msg;
}

// .anduril.entitymanager.v1.GeoLine line = 2 [json_name = "line"];
inline bool GeoShape::has_line() const {
  return shape_case() == kLine;
}
inline bool GeoShape::_internal_has_line() const {
  return shape_case() == kLine;
}
inline void GeoShape::set_has_line() {
  _impl_._oneof_case_[0] = kLine;
}
inline void GeoShape::clear_line() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (shape_case() == kLine) {
    if (GetArena() == nullptr) {
      delete _impl_.shape_.line_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.shape_.line_);
    }
    clear_has_shape();
  }
}
inline ::anduril::entitymanager::v1::GeoLine* GeoShape::release_line() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoShape.line)
  if (shape_case() == kLine) {
    clear_has_shape();
    auto* temp = _impl_.shape_.line_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoLine& GeoShape::_internal_line() const {
  return shape_case() == kLine ? *_impl_.shape_.line_ : reinterpret_cast<::anduril::entitymanager::v1::GeoLine&>(::anduril::entitymanager::v1::_GeoLine_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoLine& GeoShape::line() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoShape.line)
  return _internal_line();
}
inline ::anduril::entitymanager::v1::GeoLine* GeoShape::unsafe_arena_release_line() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoShape.line)
  if (shape_case() == kLine) {
    clear_has_shape();
    auto* temp = _impl_.shape_.line_;
    _impl_.shape_.line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoShape::unsafe_arena_set_allocated_line(::anduril::entitymanager::v1::GeoLine* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_shape();
  if (value) {
    set_has_line();
    _impl_.shape_.line_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoShape.line)
}
inline ::anduril::entitymanager::v1::GeoLine* GeoShape::_internal_mutable_line() {
  if (shape_case() != kLine) {
    clear_shape();
    set_has_line();
    _impl_.shape_.line_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoLine>(GetArena());
  }
  return _impl_.shape_.line_;
}
inline ::anduril::entitymanager::v1::GeoLine* GeoShape::mutable_line() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoLine* _msg = _internal_mutable_line();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoShape.line)
  return _msg;
}

// .anduril.entitymanager.v1.GeoPolygon polygon = 3 [json_name = "polygon"];
inline bool GeoShape::has_polygon() const {
  return shape_case() == kPolygon;
}
inline bool GeoShape::_internal_has_polygon() const {
  return shape_case() == kPolygon;
}
inline void GeoShape::set_has_polygon() {
  _impl_._oneof_case_[0] = kPolygon;
}
inline void GeoShape::clear_polygon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (shape_case() == kPolygon) {
    if (GetArena() == nullptr) {
      delete _impl_.shape_.polygon_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.shape_.polygon_);
    }
    clear_has_shape();
  }
}
inline ::anduril::entitymanager::v1::GeoPolygon* GeoShape::release_polygon() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoShape.polygon)
  if (shape_case() == kPolygon) {
    clear_has_shape();
    auto* temp = _impl_.shape_.polygon_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoPolygon& GeoShape::_internal_polygon() const {
  return shape_case() == kPolygon ? *_impl_.shape_.polygon_ : reinterpret_cast<::anduril::entitymanager::v1::GeoPolygon&>(::anduril::entitymanager::v1::_GeoPolygon_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoPolygon& GeoShape::polygon() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoShape.polygon)
  return _internal_polygon();
}
inline ::anduril::entitymanager::v1::GeoPolygon* GeoShape::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoShape.polygon)
  if (shape_case() == kPolygon) {
    clear_has_shape();
    auto* temp = _impl_.shape_.polygon_;
    _impl_.shape_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoShape::unsafe_arena_set_allocated_polygon(::anduril::entitymanager::v1::GeoPolygon* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_shape();
  if (value) {
    set_has_polygon();
    _impl_.shape_.polygon_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoShape.polygon)
}
inline ::anduril::entitymanager::v1::GeoPolygon* GeoShape::_internal_mutable_polygon() {
  if (shape_case() != kPolygon) {
    clear_shape();
    set_has_polygon();
    _impl_.shape_.polygon_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoPolygon>(GetArena());
  }
  return _impl_.shape_.polygon_;
}
inline ::anduril::entitymanager::v1::GeoPolygon* GeoShape::mutable_polygon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoPolygon* _msg = _internal_mutable_polygon();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoShape.polygon)
  return _msg;
}

// .anduril.entitymanager.v1.GeoEllipse ellipse = 4 [json_name = "ellipse"];
inline bool GeoShape::has_ellipse() const {
  return shape_case() == kEllipse;
}
inline bool GeoShape::_internal_has_ellipse() const {
  return shape_case() == kEllipse;
}
inline void GeoShape::set_has_ellipse() {
  _impl_._oneof_case_[0] = kEllipse;
}
inline void GeoShape::clear_ellipse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (shape_case() == kEllipse) {
    if (GetArena() == nullptr) {
      delete _impl_.shape_.ellipse_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.shape_.ellipse_);
    }
    clear_has_shape();
  }
}
inline ::anduril::entitymanager::v1::GeoEllipse* GeoShape::release_ellipse() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoShape.ellipse)
  if (shape_case() == kEllipse) {
    clear_has_shape();
    auto* temp = _impl_.shape_.ellipse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.ellipse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoEllipse& GeoShape::_internal_ellipse() const {
  return shape_case() == kEllipse ? *_impl_.shape_.ellipse_ : reinterpret_cast<::anduril::entitymanager::v1::GeoEllipse&>(::anduril::entitymanager::v1::_GeoEllipse_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoEllipse& GeoShape::ellipse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoShape.ellipse)
  return _internal_ellipse();
}
inline ::anduril::entitymanager::v1::GeoEllipse* GeoShape::unsafe_arena_release_ellipse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoShape.ellipse)
  if (shape_case() == kEllipse) {
    clear_has_shape();
    auto* temp = _impl_.shape_.ellipse_;
    _impl_.shape_.ellipse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoShape::unsafe_arena_set_allocated_ellipse(::anduril::entitymanager::v1::GeoEllipse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_shape();
  if (value) {
    set_has_ellipse();
    _impl_.shape_.ellipse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoShape.ellipse)
}
inline ::anduril::entitymanager::v1::GeoEllipse* GeoShape::_internal_mutable_ellipse() {
  if (shape_case() != kEllipse) {
    clear_shape();
    set_has_ellipse();
    _impl_.shape_.ellipse_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoEllipse>(GetArena());
  }
  return _impl_.shape_.ellipse_;
}
inline ::anduril::entitymanager::v1::GeoEllipse* GeoShape::mutable_ellipse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoEllipse* _msg = _internal_mutable_ellipse();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoShape.ellipse)
  return _msg;
}

// .anduril.entitymanager.v1.GeoEllipsoid ellipsoid = 5 [json_name = "ellipsoid"];
inline bool GeoShape::has_ellipsoid() const {
  return shape_case() == kEllipsoid;
}
inline bool GeoShape::_internal_has_ellipsoid() const {
  return shape_case() == kEllipsoid;
}
inline void GeoShape::set_has_ellipsoid() {
  _impl_._oneof_case_[0] = kEllipsoid;
}
inline void GeoShape::clear_ellipsoid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (shape_case() == kEllipsoid) {
    if (GetArena() == nullptr) {
      delete _impl_.shape_.ellipsoid_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.shape_.ellipsoid_);
    }
    clear_has_shape();
  }
}
inline ::anduril::entitymanager::v1::GeoEllipsoid* GeoShape::release_ellipsoid() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoShape.ellipsoid)
  if (shape_case() == kEllipsoid) {
    clear_has_shape();
    auto* temp = _impl_.shape_.ellipsoid_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_.ellipsoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GeoEllipsoid& GeoShape::_internal_ellipsoid() const {
  return shape_case() == kEllipsoid ? *_impl_.shape_.ellipsoid_ : reinterpret_cast<::anduril::entitymanager::v1::GeoEllipsoid&>(::anduril::entitymanager::v1::_GeoEllipsoid_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoEllipsoid& GeoShape::ellipsoid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoShape.ellipsoid)
  return _internal_ellipsoid();
}
inline ::anduril::entitymanager::v1::GeoEllipsoid* GeoShape::unsafe_arena_release_ellipsoid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.GeoShape.ellipsoid)
  if (shape_case() == kEllipsoid) {
    clear_has_shape();
    auto* temp = _impl_.shape_.ellipsoid_;
    _impl_.shape_.ellipsoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GeoShape::unsafe_arena_set_allocated_ellipsoid(::anduril::entitymanager::v1::GeoEllipsoid* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_shape();
  if (value) {
    set_has_ellipsoid();
    _impl_.shape_.ellipsoid_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoShape.ellipsoid)
}
inline ::anduril::entitymanager::v1::GeoEllipsoid* GeoShape::_internal_mutable_ellipsoid() {
  if (shape_case() != kEllipsoid) {
    clear_shape();
    set_has_ellipsoid();
    _impl_.shape_.ellipsoid_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoEllipsoid>(GetArena());
  }
  return _impl_.shape_.ellipsoid_;
}
inline ::anduril::entitymanager::v1::GeoEllipsoid* GeoShape::mutable_ellipsoid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoEllipsoid* _msg = _internal_mutable_ellipsoid();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoShape.ellipsoid)
  return _msg;
}

inline bool GeoShape::has_shape() const {
  return shape_case() != SHAPE_NOT_SET;
}
inline void GeoShape::clear_has_shape() {
  _impl_._oneof_case_[0] = SHAPE_NOT_SET;
}
inline GeoShape::ShapeCase GeoShape::shape_case() const {
  return GeoShape::ShapeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GeoPoint

// .anduril.entitymanager.v1.Position position = 1 [json_name = "position"];
inline bool GeoPoint::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Position& GeoPoint::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Position&>(::anduril::entitymanager::v1::_Position_default_instance_);
}
inline const ::anduril::entitymanager::v1::Position& GeoPoint::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoPoint.position)
  return _internal_position();
}
inline void GeoPoint::unsafe_arena_set_allocated_position(::anduril::entitymanager::v1::Position* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoPoint.position)
}
inline ::anduril::entitymanager::v1::Position* GeoPoint::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Position* GeoPoint::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoPoint.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Position* GeoPoint::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::anduril::entitymanager::v1::Position* GeoPoint::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoPoint.position)
  return _msg;
}
inline void GeoPoint::set_allocated_position(::anduril::entitymanager::v1::Position* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoPoint.position)
}

// -------------------------------------------------------------------

// GeoLine

// repeated .anduril.entitymanager.v1.Position positions = 1 [json_name = "positions"];
inline int GeoLine::_internal_positions_size() const {
  return _internal_positions().size();
}
inline int GeoLine::positions_size() const {
  return _internal_positions_size();
}
inline ::anduril::entitymanager::v1::Position* GeoLine::mutable_positions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoLine.positions)
  return _internal_mutable_positions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* GeoLine::mutable_positions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.GeoLine.positions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positions();
}
inline const ::anduril::entitymanager::v1::Position& GeoLine::positions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoLine.positions)
  return _internal_positions().Get(index);
}
inline ::anduril::entitymanager::v1::Position* GeoLine::add_positions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::Position* _add = _internal_mutable_positions()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.GeoLine.positions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& GeoLine::positions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.GeoLine.positions)
  return _internal_positions();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>&
GeoLine::_internal_positions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positions_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>*
GeoLine::_internal_mutable_positions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positions_;
}

// -------------------------------------------------------------------

// GeoPolygon

// repeated .anduril.entitymanager.v1.LinearRing rings = 1 [json_name = "rings"];
inline int GeoPolygon::_internal_rings_size() const {
  return _internal_rings().size();
}
inline int GeoPolygon::rings_size() const {
  return _internal_rings_size();
}
inline void GeoPolygon::clear_rings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rings_.Clear();
}
inline ::anduril::entitymanager::v1::LinearRing* GeoPolygon::mutable_rings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoPolygon.rings)
  return _internal_mutable_rings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>* GeoPolygon::mutable_rings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.GeoPolygon.rings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_rings();
}
inline const ::anduril::entitymanager::v1::LinearRing& GeoPolygon::rings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoPolygon.rings)
  return _internal_rings().Get(index);
}
inline ::anduril::entitymanager::v1::LinearRing* GeoPolygon::add_rings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::LinearRing* _add = _internal_mutable_rings()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.GeoPolygon.rings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>& GeoPolygon::rings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.GeoPolygon.rings)
  return _internal_rings();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>&
GeoPolygon::_internal_rings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rings_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::LinearRing>*
GeoPolygon::_internal_mutable_rings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.rings_;
}

// bool is_rectangle = 2 [json_name = "isRectangle"];
inline void GeoPolygon::clear_is_rectangle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_rectangle_ = false;
}
inline bool GeoPolygon::is_rectangle() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoPolygon.is_rectangle)
  return _internal_is_rectangle();
}
inline void GeoPolygon::set_is_rectangle(bool value) {
  _internal_set_is_rectangle(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.GeoPolygon.is_rectangle)
}
inline bool GeoPolygon::_internal_is_rectangle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_rectangle_;
}
inline void GeoPolygon::_internal_set_is_rectangle(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_rectangle_ = value;
}

// -------------------------------------------------------------------

// GeoEllipse

// .google.protobuf.DoubleValue semi_major_axis_m = 2 [json_name = "semiMajorAxisM"];
inline bool GeoEllipse::has_semi_major_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.semi_major_axis_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::_internal_semi_major_axis_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.semi_major_axis_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::semi_major_axis_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipse.semi_major_axis_m)
  return _internal_semi_major_axis_m();
}
inline void GeoEllipse::unsafe_arena_set_allocated_semi_major_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.semi_major_axis_m_);
  }
  _impl_.semi_major_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipse.semi_major_axis_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipse::release_semi_major_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.semi_major_axis_m_;
  _impl_.semi_major_axis_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::unsafe_arena_release_semi_major_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipse.semi_major_axis_m)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.semi_major_axis_m_;
  _impl_.semi_major_axis_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::_internal_mutable_semi_major_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.semi_major_axis_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.semi_major_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.semi_major_axis_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::mutable_semi_major_axis_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_semi_major_axis_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipse.semi_major_axis_m)
  return _msg;
}
inline void GeoEllipse::set_allocated_semi_major_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.semi_major_axis_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.semi_major_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipse.semi_major_axis_m)
}

// .google.protobuf.DoubleValue semi_minor_axis_m = 3 [json_name = "semiMinorAxisM"];
inline bool GeoEllipse::has_semi_minor_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.semi_minor_axis_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::_internal_semi_minor_axis_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.semi_minor_axis_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::semi_minor_axis_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipse.semi_minor_axis_m)
  return _internal_semi_minor_axis_m();
}
inline void GeoEllipse::unsafe_arena_set_allocated_semi_minor_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.semi_minor_axis_m_);
  }
  _impl_.semi_minor_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipse.semi_minor_axis_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipse::release_semi_minor_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* released = _impl_.semi_minor_axis_m_;
  _impl_.semi_minor_axis_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::unsafe_arena_release_semi_minor_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipse.semi_minor_axis_m)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* temp = _impl_.semi_minor_axis_m_;
  _impl_.semi_minor_axis_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::_internal_mutable_semi_minor_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.semi_minor_axis_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.semi_minor_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.semi_minor_axis_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::mutable_semi_minor_axis_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_semi_minor_axis_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipse.semi_minor_axis_m)
  return _msg;
}
inline void GeoEllipse::set_allocated_semi_minor_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.semi_minor_axis_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.semi_minor_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipse.semi_minor_axis_m)
}

// .google.protobuf.DoubleValue orientation_d = 4 [json_name = "orientationD"];
inline bool GeoEllipse::has_orientation_d() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_d_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::_internal_orientation_d() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.orientation_d_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::orientation_d() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipse.orientation_d)
  return _internal_orientation_d();
}
inline void GeoEllipse::unsafe_arena_set_allocated_orientation_d(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_d_);
  }
  _impl_.orientation_d_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipse.orientation_d)
}
inline ::google::protobuf::DoubleValue* GeoEllipse::release_orientation_d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::DoubleValue* released = _impl_.orientation_d_;
  _impl_.orientation_d_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::unsafe_arena_release_orientation_d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipse.orientation_d)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::DoubleValue* temp = _impl_.orientation_d_;
  _impl_.orientation_d_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::_internal_mutable_orientation_d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_d_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.orientation_d_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.orientation_d_;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::mutable_orientation_d() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_orientation_d();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipse.orientation_d)
  return _msg;
}
inline void GeoEllipse::set_allocated_orientation_d(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_d_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.orientation_d_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipse.orientation_d)
}

// .google.protobuf.DoubleValue height_m = 5 [json_name = "heightM"];
inline bool GeoEllipse::has_height_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.height_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::_internal_height_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.height_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipse::height_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipse.height_m)
  return _internal_height_m();
}
inline void GeoEllipse::unsafe_arena_set_allocated_height_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_m_);
  }
  _impl_.height_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipse.height_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipse::release_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::DoubleValue* released = _impl_.height_m_;
  _impl_.height_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::unsafe_arena_release_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipse.height_m)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::DoubleValue* temp = _impl_.height_m_;
  _impl_.height_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::_internal_mutable_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.height_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.height_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.height_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipse::mutable_height_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_height_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipse.height_m)
  return _msg;
}
inline void GeoEllipse::set_allocated_height_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.height_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipse.height_m)
}

// -------------------------------------------------------------------

// GeoEllipsoid

// .google.protobuf.DoubleValue forward_axis_m = 1 [json_name = "forwardAxisM"];
inline bool GeoEllipsoid::has_forward_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_axis_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::_internal_forward_axis_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.forward_axis_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::forward_axis_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipsoid.forward_axis_m)
  return _internal_forward_axis_m();
}
inline void GeoEllipsoid::unsafe_arena_set_allocated_forward_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_axis_m_);
  }
  _impl_.forward_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.forward_axis_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::release_forward_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.forward_axis_m_;
  _impl_.forward_axis_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::unsafe_arena_release_forward_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipsoid.forward_axis_m)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.forward_axis_m_;
  _impl_.forward_axis_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::_internal_mutable_forward_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.forward_axis_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.forward_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.forward_axis_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::mutable_forward_axis_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_forward_axis_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipsoid.forward_axis_m)
  return _msg;
}
inline void GeoEllipsoid::set_allocated_forward_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_axis_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.forward_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.forward_axis_m)
}

// .google.protobuf.DoubleValue side_axis_m = 2 [json_name = "sideAxisM"];
inline bool GeoEllipsoid::has_side_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.side_axis_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::_internal_side_axis_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.side_axis_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::side_axis_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipsoid.side_axis_m)
  return _internal_side_axis_m();
}
inline void GeoEllipsoid::unsafe_arena_set_allocated_side_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.side_axis_m_);
  }
  _impl_.side_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.side_axis_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::release_side_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* released = _impl_.side_axis_m_;
  _impl_.side_axis_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::unsafe_arena_release_side_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipsoid.side_axis_m)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* temp = _impl_.side_axis_m_;
  _impl_.side_axis_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::_internal_mutable_side_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.side_axis_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.side_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.side_axis_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::mutable_side_axis_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_side_axis_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipsoid.side_axis_m)
  return _msg;
}
inline void GeoEllipsoid::set_allocated_side_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.side_axis_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.side_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.side_axis_m)
}

// .google.protobuf.DoubleValue up_axis_m = 3 [json_name = "upAxisM"];
inline bool GeoEllipsoid::has_up_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.up_axis_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::_internal_up_axis_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.up_axis_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GeoEllipsoid::up_axis_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoEllipsoid.up_axis_m)
  return _internal_up_axis_m();
}
inline void GeoEllipsoid::unsafe_arena_set_allocated_up_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.up_axis_m_);
  }
  _impl_.up_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.up_axis_m)
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::release_up_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::DoubleValue* released = _impl_.up_axis_m_;
  _impl_.up_axis_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::unsafe_arena_release_up_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoEllipsoid.up_axis_m)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::DoubleValue* temp = _impl_.up_axis_m_;
  _impl_.up_axis_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::_internal_mutable_up_axis_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.up_axis_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.up_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.up_axis_m_;
}
inline ::google::protobuf::DoubleValue* GeoEllipsoid::mutable_up_axis_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_up_axis_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoEllipsoid.up_axis_m)
  return _msg;
}
inline void GeoEllipsoid::set_allocated_up_axis_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.up_axis_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.up_axis_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoEllipsoid.up_axis_m)
}

// -------------------------------------------------------------------

// LinearRing

// repeated .anduril.entitymanager.v1.Position points = 1 [json_name = "points", deprecated = true];
inline int LinearRing::_internal_points_size() const {
  return _internal_points().size();
}
inline int LinearRing::points_size() const {
  return _internal_points_size();
}
inline ::anduril::entitymanager::v1::Position* LinearRing::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.LinearRing.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>* LinearRing::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.LinearRing.points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_points();
}
inline const ::anduril::entitymanager::v1::Position& LinearRing::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.LinearRing.points)
  return _internal_points().Get(index);
}
inline ::anduril::entitymanager::v1::Position* LinearRing::add_points() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::Position* _add = _internal_mutable_points()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.LinearRing.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>& LinearRing::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.LinearRing.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>&
LinearRing::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Position>*
LinearRing::_internal_mutable_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.points_;
}

// repeated .anduril.entitymanager.v1.GeoPolygonPosition positions = 2 [json_name = "positions"];
inline int LinearRing::_internal_positions_size() const {
  return _internal_positions().size();
}
inline int LinearRing::positions_size() const {
  return _internal_positions_size();
}
inline void LinearRing::clear_positions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positions_.Clear();
}
inline ::anduril::entitymanager::v1::GeoPolygonPosition* LinearRing::mutable_positions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.LinearRing.positions)
  return _internal_mutable_positions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>* LinearRing::mutable_positions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.LinearRing.positions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_positions();
}
inline const ::anduril::entitymanager::v1::GeoPolygonPosition& LinearRing::positions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.LinearRing.positions)
  return _internal_positions().Get(index);
}
inline ::anduril::entitymanager::v1::GeoPolygonPosition* LinearRing::add_positions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::GeoPolygonPosition* _add = _internal_mutable_positions()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.LinearRing.positions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>& LinearRing::positions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.LinearRing.positions)
  return _internal_positions();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>&
LinearRing::_internal_positions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.positions_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::GeoPolygonPosition>*
LinearRing::_internal_mutable_positions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.positions_;
}

// -------------------------------------------------------------------

// GeoPolygonPosition

// .anduril.entitymanager.v1.Position position = 1 [json_name = "position"];
inline bool GeoPolygonPosition::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Position& GeoPolygonPosition::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Position&>(::anduril::entitymanager::v1::_Position_default_instance_);
}
inline const ::anduril::entitymanager::v1::Position& GeoPolygonPosition::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoPolygonPosition.position)
  return _internal_position();
}
inline void GeoPolygonPosition::unsafe_arena_set_allocated_position(::anduril::entitymanager::v1::Position* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoPolygonPosition.position)
}
inline ::anduril::entitymanager::v1::Position* GeoPolygonPosition::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Position* GeoPolygonPosition::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoPolygonPosition.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Position* GeoPolygonPosition::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::anduril::entitymanager::v1::Position* GeoPolygonPosition::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoPolygonPosition.position)
  return _msg;
}
inline void GeoPolygonPosition::set_allocated_position(::anduril::entitymanager::v1::Position* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::anduril::entitymanager::v1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoPolygonPosition.position)
}

// .google.protobuf.FloatValue height_m = 2 [json_name = "heightM"];
inline bool GeoPolygonPosition::has_height_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.height_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::FloatValue& GeoPolygonPosition::_internal_height_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FloatValue* p = _impl_.height_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FloatValue&>(::google::protobuf::_FloatValue_default_instance_);
}
inline const ::google::protobuf::FloatValue& GeoPolygonPosition::height_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoPolygonPosition.height_m)
  return _internal_height_m();
}
inline void GeoPolygonPosition::unsafe_arena_set_allocated_height_m(::google::protobuf::FloatValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_m_);
  }
  _impl_.height_m_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoPolygonPosition.height_m)
}
inline ::google::protobuf::FloatValue* GeoPolygonPosition::release_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FloatValue* released = _impl_.height_m_;
  _impl_.height_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FloatValue* GeoPolygonPosition::unsafe_arena_release_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoPolygonPosition.height_m)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FloatValue* temp = _impl_.height_m_;
  _impl_.height_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* GeoPolygonPosition::_internal_mutable_height_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.height_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FloatValue>(GetArena());
    _impl_.height_m_ = reinterpret_cast<::google::protobuf::FloatValue*>(p);
  }
  return _impl_.height_m_;
}
inline ::google::protobuf::FloatValue* GeoPolygonPosition::mutable_height_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::FloatValue* _msg = _internal_mutable_height_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoPolygonPosition.height_m)
  return _msg;
}
inline void GeoPolygonPosition::set_allocated_height_m(::google::protobuf::FloatValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.height_m_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoPolygonPosition.height_m)
}

// -------------------------------------------------------------------

// GeoVisualDetails

// .anduril.type.Color fill_color = 1 [json_name = "fillColor"];
inline bool GeoVisualDetails::has_fill_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fill_color_ != nullptr);
  return value;
}
inline const ::anduril::type::Color& GeoVisualDetails::_internal_fill_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::type::Color* p = _impl_.fill_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::type::Color&>(::anduril::type::_Color_default_instance_);
}
inline const ::anduril::type::Color& GeoVisualDetails::fill_color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoVisualDetails.fill_color)
  return _internal_fill_color();
}
inline void GeoVisualDetails::unsafe_arena_set_allocated_fill_color(::anduril::type::Color* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fill_color_);
  }
  _impl_.fill_color_ = reinterpret_cast<::anduril::type::Color*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoVisualDetails.fill_color)
}
inline ::anduril::type::Color* GeoVisualDetails::release_fill_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::type::Color* released = _impl_.fill_color_;
  _impl_.fill_color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::type::Color* GeoVisualDetails::unsafe_arena_release_fill_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoVisualDetails.fill_color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::type::Color* temp = _impl_.fill_color_;
  _impl_.fill_color_ = nullptr;
  return temp;
}
inline ::anduril::type::Color* GeoVisualDetails::_internal_mutable_fill_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fill_color_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::type::Color>(GetArena());
    _impl_.fill_color_ = reinterpret_cast<::anduril::type::Color*>(p);
  }
  return _impl_.fill_color_;
}
inline ::anduril::type::Color* GeoVisualDetails::mutable_fill_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::type::Color* _msg = _internal_mutable_fill_color();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoVisualDetails.fill_color)
  return _msg;
}
inline void GeoVisualDetails::set_allocated_fill_color(::anduril::type::Color* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fill_color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fill_color_ = reinterpret_cast<::anduril::type::Color*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoVisualDetails.fill_color)
}

// .anduril.type.Color line_color = 2 [json_name = "lineColor"];
inline bool GeoVisualDetails::has_line_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.line_color_ != nullptr);
  return value;
}
inline const ::anduril::type::Color& GeoVisualDetails::_internal_line_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::type::Color* p = _impl_.line_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::type::Color&>(::anduril::type::_Color_default_instance_);
}
inline const ::anduril::type::Color& GeoVisualDetails::line_color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.GeoVisualDetails.line_color)
  return _internal_line_color();
}
inline void GeoVisualDetails::unsafe_arena_set_allocated_line_color(::anduril::type::Color* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.line_color_);
  }
  _impl_.line_color_ = reinterpret_cast<::anduril::type::Color*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.GeoVisualDetails.line_color)
}
inline ::anduril::type::Color* GeoVisualDetails::release_line_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::type::Color* released = _impl_.line_color_;
  _impl_.line_color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::type::Color* GeoVisualDetails::unsafe_arena_release_line_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.GeoVisualDetails.line_color)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::type::Color* temp = _impl_.line_color_;
  _impl_.line_color_ = nullptr;
  return temp;
}
inline ::anduril::type::Color* GeoVisualDetails::_internal_mutable_line_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.line_color_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::type::Color>(GetArena());
    _impl_.line_color_ = reinterpret_cast<::anduril::type::Color*>(p);
  }
  return _impl_.line_color_;
}
inline ::anduril::type::Color* GeoVisualDetails::mutable_line_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::type::Color* _msg = _internal_mutable_line_color();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.GeoVisualDetails.line_color)
  return _msg;
}
inline void GeoVisualDetails::set_allocated_line_color(::anduril::type::Color* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.line_color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.line_color_ = reinterpret_cast<::anduril::type::Color*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.GeoVisualDetails.line_color)
}

// -------------------------------------------------------------------

// FSCMDetails

// .anduril.entitymanager.v1.FSCMDetailType fscm_type = 1 [json_name = "fscmType"];
inline void FSCMDetails::clear_fscm_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fscm_type_ = 0;
}
inline ::anduril::entitymanager::v1::FSCMDetailType FSCMDetails::fscm_type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.FSCMDetails.fscm_type)
  return _internal_fscm_type();
}
inline void FSCMDetails::set_fscm_type(::anduril::entitymanager::v1::FSCMDetailType value) {
  _internal_set_fscm_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.FSCMDetails.fscm_type)
}
inline ::anduril::entitymanager::v1::FSCMDetailType FSCMDetails::_internal_fscm_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::FSCMDetailType>(_impl_.fscm_type_);
}
inline void FSCMDetails::_internal_set_fscm_type(::anduril::entitymanager::v1::FSCMDetailType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fscm_type_ = value;
}

// string fscm_description = 2 [json_name = "fscmDescription"];
inline void FSCMDetails::clear_fscm_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fscm_description_.ClearToEmpty();
}
inline const std::string& FSCMDetails::fscm_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.FSCMDetails.fscm_description)
  return _internal_fscm_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FSCMDetails::set_fscm_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fscm_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.FSCMDetails.fscm_description)
}
inline std::string* FSCMDetails::mutable_fscm_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fscm_description();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.FSCMDetails.fscm_description)
  return _s;
}
inline const std::string& FSCMDetails::_internal_fscm_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fscm_description_.Get();
}
inline void FSCMDetails::_internal_set_fscm_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fscm_description_.Set(value, GetArena());
}
inline std::string* FSCMDetails::_internal_mutable_fscm_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.fscm_description_.Mutable( GetArena());
}
inline std::string* FSCMDetails::release_fscm_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.FSCMDetails.fscm_description)
  return _impl_.fscm_description_.Release();
}
inline void FSCMDetails::set_allocated_fscm_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fscm_description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fscm_description_.IsDefault()) {
          _impl_.fscm_description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.FSCMDetails.fscm_description)
}

// .anduril.entitymanager.v1.FiringAuthority firing_authority = 3 [json_name = "firingAuthority"];
inline bool FSCMDetails::has_firing_authority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.firing_authority_ != nullptr);
  return value;
}
inline void FSCMDetails::clear_firing_authority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.firing_authority_ != nullptr) _impl_.firing_authority_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::FiringAuthority& FSCMDetails::_internal_firing_authority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::FiringAuthority* p = _impl_.firing_authority_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::FiringAuthority&>(::anduril::entitymanager::v1::_FiringAuthority_default_instance_);
}
inline const ::anduril::entitymanager::v1::FiringAuthority& FSCMDetails::firing_authority() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.FSCMDetails.firing_authority)
  return _internal_firing_authority();
}
inline void FSCMDetails::unsafe_arena_set_allocated_firing_authority(::anduril::entitymanager::v1::FiringAuthority* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.firing_authority_);
  }
  _impl_.firing_authority_ = reinterpret_cast<::anduril::entitymanager::v1::FiringAuthority*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.FSCMDetails.firing_authority)
}
inline ::anduril::entitymanager::v1::FiringAuthority* FSCMDetails::release_firing_authority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::FiringAuthority* released = _impl_.firing_authority_;
  _impl_.firing_authority_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::FiringAuthority* FSCMDetails::unsafe_arena_release_firing_authority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.FSCMDetails.firing_authority)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::FiringAuthority* temp = _impl_.firing_authority_;
  _impl_.firing_authority_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::FiringAuthority* FSCMDetails::_internal_mutable_firing_authority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.firing_authority_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::FiringAuthority>(GetArena());
    _impl_.firing_authority_ = reinterpret_cast<::anduril::entitymanager::v1::FiringAuthority*>(p);
  }
  return _impl_.firing_authority_;
}
inline ::anduril::entitymanager::v1::FiringAuthority* FSCMDetails::mutable_firing_authority() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::FiringAuthority* _msg = _internal_mutable_firing_authority();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.FSCMDetails.firing_authority)
  return _msg;
}
inline void FSCMDetails::set_allocated_firing_authority(::anduril::entitymanager::v1::FiringAuthority* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.firing_authority_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.firing_authority_ = reinterpret_cast<::anduril::entitymanager::v1::FiringAuthority*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.FSCMDetails.firing_authority)
}

// .anduril.entitymanager.v1.AmmoRestrictionType ammo_restriction_type = 4 [json_name = "ammoRestrictionType", deprecated = true];
inline void FSCMDetails::clear_ammo_restriction_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ammo_restriction_type_ = 0;
}
inline ::anduril::entitymanager::v1::AmmoRestrictionType FSCMDetails::ammo_restriction_type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.FSCMDetails.ammo_restriction_type)
  return _internal_ammo_restriction_type();
}
inline void FSCMDetails::set_ammo_restriction_type(::anduril::entitymanager::v1::AmmoRestrictionType value) {
  _internal_set_ammo_restriction_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.FSCMDetails.ammo_restriction_type)
}
inline ::anduril::entitymanager::v1::AmmoRestrictionType FSCMDetails::_internal_ammo_restriction_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::AmmoRestrictionType>(_impl_.ammo_restriction_type_);
}
inline void FSCMDetails::_internal_set_ammo_restriction_type(::anduril::entitymanager::v1::AmmoRestrictionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ammo_restriction_type_ = value;
}

// .anduril.entitymanager.v1.RestrictiveMeasureType restrictive_measure_type = 5 [json_name = "restrictiveMeasureType"];
inline void FSCMDetails::clear_restrictive_measure_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.restrictive_measure_type_ = 0;
}
inline ::anduril::entitymanager::v1::RestrictiveMeasureType FSCMDetails::restrictive_measure_type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.FSCMDetails.restrictive_measure_type)
  return _internal_restrictive_measure_type();
}
inline void FSCMDetails::set_restrictive_measure_type(::anduril::entitymanager::v1::RestrictiveMeasureType value) {
  _internal_set_restrictive_measure_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.FSCMDetails.restrictive_measure_type)
}
inline ::anduril::entitymanager::v1::RestrictiveMeasureType FSCMDetails::_internal_restrictive_measure_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::RestrictiveMeasureType>(_impl_.restrictive_measure_type_);
}
inline void FSCMDetails::_internal_set_restrictive_measure_type(::anduril::entitymanager::v1::RestrictiveMeasureType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.restrictive_measure_type_ = value;
}

// repeated .anduril.entitymanager.v1.AmmoRestrictionType ammo_restrict_types = 6 [json_name = "ammoRestrictTypes"];
inline int FSCMDetails::_internal_ammo_restrict_types_size() const {
  return _internal_ammo_restrict_types().size();
}
inline int FSCMDetails::ammo_restrict_types_size() const {
  return _internal_ammo_restrict_types_size();
}
inline void FSCMDetails::clear_ammo_restrict_types() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ammo_restrict_types_.Clear();
}
inline ::anduril::entitymanager::v1::AmmoRestrictionType FSCMDetails::ammo_restrict_types(int index) const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.FSCMDetails.ammo_restrict_types)
  return static_cast<::anduril::entitymanager::v1::AmmoRestrictionType>(_internal_ammo_restrict_types().Get(index));
}
inline void FSCMDetails::set_ammo_restrict_types(int index, ::anduril::entitymanager::v1::AmmoRestrictionType value) {
  _internal_mutable_ammo_restrict_types()->Set(index, value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.FSCMDetails.ammo_restrict_types)
}
inline void FSCMDetails::add_ammo_restrict_types(::anduril::entitymanager::v1::AmmoRestrictionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_ammo_restrict_types()->Add(value);
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.FSCMDetails.ammo_restrict_types)
}
inline const ::google::protobuf::RepeatedField<int>& FSCMDetails::ammo_restrict_types() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.FSCMDetails.ammo_restrict_types)
  return _internal_ammo_restrict_types();
}
inline ::google::protobuf::RepeatedField<int>* FSCMDetails::mutable_ammo_restrict_types()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.FSCMDetails.ammo_restrict_types)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ammo_restrict_types();
}
inline const ::google::protobuf::RepeatedField<int>& FSCMDetails::_internal_ammo_restrict_types()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ammo_restrict_types_;
}
inline ::google::protobuf::RepeatedField<int>* FSCMDetails::_internal_mutable_ammo_restrict_types() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ammo_restrict_types_;
}

// bool is_ground = 7 [json_name = "isGround"];
inline void FSCMDetails::clear_is_ground() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ground_ = false;
}
inline bool FSCMDetails::is_ground() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.FSCMDetails.is_ground)
  return _internal_is_ground();
}
inline void FSCMDetails::set_is_ground(bool value) {
  _internal_set_is_ground(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.FSCMDetails.is_ground)
}
inline bool FSCMDetails::_internal_is_ground() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_ground_;
}
inline void FSCMDetails::_internal_set_is_ground(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ground_ = value;
}

// -------------------------------------------------------------------

// ACMDetails

// .anduril.entitymanager.v1.ACMDetailType acm_type = 1 [json_name = "acmType"];
inline void ACMDetails::clear_acm_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acm_type_ = 0;
}
inline ::anduril::entitymanager::v1::ACMDetailType ACMDetails::acm_type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.ACMDetails.acm_type)
  return _internal_acm_type();
}
inline void ACMDetails::set_acm_type(::anduril::entitymanager::v1::ACMDetailType value) {
  _internal_set_acm_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.ACMDetails.acm_type)
}
inline ::anduril::entitymanager::v1::ACMDetailType ACMDetails::_internal_acm_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::ACMDetailType>(_impl_.acm_type_);
}
inline void ACMDetails::_internal_set_acm_type(::anduril::entitymanager::v1::ACMDetailType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acm_type_ = value;
}

// string acm_description = 2 [json_name = "acmDescription"];
inline void ACMDetails::clear_acm_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acm_description_.ClearToEmpty();
}
inline const std::string& ACMDetails::acm_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.ACMDetails.acm_description)
  return _internal_acm_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ACMDetails::set_acm_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acm_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.ACMDetails.acm_description)
}
inline std::string* ACMDetails::mutable_acm_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_acm_description();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.ACMDetails.acm_description)
  return _s;
}
inline const std::string& ACMDetails::_internal_acm_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.acm_description_.Get();
}
inline void ACMDetails::_internal_set_acm_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acm_description_.Set(value, GetArena());
}
inline std::string* ACMDetails::_internal_mutable_acm_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.acm_description_.Mutable( GetArena());
}
inline std::string* ACMDetails::release_acm_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.ACMDetails.acm_description)
  return _impl_.acm_description_.Release();
}
inline void ACMDetails::set_allocated_acm_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acm_description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.acm_description_.IsDefault()) {
          _impl_.acm_description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.ACMDetails.acm_description)
}

// -------------------------------------------------------------------

// MCMDetails

// .anduril.entitymanager.v1.MCMDetailType mcm_type = 1 [json_name = "mcmType"];
inline void MCMDetails::clear_mcm_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mcm_type_ = 0;
}
inline ::anduril::entitymanager::v1::MCMDetailType MCMDetails::mcm_type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.MCMDetails.mcm_type)
  return _internal_mcm_type();
}
inline void MCMDetails::set_mcm_type(::anduril::entitymanager::v1::MCMDetailType value) {
  _internal_set_mcm_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.MCMDetails.mcm_type)
}
inline ::anduril::entitymanager::v1::MCMDetailType MCMDetails::_internal_mcm_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::MCMDetailType>(_impl_.mcm_type_);
}
inline void MCMDetails::_internal_set_mcm_type(::anduril::entitymanager::v1::MCMDetailType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mcm_type_ = value;
}

// string mcm_description = 2 [json_name = "mcmDescription"];
inline void MCMDetails::clear_mcm_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mcm_description_.ClearToEmpty();
}
inline const std::string& MCMDetails::mcm_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.MCMDetails.mcm_description)
  return _internal_mcm_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MCMDetails::set_mcm_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mcm_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.MCMDetails.mcm_description)
}
inline std::string* MCMDetails::mutable_mcm_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mcm_description();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.MCMDetails.mcm_description)
  return _s;
}
inline const std::string& MCMDetails::_internal_mcm_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mcm_description_.Get();
}
inline void MCMDetails::_internal_set_mcm_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mcm_description_.Set(value, GetArena());
}
inline std::string* MCMDetails::_internal_mutable_mcm_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.mcm_description_.Mutable( GetArena());
}
inline std::string* MCMDetails::release_mcm_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.MCMDetails.mcm_description)
  return _impl_.mcm_description_.Release();
}
inline void MCMDetails::set_allocated_mcm_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mcm_description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mcm_description_.IsDefault()) {
          _impl_.mcm_description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.MCMDetails.mcm_description)
}

// -------------------------------------------------------------------

// FiringAuthority

// repeated string entity_ids = 1 [json_name = "entityIds"];
inline int FiringAuthority::_internal_entity_ids_size() const {
  return _internal_entity_ids().size();
}
inline int FiringAuthority::entity_ids_size() const {
  return _internal_entity_ids_size();
}
inline void FiringAuthority::clear_entity_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_ids_.Clear();
}
inline std::string* FiringAuthority::add_entity_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_entity_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:anduril.entitymanager.v1.FiringAuthority.entity_ids)
  return _s;
}
inline const std::string& FiringAuthority::entity_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.FiringAuthority.entity_ids)
  return _internal_entity_ids().Get(index);
}
inline std::string* FiringAuthority::mutable_entity_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.FiringAuthority.entity_ids)
  return _internal_mutable_entity_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void FiringAuthority::set_entity_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_entity_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.FiringAuthority.entity_ids)
}
template <typename Arg_, typename... Args_>
inline void FiringAuthority::add_entity_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_entity_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.FiringAuthority.entity_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FiringAuthority::entity_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.FiringAuthority.entity_ids)
  return _internal_entity_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FiringAuthority::mutable_entity_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.FiringAuthority.entity_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entity_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FiringAuthority::_internal_entity_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FiringAuthority::_internal_mutable_entity_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entity_ids_;
}

// -------------------------------------------------------------------

// ControlAreaDetails

// .anduril.entitymanager.v1.ControlAreaType type = 1 [json_name = "type"];
inline void ControlAreaDetails::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::anduril::entitymanager::v1::ControlAreaType ControlAreaDetails::type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.ControlAreaDetails.type)
  return _internal_type();
}
inline void ControlAreaDetails::set_type(::anduril::entitymanager::v1::ControlAreaType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.ControlAreaDetails.type)
}
inline ::anduril::entitymanager::v1::ControlAreaType ControlAreaDetails::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::ControlAreaType>(_impl_.type_);
}
inline void ControlAreaDetails::_internal_set_type(::anduril::entitymanager::v1::ControlAreaType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::anduril::entitymanager::v1::GeoType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::GeoType>() {
  return ::anduril::entitymanager::v1::GeoType_descriptor();
}
template <>
struct is_proto_enum<::anduril::entitymanager::v1::EmergencyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::EmergencyType>() {
  return ::anduril::entitymanager::v1::EmergencyType_descriptor();
}
template <>
struct is_proto_enum<::anduril::entitymanager::v1::ControlAreaType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::ControlAreaType>() {
  return ::anduril::entitymanager::v1::ControlAreaType_descriptor();
}
template <>
struct is_proto_enum<::anduril::entitymanager::v1::FSCMDetailType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::FSCMDetailType>() {
  return ::anduril::entitymanager::v1::FSCMDetailType_descriptor();
}
template <>
struct is_proto_enum<::anduril::entitymanager::v1::ACMDetailType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::ACMDetailType>() {
  return ::anduril::entitymanager::v1::ACMDetailType_descriptor();
}
template <>
struct is_proto_enum<::anduril::entitymanager::v1::AmmoRestrictionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::AmmoRestrictionType>() {
  return ::anduril::entitymanager::v1::AmmoRestrictionType_descriptor();
}
template <>
struct is_proto_enum<::anduril::entitymanager::v1::RestrictiveMeasureType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::RestrictiveMeasureType>() {
  return ::anduril::entitymanager::v1::RestrictiveMeasureType_descriptor();
}
template <>
struct is_proto_enum<::anduril::entitymanager::v1::MCMDetailType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::MCMDetailType>() {
  return ::anduril::entitymanager::v1::MCMDetailType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2fgeoentity_2epub_2eproto_2epb_2eh
