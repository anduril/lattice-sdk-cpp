// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/entitymanager/v1/relationship.pub.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "anduril/entitymanager/v1/sensors.pub.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto;
namespace anduril {
namespace entitymanager {
namespace v1 {
class GroupChild;
struct GroupChildDefaultTypeInternal;
extern GroupChildDefaultTypeInternal _GroupChild_default_instance_;
class GroupParent;
struct GroupParentDefaultTypeInternal;
extern GroupParentDefaultTypeInternal _GroupParent_default_instance_;
class MergedFrom;
struct MergedFromDefaultTypeInternal;
extern MergedFromDefaultTypeInternal _MergedFrom_default_instance_;
class Relationship;
struct RelationshipDefaultTypeInternal;
extern RelationshipDefaultTypeInternal _Relationship_default_instance_;
class RelationshipType;
struct RelationshipTypeDefaultTypeInternal;
extern RelationshipTypeDefaultTypeInternal _RelationshipType_default_instance_;
class Relationships;
struct RelationshipsDefaultTypeInternal;
extern RelationshipsDefaultTypeInternal _Relationships_default_instance_;
class TrackedBy;
struct TrackedByDefaultTypeInternal;
extern TrackedByDefaultTypeInternal _TrackedBy_default_instance_;
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace entitymanager {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class MergedFrom final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.MergedFrom) */ {
 public:
  inline MergedFrom() : MergedFrom(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MergedFrom(
      ::google::protobuf::internal::ConstantInitialized);

  inline MergedFrom(const MergedFrom& from) : MergedFrom(nullptr, from) {}
  inline MergedFrom(MergedFrom&& from) noexcept
      : MergedFrom(nullptr, std::move(from)) {}
  inline MergedFrom& operator=(const MergedFrom& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergedFrom& operator=(MergedFrom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MergedFrom& default_instance() {
    return *internal_default_instance();
  }
  static inline const MergedFrom* internal_default_instance() {
    return reinterpret_cast<const MergedFrom*>(
        &_MergedFrom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(MergedFrom& a, MergedFrom& b) { a.Swap(&b); }
  inline void Swap(MergedFrom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergedFrom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MergedFrom* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<MergedFrom>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MergedFrom& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MergedFrom& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.MergedFrom"; }

 protected:
  explicit MergedFrom(::google::protobuf::Arena* arena);
  MergedFrom(::google::protobuf::Arena* arena, const MergedFrom& from);
  MergedFrom(::google::protobuf::Arena* arena, MergedFrom&& from) noexcept
      : MergedFrom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.MergedFrom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MergedFrom_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MergedFrom& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto;
};
// -------------------------------------------------------------------

class GroupParent final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GroupParent) */ {
 public:
  inline GroupParent() : GroupParent(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GroupParent(
      ::google::protobuf::internal::ConstantInitialized);

  inline GroupParent(const GroupParent& from) : GroupParent(nullptr, from) {}
  inline GroupParent(GroupParent&& from) noexcept
      : GroupParent(nullptr, std::move(from)) {}
  inline GroupParent& operator=(const GroupParent& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupParent& operator=(GroupParent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupParent& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupParent* internal_default_instance() {
    return reinterpret_cast<const GroupParent*>(
        &_GroupParent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(GroupParent& a, GroupParent& b) { a.Swap(&b); }
  inline void Swap(GroupParent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupParent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupParent* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GroupParent>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GroupParent& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GroupParent& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GroupParent"; }

 protected:
  explicit GroupParent(::google::protobuf::Arena* arena);
  GroupParent(::google::protobuf::Arena* arena, const GroupParent& from);
  GroupParent(::google::protobuf::Arena* arena, GroupParent&& from) noexcept
      : GroupParent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GroupParent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GroupParent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GroupParent& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto;
};
// -------------------------------------------------------------------

class GroupChild final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.GroupChild) */ {
 public:
  inline GroupChild() : GroupChild(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GroupChild(
      ::google::protobuf::internal::ConstantInitialized);

  inline GroupChild(const GroupChild& from) : GroupChild(nullptr, from) {}
  inline GroupChild(GroupChild&& from) noexcept
      : GroupChild(nullptr, std::move(from)) {}
  inline GroupChild& operator=(const GroupChild& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupChild& operator=(GroupChild&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupChild& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupChild* internal_default_instance() {
    return reinterpret_cast<const GroupChild*>(
        &_GroupChild_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(GroupChild& a, GroupChild& b) { a.Swap(&b); }
  inline void Swap(GroupChild* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupChild* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupChild* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GroupChild>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GroupChild& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GroupChild& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.GroupChild"; }

 protected:
  explicit GroupChild(::google::protobuf::Arena* arena);
  GroupChild(::google::protobuf::Arena* arena, const GroupChild& from);
  GroupChild(::google::protobuf::Arena* arena, GroupChild&& from) noexcept
      : GroupChild(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.GroupChild)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GroupChild_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GroupChild& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto;
};
// -------------------------------------------------------------------

class TrackedBy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.TrackedBy) */ {
 public:
  inline TrackedBy() : TrackedBy(nullptr) {}
  ~TrackedBy() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackedBy(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrackedBy(const TrackedBy& from) : TrackedBy(nullptr, from) {}
  inline TrackedBy(TrackedBy&& from) noexcept
      : TrackedBy(nullptr, std::move(from)) {}
  inline TrackedBy& operator=(const TrackedBy& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackedBy& operator=(TrackedBy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackedBy& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackedBy* internal_default_instance() {
    return reinterpret_cast<const TrackedBy*>(
        &_TrackedBy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TrackedBy& a, TrackedBy& b) { a.Swap(&b); }
  inline void Swap(TrackedBy* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackedBy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackedBy* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TrackedBy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackedBy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackedBy& from) { TrackedBy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrackedBy* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.TrackedBy"; }

 protected:
  explicit TrackedBy(::google::protobuf::Arena* arena);
  TrackedBy(::google::protobuf::Arena* arena, const TrackedBy& from);
  TrackedBy(::google::protobuf::Arena* arena, TrackedBy&& from) noexcept
      : TrackedBy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActivelyTrackingSensorsFieldNumber = 1,
    kLastMeasurementTimestampFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.Sensors actively_tracking_sensors = 1 [json_name = "activelyTrackingSensors"];
  bool has_actively_tracking_sensors() const;
  void clear_actively_tracking_sensors() ;
  const ::anduril::entitymanager::v1::Sensors& actively_tracking_sensors() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Sensors* release_actively_tracking_sensors();
  ::anduril::entitymanager::v1::Sensors* mutable_actively_tracking_sensors();
  void set_allocated_actively_tracking_sensors(::anduril::entitymanager::v1::Sensors* value);
  void unsafe_arena_set_allocated_actively_tracking_sensors(::anduril::entitymanager::v1::Sensors* value);
  ::anduril::entitymanager::v1::Sensors* unsafe_arena_release_actively_tracking_sensors();

  private:
  const ::anduril::entitymanager::v1::Sensors& _internal_actively_tracking_sensors() const;
  ::anduril::entitymanager::v1::Sensors* _internal_mutable_actively_tracking_sensors();

  public:
  // .google.protobuf.Timestamp last_measurement_timestamp = 2 [json_name = "lastMeasurementTimestamp"];
  bool has_last_measurement_timestamp() const;
  void clear_last_measurement_timestamp() ;
  const ::google::protobuf::Timestamp& last_measurement_timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_measurement_timestamp();
  ::google::protobuf::Timestamp* mutable_last_measurement_timestamp();
  void set_allocated_last_measurement_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_measurement_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_measurement_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_last_measurement_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_measurement_timestamp();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.TrackedBy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TrackedBy_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrackedBy& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Sensors* actively_tracking_sensors_;
    ::google::protobuf::Timestamp* last_measurement_timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto;
};
// -------------------------------------------------------------------

class RelationshipType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.RelationshipType) */ {
 public:
  inline RelationshipType() : RelationshipType(nullptr) {}
  ~RelationshipType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RelationshipType(
      ::google::protobuf::internal::ConstantInitialized);

  inline RelationshipType(const RelationshipType& from) : RelationshipType(nullptr, from) {}
  inline RelationshipType(RelationshipType&& from) noexcept
      : RelationshipType(nullptr, std::move(from)) {}
  inline RelationshipType& operator=(const RelationshipType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationshipType& operator=(RelationshipType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationshipType& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kTrackedBy = 2,
    kGroupChild = 4,
    kGroupParent = 5,
    kMergedFrom = 6,
    TYPE_NOT_SET = 0,
  };
  static inline const RelationshipType* internal_default_instance() {
    return reinterpret_cast<const RelationshipType*>(
        &_RelationshipType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RelationshipType& a, RelationshipType& b) { a.Swap(&b); }
  inline void Swap(RelationshipType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationshipType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationshipType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RelationshipType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RelationshipType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RelationshipType& from) { RelationshipType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RelationshipType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.RelationshipType"; }

 protected:
  explicit RelationshipType(::google::protobuf::Arena* arena);
  RelationshipType(::google::protobuf::Arena* arena, const RelationshipType& from);
  RelationshipType(::google::protobuf::Arena* arena, RelationshipType&& from) noexcept
      : RelationshipType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackedByFieldNumber = 2,
    kGroupChildFieldNumber = 4,
    kGroupParentFieldNumber = 5,
    kMergedFromFieldNumber = 6,
  };
  // .anduril.entitymanager.v1.TrackedBy tracked_by = 2 [json_name = "trackedBy"];
  bool has_tracked_by() const;
  private:
  bool _internal_has_tracked_by() const;

  public:
  void clear_tracked_by() ;
  const ::anduril::entitymanager::v1::TrackedBy& tracked_by() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::TrackedBy* release_tracked_by();
  ::anduril::entitymanager::v1::TrackedBy* mutable_tracked_by();
  void set_allocated_tracked_by(::anduril::entitymanager::v1::TrackedBy* value);
  void unsafe_arena_set_allocated_tracked_by(::anduril::entitymanager::v1::TrackedBy* value);
  ::anduril::entitymanager::v1::TrackedBy* unsafe_arena_release_tracked_by();

  private:
  const ::anduril::entitymanager::v1::TrackedBy& _internal_tracked_by() const;
  ::anduril::entitymanager::v1::TrackedBy* _internal_mutable_tracked_by();

  public:
  // .anduril.entitymanager.v1.GroupChild group_child = 4 [json_name = "groupChild"];
  bool has_group_child() const;
  private:
  bool _internal_has_group_child() const;

  public:
  void clear_group_child() ;
  const ::anduril::entitymanager::v1::GroupChild& group_child() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GroupChild* release_group_child();
  ::anduril::entitymanager::v1::GroupChild* mutable_group_child();
  void set_allocated_group_child(::anduril::entitymanager::v1::GroupChild* value);
  void unsafe_arena_set_allocated_group_child(::anduril::entitymanager::v1::GroupChild* value);
  ::anduril::entitymanager::v1::GroupChild* unsafe_arena_release_group_child();

  private:
  const ::anduril::entitymanager::v1::GroupChild& _internal_group_child() const;
  ::anduril::entitymanager::v1::GroupChild* _internal_mutable_group_child();

  public:
  // .anduril.entitymanager.v1.GroupParent group_parent = 5 [json_name = "groupParent"];
  bool has_group_parent() const;
  private:
  bool _internal_has_group_parent() const;

  public:
  void clear_group_parent() ;
  const ::anduril::entitymanager::v1::GroupParent& group_parent() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GroupParent* release_group_parent();
  ::anduril::entitymanager::v1::GroupParent* mutable_group_parent();
  void set_allocated_group_parent(::anduril::entitymanager::v1::GroupParent* value);
  void unsafe_arena_set_allocated_group_parent(::anduril::entitymanager::v1::GroupParent* value);
  ::anduril::entitymanager::v1::GroupParent* unsafe_arena_release_group_parent();

  private:
  const ::anduril::entitymanager::v1::GroupParent& _internal_group_parent() const;
  ::anduril::entitymanager::v1::GroupParent* _internal_mutable_group_parent();

  public:
  // .anduril.entitymanager.v1.MergedFrom merged_from = 6 [json_name = "mergedFrom"];
  bool has_merged_from() const;
  private:
  bool _internal_has_merged_from() const;

  public:
  void clear_merged_from() ;
  const ::anduril::entitymanager::v1::MergedFrom& merged_from() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::MergedFrom* release_merged_from();
  ::anduril::entitymanager::v1::MergedFrom* mutable_merged_from();
  void set_allocated_merged_from(::anduril::entitymanager::v1::MergedFrom* value);
  void unsafe_arena_set_allocated_merged_from(::anduril::entitymanager::v1::MergedFrom* value);
  ::anduril::entitymanager::v1::MergedFrom* unsafe_arena_release_merged_from();

  private:
  const ::anduril::entitymanager::v1::MergedFrom& _internal_merged_from() const;
  ::anduril::entitymanager::v1::MergedFrom* _internal_mutable_merged_from();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.RelationshipType)
 private:
  class _Internal;
  void set_has_tracked_by();
  void set_has_group_child();
  void set_has_group_parent();
  void set_has_merged_from();
  inline bool has_type() const;
  inline void clear_has_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RelationshipType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RelationshipType& from_msg);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::TrackedBy* tracked_by_;
      ::anduril::entitymanager::v1::GroupChild* group_child_;
      ::anduril::entitymanager::v1::GroupParent* group_parent_;
      ::anduril::entitymanager::v1::MergedFrom* merged_from_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto;
};
// -------------------------------------------------------------------

class Relationship final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Relationship) */ {
 public:
  inline Relationship() : Relationship(nullptr) {}
  ~Relationship() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Relationship(
      ::google::protobuf::internal::ConstantInitialized);

  inline Relationship(const Relationship& from) : Relationship(nullptr, from) {}
  inline Relationship(Relationship&& from) noexcept
      : Relationship(nullptr, std::move(from)) {}
  inline Relationship& operator=(const Relationship& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relationship& operator=(Relationship&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Relationship& default_instance() {
    return *internal_default_instance();
  }
  static inline const Relationship* internal_default_instance() {
    return reinterpret_cast<const Relationship*>(
        &_Relationship_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Relationship& a, Relationship& b) { a.Swap(&b); }
  inline void Swap(Relationship* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relationship* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Relationship* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Relationship>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Relationship& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Relationship& from) { Relationship::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Relationship* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Relationship"; }

 protected:
  explicit Relationship(::google::protobuf::Arena* arena);
  Relationship(::google::protobuf::Arena* arena, const Relationship& from);
  Relationship(::google::protobuf::Arena* arena, Relationship&& from) noexcept
      : Relationship(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRelatedEntityIdFieldNumber = 1,
    kRelationshipIdFieldNumber = 2,
    kRelationshipTypeFieldNumber = 3,
  };
  // string related_entity_id = 1 [json_name = "relatedEntityId"];
  void clear_related_entity_id() ;
  const std::string& related_entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_related_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_related_entity_id();
  PROTOBUF_NODISCARD std::string* release_related_entity_id();
  void set_allocated_related_entity_id(std::string* value);

  private:
  const std::string& _internal_related_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_related_entity_id(
      const std::string& value);
  std::string* _internal_mutable_related_entity_id();

  public:
  // string relationship_id = 2 [json_name = "relationshipId"];
  void clear_relationship_id() ;
  const std::string& relationship_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relationship_id(Arg_&& arg, Args_... args);
  std::string* mutable_relationship_id();
  PROTOBUF_NODISCARD std::string* release_relationship_id();
  void set_allocated_relationship_id(std::string* value);

  private:
  const std::string& _internal_relationship_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relationship_id(
      const std::string& value);
  std::string* _internal_mutable_relationship_id();

  public:
  // .anduril.entitymanager.v1.RelationshipType relationship_type = 3 [json_name = "relationshipType"];
  bool has_relationship_type() const;
  void clear_relationship_type() ;
  const ::anduril::entitymanager::v1::RelationshipType& relationship_type() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::RelationshipType* release_relationship_type();
  ::anduril::entitymanager::v1::RelationshipType* mutable_relationship_type();
  void set_allocated_relationship_type(::anduril::entitymanager::v1::RelationshipType* value);
  void unsafe_arena_set_allocated_relationship_type(::anduril::entitymanager::v1::RelationshipType* value);
  ::anduril::entitymanager::v1::RelationshipType* unsafe_arena_release_relationship_type();

  private:
  const ::anduril::entitymanager::v1::RelationshipType& _internal_relationship_type() const;
  ::anduril::entitymanager::v1::RelationshipType* _internal_mutable_relationship_type();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Relationship)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      78, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Relationship_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Relationship& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr related_entity_id_;
    ::google::protobuf::internal::ArenaStringPtr relationship_id_;
    ::anduril::entitymanager::v1::RelationshipType* relationship_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto;
};
// -------------------------------------------------------------------

class Relationships final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Relationships) */ {
 public:
  inline Relationships() : Relationships(nullptr) {}
  ~Relationships() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Relationships(
      ::google::protobuf::internal::ConstantInitialized);

  inline Relationships(const Relationships& from) : Relationships(nullptr, from) {}
  inline Relationships(Relationships&& from) noexcept
      : Relationships(nullptr, std::move(from)) {}
  inline Relationships& operator=(const Relationships& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relationships& operator=(Relationships&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Relationships& default_instance() {
    return *internal_default_instance();
  }
  static inline const Relationships* internal_default_instance() {
    return reinterpret_cast<const Relationships*>(
        &_Relationships_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Relationships& a, Relationships& b) { a.Swap(&b); }
  inline void Swap(Relationships* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relationships* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Relationships* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Relationships>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Relationships& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Relationships& from) { Relationships::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Relationships* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Relationships"; }

 protected:
  explicit Relationships(::google::protobuf::Arena* arena);
  Relationships(::google::protobuf::Arena* arena, const Relationships& from);
  Relationships(::google::protobuf::Arena* arena, Relationships&& from) noexcept
      : Relationships(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRelationshipsFieldNumber = 1,
  };
  // repeated .anduril.entitymanager.v1.Relationship relationships = 1 [json_name = "relationships"];
  int relationships_size() const;
  private:
  int _internal_relationships_size() const;

  public:
  void clear_relationships() ;
  ::anduril::entitymanager::v1::Relationship* mutable_relationships(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Relationship>* mutable_relationships();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Relationship>& _internal_relationships() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Relationship>* _internal_mutable_relationships();
  public:
  const ::anduril::entitymanager::v1::Relationship& relationships(int index) const;
  ::anduril::entitymanager::v1::Relationship* add_relationships();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Relationship>& relationships() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Relationships)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Relationships_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Relationships& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Relationship > relationships_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Relationships

// repeated .anduril.entitymanager.v1.Relationship relationships = 1 [json_name = "relationships"];
inline int Relationships::_internal_relationships_size() const {
  return _internal_relationships().size();
}
inline int Relationships::relationships_size() const {
  return _internal_relationships_size();
}
inline void Relationships::clear_relationships() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.relationships_.Clear();
}
inline ::anduril::entitymanager::v1::Relationship* Relationships::mutable_relationships(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Relationships.relationships)
  return _internal_mutable_relationships()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Relationship>* Relationships::mutable_relationships()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.Relationships.relationships)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_relationships();
}
inline const ::anduril::entitymanager::v1::Relationship& Relationships::relationships(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Relationships.relationships)
  return _internal_relationships().Get(index);
}
inline ::anduril::entitymanager::v1::Relationship* Relationships::add_relationships() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::Relationship* _add = _internal_mutable_relationships()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.Relationships.relationships)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Relationship>& Relationships::relationships() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.Relationships.relationships)
  return _internal_relationships();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Relationship>&
Relationships::_internal_relationships() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.relationships_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Relationship>*
Relationships::_internal_mutable_relationships() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.relationships_;
}

// -------------------------------------------------------------------

// Relationship

// string related_entity_id = 1 [json_name = "relatedEntityId"];
inline void Relationship::clear_related_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.related_entity_id_.ClearToEmpty();
}
inline const std::string& Relationship::related_entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Relationship.related_entity_id)
  return _internal_related_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Relationship::set_related_entity_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.related_entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Relationship.related_entity_id)
}
inline std::string* Relationship::mutable_related_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_related_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Relationship.related_entity_id)
  return _s;
}
inline const std::string& Relationship::_internal_related_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.related_entity_id_.Get();
}
inline void Relationship::_internal_set_related_entity_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.related_entity_id_.Set(value, GetArena());
}
inline std::string* Relationship::_internal_mutable_related_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.related_entity_id_.Mutable( GetArena());
}
inline std::string* Relationship::release_related_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Relationship.related_entity_id)
  return _impl_.related_entity_id_.Release();
}
inline void Relationship::set_allocated_related_entity_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.related_entity_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.related_entity_id_.IsDefault()) {
          _impl_.related_entity_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Relationship.related_entity_id)
}

// string relationship_id = 2 [json_name = "relationshipId"];
inline void Relationship::clear_relationship_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.relationship_id_.ClearToEmpty();
}
inline const std::string& Relationship::relationship_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Relationship.relationship_id)
  return _internal_relationship_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Relationship::set_relationship_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.relationship_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Relationship.relationship_id)
}
inline std::string* Relationship::mutable_relationship_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_relationship_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Relationship.relationship_id)
  return _s;
}
inline const std::string& Relationship::_internal_relationship_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.relationship_id_.Get();
}
inline void Relationship::_internal_set_relationship_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.relationship_id_.Set(value, GetArena());
}
inline std::string* Relationship::_internal_mutable_relationship_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.relationship_id_.Mutable( GetArena());
}
inline std::string* Relationship::release_relationship_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Relationship.relationship_id)
  return _impl_.relationship_id_.Release();
}
inline void Relationship::set_allocated_relationship_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.relationship_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relationship_id_.IsDefault()) {
          _impl_.relationship_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Relationship.relationship_id)
}

// .anduril.entitymanager.v1.RelationshipType relationship_type = 3 [json_name = "relationshipType"];
inline bool Relationship::has_relationship_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relationship_type_ != nullptr);
  return value;
}
inline void Relationship::clear_relationship_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.relationship_type_ != nullptr) _impl_.relationship_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::RelationshipType& Relationship::_internal_relationship_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::RelationshipType* p = _impl_.relationship_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::RelationshipType&>(::anduril::entitymanager::v1::_RelationshipType_default_instance_);
}
inline const ::anduril::entitymanager::v1::RelationshipType& Relationship::relationship_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Relationship.relationship_type)
  return _internal_relationship_type();
}
inline void Relationship::unsafe_arena_set_allocated_relationship_type(::anduril::entitymanager::v1::RelationshipType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relationship_type_);
  }
  _impl_.relationship_type_ = reinterpret_cast<::anduril::entitymanager::v1::RelationshipType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Relationship.relationship_type)
}
inline ::anduril::entitymanager::v1::RelationshipType* Relationship::release_relationship_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::RelationshipType* released = _impl_.relationship_type_;
  _impl_.relationship_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::RelationshipType* Relationship::unsafe_arena_release_relationship_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Relationship.relationship_type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::RelationshipType* temp = _impl_.relationship_type_;
  _impl_.relationship_type_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::RelationshipType* Relationship::_internal_mutable_relationship_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.relationship_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::RelationshipType>(GetArena());
    _impl_.relationship_type_ = reinterpret_cast<::anduril::entitymanager::v1::RelationshipType*>(p);
  }
  return _impl_.relationship_type_;
}
inline ::anduril::entitymanager::v1::RelationshipType* Relationship::mutable_relationship_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::RelationshipType* _msg = _internal_mutable_relationship_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Relationship.relationship_type)
  return _msg;
}
inline void Relationship::set_allocated_relationship_type(::anduril::entitymanager::v1::RelationshipType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.relationship_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.relationship_type_ = reinterpret_cast<::anduril::entitymanager::v1::RelationshipType*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Relationship.relationship_type)
}

// -------------------------------------------------------------------

// RelationshipType

// .anduril.entitymanager.v1.TrackedBy tracked_by = 2 [json_name = "trackedBy"];
inline bool RelationshipType::has_tracked_by() const {
  return type_case() == kTrackedBy;
}
inline bool RelationshipType::_internal_has_tracked_by() const {
  return type_case() == kTrackedBy;
}
inline void RelationshipType::set_has_tracked_by() {
  _impl_._oneof_case_[0] = kTrackedBy;
}
inline void RelationshipType::clear_tracked_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kTrackedBy) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.tracked_by_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.tracked_by_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::TrackedBy* RelationshipType::release_tracked_by() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RelationshipType.tracked_by)
  if (type_case() == kTrackedBy) {
    clear_has_type();
    auto* temp = _impl_.type_.tracked_by_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.tracked_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::TrackedBy& RelationshipType::_internal_tracked_by() const {
  return type_case() == kTrackedBy ? *_impl_.type_.tracked_by_ : reinterpret_cast<::anduril::entitymanager::v1::TrackedBy&>(::anduril::entitymanager::v1::_TrackedBy_default_instance_);
}
inline const ::anduril::entitymanager::v1::TrackedBy& RelationshipType::tracked_by() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RelationshipType.tracked_by)
  return _internal_tracked_by();
}
inline ::anduril::entitymanager::v1::TrackedBy* RelationshipType::unsafe_arena_release_tracked_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.RelationshipType.tracked_by)
  if (type_case() == kTrackedBy) {
    clear_has_type();
    auto* temp = _impl_.type_.tracked_by_;
    _impl_.type_.tracked_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelationshipType::unsafe_arena_set_allocated_tracked_by(::anduril::entitymanager::v1::TrackedBy* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_tracked_by();
    _impl_.type_.tracked_by_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RelationshipType.tracked_by)
}
inline ::anduril::entitymanager::v1::TrackedBy* RelationshipType::_internal_mutable_tracked_by() {
  if (type_case() != kTrackedBy) {
    clear_type();
    set_has_tracked_by();
    _impl_.type_.tracked_by_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::TrackedBy>(GetArena());
  }
  return _impl_.type_.tracked_by_;
}
inline ::anduril::entitymanager::v1::TrackedBy* RelationshipType::mutable_tracked_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::TrackedBy* _msg = _internal_mutable_tracked_by();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RelationshipType.tracked_by)
  return _msg;
}

// .anduril.entitymanager.v1.GroupChild group_child = 4 [json_name = "groupChild"];
inline bool RelationshipType::has_group_child() const {
  return type_case() == kGroupChild;
}
inline bool RelationshipType::_internal_has_group_child() const {
  return type_case() == kGroupChild;
}
inline void RelationshipType::set_has_group_child() {
  _impl_._oneof_case_[0] = kGroupChild;
}
inline void RelationshipType::clear_group_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kGroupChild) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.group_child_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.group_child_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::GroupChild* RelationshipType::release_group_child() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RelationshipType.group_child)
  if (type_case() == kGroupChild) {
    clear_has_type();
    auto* temp = _impl_.type_.group_child_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.group_child_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GroupChild& RelationshipType::_internal_group_child() const {
  return type_case() == kGroupChild ? *_impl_.type_.group_child_ : reinterpret_cast<::anduril::entitymanager::v1::GroupChild&>(::anduril::entitymanager::v1::_GroupChild_default_instance_);
}
inline const ::anduril::entitymanager::v1::GroupChild& RelationshipType::group_child() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RelationshipType.group_child)
  return _internal_group_child();
}
inline ::anduril::entitymanager::v1::GroupChild* RelationshipType::unsafe_arena_release_group_child() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.RelationshipType.group_child)
  if (type_case() == kGroupChild) {
    clear_has_type();
    auto* temp = _impl_.type_.group_child_;
    _impl_.type_.group_child_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelationshipType::unsafe_arena_set_allocated_group_child(::anduril::entitymanager::v1::GroupChild* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_group_child();
    _impl_.type_.group_child_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RelationshipType.group_child)
}
inline ::anduril::entitymanager::v1::GroupChild* RelationshipType::_internal_mutable_group_child() {
  if (type_case() != kGroupChild) {
    clear_type();
    set_has_group_child();
    _impl_.type_.group_child_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GroupChild>(GetArena());
  }
  return _impl_.type_.group_child_;
}
inline ::anduril::entitymanager::v1::GroupChild* RelationshipType::mutable_group_child() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GroupChild* _msg = _internal_mutable_group_child();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RelationshipType.group_child)
  return _msg;
}

// .anduril.entitymanager.v1.GroupParent group_parent = 5 [json_name = "groupParent"];
inline bool RelationshipType::has_group_parent() const {
  return type_case() == kGroupParent;
}
inline bool RelationshipType::_internal_has_group_parent() const {
  return type_case() == kGroupParent;
}
inline void RelationshipType::set_has_group_parent() {
  _impl_._oneof_case_[0] = kGroupParent;
}
inline void RelationshipType::clear_group_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kGroupParent) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.group_parent_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.group_parent_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::GroupParent* RelationshipType::release_group_parent() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RelationshipType.group_parent)
  if (type_case() == kGroupParent) {
    clear_has_type();
    auto* temp = _impl_.type_.group_parent_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.group_parent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::GroupParent& RelationshipType::_internal_group_parent() const {
  return type_case() == kGroupParent ? *_impl_.type_.group_parent_ : reinterpret_cast<::anduril::entitymanager::v1::GroupParent&>(::anduril::entitymanager::v1::_GroupParent_default_instance_);
}
inline const ::anduril::entitymanager::v1::GroupParent& RelationshipType::group_parent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RelationshipType.group_parent)
  return _internal_group_parent();
}
inline ::anduril::entitymanager::v1::GroupParent* RelationshipType::unsafe_arena_release_group_parent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.RelationshipType.group_parent)
  if (type_case() == kGroupParent) {
    clear_has_type();
    auto* temp = _impl_.type_.group_parent_;
    _impl_.type_.group_parent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelationshipType::unsafe_arena_set_allocated_group_parent(::anduril::entitymanager::v1::GroupParent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_group_parent();
    _impl_.type_.group_parent_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RelationshipType.group_parent)
}
inline ::anduril::entitymanager::v1::GroupParent* RelationshipType::_internal_mutable_group_parent() {
  if (type_case() != kGroupParent) {
    clear_type();
    set_has_group_parent();
    _impl_.type_.group_parent_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GroupParent>(GetArena());
  }
  return _impl_.type_.group_parent_;
}
inline ::anduril::entitymanager::v1::GroupParent* RelationshipType::mutable_group_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GroupParent* _msg = _internal_mutable_group_parent();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RelationshipType.group_parent)
  return _msg;
}

// .anduril.entitymanager.v1.MergedFrom merged_from = 6 [json_name = "mergedFrom"];
inline bool RelationshipType::has_merged_from() const {
  return type_case() == kMergedFrom;
}
inline bool RelationshipType::_internal_has_merged_from() const {
  return type_case() == kMergedFrom;
}
inline void RelationshipType::set_has_merged_from() {
  _impl_._oneof_case_[0] = kMergedFrom;
}
inline void RelationshipType::clear_merged_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kMergedFrom) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.merged_from_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.merged_from_);
    }
    clear_has_type();
  }
}
inline ::anduril::entitymanager::v1::MergedFrom* RelationshipType::release_merged_from() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RelationshipType.merged_from)
  if (type_case() == kMergedFrom) {
    clear_has_type();
    auto* temp = _impl_.type_.merged_from_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.merged_from_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::MergedFrom& RelationshipType::_internal_merged_from() const {
  return type_case() == kMergedFrom ? *_impl_.type_.merged_from_ : reinterpret_cast<::anduril::entitymanager::v1::MergedFrom&>(::anduril::entitymanager::v1::_MergedFrom_default_instance_);
}
inline const ::anduril::entitymanager::v1::MergedFrom& RelationshipType::merged_from() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RelationshipType.merged_from)
  return _internal_merged_from();
}
inline ::anduril::entitymanager::v1::MergedFrom* RelationshipType::unsafe_arena_release_merged_from() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.RelationshipType.merged_from)
  if (type_case() == kMergedFrom) {
    clear_has_type();
    auto* temp = _impl_.type_.merged_from_;
    _impl_.type_.merged_from_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelationshipType::unsafe_arena_set_allocated_merged_from(::anduril::entitymanager::v1::MergedFrom* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_merged_from();
    _impl_.type_.merged_from_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RelationshipType.merged_from)
}
inline ::anduril::entitymanager::v1::MergedFrom* RelationshipType::_internal_mutable_merged_from() {
  if (type_case() != kMergedFrom) {
    clear_type();
    set_has_merged_from();
    _impl_.type_.merged_from_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::MergedFrom>(GetArena());
  }
  return _impl_.type_.merged_from_;
}
inline ::anduril::entitymanager::v1::MergedFrom* RelationshipType::mutable_merged_from() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::MergedFrom* _msg = _internal_mutable_merged_from();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RelationshipType.merged_from)
  return _msg;
}

inline bool RelationshipType::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void RelationshipType::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline RelationshipType::TypeCase RelationshipType::type_case() const {
  return RelationshipType::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrackedBy

// .anduril.entitymanager.v1.Sensors actively_tracking_sensors = 1 [json_name = "activelyTrackingSensors"];
inline bool TrackedBy::has_actively_tracking_sensors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.actively_tracking_sensors_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Sensors& TrackedBy::_internal_actively_tracking_sensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Sensors* p = _impl_.actively_tracking_sensors_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Sensors&>(::anduril::entitymanager::v1::_Sensors_default_instance_);
}
inline const ::anduril::entitymanager::v1::Sensors& TrackedBy::actively_tracking_sensors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.TrackedBy.actively_tracking_sensors)
  return _internal_actively_tracking_sensors();
}
inline void TrackedBy::unsafe_arena_set_allocated_actively_tracking_sensors(::anduril::entitymanager::v1::Sensors* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.actively_tracking_sensors_);
  }
  _impl_.actively_tracking_sensors_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.TrackedBy.actively_tracking_sensors)
}
inline ::anduril::entitymanager::v1::Sensors* TrackedBy::release_actively_tracking_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Sensors* released = _impl_.actively_tracking_sensors_;
  _impl_.actively_tracking_sensors_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Sensors* TrackedBy::unsafe_arena_release_actively_tracking_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.TrackedBy.actively_tracking_sensors)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Sensors* temp = _impl_.actively_tracking_sensors_;
  _impl_.actively_tracking_sensors_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Sensors* TrackedBy::_internal_mutable_actively_tracking_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.actively_tracking_sensors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Sensors>(GetArena());
    _impl_.actively_tracking_sensors_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(p);
  }
  return _impl_.actively_tracking_sensors_;
}
inline ::anduril::entitymanager::v1::Sensors* TrackedBy::mutable_actively_tracking_sensors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Sensors* _msg = _internal_mutable_actively_tracking_sensors();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.TrackedBy.actively_tracking_sensors)
  return _msg;
}
inline void TrackedBy::set_allocated_actively_tracking_sensors(::anduril::entitymanager::v1::Sensors* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.actively_tracking_sensors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.actively_tracking_sensors_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.TrackedBy.actively_tracking_sensors)
}

// .google.protobuf.Timestamp last_measurement_timestamp = 2 [json_name = "lastMeasurementTimestamp"];
inline bool TrackedBy::has_last_measurement_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_measurement_timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TrackedBy::_internal_last_measurement_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.last_measurement_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TrackedBy::last_measurement_timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.TrackedBy.last_measurement_timestamp)
  return _internal_last_measurement_timestamp();
}
inline void TrackedBy::unsafe_arena_set_allocated_last_measurement_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_measurement_timestamp_);
  }
  _impl_.last_measurement_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.TrackedBy.last_measurement_timestamp)
}
inline ::google::protobuf::Timestamp* TrackedBy::release_last_measurement_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.last_measurement_timestamp_;
  _impl_.last_measurement_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* TrackedBy::unsafe_arena_release_last_measurement_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.TrackedBy.last_measurement_timestamp)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.last_measurement_timestamp_;
  _impl_.last_measurement_timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TrackedBy::_internal_mutable_last_measurement_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_measurement_timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_measurement_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_measurement_timestamp_;
}
inline ::google::protobuf::Timestamp* TrackedBy::mutable_last_measurement_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_measurement_timestamp();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.TrackedBy.last_measurement_timestamp)
  return _msg;
}
inline void TrackedBy::set_allocated_last_measurement_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_measurement_timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.last_measurement_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.TrackedBy.last_measurement_timestamp)
}

// -------------------------------------------------------------------

// GroupChild

// -------------------------------------------------------------------

// GroupParent

// -------------------------------------------------------------------

// MergedFrom

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2frelationship_2epub_2eproto_2epb_2eh
