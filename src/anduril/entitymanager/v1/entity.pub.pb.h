// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/entitymanager/v1/entity.pub.proto
// Protobuf C++ Version: 5.29.0

#ifndef anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto_2epb_2eh
#define anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "anduril/entitymanager/v1/classification.pub.pb.h"
#include "anduril/entitymanager/v1/dimensions.pub.pb.h"
#include "anduril/entitymanager/v1/geoentity.pub.pb.h"
#include "anduril/entitymanager/v1/group.pub.pb.h"
#include "anduril/entitymanager/v1/health_status.pub.pb.h"
#include "anduril/entitymanager/v1/location.pub.pb.h"
#include "anduril/entitymanager/v1/ontology.pub.pb.h"
#include "anduril/entitymanager/v1/options.pub.pb.h"
#include "anduril/entitymanager/v1/orbit.pub.pb.h"
#include "anduril/entitymanager/v1/payloads.pub.pb.h"
#include "anduril/entitymanager/v1/power.pub.pb.h"
#include "anduril/entitymanager/v1/relationship.pub.pb.h"
#include "anduril/entitymanager/v1/route_details.pub.pb.h"
#include "anduril/entitymanager/v1/schedule.pub.pb.h"
#include "anduril/entitymanager/v1/sensors.pub.pb.h"
#include "anduril/entitymanager/v1/signal.pub.pb.h"
#include "anduril/entitymanager/v1/supplies.pub.pb.h"
#include "anduril/entitymanager/v1/target_priority.pub.pb.h"
#include "anduril/entitymanager/v1/transponder_codes.pub.pb.h"
#include "anduril/entitymanager/v1/types.pub.pb.h"
#include "anduril/tasks/v2/catalog.pub.pb.h"
#include "anduril/type/color.pub.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
namespace anduril {
namespace entitymanager {
namespace v1 {
class Aliases;
struct AliasesDefaultTypeInternal;
extern AliasesDefaultTypeInternal _Aliases_default_instance_;
class AlternateId;
struct AlternateIdDefaultTypeInternal;
extern AlternateIdDefaultTypeInternal _AlternateId_default_instance_;
class Correlation;
struct CorrelationDefaultTypeInternal;
extern CorrelationDefaultTypeInternal _Correlation_default_instance_;
class CorrelationMembership;
struct CorrelationMembershipDefaultTypeInternal;
extern CorrelationMembershipDefaultTypeInternal _CorrelationMembership_default_instance_;
class CorrelationMetadata;
struct CorrelationMetadataDefaultTypeInternal;
extern CorrelationMetadataDefaultTypeInternal _CorrelationMetadata_default_instance_;
class DecorrelatedAll;
struct DecorrelatedAllDefaultTypeInternal;
extern DecorrelatedAllDefaultTypeInternal _DecorrelatedAll_default_instance_;
class DecorrelatedSingle;
struct DecorrelatedSingleDefaultTypeInternal;
extern DecorrelatedSingleDefaultTypeInternal _DecorrelatedSingle_default_instance_;
class Decorrelation;
struct DecorrelationDefaultTypeInternal;
extern DecorrelationDefaultTypeInternal _Decorrelation_default_instance_;
class Entity;
struct EntityDefaultTypeInternal;
extern EntityDefaultTypeInternal _Entity_default_instance_;
class Indicators;
struct IndicatorsDefaultTypeInternal;
extern IndicatorsDefaultTypeInternal _Indicators_default_instance_;
class NonPrimaryMembership;
struct NonPrimaryMembershipDefaultTypeInternal;
extern NonPrimaryMembershipDefaultTypeInternal _NonPrimaryMembership_default_instance_;
class Override;
struct OverrideDefaultTypeInternal;
extern OverrideDefaultTypeInternal _Override_default_instance_;
class Overrides;
struct OverridesDefaultTypeInternal;
extern OverridesDefaultTypeInternal _Overrides_default_instance_;
class PrimaryCorrelation;
struct PrimaryCorrelationDefaultTypeInternal;
extern PrimaryCorrelationDefaultTypeInternal _PrimaryCorrelation_default_instance_;
class PrimaryMembership;
struct PrimaryMembershipDefaultTypeInternal;
extern PrimaryMembershipDefaultTypeInternal _PrimaryMembership_default_instance_;
class Provenance;
struct ProvenanceDefaultTypeInternal;
extern ProvenanceDefaultTypeInternal _Provenance_default_instance_;
class RangeRings;
struct RangeRingsDefaultTypeInternal;
extern RangeRingsDefaultTypeInternal _RangeRings_default_instance_;
class SecondaryCorrelation;
struct SecondaryCorrelationDefaultTypeInternal;
extern SecondaryCorrelationDefaultTypeInternal _SecondaryCorrelation_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class Tracked;
struct TrackedDefaultTypeInternal;
extern TrackedDefaultTypeInternal _Tracked_default_instance_;
class VisualDetails;
struct VisualDetailsDefaultTypeInternal;
extern VisualDetailsDefaultTypeInternal _VisualDetails_default_instance_;
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace entitymanager {
namespace v1 {
enum CorrelationType : int {
  CORRELATION_TYPE_INVALID = 0,
  CORRELATION_TYPE_MANUAL = 1,
  CORRELATION_TYPE_AUTOMATED = 2,
  CorrelationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CorrelationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CorrelationType_IsValid(int value);
extern const uint32_t CorrelationType_internal_data_[];
constexpr CorrelationType CorrelationType_MIN = static_cast<CorrelationType>(0);
constexpr CorrelationType CorrelationType_MAX = static_cast<CorrelationType>(2);
constexpr int CorrelationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
CorrelationType_descriptor();
template <typename T>
const std::string& CorrelationType_Name(T value) {
  static_assert(std::is_same<T, CorrelationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CorrelationType_Name().");
  return CorrelationType_Name(static_cast<CorrelationType>(value));
}
template <>
inline const std::string& CorrelationType_Name(CorrelationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CorrelationType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CorrelationType_Parse(absl::string_view name, CorrelationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CorrelationType>(
      CorrelationType_descriptor(), name, value);
}
enum CorrelationReplicationMode : int {
  CORRELATION_REPLICATION_MODE_INVALID = 0,
  CORRELATION_REPLICATION_MODE_LOCAL = 1,
  CORRELATION_REPLICATION_MODE_GLOBAL = 2,
  CorrelationReplicationMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CorrelationReplicationMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CorrelationReplicationMode_IsValid(int value);
extern const uint32_t CorrelationReplicationMode_internal_data_[];
constexpr CorrelationReplicationMode CorrelationReplicationMode_MIN = static_cast<CorrelationReplicationMode>(0);
constexpr CorrelationReplicationMode CorrelationReplicationMode_MAX = static_cast<CorrelationReplicationMode>(2);
constexpr int CorrelationReplicationMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
CorrelationReplicationMode_descriptor();
template <typename T>
const std::string& CorrelationReplicationMode_Name(T value) {
  static_assert(std::is_same<T, CorrelationReplicationMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CorrelationReplicationMode_Name().");
  return CorrelationReplicationMode_Name(static_cast<CorrelationReplicationMode>(value));
}
template <>
inline const std::string& CorrelationReplicationMode_Name(CorrelationReplicationMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CorrelationReplicationMode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CorrelationReplicationMode_Parse(absl::string_view name, CorrelationReplicationMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CorrelationReplicationMode>(
      CorrelationReplicationMode_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Status final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Status* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Status));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Status(
      ::google::protobuf::internal::ConstantInitialized);

  inline Status(const Status& from) : Status(nullptr, from) {}
  inline Status(Status&& from) noexcept
      : Status(nullptr, std::move(from)) {}
  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
        &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Status& a, Status& b) { a.Swap(&b); }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Status>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Status& from) { Status::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Status* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Status"; }

 protected:
  explicit Status(::google::protobuf::Arena* arena);
  Status(::google::protobuf::Arena* arena, const Status& from);
  Status(::google::protobuf::Arena* arena, Status&& from) noexcept
      : Status(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlatformActivityFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // string platform_activity = 1 [json_name = "platformActivity"];
  void clear_platform_activity() ;
  const std::string& platform_activity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform_activity(Arg_&& arg, Args_... args);
  std::string* mutable_platform_activity();
  PROTOBUF_NODISCARD std::string* release_platform_activity();
  void set_allocated_platform_activity(std::string* value);

  private:
  const std::string& _internal_platform_activity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform_activity(
      const std::string& value);
  std::string* _internal_mutable_platform_activity();

  public:
  // string role = 2 [json_name = "role"];
  void clear_role() ;
  const std::string& role() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role(Arg_&& arg, Args_... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* value);

  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(
      const std::string& value);
  std::string* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Status)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      61, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Status& from_msg);
    ::google::protobuf::internal::ArenaStringPtr platform_activity_;
    ::google::protobuf::internal::ArenaStringPtr role_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class PrimaryMembership final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.PrimaryMembership) */ {
 public:
  inline PrimaryMembership() : PrimaryMembership(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PrimaryMembership* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PrimaryMembership));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrimaryMembership(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrimaryMembership(const PrimaryMembership& from) : PrimaryMembership(nullptr, from) {}
  inline PrimaryMembership(PrimaryMembership&& from) noexcept
      : PrimaryMembership(nullptr, std::move(from)) {}
  inline PrimaryMembership& operator=(const PrimaryMembership& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrimaryMembership& operator=(PrimaryMembership&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrimaryMembership& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrimaryMembership* internal_default_instance() {
    return reinterpret_cast<const PrimaryMembership*>(
        &_PrimaryMembership_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(PrimaryMembership& a, PrimaryMembership& b) { a.Swap(&b); }
  inline void Swap(PrimaryMembership* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrimaryMembership* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrimaryMembership* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<PrimaryMembership>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PrimaryMembership& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PrimaryMembership& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.PrimaryMembership"; }

 protected:
  explicit PrimaryMembership(::google::protobuf::Arena* arena);
  PrimaryMembership(::google::protobuf::Arena* arena, const PrimaryMembership& from);
  PrimaryMembership(::google::protobuf::Arena* arena, PrimaryMembership&& from) noexcept
      : PrimaryMembership(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.PrimaryMembership)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PrimaryMembership& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class PrimaryCorrelation final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.PrimaryCorrelation) */ {
 public:
  inline PrimaryCorrelation() : PrimaryCorrelation(nullptr) {}
  ~PrimaryCorrelation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PrimaryCorrelation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PrimaryCorrelation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrimaryCorrelation(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrimaryCorrelation(const PrimaryCorrelation& from) : PrimaryCorrelation(nullptr, from) {}
  inline PrimaryCorrelation(PrimaryCorrelation&& from) noexcept
      : PrimaryCorrelation(nullptr, std::move(from)) {}
  inline PrimaryCorrelation& operator=(const PrimaryCorrelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrimaryCorrelation& operator=(PrimaryCorrelation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrimaryCorrelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrimaryCorrelation* internal_default_instance() {
    return reinterpret_cast<const PrimaryCorrelation*>(
        &_PrimaryCorrelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(PrimaryCorrelation& a, PrimaryCorrelation& b) { a.Swap(&b); }
  inline void Swap(PrimaryCorrelation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrimaryCorrelation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrimaryCorrelation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PrimaryCorrelation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrimaryCorrelation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrimaryCorrelation& from) { PrimaryCorrelation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PrimaryCorrelation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.PrimaryCorrelation"; }

 protected:
  explicit PrimaryCorrelation(::google::protobuf::Arena* arena);
  PrimaryCorrelation(::google::protobuf::Arena* arena, const PrimaryCorrelation& from);
  PrimaryCorrelation(::google::protobuf::Arena* arena, PrimaryCorrelation&& from) noexcept
      : PrimaryCorrelation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSecondaryEntityIdsFieldNumber = 1,
  };
  // repeated string secondary_entity_ids = 1 [json_name = "secondaryEntityIds"];
  int secondary_entity_ids_size() const;
  private:
  int _internal_secondary_entity_ids_size() const;

  public:
  void clear_secondary_entity_ids() ;
  const std::string& secondary_entity_ids(int index) const;
  std::string* mutable_secondary_entity_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secondary_entity_ids(int index, Arg_&& value, Args_... args);
  std::string* add_secondary_entity_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_secondary_entity_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& secondary_entity_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_secondary_entity_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_secondary_entity_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_secondary_entity_ids();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.PrimaryCorrelation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      72, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PrimaryCorrelation& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> secondary_entity_ids_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class NonPrimaryMembership final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.NonPrimaryMembership) */ {
 public:
  inline NonPrimaryMembership() : NonPrimaryMembership(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NonPrimaryMembership* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NonPrimaryMembership));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NonPrimaryMembership(
      ::google::protobuf::internal::ConstantInitialized);

  inline NonPrimaryMembership(const NonPrimaryMembership& from) : NonPrimaryMembership(nullptr, from) {}
  inline NonPrimaryMembership(NonPrimaryMembership&& from) noexcept
      : NonPrimaryMembership(nullptr, std::move(from)) {}
  inline NonPrimaryMembership& operator=(const NonPrimaryMembership& from) {
    CopyFrom(from);
    return *this;
  }
  inline NonPrimaryMembership& operator=(NonPrimaryMembership&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NonPrimaryMembership& default_instance() {
    return *internal_default_instance();
  }
  static inline const NonPrimaryMembership* internal_default_instance() {
    return reinterpret_cast<const NonPrimaryMembership*>(
        &_NonPrimaryMembership_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(NonPrimaryMembership& a, NonPrimaryMembership& b) { a.Swap(&b); }
  inline void Swap(NonPrimaryMembership* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NonPrimaryMembership* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NonPrimaryMembership* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<NonPrimaryMembership>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NonPrimaryMembership& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NonPrimaryMembership& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.NonPrimaryMembership"; }

 protected:
  explicit NonPrimaryMembership(::google::protobuf::Arena* arena);
  NonPrimaryMembership(::google::protobuf::Arena* arena, const NonPrimaryMembership& from);
  NonPrimaryMembership(::google::protobuf::Arena* arena, NonPrimaryMembership&& from) noexcept
      : NonPrimaryMembership(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.NonPrimaryMembership)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NonPrimaryMembership& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class AlternateId final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.AlternateId) */ {
 public:
  inline AlternateId() : AlternateId(nullptr) {}
  ~AlternateId() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AlternateId* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AlternateId));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AlternateId(
      ::google::protobuf::internal::ConstantInitialized);

  inline AlternateId(const AlternateId& from) : AlternateId(nullptr, from) {}
  inline AlternateId(AlternateId&& from) noexcept
      : AlternateId(nullptr, std::move(from)) {}
  inline AlternateId& operator=(const AlternateId& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlternateId& operator=(AlternateId&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlternateId& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlternateId* internal_default_instance() {
    return reinterpret_cast<const AlternateId*>(
        &_AlternateId_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(AlternateId& a, AlternateId& b) { a.Swap(&b); }
  inline void Swap(AlternateId* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlternateId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlternateId* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AlternateId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AlternateId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AlternateId& from) { AlternateId::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AlternateId* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.AlternateId"; }

 protected:
  explicit AlternateId(::google::protobuf::Arena* arena);
  AlternateId(::google::protobuf::Arena* arena, const AlternateId& from);
  AlternateId(::google::protobuf::Arena* arena, AlternateId&& from) noexcept
      : AlternateId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string id = 2 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .anduril.entitymanager.v1.AltIdType type = 3 [json_name = "type"];
  void clear_type() ;
  ::anduril::entitymanager::v1::AltIdType type() const;
  void set_type(::anduril::entitymanager::v1::AltIdType value);

  private:
  ::anduril::entitymanager::v1::AltIdType _internal_type() const;
  void _internal_set_type(::anduril::entitymanager::v1::AltIdType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.AlternateId)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      47, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AlternateId& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    int type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class Provenance final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Provenance) */ {
 public:
  inline Provenance() : Provenance(nullptr) {}
  ~Provenance() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Provenance* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Provenance));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Provenance(
      ::google::protobuf::internal::ConstantInitialized);

  inline Provenance(const Provenance& from) : Provenance(nullptr, from) {}
  inline Provenance(Provenance&& from) noexcept
      : Provenance(nullptr, std::move(from)) {}
  inline Provenance& operator=(const Provenance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Provenance& operator=(Provenance&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Provenance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Provenance* internal_default_instance() {
    return reinterpret_cast<const Provenance*>(
        &_Provenance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Provenance& a, Provenance& b) { a.Swap(&b); }
  inline void Swap(Provenance* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Provenance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Provenance* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Provenance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Provenance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Provenance& from) { Provenance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Provenance* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Provenance"; }

 protected:
  explicit Provenance(::google::protobuf::Arena* arena);
  Provenance(::google::protobuf::Arena* arena, const Provenance& from);
  Provenance(::google::protobuf::Arena* arena, Provenance&& from) noexcept
      : Provenance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceIdFieldNumber = 3,
    kSourceDescriptionFieldNumber = 4,
    kIntegrationNameFieldNumber = 5,
    kDataTypeFieldNumber = 6,
    kSourceUpdateTimeFieldNumber = 2,
  };
  // string source_id = 3 [json_name = "sourceId"];
  void clear_source_id() ;
  const std::string& source_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_id();
  PROTOBUF_NODISCARD std::string* release_source_id();
  void set_allocated_source_id(std::string* value);

  private:
  const std::string& _internal_source_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_id(
      const std::string& value);
  std::string* _internal_mutable_source_id();

  public:
  // string source_description = 4 [json_name = "sourceDescription"];
  void clear_source_description() ;
  const std::string& source_description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_description(Arg_&& arg, Args_... args);
  std::string* mutable_source_description();
  PROTOBUF_NODISCARD std::string* release_source_description();
  void set_allocated_source_description(std::string* value);

  private:
  const std::string& _internal_source_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_description(
      const std::string& value);
  std::string* _internal_mutable_source_description();

  public:
  // string integration_name = 5 [json_name = "integrationName"];
  void clear_integration_name() ;
  const std::string& integration_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_integration_name(Arg_&& arg, Args_... args);
  std::string* mutable_integration_name();
  PROTOBUF_NODISCARD std::string* release_integration_name();
  void set_allocated_integration_name(std::string* value);

  private:
  const std::string& _internal_integration_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration_name(
      const std::string& value);
  std::string* _internal_mutable_integration_name();

  public:
  // string data_type = 6 [json_name = "dataType"];
  void clear_data_type() ;
  const std::string& data_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_type(Arg_&& arg, Args_... args);
  std::string* mutable_data_type();
  PROTOBUF_NODISCARD std::string* release_data_type();
  void set_allocated_data_type(std::string* value);

  private:
  const std::string& _internal_data_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_type(
      const std::string& value);
  std::string* _internal_mutable_data_type();

  public:
  // .google.protobuf.Timestamp source_update_time = 2 [json_name = "sourceUpdateTime"];
  bool has_source_update_time() const;
  void clear_source_update_time() ;
  const ::google::protobuf::Timestamp& source_update_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_source_update_time();
  ::google::protobuf::Timestamp* mutable_source_update_time();
  void set_allocated_source_update_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_source_update_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_source_update_time();

  private:
  const ::google::protobuf::Timestamp& _internal_source_update_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_source_update_time();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Provenance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      96, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Provenance& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr source_id_;
    ::google::protobuf::internal::ArenaStringPtr source_description_;
    ::google::protobuf::internal::ArenaStringPtr integration_name_;
    ::google::protobuf::internal::ArenaStringPtr data_type_;
    ::google::protobuf::Timestamp* source_update_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class Indicators final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Indicators) */ {
 public:
  inline Indicators() : Indicators(nullptr) {}
  ~Indicators() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Indicators* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Indicators));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Indicators(
      ::google::protobuf::internal::ConstantInitialized);

  inline Indicators(const Indicators& from) : Indicators(nullptr, from) {}
  inline Indicators(Indicators&& from) noexcept
      : Indicators(nullptr, std::move(from)) {}
  inline Indicators& operator=(const Indicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline Indicators& operator=(Indicators&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Indicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const Indicators* internal_default_instance() {
    return reinterpret_cast<const Indicators*>(
        &_Indicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Indicators& a, Indicators& b) { a.Swap(&b); }
  inline void Swap(Indicators* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Indicators* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Indicators* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Indicators>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Indicators& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Indicators& from) { Indicators::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Indicators* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Indicators"; }

 protected:
  explicit Indicators(::google::protobuf::Arena* arena);
  Indicators(::google::protobuf::Arena* arena, const Indicators& from);
  Indicators(::google::protobuf::Arena* arena, Indicators&& from) noexcept
      : Indicators(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSimulatedFieldNumber = 1,
    kExerciseFieldNumber = 2,
    kEmergencyFieldNumber = 3,
    kC2FieldNumber = 4,
    kEgressableFieldNumber = 6,
    kStarredFieldNumber = 7,
  };
  // .google.protobuf.BoolValue simulated = 1 [json_name = "simulated"];
  bool has_simulated() const;
  void clear_simulated() ;
  const ::google::protobuf::BoolValue& simulated() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_simulated();
  ::google::protobuf::BoolValue* mutable_simulated();
  void set_allocated_simulated(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_simulated(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_simulated();

  private:
  const ::google::protobuf::BoolValue& _internal_simulated() const;
  ::google::protobuf::BoolValue* _internal_mutable_simulated();

  public:
  // .google.protobuf.BoolValue exercise = 2 [json_name = "exercise"];
  bool has_exercise() const;
  void clear_exercise() ;
  const ::google::protobuf::BoolValue& exercise() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_exercise();
  ::google::protobuf::BoolValue* mutable_exercise();
  void set_allocated_exercise(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_exercise(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_exercise();

  private:
  const ::google::protobuf::BoolValue& _internal_exercise() const;
  ::google::protobuf::BoolValue* _internal_mutable_exercise();

  public:
  // .google.protobuf.BoolValue emergency = 3 [json_name = "emergency"];
  bool has_emergency() const;
  void clear_emergency() ;
  const ::google::protobuf::BoolValue& emergency() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_emergency();
  ::google::protobuf::BoolValue* mutable_emergency();
  void set_allocated_emergency(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_emergency(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_emergency();

  private:
  const ::google::protobuf::BoolValue& _internal_emergency() const;
  ::google::protobuf::BoolValue* _internal_mutable_emergency();

  public:
  // .google.protobuf.BoolValue c2 = 4 [json_name = "c2"];
  bool has_c2() const;
  void clear_c2() ;
  const ::google::protobuf::BoolValue& c2() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_c2();
  ::google::protobuf::BoolValue* mutable_c2();
  void set_allocated_c2(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_c2(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_c2();

  private:
  const ::google::protobuf::BoolValue& _internal_c2() const;
  ::google::protobuf::BoolValue* _internal_mutable_c2();

  public:
  // .google.protobuf.BoolValue egressable = 6 [json_name = "egressable", (.anduril.entitymanager.v1.overridable) = true];
  bool has_egressable() const;
  void clear_egressable() ;
  const ::google::protobuf::BoolValue& egressable() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_egressable();
  ::google::protobuf::BoolValue* mutable_egressable();
  void set_allocated_egressable(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_egressable(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_egressable();

  private:
  const ::google::protobuf::BoolValue& _internal_egressable() const;
  ::google::protobuf::BoolValue* _internal_mutable_egressable();

  public:
  // .google.protobuf.BoolValue starred = 7 [json_name = "starred", (.anduril.entitymanager.v1.overridable) = true];
  bool has_starred() const;
  void clear_starred() ;
  const ::google::protobuf::BoolValue& starred() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_starred();
  ::google::protobuf::BoolValue* mutable_starred();
  void set_allocated_starred(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_starred(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_starred();

  private:
  const ::google::protobuf::BoolValue& _internal_starred() const;
  ::google::protobuf::BoolValue* _internal_mutable_starred();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Indicators)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Indicators& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::BoolValue* simulated_;
    ::google::protobuf::BoolValue* exercise_;
    ::google::protobuf::BoolValue* emergency_;
    ::google::protobuf::BoolValue* c2_;
    ::google::protobuf::BoolValue* egressable_;
    ::google::protobuf::BoolValue* starred_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class Aliases final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Aliases) */ {
 public:
  inline Aliases() : Aliases(nullptr) {}
  ~Aliases() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Aliases* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Aliases));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Aliases(
      ::google::protobuf::internal::ConstantInitialized);

  inline Aliases(const Aliases& from) : Aliases(nullptr, from) {}
  inline Aliases(Aliases&& from) noexcept
      : Aliases(nullptr, std::move(from)) {}
  inline Aliases& operator=(const Aliases& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aliases& operator=(Aliases&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aliases& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aliases* internal_default_instance() {
    return reinterpret_cast<const Aliases*>(
        &_Aliases_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Aliases& a, Aliases& b) { a.Swap(&b); }
  inline void Swap(Aliases* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aliases* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aliases* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Aliases>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Aliases& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Aliases& from) { Aliases::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Aliases* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Aliases"; }

 protected:
  explicit Aliases(::google::protobuf::Arena* arena);
  Aliases(::google::protobuf::Arena* arena, const Aliases& from);
  Aliases(::google::protobuf::Arena* arena, Aliases&& from) noexcept
      : Aliases(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAlternateIdsFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // repeated .anduril.entitymanager.v1.AlternateId alternate_ids = 1 [json_name = "alternateIds", (.anduril.entitymanager.v1.overridable) = true];
  int alternate_ids_size() const;
  private:
  int _internal_alternate_ids_size() const;

  public:
  void clear_alternate_ids() ;
  ::anduril::entitymanager::v1::AlternateId* mutable_alternate_ids(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>* mutable_alternate_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>& _internal_alternate_ids() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>* _internal_mutable_alternate_ids();
  public:
  const ::anduril::entitymanager::v1::AlternateId& alternate_ids(int index) const;
  ::anduril::entitymanager::v1::AlternateId* add_alternate_ids();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>& alternate_ids() const;
  // string name = 2 [json_name = "name", (.anduril.entitymanager.v1.overridable) = true];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Aliases)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      45, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Aliases& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::AlternateId > alternate_ids_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class RangeRings final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.RangeRings) */ {
 public:
  inline RangeRings() : RangeRings(nullptr) {}
  ~RangeRings() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RangeRings* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RangeRings));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RangeRings(
      ::google::protobuf::internal::ConstantInitialized);

  inline RangeRings(const RangeRings& from) : RangeRings(nullptr, from) {}
  inline RangeRings(RangeRings&& from) noexcept
      : RangeRings(nullptr, std::move(from)) {}
  inline RangeRings& operator=(const RangeRings& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeRings& operator=(RangeRings&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeRings& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeRings* internal_default_instance() {
    return reinterpret_cast<const RangeRings*>(
        &_RangeRings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(RangeRings& a, RangeRings& b) { a.Swap(&b); }
  inline void Swap(RangeRings* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeRings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeRings* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RangeRings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RangeRings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RangeRings& from) { RangeRings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RangeRings* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.RangeRings"; }

 protected:
  explicit RangeRings(::google::protobuf::Arena* arena);
  RangeRings(::google::protobuf::Arena* arena, const RangeRings& from);
  RangeRings(::google::protobuf::Arena* arena, RangeRings&& from) noexcept
      : RangeRings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMinDistanceMFieldNumber = 1,
    kMaxDistanceMFieldNumber = 2,
    kRingLineColorFieldNumber = 4,
    kRingCountFieldNumber = 3,
  };
  // .google.protobuf.DoubleValue min_distance_m = 1 [json_name = "minDistanceM"];
  bool has_min_distance_m() const;
  void clear_min_distance_m() ;
  const ::google::protobuf::DoubleValue& min_distance_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_min_distance_m();
  ::google::protobuf::DoubleValue* mutable_min_distance_m();
  void set_allocated_min_distance_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_min_distance_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_min_distance_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_min_distance_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_min_distance_m();

  public:
  // .google.protobuf.DoubleValue max_distance_m = 2 [json_name = "maxDistanceM"];
  bool has_max_distance_m() const;
  void clear_max_distance_m() ;
  const ::google::protobuf::DoubleValue& max_distance_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_max_distance_m();
  ::google::protobuf::DoubleValue* mutable_max_distance_m();
  void set_allocated_max_distance_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_max_distance_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_max_distance_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_max_distance_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_max_distance_m();

  public:
  // .anduril.type.Color ring_line_color = 4 [json_name = "ringLineColor"];
  bool has_ring_line_color() const;
  void clear_ring_line_color() ;
  const ::anduril::type::Color& ring_line_color() const;
  PROTOBUF_NODISCARD ::anduril::type::Color* release_ring_line_color();
  ::anduril::type::Color* mutable_ring_line_color();
  void set_allocated_ring_line_color(::anduril::type::Color* value);
  void unsafe_arena_set_allocated_ring_line_color(::anduril::type::Color* value);
  ::anduril::type::Color* unsafe_arena_release_ring_line_color();

  private:
  const ::anduril::type::Color& _internal_ring_line_color() const;
  ::anduril::type::Color* _internal_mutable_ring_line_color();

  public:
  // uint32 ring_count = 3 [json_name = "ringCount"];
  void clear_ring_count() ;
  ::uint32_t ring_count() const;
  void set_ring_count(::uint32_t value);

  private:
  ::uint32_t _internal_ring_count() const;
  void _internal_set_ring_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.RangeRings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RangeRings& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::DoubleValue* min_distance_m_;
    ::google::protobuf::DoubleValue* max_distance_m_;
    ::anduril::type::Color* ring_line_color_;
    ::uint32_t ring_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class CorrelationMetadata final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.CorrelationMetadata) */ {
 public:
  inline CorrelationMetadata() : CorrelationMetadata(nullptr) {}
  ~CorrelationMetadata() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CorrelationMetadata* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CorrelationMetadata));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CorrelationMetadata(
      ::google::protobuf::internal::ConstantInitialized);

  inline CorrelationMetadata(const CorrelationMetadata& from) : CorrelationMetadata(nullptr, from) {}
  inline CorrelationMetadata(CorrelationMetadata&& from) noexcept
      : CorrelationMetadata(nullptr, std::move(from)) {}
  inline CorrelationMetadata& operator=(const CorrelationMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CorrelationMetadata& operator=(CorrelationMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CorrelationMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CorrelationMetadata* internal_default_instance() {
    return reinterpret_cast<const CorrelationMetadata*>(
        &_CorrelationMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(CorrelationMetadata& a, CorrelationMetadata& b) { a.Swap(&b); }
  inline void Swap(CorrelationMetadata* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CorrelationMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CorrelationMetadata* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CorrelationMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CorrelationMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CorrelationMetadata& from) { CorrelationMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CorrelationMetadata* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.CorrelationMetadata"; }

 protected:
  explicit CorrelationMetadata(::google::protobuf::Arena* arena);
  CorrelationMetadata(::google::protobuf::Arena* arena, const CorrelationMetadata& from);
  CorrelationMetadata(::google::protobuf::Arena* arena, CorrelationMetadata&& from) noexcept
      : CorrelationMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProvenanceFieldNumber = 1,
    kReplicationModeFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // .anduril.entitymanager.v1.Provenance provenance = 1 [json_name = "provenance"];
  bool has_provenance() const;
  void clear_provenance() ;
  const ::anduril::entitymanager::v1::Provenance& provenance() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Provenance* release_provenance();
  ::anduril::entitymanager::v1::Provenance* mutable_provenance();
  void set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  void unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  ::anduril::entitymanager::v1::Provenance* unsafe_arena_release_provenance();

  private:
  const ::anduril::entitymanager::v1::Provenance& _internal_provenance() const;
  ::anduril::entitymanager::v1::Provenance* _internal_mutable_provenance();

  public:
  // .anduril.entitymanager.v1.CorrelationReplicationMode replication_mode = 2 [json_name = "replicationMode"];
  void clear_replication_mode() ;
  ::anduril::entitymanager::v1::CorrelationReplicationMode replication_mode() const;
  void set_replication_mode(::anduril::entitymanager::v1::CorrelationReplicationMode value);

  private:
  ::anduril::entitymanager::v1::CorrelationReplicationMode _internal_replication_mode() const;
  void _internal_set_replication_mode(::anduril::entitymanager::v1::CorrelationReplicationMode value);

  public:
  // .anduril.entitymanager.v1.CorrelationType type = 3 [json_name = "type"];
  void clear_type() ;
  ::anduril::entitymanager::v1::CorrelationType type() const;
  void set_type(::anduril::entitymanager::v1::CorrelationType value);

  private:
  ::anduril::entitymanager::v1::CorrelationType _internal_type() const;
  void _internal_set_type(::anduril::entitymanager::v1::CorrelationType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.CorrelationMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CorrelationMetadata& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Provenance* provenance_;
    int replication_mode_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class VisualDetails final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.VisualDetails) */ {
 public:
  inline VisualDetails() : VisualDetails(nullptr) {}
  ~VisualDetails() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VisualDetails* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VisualDetails));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VisualDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline VisualDetails(const VisualDetails& from) : VisualDetails(nullptr, from) {}
  inline VisualDetails(VisualDetails&& from) noexcept
      : VisualDetails(nullptr, std::move(from)) {}
  inline VisualDetails& operator=(const VisualDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisualDetails& operator=(VisualDetails&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisualDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisualDetails* internal_default_instance() {
    return reinterpret_cast<const VisualDetails*>(
        &_VisualDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(VisualDetails& a, VisualDetails& b) { a.Swap(&b); }
  inline void Swap(VisualDetails* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisualDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisualDetails* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VisualDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisualDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VisualDetails& from) { VisualDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VisualDetails* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.VisualDetails"; }

 protected:
  explicit VisualDetails(::google::protobuf::Arena* arena);
  VisualDetails(::google::protobuf::Arena* arena, const VisualDetails& from);
  VisualDetails(::google::protobuf::Arena* arena, VisualDetails&& from) noexcept
      : VisualDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRangeRingsFieldNumber = 1,
  };
  // .anduril.entitymanager.v1.RangeRings range_rings = 1 [json_name = "rangeRings", (.anduril.entitymanager.v1.overridable) = true];
  bool has_range_rings() const;
  void clear_range_rings() ;
  const ::anduril::entitymanager::v1::RangeRings& range_rings() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::RangeRings* release_range_rings();
  ::anduril::entitymanager::v1::RangeRings* mutable_range_rings();
  void set_allocated_range_rings(::anduril::entitymanager::v1::RangeRings* value);
  void unsafe_arena_set_allocated_range_rings(::anduril::entitymanager::v1::RangeRings* value);
  ::anduril::entitymanager::v1::RangeRings* unsafe_arena_release_range_rings();

  private:
  const ::anduril::entitymanager::v1::RangeRings& _internal_range_rings() const;
  ::anduril::entitymanager::v1::RangeRings* _internal_mutable_range_rings();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.VisualDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VisualDetails& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::RangeRings* range_rings_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class SecondaryCorrelation final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.SecondaryCorrelation) */ {
 public:
  inline SecondaryCorrelation() : SecondaryCorrelation(nullptr) {}
  ~SecondaryCorrelation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SecondaryCorrelation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SecondaryCorrelation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SecondaryCorrelation(
      ::google::protobuf::internal::ConstantInitialized);

  inline SecondaryCorrelation(const SecondaryCorrelation& from) : SecondaryCorrelation(nullptr, from) {}
  inline SecondaryCorrelation(SecondaryCorrelation&& from) noexcept
      : SecondaryCorrelation(nullptr, std::move(from)) {}
  inline SecondaryCorrelation& operator=(const SecondaryCorrelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecondaryCorrelation& operator=(SecondaryCorrelation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecondaryCorrelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecondaryCorrelation* internal_default_instance() {
    return reinterpret_cast<const SecondaryCorrelation*>(
        &_SecondaryCorrelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SecondaryCorrelation& a, SecondaryCorrelation& b) { a.Swap(&b); }
  inline void Swap(SecondaryCorrelation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecondaryCorrelation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecondaryCorrelation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SecondaryCorrelation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SecondaryCorrelation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SecondaryCorrelation& from) { SecondaryCorrelation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SecondaryCorrelation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.SecondaryCorrelation"; }

 protected:
  explicit SecondaryCorrelation(::google::protobuf::Arena* arena);
  SecondaryCorrelation(::google::protobuf::Arena* arena, const SecondaryCorrelation& from);
  SecondaryCorrelation(::google::protobuf::Arena* arena, SecondaryCorrelation&& from) noexcept
      : SecondaryCorrelation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrimaryEntityIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // string primary_entity_id = 1 [json_name = "primaryEntityId"];
  void clear_primary_entity_id() ;
  const std::string& primary_entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_primary_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_primary_entity_id();
  PROTOBUF_NODISCARD std::string* release_primary_entity_id();
  void set_allocated_primary_entity_id(std::string* value);

  private:
  const std::string& _internal_primary_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_entity_id(
      const std::string& value);
  std::string* _internal_mutable_primary_entity_id();

  public:
  // .anduril.entitymanager.v1.CorrelationMetadata metadata = 2 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::anduril::entitymanager::v1::CorrelationMetadata& metadata() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::CorrelationMetadata* release_metadata();
  ::anduril::entitymanager::v1::CorrelationMetadata* mutable_metadata();
  void set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value);
  void unsafe_arena_set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value);
  ::anduril::entitymanager::v1::CorrelationMetadata* unsafe_arena_release_metadata();

  private:
  const ::anduril::entitymanager::v1::CorrelationMetadata& _internal_metadata() const;
  ::anduril::entitymanager::v1::CorrelationMetadata* _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.SecondaryCorrelation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      71, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SecondaryCorrelation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr primary_entity_id_;
    ::anduril::entitymanager::v1::CorrelationMetadata* metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class DecorrelatedSingle final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.DecorrelatedSingle) */ {
 public:
  inline DecorrelatedSingle() : DecorrelatedSingle(nullptr) {}
  ~DecorrelatedSingle() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DecorrelatedSingle* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DecorrelatedSingle));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DecorrelatedSingle(
      ::google::protobuf::internal::ConstantInitialized);

  inline DecorrelatedSingle(const DecorrelatedSingle& from) : DecorrelatedSingle(nullptr, from) {}
  inline DecorrelatedSingle(DecorrelatedSingle&& from) noexcept
      : DecorrelatedSingle(nullptr, std::move(from)) {}
  inline DecorrelatedSingle& operator=(const DecorrelatedSingle& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecorrelatedSingle& operator=(DecorrelatedSingle&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecorrelatedSingle& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecorrelatedSingle* internal_default_instance() {
    return reinterpret_cast<const DecorrelatedSingle*>(
        &_DecorrelatedSingle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(DecorrelatedSingle& a, DecorrelatedSingle& b) { a.Swap(&b); }
  inline void Swap(DecorrelatedSingle* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecorrelatedSingle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecorrelatedSingle* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DecorrelatedSingle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DecorrelatedSingle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DecorrelatedSingle& from) { DecorrelatedSingle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DecorrelatedSingle* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.DecorrelatedSingle"; }

 protected:
  explicit DecorrelatedSingle(::google::protobuf::Arena* arena);
  DecorrelatedSingle(::google::protobuf::Arena* arena, const DecorrelatedSingle& from);
  DecorrelatedSingle(::google::protobuf::Arena* arena, DecorrelatedSingle&& from) noexcept
      : DecorrelatedSingle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // .anduril.entitymanager.v1.CorrelationMetadata metadata = 2 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::anduril::entitymanager::v1::CorrelationMetadata& metadata() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::CorrelationMetadata* release_metadata();
  ::anduril::entitymanager::v1::CorrelationMetadata* mutable_metadata();
  void set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value);
  void unsafe_arena_set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value);
  ::anduril::entitymanager::v1::CorrelationMetadata* unsafe_arena_release_metadata();

  private:
  const ::anduril::entitymanager::v1::CorrelationMetadata& _internal_metadata() const;
  ::anduril::entitymanager::v1::CorrelationMetadata* _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.DecorrelatedSingle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      61, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DecorrelatedSingle& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::anduril::entitymanager::v1::CorrelationMetadata* metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class DecorrelatedAll final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.DecorrelatedAll) */ {
 public:
  inline DecorrelatedAll() : DecorrelatedAll(nullptr) {}
  ~DecorrelatedAll() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DecorrelatedAll* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DecorrelatedAll));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DecorrelatedAll(
      ::google::protobuf::internal::ConstantInitialized);

  inline DecorrelatedAll(const DecorrelatedAll& from) : DecorrelatedAll(nullptr, from) {}
  inline DecorrelatedAll(DecorrelatedAll&& from) noexcept
      : DecorrelatedAll(nullptr, std::move(from)) {}
  inline DecorrelatedAll& operator=(const DecorrelatedAll& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecorrelatedAll& operator=(DecorrelatedAll&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecorrelatedAll& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecorrelatedAll* internal_default_instance() {
    return reinterpret_cast<const DecorrelatedAll*>(
        &_DecorrelatedAll_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(DecorrelatedAll& a, DecorrelatedAll& b) { a.Swap(&b); }
  inline void Swap(DecorrelatedAll* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecorrelatedAll* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecorrelatedAll* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DecorrelatedAll>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DecorrelatedAll& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DecorrelatedAll& from) { DecorrelatedAll::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DecorrelatedAll* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.DecorrelatedAll"; }

 protected:
  explicit DecorrelatedAll(::google::protobuf::Arena* arena);
  DecorrelatedAll(::google::protobuf::Arena* arena, const DecorrelatedAll& from);
  DecorrelatedAll(::google::protobuf::Arena* arena, DecorrelatedAll&& from) noexcept
      : DecorrelatedAll(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 1,
  };
  // .anduril.entitymanager.v1.CorrelationMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::anduril::entitymanager::v1::CorrelationMetadata& metadata() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::CorrelationMetadata* release_metadata();
  ::anduril::entitymanager::v1::CorrelationMetadata* mutable_metadata();
  void set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value);
  void unsafe_arena_set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value);
  ::anduril::entitymanager::v1::CorrelationMetadata* unsafe_arena_release_metadata();

  private:
  const ::anduril::entitymanager::v1::CorrelationMetadata& _internal_metadata() const;
  ::anduril::entitymanager::v1::CorrelationMetadata* _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.DecorrelatedAll)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DecorrelatedAll& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::CorrelationMetadata* metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class CorrelationMembership final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.CorrelationMembership) */ {
 public:
  inline CorrelationMembership() : CorrelationMembership(nullptr) {}
  ~CorrelationMembership() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CorrelationMembership* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CorrelationMembership));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CorrelationMembership(
      ::google::protobuf::internal::ConstantInitialized);

  inline CorrelationMembership(const CorrelationMembership& from) : CorrelationMembership(nullptr, from) {}
  inline CorrelationMembership(CorrelationMembership&& from) noexcept
      : CorrelationMembership(nullptr, std::move(from)) {}
  inline CorrelationMembership& operator=(const CorrelationMembership& from) {
    CopyFrom(from);
    return *this;
  }
  inline CorrelationMembership& operator=(CorrelationMembership&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CorrelationMembership& default_instance() {
    return *internal_default_instance();
  }
  enum MembershipCase {
    kPrimary = 2,
    kNonPrimary = 3,
    MEMBERSHIP_NOT_SET = 0,
  };
  static inline const CorrelationMembership* internal_default_instance() {
    return reinterpret_cast<const CorrelationMembership*>(
        &_CorrelationMembership_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(CorrelationMembership& a, CorrelationMembership& b) { a.Swap(&b); }
  inline void Swap(CorrelationMembership* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CorrelationMembership* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CorrelationMembership* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CorrelationMembership>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CorrelationMembership& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CorrelationMembership& from) { CorrelationMembership::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CorrelationMembership* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.CorrelationMembership"; }

 protected:
  explicit CorrelationMembership(::google::protobuf::Arena* arena);
  CorrelationMembership(::google::protobuf::Arena* arena, const CorrelationMembership& from);
  CorrelationMembership(::google::protobuf::Arena* arena, CorrelationMembership&& from) noexcept
      : CorrelationMembership(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCorrelationSetIdFieldNumber = 1,
    kMetadataFieldNumber = 4,
    kPrimaryFieldNumber = 2,
    kNonPrimaryFieldNumber = 3,
  };
  // string correlation_set_id = 1 [json_name = "correlationSetId"];
  void clear_correlation_set_id() ;
  const std::string& correlation_set_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_correlation_set_id(Arg_&& arg, Args_... args);
  std::string* mutable_correlation_set_id();
  PROTOBUF_NODISCARD std::string* release_correlation_set_id();
  void set_allocated_correlation_set_id(std::string* value);

  private:
  const std::string& _internal_correlation_set_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correlation_set_id(
      const std::string& value);
  std::string* _internal_mutable_correlation_set_id();

  public:
  // .anduril.entitymanager.v1.CorrelationMetadata metadata = 4 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::anduril::entitymanager::v1::CorrelationMetadata& metadata() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::CorrelationMetadata* release_metadata();
  ::anduril::entitymanager::v1::CorrelationMetadata* mutable_metadata();
  void set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value);
  void unsafe_arena_set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value);
  ::anduril::entitymanager::v1::CorrelationMetadata* unsafe_arena_release_metadata();

  private:
  const ::anduril::entitymanager::v1::CorrelationMetadata& _internal_metadata() const;
  ::anduril::entitymanager::v1::CorrelationMetadata* _internal_mutable_metadata();

  public:
  // .anduril.entitymanager.v1.PrimaryMembership primary = 2 [json_name = "primary"];
  bool has_primary() const;
  private:
  bool _internal_has_primary() const;

  public:
  void clear_primary() ;
  const ::anduril::entitymanager::v1::PrimaryMembership& primary() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::PrimaryMembership* release_primary();
  ::anduril::entitymanager::v1::PrimaryMembership* mutable_primary();
  void set_allocated_primary(::anduril::entitymanager::v1::PrimaryMembership* value);
  void unsafe_arena_set_allocated_primary(::anduril::entitymanager::v1::PrimaryMembership* value);
  ::anduril::entitymanager::v1::PrimaryMembership* unsafe_arena_release_primary();

  private:
  const ::anduril::entitymanager::v1::PrimaryMembership& _internal_primary() const;
  ::anduril::entitymanager::v1::PrimaryMembership* _internal_mutable_primary();

  public:
  // .anduril.entitymanager.v1.NonPrimaryMembership non_primary = 3 [json_name = "nonPrimary"];
  bool has_non_primary() const;
  private:
  bool _internal_has_non_primary() const;

  public:
  void clear_non_primary() ;
  const ::anduril::entitymanager::v1::NonPrimaryMembership& non_primary() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::NonPrimaryMembership* release_non_primary();
  ::anduril::entitymanager::v1::NonPrimaryMembership* mutable_non_primary();
  void set_allocated_non_primary(::anduril::entitymanager::v1::NonPrimaryMembership* value);
  void unsafe_arena_set_allocated_non_primary(::anduril::entitymanager::v1::NonPrimaryMembership* value);
  ::anduril::entitymanager::v1::NonPrimaryMembership* unsafe_arena_release_non_primary();

  private:
  const ::anduril::entitymanager::v1::NonPrimaryMembership& _internal_non_primary() const;
  ::anduril::entitymanager::v1::NonPrimaryMembership* _internal_mutable_non_primary();

  public:
  void clear_membership();
  MembershipCase membership_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.CorrelationMembership)
 private:
  class _Internal;
  void set_has_primary();
  void set_has_non_primary();
  inline bool has_membership() const;
  inline void clear_has_membership();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 3,
      73, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CorrelationMembership& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr correlation_set_id_;
    ::anduril::entitymanager::v1::CorrelationMetadata* metadata_;
    union MembershipUnion {
      constexpr MembershipUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::PrimaryMembership* primary_;
      ::anduril::entitymanager::v1::NonPrimaryMembership* non_primary_;
    } membership_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class Tracked final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Tracked) */ {
 public:
  inline Tracked() : Tracked(nullptr) {}
  ~Tracked() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Tracked* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Tracked));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Tracked(
      ::google::protobuf::internal::ConstantInitialized);

  inline Tracked(const Tracked& from) : Tracked(nullptr, from) {}
  inline Tracked(Tracked&& from) noexcept
      : Tracked(nullptr, std::move(from)) {}
  inline Tracked& operator=(const Tracked& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tracked& operator=(Tracked&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tracked& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tracked* internal_default_instance() {
    return reinterpret_cast<const Tracked*>(
        &_Tracked_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Tracked& a, Tracked& b) { a.Swap(&b); }
  inline void Swap(Tracked* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tracked* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tracked* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Tracked>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Tracked& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Tracked& from) { Tracked::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Tracked* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Tracked"; }

 protected:
  explicit Tracked(::google::protobuf::Arena* arena);
  Tracked(::google::protobuf::Arena* arena, const Tracked& from);
  Tracked(::google::protobuf::Arena* arena, Tracked&& from) noexcept
      : Tracked(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackQualityWrapperFieldNumber = 2,
    kSensorHitsFieldNumber = 3,
    kNumberOfObjectsFieldNumber = 4,
    kRadarCrossSectionFieldNumber = 6,
    kLastMeasurementTimeFieldNumber = 7,
    kLineOfBearingFieldNumber = 9,
  };
  // .google.protobuf.Int32Value track_quality_wrapper = 2 [json_name = "trackQualityWrapper"];
  bool has_track_quality_wrapper() const;
  void clear_track_quality_wrapper() ;
  const ::google::protobuf::Int32Value& track_quality_wrapper() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int32Value* release_track_quality_wrapper();
  ::google::protobuf::Int32Value* mutable_track_quality_wrapper();
  void set_allocated_track_quality_wrapper(::google::protobuf::Int32Value* value);
  void unsafe_arena_set_allocated_track_quality_wrapper(::google::protobuf::Int32Value* value);
  ::google::protobuf::Int32Value* unsafe_arena_release_track_quality_wrapper();

  private:
  const ::google::protobuf::Int32Value& _internal_track_quality_wrapper() const;
  ::google::protobuf::Int32Value* _internal_mutable_track_quality_wrapper();

  public:
  // .google.protobuf.Int32Value sensor_hits = 3 [json_name = "sensorHits"];
  bool has_sensor_hits() const;
  void clear_sensor_hits() ;
  const ::google::protobuf::Int32Value& sensor_hits() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int32Value* release_sensor_hits();
  ::google::protobuf::Int32Value* mutable_sensor_hits();
  void set_allocated_sensor_hits(::google::protobuf::Int32Value* value);
  void unsafe_arena_set_allocated_sensor_hits(::google::protobuf::Int32Value* value);
  ::google::protobuf::Int32Value* unsafe_arena_release_sensor_hits();

  private:
  const ::google::protobuf::Int32Value& _internal_sensor_hits() const;
  ::google::protobuf::Int32Value* _internal_mutable_sensor_hits();

  public:
  // .anduril.entitymanager.v1.UInt32Range number_of_objects = 4 [json_name = "numberOfObjects"];
  bool has_number_of_objects() const;
  void clear_number_of_objects() ;
  const ::anduril::entitymanager::v1::UInt32Range& number_of_objects() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::UInt32Range* release_number_of_objects();
  ::anduril::entitymanager::v1::UInt32Range* mutable_number_of_objects();
  void set_allocated_number_of_objects(::anduril::entitymanager::v1::UInt32Range* value);
  void unsafe_arena_set_allocated_number_of_objects(::anduril::entitymanager::v1::UInt32Range* value);
  ::anduril::entitymanager::v1::UInt32Range* unsafe_arena_release_number_of_objects();

  private:
  const ::anduril::entitymanager::v1::UInt32Range& _internal_number_of_objects() const;
  ::anduril::entitymanager::v1::UInt32Range* _internal_mutable_number_of_objects();

  public:
  // .google.protobuf.DoubleValue radar_cross_section = 6 [json_name = "radarCrossSection"];
  bool has_radar_cross_section() const;
  void clear_radar_cross_section() ;
  const ::google::protobuf::DoubleValue& radar_cross_section() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_radar_cross_section();
  ::google::protobuf::DoubleValue* mutable_radar_cross_section();
  void set_allocated_radar_cross_section(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_radar_cross_section(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_radar_cross_section();

  private:
  const ::google::protobuf::DoubleValue& _internal_radar_cross_section() const;
  ::google::protobuf::DoubleValue* _internal_mutable_radar_cross_section();

  public:
  // .google.protobuf.Timestamp last_measurement_time = 7 [json_name = "lastMeasurementTime"];
  bool has_last_measurement_time() const;
  void clear_last_measurement_time() ;
  const ::google::protobuf::Timestamp& last_measurement_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_measurement_time();
  ::google::protobuf::Timestamp* mutable_last_measurement_time();
  void set_allocated_last_measurement_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_measurement_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_measurement_time();

  private:
  const ::google::protobuf::Timestamp& _internal_last_measurement_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_measurement_time();

  public:
  // .anduril.entitymanager.v1.LineOfBearing line_of_bearing = 9 [json_name = "lineOfBearing"];
  bool has_line_of_bearing() const;
  void clear_line_of_bearing() ;
  const ::anduril::entitymanager::v1::LineOfBearing& line_of_bearing() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::LineOfBearing* release_line_of_bearing();
  ::anduril::entitymanager::v1::LineOfBearing* mutable_line_of_bearing();
  void set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value);
  void unsafe_arena_set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value);
  ::anduril::entitymanager::v1::LineOfBearing* unsafe_arena_release_line_of_bearing();

  private:
  const ::anduril::entitymanager::v1::LineOfBearing& _internal_line_of_bearing() const;
  ::anduril::entitymanager::v1::LineOfBearing* _internal_mutable_line_of_bearing();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Tracked)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Tracked& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int32Value* track_quality_wrapper_;
    ::google::protobuf::Int32Value* sensor_hits_;
    ::anduril::entitymanager::v1::UInt32Range* number_of_objects_;
    ::google::protobuf::DoubleValue* radar_cross_section_;
    ::google::protobuf::Timestamp* last_measurement_time_;
    ::anduril::entitymanager::v1::LineOfBearing* line_of_bearing_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class Decorrelation final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Decorrelation) */ {
 public:
  inline Decorrelation() : Decorrelation(nullptr) {}
  ~Decorrelation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Decorrelation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Decorrelation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Decorrelation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Decorrelation(const Decorrelation& from) : Decorrelation(nullptr, from) {}
  inline Decorrelation(Decorrelation&& from) noexcept
      : Decorrelation(nullptr, std::move(from)) {}
  inline Decorrelation& operator=(const Decorrelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Decorrelation& operator=(Decorrelation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Decorrelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Decorrelation* internal_default_instance() {
    return reinterpret_cast<const Decorrelation*>(
        &_Decorrelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(Decorrelation& a, Decorrelation& b) { a.Swap(&b); }
  inline void Swap(Decorrelation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Decorrelation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Decorrelation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Decorrelation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Decorrelation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Decorrelation& from) { Decorrelation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Decorrelation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Decorrelation"; }

 protected:
  explicit Decorrelation(::google::protobuf::Arena* arena);
  Decorrelation(::google::protobuf::Arena* arena, const Decorrelation& from);
  Decorrelation(::google::protobuf::Arena* arena, Decorrelation&& from) noexcept
      : Decorrelation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDecorrelatedEntitiesFieldNumber = 2,
    kAllFieldNumber = 1,
  };
  // repeated .anduril.entitymanager.v1.DecorrelatedSingle decorrelated_entities = 2 [json_name = "decorrelatedEntities"];
  int decorrelated_entities_size() const;
  private:
  int _internal_decorrelated_entities_size() const;

  public:
  void clear_decorrelated_entities() ;
  ::anduril::entitymanager::v1::DecorrelatedSingle* mutable_decorrelated_entities(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::DecorrelatedSingle>* mutable_decorrelated_entities();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::DecorrelatedSingle>& _internal_decorrelated_entities() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::DecorrelatedSingle>* _internal_mutable_decorrelated_entities();
  public:
  const ::anduril::entitymanager::v1::DecorrelatedSingle& decorrelated_entities(int index) const;
  ::anduril::entitymanager::v1::DecorrelatedSingle* add_decorrelated_entities();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::DecorrelatedSingle>& decorrelated_entities() const;
  // .anduril.entitymanager.v1.DecorrelatedAll all = 1 [json_name = "all"];
  bool has_all() const;
  void clear_all() ;
  const ::anduril::entitymanager::v1::DecorrelatedAll& all() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::DecorrelatedAll* release_all();
  ::anduril::entitymanager::v1::DecorrelatedAll* mutable_all();
  void set_allocated_all(::anduril::entitymanager::v1::DecorrelatedAll* value);
  void unsafe_arena_set_allocated_all(::anduril::entitymanager::v1::DecorrelatedAll* value);
  ::anduril::entitymanager::v1::DecorrelatedAll* unsafe_arena_release_all();

  private:
  const ::anduril::entitymanager::v1::DecorrelatedAll& _internal_all() const;
  ::anduril::entitymanager::v1::DecorrelatedAll* _internal_mutable_all();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Decorrelation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Decorrelation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::DecorrelatedSingle > decorrelated_entities_;
    ::anduril::entitymanager::v1::DecorrelatedAll* all_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class Correlation final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Correlation) */ {
 public:
  inline Correlation() : Correlation(nullptr) {}
  ~Correlation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Correlation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Correlation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Correlation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Correlation(const Correlation& from) : Correlation(nullptr, from) {}
  inline Correlation(Correlation&& from) noexcept
      : Correlation(nullptr, std::move(from)) {}
  inline Correlation& operator=(const Correlation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Correlation& operator=(Correlation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Correlation& default_instance() {
    return *internal_default_instance();
  }
  enum CorrelationCase {
    kPrimary = 1,
    kSecondary = 2,
    CORRELATION_NOT_SET = 0,
  };
  static inline const Correlation* internal_default_instance() {
    return reinterpret_cast<const Correlation*>(
        &_Correlation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Correlation& a, Correlation& b) { a.Swap(&b); }
  inline void Swap(Correlation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Correlation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Correlation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Correlation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Correlation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Correlation& from) { Correlation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Correlation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Correlation"; }

 protected:
  explicit Correlation(::google::protobuf::Arena* arena);
  Correlation(::google::protobuf::Arena* arena, const Correlation& from);
  Correlation(::google::protobuf::Arena* arena, Correlation&& from) noexcept
      : Correlation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDecorrelationFieldNumber = 3,
    kMembershipFieldNumber = 4,
    kPrimaryFieldNumber = 1,
    kSecondaryFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.Decorrelation decorrelation = 3 [json_name = "decorrelation"];
  bool has_decorrelation() const;
  void clear_decorrelation() ;
  const ::anduril::entitymanager::v1::Decorrelation& decorrelation() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Decorrelation* release_decorrelation();
  ::anduril::entitymanager::v1::Decorrelation* mutable_decorrelation();
  void set_allocated_decorrelation(::anduril::entitymanager::v1::Decorrelation* value);
  void unsafe_arena_set_allocated_decorrelation(::anduril::entitymanager::v1::Decorrelation* value);
  ::anduril::entitymanager::v1::Decorrelation* unsafe_arena_release_decorrelation();

  private:
  const ::anduril::entitymanager::v1::Decorrelation& _internal_decorrelation() const;
  ::anduril::entitymanager::v1::Decorrelation* _internal_mutable_decorrelation();

  public:
  // .anduril.entitymanager.v1.CorrelationMembership membership = 4 [json_name = "membership"];
  bool has_membership() const;
  void clear_membership() ;
  const ::anduril::entitymanager::v1::CorrelationMembership& membership() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::CorrelationMembership* release_membership();
  ::anduril::entitymanager::v1::CorrelationMembership* mutable_membership();
  void set_allocated_membership(::anduril::entitymanager::v1::CorrelationMembership* value);
  void unsafe_arena_set_allocated_membership(::anduril::entitymanager::v1::CorrelationMembership* value);
  ::anduril::entitymanager::v1::CorrelationMembership* unsafe_arena_release_membership();

  private:
  const ::anduril::entitymanager::v1::CorrelationMembership& _internal_membership() const;
  ::anduril::entitymanager::v1::CorrelationMembership* _internal_mutable_membership();

  public:
  // .anduril.entitymanager.v1.PrimaryCorrelation primary = 1 [json_name = "primary"];
  bool has_primary() const;
  private:
  bool _internal_has_primary() const;

  public:
  void clear_primary() ;
  const ::anduril::entitymanager::v1::PrimaryCorrelation& primary() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::PrimaryCorrelation* release_primary();
  ::anduril::entitymanager::v1::PrimaryCorrelation* mutable_primary();
  void set_allocated_primary(::anduril::entitymanager::v1::PrimaryCorrelation* value);
  void unsafe_arena_set_allocated_primary(::anduril::entitymanager::v1::PrimaryCorrelation* value);
  ::anduril::entitymanager::v1::PrimaryCorrelation* unsafe_arena_release_primary();

  private:
  const ::anduril::entitymanager::v1::PrimaryCorrelation& _internal_primary() const;
  ::anduril::entitymanager::v1::PrimaryCorrelation* _internal_mutable_primary();

  public:
  // .anduril.entitymanager.v1.SecondaryCorrelation secondary = 2 [json_name = "secondary"];
  bool has_secondary() const;
  private:
  bool _internal_has_secondary() const;

  public:
  void clear_secondary() ;
  const ::anduril::entitymanager::v1::SecondaryCorrelation& secondary() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::SecondaryCorrelation* release_secondary();
  ::anduril::entitymanager::v1::SecondaryCorrelation* mutable_secondary();
  void set_allocated_secondary(::anduril::entitymanager::v1::SecondaryCorrelation* value);
  void unsafe_arena_set_allocated_secondary(::anduril::entitymanager::v1::SecondaryCorrelation* value);
  ::anduril::entitymanager::v1::SecondaryCorrelation* unsafe_arena_release_secondary();

  private:
  const ::anduril::entitymanager::v1::SecondaryCorrelation& _internal_secondary() const;
  ::anduril::entitymanager::v1::SecondaryCorrelation* _internal_mutable_secondary();

  public:
  void clear_correlation();
  CorrelationCase correlation_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Correlation)
 private:
  class _Internal;
  void set_has_primary();
  void set_has_secondary();
  inline bool has_correlation() const;
  inline void clear_has_correlation();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Correlation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Decorrelation* decorrelation_;
    ::anduril::entitymanager::v1::CorrelationMembership* membership_;
    union CorrelationUnion {
      constexpr CorrelationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entitymanager::v1::PrimaryCorrelation* primary_;
      ::anduril::entitymanager::v1::SecondaryCorrelation* secondary_;
    } correlation_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class Entity final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Entity) */ {
 public:
  inline Entity() : Entity(nullptr) {}
  ~Entity() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Entity* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Entity));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Entity(
      ::google::protobuf::internal::ConstantInitialized);

  inline Entity(const Entity& from) : Entity(nullptr, from) {}
  inline Entity(Entity&& from) noexcept
      : Entity(nullptr, std::move(from)) {}
  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity& operator=(Entity&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity* internal_default_instance() {
    return reinterpret_cast<const Entity*>(
        &_Entity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Entity& a, Entity& b) { a.Swap(&b); }
  inline void Swap(Entity* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Entity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Entity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Entity& from) { Entity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Entity* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Entity"; }

 protected:
  explicit Entity(::google::protobuf::Arena* arena);
  Entity(::google::protobuf::Arena* arena, const Entity& from);
  Entity(::google::protobuf::Arena* arena, Entity&& from) noexcept
      : Entity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kCreatedTimeFieldNumber = 4,
    kExpiryTimeFieldNumber = 5,
    kLocationFieldNumber = 6,
    kAliasesFieldNumber = 7,
    kTrackedFieldNumber = 8,
    kMilViewFieldNumber = 10,
    kOntologyFieldNumber = 11,
    kProvenanceFieldNumber = 12,
    kOverridesFieldNumber = 13,
    kIndicatorsFieldNumber = 14,
    kLocationUncertaintyFieldNumber = 15,
    kStatusFieldNumber = 19,
    kSensorsFieldNumber = 20,
    kPayloadsFieldNumber = 21,
    kTargetPriorityFieldNumber = 22,
    kGeoShapeFieldNumber = 23,
    kGeoDetailsFieldNumber = 24,
    kSignalFieldNumber = 25,
    kTransponderCodesFieldNumber = 26,
    kDataClassificationFieldNumber = 29,
    kPowerStateFieldNumber = 30,
    kTaskCatalogFieldNumber = 31,
    kRelationshipsFieldNumber = 33,
    kVisualDetailsFieldNumber = 34,
    kDimensionsFieldNumber = 36,
    kRouteDetailsFieldNumber = 37,
    kSchedulesFieldNumber = 38,
    kHealthFieldNumber = 39,
    kGroupDetailsFieldNumber = 40,
    kSuppliesFieldNumber = 42,
    kOrbitFieldNumber = 46,
    kCorrelationFieldNumber = 47,
    kIsLiveFieldNumber = 3,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .google.protobuf.Timestamp created_time = 4 [json_name = "createdTime"];
  bool has_created_time() const;
  void clear_created_time() ;
  const ::google::protobuf::Timestamp& created_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_time();
  ::google::protobuf::Timestamp* mutable_created_time();
  void set_allocated_created_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_time();

  private:
  const ::google::protobuf::Timestamp& _internal_created_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_time();

  public:
  // .google.protobuf.Timestamp expiry_time = 5 [json_name = "expiryTime", (.anduril.entitymanager.v1.overridable) = true];
  bool has_expiry_time() const;
  void clear_expiry_time() ;
  const ::google::protobuf::Timestamp& expiry_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_expiry_time();
  ::google::protobuf::Timestamp* mutable_expiry_time();
  void set_allocated_expiry_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_expiry_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_expiry_time();

  private:
  const ::google::protobuf::Timestamp& _internal_expiry_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_expiry_time();

  public:
  // .anduril.entitymanager.v1.Location location = 6 [json_name = "location"];
  bool has_location() const;
  void clear_location() ;
  const ::anduril::entitymanager::v1::Location& location() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Location* release_location();
  ::anduril::entitymanager::v1::Location* mutable_location();
  void set_allocated_location(::anduril::entitymanager::v1::Location* value);
  void unsafe_arena_set_allocated_location(::anduril::entitymanager::v1::Location* value);
  ::anduril::entitymanager::v1::Location* unsafe_arena_release_location();

  private:
  const ::anduril::entitymanager::v1::Location& _internal_location() const;
  ::anduril::entitymanager::v1::Location* _internal_mutable_location();

  public:
  // .anduril.entitymanager.v1.Aliases aliases = 7 [json_name = "aliases"];
  bool has_aliases() const;
  void clear_aliases() ;
  const ::anduril::entitymanager::v1::Aliases& aliases() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Aliases* release_aliases();
  ::anduril::entitymanager::v1::Aliases* mutable_aliases();
  void set_allocated_aliases(::anduril::entitymanager::v1::Aliases* value);
  void unsafe_arena_set_allocated_aliases(::anduril::entitymanager::v1::Aliases* value);
  ::anduril::entitymanager::v1::Aliases* unsafe_arena_release_aliases();

  private:
  const ::anduril::entitymanager::v1::Aliases& _internal_aliases() const;
  ::anduril::entitymanager::v1::Aliases* _internal_mutable_aliases();

  public:
  // .anduril.entitymanager.v1.Tracked tracked = 8 [json_name = "tracked"];
  bool has_tracked() const;
  void clear_tracked() ;
  const ::anduril::entitymanager::v1::Tracked& tracked() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Tracked* release_tracked();
  ::anduril::entitymanager::v1::Tracked* mutable_tracked();
  void set_allocated_tracked(::anduril::entitymanager::v1::Tracked* value);
  void unsafe_arena_set_allocated_tracked(::anduril::entitymanager::v1::Tracked* value);
  ::anduril::entitymanager::v1::Tracked* unsafe_arena_release_tracked();

  private:
  const ::anduril::entitymanager::v1::Tracked& _internal_tracked() const;
  ::anduril::entitymanager::v1::Tracked* _internal_mutable_tracked();

  public:
  // .anduril.entitymanager.v1.MilView mil_view = 10 [json_name = "milView"];
  bool has_mil_view() const;
  void clear_mil_view() ;
  const ::anduril::entitymanager::v1::MilView& mil_view() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::MilView* release_mil_view();
  ::anduril::entitymanager::v1::MilView* mutable_mil_view();
  void set_allocated_mil_view(::anduril::entitymanager::v1::MilView* value);
  void unsafe_arena_set_allocated_mil_view(::anduril::entitymanager::v1::MilView* value);
  ::anduril::entitymanager::v1::MilView* unsafe_arena_release_mil_view();

  private:
  const ::anduril::entitymanager::v1::MilView& _internal_mil_view() const;
  ::anduril::entitymanager::v1::MilView* _internal_mutable_mil_view();

  public:
  // .anduril.entitymanager.v1.Ontology ontology = 11 [json_name = "ontology"];
  bool has_ontology() const;
  void clear_ontology() ;
  const ::anduril::entitymanager::v1::Ontology& ontology() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Ontology* release_ontology();
  ::anduril::entitymanager::v1::Ontology* mutable_ontology();
  void set_allocated_ontology(::anduril::entitymanager::v1::Ontology* value);
  void unsafe_arena_set_allocated_ontology(::anduril::entitymanager::v1::Ontology* value);
  ::anduril::entitymanager::v1::Ontology* unsafe_arena_release_ontology();

  private:
  const ::anduril::entitymanager::v1::Ontology& _internal_ontology() const;
  ::anduril::entitymanager::v1::Ontology* _internal_mutable_ontology();

  public:
  // .anduril.entitymanager.v1.Provenance provenance = 12 [json_name = "provenance"];
  bool has_provenance() const;
  void clear_provenance() ;
  const ::anduril::entitymanager::v1::Provenance& provenance() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Provenance* release_provenance();
  ::anduril::entitymanager::v1::Provenance* mutable_provenance();
  void set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  void unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  ::anduril::entitymanager::v1::Provenance* unsafe_arena_release_provenance();

  private:
  const ::anduril::entitymanager::v1::Provenance& _internal_provenance() const;
  ::anduril::entitymanager::v1::Provenance* _internal_mutable_provenance();

  public:
  // .anduril.entitymanager.v1.Overrides overrides = 13 [json_name = "overrides"];
  bool has_overrides() const;
  void clear_overrides() ;
  const ::anduril::entitymanager::v1::Overrides& overrides() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Overrides* release_overrides();
  ::anduril::entitymanager::v1::Overrides* mutable_overrides();
  void set_allocated_overrides(::anduril::entitymanager::v1::Overrides* value);
  void unsafe_arena_set_allocated_overrides(::anduril::entitymanager::v1::Overrides* value);
  ::anduril::entitymanager::v1::Overrides* unsafe_arena_release_overrides();

  private:
  const ::anduril::entitymanager::v1::Overrides& _internal_overrides() const;
  ::anduril::entitymanager::v1::Overrides* _internal_mutable_overrides();

  public:
  // .anduril.entitymanager.v1.Indicators indicators = 14 [json_name = "indicators"];
  bool has_indicators() const;
  void clear_indicators() ;
  const ::anduril::entitymanager::v1::Indicators& indicators() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Indicators* release_indicators();
  ::anduril::entitymanager::v1::Indicators* mutable_indicators();
  void set_allocated_indicators(::anduril::entitymanager::v1::Indicators* value);
  void unsafe_arena_set_allocated_indicators(::anduril::entitymanager::v1::Indicators* value);
  ::anduril::entitymanager::v1::Indicators* unsafe_arena_release_indicators();

  private:
  const ::anduril::entitymanager::v1::Indicators& _internal_indicators() const;
  ::anduril::entitymanager::v1::Indicators* _internal_mutable_indicators();

  public:
  // .anduril.entitymanager.v1.LocationUncertainty location_uncertainty = 15 [json_name = "locationUncertainty"];
  bool has_location_uncertainty() const;
  void clear_location_uncertainty() ;
  const ::anduril::entitymanager::v1::LocationUncertainty& location_uncertainty() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::LocationUncertainty* release_location_uncertainty();
  ::anduril::entitymanager::v1::LocationUncertainty* mutable_location_uncertainty();
  void set_allocated_location_uncertainty(::anduril::entitymanager::v1::LocationUncertainty* value);
  void unsafe_arena_set_allocated_location_uncertainty(::anduril::entitymanager::v1::LocationUncertainty* value);
  ::anduril::entitymanager::v1::LocationUncertainty* unsafe_arena_release_location_uncertainty();

  private:
  const ::anduril::entitymanager::v1::LocationUncertainty& _internal_location_uncertainty() const;
  ::anduril::entitymanager::v1::LocationUncertainty* _internal_mutable_location_uncertainty();

  public:
  // .anduril.entitymanager.v1.Status status = 19 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::anduril::entitymanager::v1::Status& status() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Status* release_status();
  ::anduril::entitymanager::v1::Status* mutable_status();
  void set_allocated_status(::anduril::entitymanager::v1::Status* value);
  void unsafe_arena_set_allocated_status(::anduril::entitymanager::v1::Status* value);
  ::anduril::entitymanager::v1::Status* unsafe_arena_release_status();

  private:
  const ::anduril::entitymanager::v1::Status& _internal_status() const;
  ::anduril::entitymanager::v1::Status* _internal_mutable_status();

  public:
  // .anduril.entitymanager.v1.Sensors sensors = 20 [json_name = "sensors"];
  bool has_sensors() const;
  void clear_sensors() ;
  const ::anduril::entitymanager::v1::Sensors& sensors() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Sensors* release_sensors();
  ::anduril::entitymanager::v1::Sensors* mutable_sensors();
  void set_allocated_sensors(::anduril::entitymanager::v1::Sensors* value);
  void unsafe_arena_set_allocated_sensors(::anduril::entitymanager::v1::Sensors* value);
  ::anduril::entitymanager::v1::Sensors* unsafe_arena_release_sensors();

  private:
  const ::anduril::entitymanager::v1::Sensors& _internal_sensors() const;
  ::anduril::entitymanager::v1::Sensors* _internal_mutable_sensors();

  public:
  // .anduril.entitymanager.v1.Payloads payloads = 21 [json_name = "payloads"];
  bool has_payloads() const;
  void clear_payloads() ;
  const ::anduril::entitymanager::v1::Payloads& payloads() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Payloads* release_payloads();
  ::anduril::entitymanager::v1::Payloads* mutable_payloads();
  void set_allocated_payloads(::anduril::entitymanager::v1::Payloads* value);
  void unsafe_arena_set_allocated_payloads(::anduril::entitymanager::v1::Payloads* value);
  ::anduril::entitymanager::v1::Payloads* unsafe_arena_release_payloads();

  private:
  const ::anduril::entitymanager::v1::Payloads& _internal_payloads() const;
  ::anduril::entitymanager::v1::Payloads* _internal_mutable_payloads();

  public:
  // .anduril.entitymanager.v1.TargetPriority target_priority = 22 [json_name = "targetPriority"];
  bool has_target_priority() const;
  void clear_target_priority() ;
  const ::anduril::entitymanager::v1::TargetPriority& target_priority() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::TargetPriority* release_target_priority();
  ::anduril::entitymanager::v1::TargetPriority* mutable_target_priority();
  void set_allocated_target_priority(::anduril::entitymanager::v1::TargetPriority* value);
  void unsafe_arena_set_allocated_target_priority(::anduril::entitymanager::v1::TargetPriority* value);
  ::anduril::entitymanager::v1::TargetPriority* unsafe_arena_release_target_priority();

  private:
  const ::anduril::entitymanager::v1::TargetPriority& _internal_target_priority() const;
  ::anduril::entitymanager::v1::TargetPriority* _internal_mutable_target_priority();

  public:
  // .anduril.entitymanager.v1.GeoShape geo_shape = 23 [json_name = "geoShape"];
  bool has_geo_shape() const;
  void clear_geo_shape() ;
  const ::anduril::entitymanager::v1::GeoShape& geo_shape() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoShape* release_geo_shape();
  ::anduril::entitymanager::v1::GeoShape* mutable_geo_shape();
  void set_allocated_geo_shape(::anduril::entitymanager::v1::GeoShape* value);
  void unsafe_arena_set_allocated_geo_shape(::anduril::entitymanager::v1::GeoShape* value);
  ::anduril::entitymanager::v1::GeoShape* unsafe_arena_release_geo_shape();

  private:
  const ::anduril::entitymanager::v1::GeoShape& _internal_geo_shape() const;
  ::anduril::entitymanager::v1::GeoShape* _internal_mutable_geo_shape();

  public:
  // .anduril.entitymanager.v1.GeoDetails geo_details = 24 [json_name = "geoDetails"];
  bool has_geo_details() const;
  void clear_geo_details() ;
  const ::anduril::entitymanager::v1::GeoDetails& geo_details() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoDetails* release_geo_details();
  ::anduril::entitymanager::v1::GeoDetails* mutable_geo_details();
  void set_allocated_geo_details(::anduril::entitymanager::v1::GeoDetails* value);
  void unsafe_arena_set_allocated_geo_details(::anduril::entitymanager::v1::GeoDetails* value);
  ::anduril::entitymanager::v1::GeoDetails* unsafe_arena_release_geo_details();

  private:
  const ::anduril::entitymanager::v1::GeoDetails& _internal_geo_details() const;
  ::anduril::entitymanager::v1::GeoDetails* _internal_mutable_geo_details();

  public:
  // .anduril.entitymanager.v1.Signal signal = 25 [json_name = "signal"];
  bool has_signal() const;
  void clear_signal() ;
  const ::anduril::entitymanager::v1::Signal& signal() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Signal* release_signal();
  ::anduril::entitymanager::v1::Signal* mutable_signal();
  void set_allocated_signal(::anduril::entitymanager::v1::Signal* value);
  void unsafe_arena_set_allocated_signal(::anduril::entitymanager::v1::Signal* value);
  ::anduril::entitymanager::v1::Signal* unsafe_arena_release_signal();

  private:
  const ::anduril::entitymanager::v1::Signal& _internal_signal() const;
  ::anduril::entitymanager::v1::Signal* _internal_mutable_signal();

  public:
  // .anduril.entitymanager.v1.TransponderCodes transponder_codes = 26 [json_name = "transponderCodes"];
  bool has_transponder_codes() const;
  void clear_transponder_codes() ;
  const ::anduril::entitymanager::v1::TransponderCodes& transponder_codes() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::TransponderCodes* release_transponder_codes();
  ::anduril::entitymanager::v1::TransponderCodes* mutable_transponder_codes();
  void set_allocated_transponder_codes(::anduril::entitymanager::v1::TransponderCodes* value);
  void unsafe_arena_set_allocated_transponder_codes(::anduril::entitymanager::v1::TransponderCodes* value);
  ::anduril::entitymanager::v1::TransponderCodes* unsafe_arena_release_transponder_codes();

  private:
  const ::anduril::entitymanager::v1::TransponderCodes& _internal_transponder_codes() const;
  ::anduril::entitymanager::v1::TransponderCodes* _internal_mutable_transponder_codes();

  public:
  // .anduril.entitymanager.v1.Classification data_classification = 29 [json_name = "dataClassification"];
  bool has_data_classification() const;
  void clear_data_classification() ;
  const ::anduril::entitymanager::v1::Classification& data_classification() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Classification* release_data_classification();
  ::anduril::entitymanager::v1::Classification* mutable_data_classification();
  void set_allocated_data_classification(::anduril::entitymanager::v1::Classification* value);
  void unsafe_arena_set_allocated_data_classification(::anduril::entitymanager::v1::Classification* value);
  ::anduril::entitymanager::v1::Classification* unsafe_arena_release_data_classification();

  private:
  const ::anduril::entitymanager::v1::Classification& _internal_data_classification() const;
  ::anduril::entitymanager::v1::Classification* _internal_mutable_data_classification();

  public:
  // .anduril.entitymanager.v1.PowerState power_state = 30 [json_name = "powerState"];
  bool has_power_state() const;
  void clear_power_state() ;
  const ::anduril::entitymanager::v1::PowerState& power_state() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::PowerState* release_power_state();
  ::anduril::entitymanager::v1::PowerState* mutable_power_state();
  void set_allocated_power_state(::anduril::entitymanager::v1::PowerState* value);
  void unsafe_arena_set_allocated_power_state(::anduril::entitymanager::v1::PowerState* value);
  ::anduril::entitymanager::v1::PowerState* unsafe_arena_release_power_state();

  private:
  const ::anduril::entitymanager::v1::PowerState& _internal_power_state() const;
  ::anduril::entitymanager::v1::PowerState* _internal_mutable_power_state();

  public:
  // .anduril.tasks.v2.TaskCatalog task_catalog = 31 [json_name = "taskCatalog", (.anduril.entitymanager.v1.overridable) = true];
  bool has_task_catalog() const;
  void clear_task_catalog() ;
  const ::anduril::tasks::v2::TaskCatalog& task_catalog() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::TaskCatalog* release_task_catalog();
  ::anduril::tasks::v2::TaskCatalog* mutable_task_catalog();
  void set_allocated_task_catalog(::anduril::tasks::v2::TaskCatalog* value);
  void unsafe_arena_set_allocated_task_catalog(::anduril::tasks::v2::TaskCatalog* value);
  ::anduril::tasks::v2::TaskCatalog* unsafe_arena_release_task_catalog();

  private:
  const ::anduril::tasks::v2::TaskCatalog& _internal_task_catalog() const;
  ::anduril::tasks::v2::TaskCatalog* _internal_mutable_task_catalog();

  public:
  // .anduril.entitymanager.v1.Relationships relationships = 33 [json_name = "relationships"];
  bool has_relationships() const;
  void clear_relationships() ;
  const ::anduril::entitymanager::v1::Relationships& relationships() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Relationships* release_relationships();
  ::anduril::entitymanager::v1::Relationships* mutable_relationships();
  void set_allocated_relationships(::anduril::entitymanager::v1::Relationships* value);
  void unsafe_arena_set_allocated_relationships(::anduril::entitymanager::v1::Relationships* value);
  ::anduril::entitymanager::v1::Relationships* unsafe_arena_release_relationships();

  private:
  const ::anduril::entitymanager::v1::Relationships& _internal_relationships() const;
  ::anduril::entitymanager::v1::Relationships* _internal_mutable_relationships();

  public:
  // .anduril.entitymanager.v1.VisualDetails visual_details = 34 [json_name = "visualDetails"];
  bool has_visual_details() const;
  void clear_visual_details() ;
  const ::anduril::entitymanager::v1::VisualDetails& visual_details() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::VisualDetails* release_visual_details();
  ::anduril::entitymanager::v1::VisualDetails* mutable_visual_details();
  void set_allocated_visual_details(::anduril::entitymanager::v1::VisualDetails* value);
  void unsafe_arena_set_allocated_visual_details(::anduril::entitymanager::v1::VisualDetails* value);
  ::anduril::entitymanager::v1::VisualDetails* unsafe_arena_release_visual_details();

  private:
  const ::anduril::entitymanager::v1::VisualDetails& _internal_visual_details() const;
  ::anduril::entitymanager::v1::VisualDetails* _internal_mutable_visual_details();

  public:
  // .anduril.entitymanager.v1.Dimensions dimensions = 36 [json_name = "dimensions"];
  bool has_dimensions() const;
  void clear_dimensions() ;
  const ::anduril::entitymanager::v1::Dimensions& dimensions() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Dimensions* release_dimensions();
  ::anduril::entitymanager::v1::Dimensions* mutable_dimensions();
  void set_allocated_dimensions(::anduril::entitymanager::v1::Dimensions* value);
  void unsafe_arena_set_allocated_dimensions(::anduril::entitymanager::v1::Dimensions* value);
  ::anduril::entitymanager::v1::Dimensions* unsafe_arena_release_dimensions();

  private:
  const ::anduril::entitymanager::v1::Dimensions& _internal_dimensions() const;
  ::anduril::entitymanager::v1::Dimensions* _internal_mutable_dimensions();

  public:
  // .anduril.entitymanager.v1.RouteDetails route_details = 37 [json_name = "routeDetails"];
  bool has_route_details() const;
  void clear_route_details() ;
  const ::anduril::entitymanager::v1::RouteDetails& route_details() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::RouteDetails* release_route_details();
  ::anduril::entitymanager::v1::RouteDetails* mutable_route_details();
  void set_allocated_route_details(::anduril::entitymanager::v1::RouteDetails* value);
  void unsafe_arena_set_allocated_route_details(::anduril::entitymanager::v1::RouteDetails* value);
  ::anduril::entitymanager::v1::RouteDetails* unsafe_arena_release_route_details();

  private:
  const ::anduril::entitymanager::v1::RouteDetails& _internal_route_details() const;
  ::anduril::entitymanager::v1::RouteDetails* _internal_mutable_route_details();

  public:
  // .anduril.entitymanager.v1.Schedules schedules = 38 [json_name = "schedules"];
  bool has_schedules() const;
  void clear_schedules() ;
  const ::anduril::entitymanager::v1::Schedules& schedules() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Schedules* release_schedules();
  ::anduril::entitymanager::v1::Schedules* mutable_schedules();
  void set_allocated_schedules(::anduril::entitymanager::v1::Schedules* value);
  void unsafe_arena_set_allocated_schedules(::anduril::entitymanager::v1::Schedules* value);
  ::anduril::entitymanager::v1::Schedules* unsafe_arena_release_schedules();

  private:
  const ::anduril::entitymanager::v1::Schedules& _internal_schedules() const;
  ::anduril::entitymanager::v1::Schedules* _internal_mutable_schedules();

  public:
  // .anduril.entitymanager.v1.Health health = 39 [json_name = "health"];
  bool has_health() const;
  void clear_health() ;
  const ::anduril::entitymanager::v1::Health& health() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Health* release_health();
  ::anduril::entitymanager::v1::Health* mutable_health();
  void set_allocated_health(::anduril::entitymanager::v1::Health* value);
  void unsafe_arena_set_allocated_health(::anduril::entitymanager::v1::Health* value);
  ::anduril::entitymanager::v1::Health* unsafe_arena_release_health();

  private:
  const ::anduril::entitymanager::v1::Health& _internal_health() const;
  ::anduril::entitymanager::v1::Health* _internal_mutable_health();

  public:
  // .anduril.entitymanager.v1.GroupDetails group_details = 40 [json_name = "groupDetails"];
  bool has_group_details() const;
  void clear_group_details() ;
  const ::anduril::entitymanager::v1::GroupDetails& group_details() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GroupDetails* release_group_details();
  ::anduril::entitymanager::v1::GroupDetails* mutable_group_details();
  void set_allocated_group_details(::anduril::entitymanager::v1::GroupDetails* value);
  void unsafe_arena_set_allocated_group_details(::anduril::entitymanager::v1::GroupDetails* value);
  ::anduril::entitymanager::v1::GroupDetails* unsafe_arena_release_group_details();

  private:
  const ::anduril::entitymanager::v1::GroupDetails& _internal_group_details() const;
  ::anduril::entitymanager::v1::GroupDetails* _internal_mutable_group_details();

  public:
  // .anduril.entitymanager.v1.Supplies supplies = 42 [json_name = "supplies"];
  bool has_supplies() const;
  void clear_supplies() ;
  const ::anduril::entitymanager::v1::Supplies& supplies() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Supplies* release_supplies();
  ::anduril::entitymanager::v1::Supplies* mutable_supplies();
  void set_allocated_supplies(::anduril::entitymanager::v1::Supplies* value);
  void unsafe_arena_set_allocated_supplies(::anduril::entitymanager::v1::Supplies* value);
  ::anduril::entitymanager::v1::Supplies* unsafe_arena_release_supplies();

  private:
  const ::anduril::entitymanager::v1::Supplies& _internal_supplies() const;
  ::anduril::entitymanager::v1::Supplies* _internal_mutable_supplies();

  public:
  // .anduril.entitymanager.v1.Orbit orbit = 46 [json_name = "orbit"];
  bool has_orbit() const;
  void clear_orbit() ;
  const ::anduril::entitymanager::v1::Orbit& orbit() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Orbit* release_orbit();
  ::anduril::entitymanager::v1::Orbit* mutable_orbit();
  void set_allocated_orbit(::anduril::entitymanager::v1::Orbit* value);
  void unsafe_arena_set_allocated_orbit(::anduril::entitymanager::v1::Orbit* value);
  ::anduril::entitymanager::v1::Orbit* unsafe_arena_release_orbit();

  private:
  const ::anduril::entitymanager::v1::Orbit& _internal_orbit() const;
  ::anduril::entitymanager::v1::Orbit* _internal_mutable_orbit();

  public:
  // .anduril.entitymanager.v1.Correlation correlation = 47 [json_name = "correlation"];
  bool has_correlation() const;
  void clear_correlation() ;
  const ::anduril::entitymanager::v1::Correlation& correlation() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Correlation* release_correlation();
  ::anduril::entitymanager::v1::Correlation* mutable_correlation();
  void set_allocated_correlation(::anduril::entitymanager::v1::Correlation* value);
  void unsafe_arena_set_allocated_correlation(::anduril::entitymanager::v1::Correlation* value);
  ::anduril::entitymanager::v1::Correlation* unsafe_arena_release_correlation();

  private:
  const ::anduril::entitymanager::v1::Correlation& _internal_correlation() const;
  ::anduril::entitymanager::v1::Correlation* _internal_mutable_correlation();

  public:
  // bool is_live = 3 [json_name = "isLive"];
  void clear_is_live() ;
  bool is_live() const;
  void set_is_live(bool value);

  private:
  bool _internal_is_live() const;
  void _internal_set_is_live(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Entity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 35, 32,
      92, 7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Entity& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::Timestamp* created_time_;
    ::google::protobuf::Timestamp* expiry_time_;
    ::anduril::entitymanager::v1::Location* location_;
    ::anduril::entitymanager::v1::Aliases* aliases_;
    ::anduril::entitymanager::v1::Tracked* tracked_;
    ::anduril::entitymanager::v1::MilView* mil_view_;
    ::anduril::entitymanager::v1::Ontology* ontology_;
    ::anduril::entitymanager::v1::Provenance* provenance_;
    ::anduril::entitymanager::v1::Overrides* overrides_;
    ::anduril::entitymanager::v1::Indicators* indicators_;
    ::anduril::entitymanager::v1::LocationUncertainty* location_uncertainty_;
    ::anduril::entitymanager::v1::Status* status_;
    ::anduril::entitymanager::v1::Sensors* sensors_;
    ::anduril::entitymanager::v1::Payloads* payloads_;
    ::anduril::entitymanager::v1::TargetPriority* target_priority_;
    ::anduril::entitymanager::v1::GeoShape* geo_shape_;
    ::anduril::entitymanager::v1::GeoDetails* geo_details_;
    ::anduril::entitymanager::v1::Signal* signal_;
    ::anduril::entitymanager::v1::TransponderCodes* transponder_codes_;
    ::anduril::entitymanager::v1::Classification* data_classification_;
    ::anduril::entitymanager::v1::PowerState* power_state_;
    ::anduril::tasks::v2::TaskCatalog* task_catalog_;
    ::anduril::entitymanager::v1::Relationships* relationships_;
    ::anduril::entitymanager::v1::VisualDetails* visual_details_;
    ::anduril::entitymanager::v1::Dimensions* dimensions_;
    ::anduril::entitymanager::v1::RouteDetails* route_details_;
    ::anduril::entitymanager::v1::Schedules* schedules_;
    ::anduril::entitymanager::v1::Health* health_;
    ::anduril::entitymanager::v1::GroupDetails* group_details_;
    ::anduril::entitymanager::v1::Supplies* supplies_;
    ::anduril::entitymanager::v1::Orbit* orbit_;
    ::anduril::entitymanager::v1::Correlation* correlation_;
    bool is_live_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class Override final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Override) */ {
 public:
  inline Override() : Override(nullptr) {}
  ~Override() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Override* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Override));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Override(
      ::google::protobuf::internal::ConstantInitialized);

  inline Override(const Override& from) : Override(nullptr, from) {}
  inline Override(Override&& from) noexcept
      : Override(nullptr, std::move(from)) {}
  inline Override& operator=(const Override& from) {
    CopyFrom(from);
    return *this;
  }
  inline Override& operator=(Override&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Override& default_instance() {
    return *internal_default_instance();
  }
  static inline const Override* internal_default_instance() {
    return reinterpret_cast<const Override*>(
        &_Override_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Override& a, Override& b) { a.Swap(&b); }
  inline void Swap(Override* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Override* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Override* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Override>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Override& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Override& from) { Override::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Override* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Override"; }

 protected:
  explicit Override(::google::protobuf::Arena* arena);
  Override(::google::protobuf::Arena* arena, const Override& from);
  Override(::google::protobuf::Arena* arena, Override&& from) noexcept
      : Override(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRequestIdFieldNumber = 1,
    kFieldPathFieldNumber = 2,
    kMaskedFieldValueFieldNumber = 3,
    kProvenanceFieldNumber = 5,
    kRequestTimestampFieldNumber = 7,
    kStatusFieldNumber = 4,
    kTypeFieldNumber = 6,
  };
  // string request_id = 1 [json_name = "requestId"];
  void clear_request_id() ;
  const std::string& request_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* value);

  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(
      const std::string& value);
  std::string* _internal_mutable_request_id();

  public:
  // string field_path = 2 [json_name = "fieldPath"];
  void clear_field_path() ;
  const std::string& field_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_field_path(Arg_&& arg, Args_... args);
  std::string* mutable_field_path();
  PROTOBUF_NODISCARD std::string* release_field_path();
  void set_allocated_field_path(std::string* value);

  private:
  const std::string& _internal_field_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_path(
      const std::string& value);
  std::string* _internal_mutable_field_path();

  public:
  // .anduril.entitymanager.v1.Entity masked_field_value = 3 [json_name = "maskedFieldValue"];
  bool has_masked_field_value() const;
  void clear_masked_field_value() ;
  const ::anduril::entitymanager::v1::Entity& masked_field_value() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Entity* release_masked_field_value();
  ::anduril::entitymanager::v1::Entity* mutable_masked_field_value();
  void set_allocated_masked_field_value(::anduril::entitymanager::v1::Entity* value);
  void unsafe_arena_set_allocated_masked_field_value(::anduril::entitymanager::v1::Entity* value);
  ::anduril::entitymanager::v1::Entity* unsafe_arena_release_masked_field_value();

  private:
  const ::anduril::entitymanager::v1::Entity& _internal_masked_field_value() const;
  ::anduril::entitymanager::v1::Entity* _internal_mutable_masked_field_value();

  public:
  // .anduril.entitymanager.v1.Provenance provenance = 5 [json_name = "provenance"];
  bool has_provenance() const;
  void clear_provenance() ;
  const ::anduril::entitymanager::v1::Provenance& provenance() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Provenance* release_provenance();
  ::anduril::entitymanager::v1::Provenance* mutable_provenance();
  void set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  void unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  ::anduril::entitymanager::v1::Provenance* unsafe_arena_release_provenance();

  private:
  const ::anduril::entitymanager::v1::Provenance& _internal_provenance() const;
  ::anduril::entitymanager::v1::Provenance* _internal_mutable_provenance();

  public:
  // .google.protobuf.Timestamp request_timestamp = 7 [json_name = "requestTimestamp"];
  bool has_request_timestamp() const;
  void clear_request_timestamp() ;
  const ::google::protobuf::Timestamp& request_timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_request_timestamp();
  ::google::protobuf::Timestamp* mutable_request_timestamp();
  void set_allocated_request_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_request_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_request_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_request_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_request_timestamp();

  public:
  // .anduril.entitymanager.v1.OverrideStatus status = 4 [json_name = "status"];
  void clear_status() ;
  ::anduril::entitymanager::v1::OverrideStatus status() const;
  void set_status(::anduril::entitymanager::v1::OverrideStatus value);

  private:
  ::anduril::entitymanager::v1::OverrideStatus _internal_status() const;
  void _internal_set_status(::anduril::entitymanager::v1::OverrideStatus value);

  public:
  // .anduril.entitymanager.v1.OverrideType type = 6 [json_name = "type"];
  void clear_type() ;
  ::anduril::entitymanager::v1::OverrideType type() const;
  void set_type(::anduril::entitymanager::v1::OverrideType value);

  private:
  ::anduril::entitymanager::v1::OverrideType _internal_type() const;
  void _internal_set_type(::anduril::entitymanager::v1::OverrideType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Override)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      62, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Override& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr request_id_;
    ::google::protobuf::internal::ArenaStringPtr field_path_;
    ::anduril::entitymanager::v1::Entity* masked_field_value_;
    ::anduril::entitymanager::v1::Provenance* provenance_;
    ::google::protobuf::Timestamp* request_timestamp_;
    int status_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};
// -------------------------------------------------------------------

class Overrides final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Overrides) */ {
 public:
  inline Overrides() : Overrides(nullptr) {}
  ~Overrides() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Overrides* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Overrides));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Overrides(
      ::google::protobuf::internal::ConstantInitialized);

  inline Overrides(const Overrides& from) : Overrides(nullptr, from) {}
  inline Overrides(Overrides&& from) noexcept
      : Overrides(nullptr, std::move(from)) {}
  inline Overrides& operator=(const Overrides& from) {
    CopyFrom(from);
    return *this;
  }
  inline Overrides& operator=(Overrides&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Overrides& default_instance() {
    return *internal_default_instance();
  }
  static inline const Overrides* internal_default_instance() {
    return reinterpret_cast<const Overrides*>(
        &_Overrides_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Overrides& a, Overrides& b) { a.Swap(&b); }
  inline void Swap(Overrides* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Overrides* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Overrides* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Overrides>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Overrides& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Overrides& from) { Overrides::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Overrides* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.entitymanager.v1.Overrides"; }

 protected:
  explicit Overrides(::google::protobuf::Arena* arena);
  Overrides(::google::protobuf::Arena* arena, const Overrides& from);
  Overrides(::google::protobuf::Arena* arena, Overrides&& from) noexcept
      : Overrides(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOverrideFieldNumber = 2,
  };
  // repeated .anduril.entitymanager.v1.Override override = 2 [json_name = "override"];
  int override_size() const;
  private:
  int _internal_override_size() const;

  public:
  void clear_override() ;
  ::anduril::entitymanager::v1::Override* mutable_override(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>* mutable_override();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>& _internal_override() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>* _internal_mutable_override();
  public:
  const ::anduril::entitymanager::v1::Override& override(int index) const;
  ::anduril::entitymanager::v1::Override* add_override();
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>& override() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Overrides)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Overrides& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Override > override_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Entity

// string entity_id = 1 [json_name = "entityId"];
inline void Entity::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& Entity::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Entity::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Entity.entity_id)
}
inline std::string* Entity::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.entity_id)
  return _s;
}
inline const std::string& Entity::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void Entity::_internal_set_entity_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* Entity::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* Entity::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.entity_id)
  return _impl_.entity_id_.Release();
}
inline void Entity::set_allocated_entity_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.entity_id)
}

// string description = 2 [json_name = "description"];
inline void Entity::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Entity::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Entity::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Entity.description)
}
inline std::string* Entity::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.description)
  return _s;
}
inline const std::string& Entity::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Entity::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* Entity::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* Entity::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.description)
  return _impl_.description_.Release();
}
inline void Entity::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.description)
}

// bool is_live = 3 [json_name = "isLive"];
inline void Entity::clear_is_live() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_live_ = false;
}
inline bool Entity::is_live() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.is_live)
  return _internal_is_live();
}
inline void Entity::set_is_live(bool value) {
  _internal_set_is_live(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Entity.is_live)
}
inline bool Entity::_internal_is_live() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_live_;
}
inline void Entity::_internal_set_is_live(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_live_ = value;
}

// .google.protobuf.Timestamp created_time = 4 [json_name = "createdTime"];
inline bool Entity::has_created_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Entity::_internal_created_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.created_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Entity::created_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.created_time)
  return _internal_created_time();
}
inline void Entity::unsafe_arena_set_allocated_created_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_time_);
  }
  _impl_.created_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.created_time)
}
inline ::google::protobuf::Timestamp* Entity::release_created_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_time_;
  _impl_.created_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Entity::unsafe_arena_release_created_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.created_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_time_;
  _impl_.created_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Entity::_internal_mutable_created_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_time_;
}
inline ::google::protobuf::Timestamp* Entity::mutable_created_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_time();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.created_time)
  return _msg;
}
inline void Entity::set_allocated_created_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.created_time)
}

// .google.protobuf.Timestamp expiry_time = 5 [json_name = "expiryTime", (.anduril.entitymanager.v1.overridable) = true];
inline bool Entity::has_expiry_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expiry_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Entity::_internal_expiry_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.expiry_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Entity::expiry_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.expiry_time)
  return _internal_expiry_time();
}
inline void Entity::unsafe_arena_set_allocated_expiry_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiry_time_);
  }
  _impl_.expiry_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.expiry_time)
}
inline ::google::protobuf::Timestamp* Entity::release_expiry_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.expiry_time_;
  _impl_.expiry_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Entity::unsafe_arena_release_expiry_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.expiry_time)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.expiry_time_;
  _impl_.expiry_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Entity::_internal_mutable_expiry_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expiry_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.expiry_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.expiry_time_;
}
inline ::google::protobuf::Timestamp* Entity::mutable_expiry_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_expiry_time();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.expiry_time)
  return _msg;
}
inline void Entity::set_allocated_expiry_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiry_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.expiry_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.expiry_time)
}

// .anduril.entitymanager.v1.Status status = 19 [json_name = "status"];
inline bool Entity::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void Entity::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::anduril::entitymanager::v1::Status& Entity::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Status&>(::anduril::entitymanager::v1::_Status_default_instance_);
}
inline const ::anduril::entitymanager::v1::Status& Entity::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.status)
  return _internal_status();
}
inline void Entity::unsafe_arena_set_allocated_status(::anduril::entitymanager::v1::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::anduril::entitymanager::v1::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.status)
}
inline ::anduril::entitymanager::v1::Status* Entity::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::anduril::entitymanager::v1::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Status* Entity::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.status)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::anduril::entitymanager::v1::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Status* Entity::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::anduril::entitymanager::v1::Status*>(p);
  }
  return _impl_.status_;
}
inline ::anduril::entitymanager::v1::Status* Entity::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000800u;
  ::anduril::entitymanager::v1::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.status)
  return _msg;
}
inline void Entity::set_allocated_status(::anduril::entitymanager::v1::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.status_ = reinterpret_cast<::anduril::entitymanager::v1::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.status)
}

// .anduril.entitymanager.v1.Location location = 6 [json_name = "location"];
inline bool Entity::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Location& Entity::_internal_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Location* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Location&>(::anduril::entitymanager::v1::_Location_default_instance_);
}
inline const ::anduril::entitymanager::v1::Location& Entity::location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.location)
  return _internal_location();
}
inline void Entity::unsafe_arena_set_allocated_location(::anduril::entitymanager::v1::Location* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::anduril::entitymanager::v1::Location*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.location)
}
inline ::anduril::entitymanager::v1::Location* Entity::release_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::entitymanager::v1::Location* released = _impl_.location_;
  _impl_.location_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Location* Entity::unsafe_arena_release_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.location)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::entitymanager::v1::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Location* Entity::_internal_mutable_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.location_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Location>(GetArena());
    _impl_.location_ = reinterpret_cast<::anduril::entitymanager::v1::Location*>(p);
  }
  return _impl_.location_;
}
inline ::anduril::entitymanager::v1::Location* Entity::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::anduril::entitymanager::v1::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.location)
  return _msg;
}
inline void Entity::set_allocated_location(::anduril::entitymanager::v1::Location* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.location_ = reinterpret_cast<::anduril::entitymanager::v1::Location*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.location)
}

// .anduril.entitymanager.v1.LocationUncertainty location_uncertainty = 15 [json_name = "locationUncertainty"];
inline bool Entity::has_location_uncertainty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_uncertainty_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::LocationUncertainty& Entity::_internal_location_uncertainty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::LocationUncertainty* p = _impl_.location_uncertainty_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::LocationUncertainty&>(::anduril::entitymanager::v1::_LocationUncertainty_default_instance_);
}
inline const ::anduril::entitymanager::v1::LocationUncertainty& Entity::location_uncertainty() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.location_uncertainty)
  return _internal_location_uncertainty();
}
inline void Entity::unsafe_arena_set_allocated_location_uncertainty(::anduril::entitymanager::v1::LocationUncertainty* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_uncertainty_);
  }
  _impl_.location_uncertainty_ = reinterpret_cast<::anduril::entitymanager::v1::LocationUncertainty*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.location_uncertainty)
}
inline ::anduril::entitymanager::v1::LocationUncertainty* Entity::release_location_uncertainty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::anduril::entitymanager::v1::LocationUncertainty* released = _impl_.location_uncertainty_;
  _impl_.location_uncertainty_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::LocationUncertainty* Entity::unsafe_arena_release_location_uncertainty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.location_uncertainty)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::anduril::entitymanager::v1::LocationUncertainty* temp = _impl_.location_uncertainty_;
  _impl_.location_uncertainty_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::LocationUncertainty* Entity::_internal_mutable_location_uncertainty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.location_uncertainty_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::LocationUncertainty>(GetArena());
    _impl_.location_uncertainty_ = reinterpret_cast<::anduril::entitymanager::v1::LocationUncertainty*>(p);
  }
  return _impl_.location_uncertainty_;
}
inline ::anduril::entitymanager::v1::LocationUncertainty* Entity::mutable_location_uncertainty() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::anduril::entitymanager::v1::LocationUncertainty* _msg = _internal_mutable_location_uncertainty();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.location_uncertainty)
  return _msg;
}
inline void Entity::set_allocated_location_uncertainty(::anduril::entitymanager::v1::LocationUncertainty* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_uncertainty_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.location_uncertainty_ = reinterpret_cast<::anduril::entitymanager::v1::LocationUncertainty*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.location_uncertainty)
}

// .anduril.entitymanager.v1.GeoShape geo_shape = 23 [json_name = "geoShape"];
inline bool Entity::has_geo_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geo_shape_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::GeoShape& Entity::_internal_geo_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::GeoShape* p = _impl_.geo_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::GeoShape&>(::anduril::entitymanager::v1::_GeoShape_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoShape& Entity::geo_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.geo_shape)
  return _internal_geo_shape();
}
inline void Entity::unsafe_arena_set_allocated_geo_shape(::anduril::entitymanager::v1::GeoShape* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_shape_);
  }
  _impl_.geo_shape_ = reinterpret_cast<::anduril::entitymanager::v1::GeoShape*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.geo_shape)
}
inline ::anduril::entitymanager::v1::GeoShape* Entity::release_geo_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::anduril::entitymanager::v1::GeoShape* released = _impl_.geo_shape_;
  _impl_.geo_shape_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::GeoShape* Entity::unsafe_arena_release_geo_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.geo_shape)

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::anduril::entitymanager::v1::GeoShape* temp = _impl_.geo_shape_;
  _impl_.geo_shape_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::GeoShape* Entity::_internal_mutable_geo_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.geo_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoShape>(GetArena());
    _impl_.geo_shape_ = reinterpret_cast<::anduril::entitymanager::v1::GeoShape*>(p);
  }
  return _impl_.geo_shape_;
}
inline ::anduril::entitymanager::v1::GeoShape* Entity::mutable_geo_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00008000u;
  ::anduril::entitymanager::v1::GeoShape* _msg = _internal_mutable_geo_shape();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.geo_shape)
  return _msg;
}
inline void Entity::set_allocated_geo_shape(::anduril::entitymanager::v1::GeoShape* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }

  _impl_.geo_shape_ = reinterpret_cast<::anduril::entitymanager::v1::GeoShape*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.geo_shape)
}

// .anduril.entitymanager.v1.GeoDetails geo_details = 24 [json_name = "geoDetails"];
inline bool Entity::has_geo_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geo_details_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::GeoDetails& Entity::_internal_geo_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::GeoDetails* p = _impl_.geo_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::GeoDetails&>(::anduril::entitymanager::v1::_GeoDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoDetails& Entity::geo_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.geo_details)
  return _internal_geo_details();
}
inline void Entity::unsafe_arena_set_allocated_geo_details(::anduril::entitymanager::v1::GeoDetails* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_details_);
  }
  _impl_.geo_details_ = reinterpret_cast<::anduril::entitymanager::v1::GeoDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.geo_details)
}
inline ::anduril::entitymanager::v1::GeoDetails* Entity::release_geo_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00010000u;
  ::anduril::entitymanager::v1::GeoDetails* released = _impl_.geo_details_;
  _impl_.geo_details_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::GeoDetails* Entity::unsafe_arena_release_geo_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.geo_details)

  _impl_._has_bits_[0] &= ~0x00010000u;
  ::anduril::entitymanager::v1::GeoDetails* temp = _impl_.geo_details_;
  _impl_.geo_details_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::GeoDetails* Entity::_internal_mutable_geo_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.geo_details_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GeoDetails>(GetArena());
    _impl_.geo_details_ = reinterpret_cast<::anduril::entitymanager::v1::GeoDetails*>(p);
  }
  return _impl_.geo_details_;
}
inline ::anduril::entitymanager::v1::GeoDetails* Entity::mutable_geo_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00010000u;
  ::anduril::entitymanager::v1::GeoDetails* _msg = _internal_mutable_geo_details();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.geo_details)
  return _msg;
}
inline void Entity::set_allocated_geo_details(::anduril::entitymanager::v1::GeoDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }

  _impl_.geo_details_ = reinterpret_cast<::anduril::entitymanager::v1::GeoDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.geo_details)
}

// .anduril.entitymanager.v1.Aliases aliases = 7 [json_name = "aliases"];
inline bool Entity::has_aliases() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.aliases_ != nullptr);
  return value;
}
inline void Entity::clear_aliases() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.aliases_ != nullptr) _impl_.aliases_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::anduril::entitymanager::v1::Aliases& Entity::_internal_aliases() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Aliases* p = _impl_.aliases_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Aliases&>(::anduril::entitymanager::v1::_Aliases_default_instance_);
}
inline const ::anduril::entitymanager::v1::Aliases& Entity::aliases() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.aliases)
  return _internal_aliases();
}
inline void Entity::unsafe_arena_set_allocated_aliases(::anduril::entitymanager::v1::Aliases* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.aliases_);
  }
  _impl_.aliases_ = reinterpret_cast<::anduril::entitymanager::v1::Aliases*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.aliases)
}
inline ::anduril::entitymanager::v1::Aliases* Entity::release_aliases() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::entitymanager::v1::Aliases* released = _impl_.aliases_;
  _impl_.aliases_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Aliases* Entity::unsafe_arena_release_aliases() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.aliases)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::entitymanager::v1::Aliases* temp = _impl_.aliases_;
  _impl_.aliases_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Aliases* Entity::_internal_mutable_aliases() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.aliases_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Aliases>(GetArena());
    _impl_.aliases_ = reinterpret_cast<::anduril::entitymanager::v1::Aliases*>(p);
  }
  return _impl_.aliases_;
}
inline ::anduril::entitymanager::v1::Aliases* Entity::mutable_aliases() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::anduril::entitymanager::v1::Aliases* _msg = _internal_mutable_aliases();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.aliases)
  return _msg;
}
inline void Entity::set_allocated_aliases(::anduril::entitymanager::v1::Aliases* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.aliases_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.aliases_ = reinterpret_cast<::anduril::entitymanager::v1::Aliases*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.aliases)
}

// .anduril.entitymanager.v1.Tracked tracked = 8 [json_name = "tracked"];
inline bool Entity::has_tracked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tracked_ != nullptr);
  return value;
}
inline void Entity::clear_tracked() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tracked_ != nullptr) _impl_.tracked_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::anduril::entitymanager::v1::Tracked& Entity::_internal_tracked() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Tracked* p = _impl_.tracked_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Tracked&>(::anduril::entitymanager::v1::_Tracked_default_instance_);
}
inline const ::anduril::entitymanager::v1::Tracked& Entity::tracked() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.tracked)
  return _internal_tracked();
}
inline void Entity::unsafe_arena_set_allocated_tracked(::anduril::entitymanager::v1::Tracked* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tracked_);
  }
  _impl_.tracked_ = reinterpret_cast<::anduril::entitymanager::v1::Tracked*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.tracked)
}
inline ::anduril::entitymanager::v1::Tracked* Entity::release_tracked() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::anduril::entitymanager::v1::Tracked* released = _impl_.tracked_;
  _impl_.tracked_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Tracked* Entity::unsafe_arena_release_tracked() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.tracked)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::anduril::entitymanager::v1::Tracked* temp = _impl_.tracked_;
  _impl_.tracked_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Tracked* Entity::_internal_mutable_tracked() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tracked_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Tracked>(GetArena());
    _impl_.tracked_ = reinterpret_cast<::anduril::entitymanager::v1::Tracked*>(p);
  }
  return _impl_.tracked_;
}
inline ::anduril::entitymanager::v1::Tracked* Entity::mutable_tracked() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::anduril::entitymanager::v1::Tracked* _msg = _internal_mutable_tracked();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.tracked)
  return _msg;
}
inline void Entity::set_allocated_tracked(::anduril::entitymanager::v1::Tracked* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tracked_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.tracked_ = reinterpret_cast<::anduril::entitymanager::v1::Tracked*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.tracked)
}

// .anduril.entitymanager.v1.Correlation correlation = 47 [json_name = "correlation"];
inline bool Entity::has_correlation() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.correlation_ != nullptr);
  return value;
}
inline void Entity::clear_correlation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.correlation_ != nullptr) _impl_.correlation_->Clear();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const ::anduril::entitymanager::v1::Correlation& Entity::_internal_correlation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Correlation* p = _impl_.correlation_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Correlation&>(::anduril::entitymanager::v1::_Correlation_default_instance_);
}
inline const ::anduril::entitymanager::v1::Correlation& Entity::correlation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.correlation)
  return _internal_correlation();
}
inline void Entity::unsafe_arena_set_allocated_correlation(::anduril::entitymanager::v1::Correlation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.correlation_);
  }
  _impl_.correlation_ = reinterpret_cast<::anduril::entitymanager::v1::Correlation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.correlation)
}
inline ::anduril::entitymanager::v1::Correlation* Entity::release_correlation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x80000000u;
  ::anduril::entitymanager::v1::Correlation* released = _impl_.correlation_;
  _impl_.correlation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Correlation* Entity::unsafe_arena_release_correlation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.correlation)

  _impl_._has_bits_[0] &= ~0x80000000u;
  ::anduril::entitymanager::v1::Correlation* temp = _impl_.correlation_;
  _impl_.correlation_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Correlation* Entity::_internal_mutable_correlation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.correlation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Correlation>(GetArena());
    _impl_.correlation_ = reinterpret_cast<::anduril::entitymanager::v1::Correlation*>(p);
  }
  return _impl_.correlation_;
}
inline ::anduril::entitymanager::v1::Correlation* Entity::mutable_correlation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x80000000u;
  ::anduril::entitymanager::v1::Correlation* _msg = _internal_mutable_correlation();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.correlation)
  return _msg;
}
inline void Entity::set_allocated_correlation(::anduril::entitymanager::v1::Correlation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.correlation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }

  _impl_.correlation_ = reinterpret_cast<::anduril::entitymanager::v1::Correlation*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.correlation)
}

// .anduril.entitymanager.v1.MilView mil_view = 10 [json_name = "milView"];
inline bool Entity::has_mil_view() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mil_view_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::MilView& Entity::_internal_mil_view() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::MilView* p = _impl_.mil_view_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::MilView&>(::anduril::entitymanager::v1::_MilView_default_instance_);
}
inline const ::anduril::entitymanager::v1::MilView& Entity::mil_view() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.mil_view)
  return _internal_mil_view();
}
inline void Entity::unsafe_arena_set_allocated_mil_view(::anduril::entitymanager::v1::MilView* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mil_view_);
  }
  _impl_.mil_view_ = reinterpret_cast<::anduril::entitymanager::v1::MilView*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.mil_view)
}
inline ::anduril::entitymanager::v1::MilView* Entity::release_mil_view() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::anduril::entitymanager::v1::MilView* released = _impl_.mil_view_;
  _impl_.mil_view_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::MilView* Entity::unsafe_arena_release_mil_view() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.mil_view)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::anduril::entitymanager::v1::MilView* temp = _impl_.mil_view_;
  _impl_.mil_view_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::MilView* Entity::_internal_mutable_mil_view() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mil_view_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::MilView>(GetArena());
    _impl_.mil_view_ = reinterpret_cast<::anduril::entitymanager::v1::MilView*>(p);
  }
  return _impl_.mil_view_;
}
inline ::anduril::entitymanager::v1::MilView* Entity::mutable_mil_view() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::anduril::entitymanager::v1::MilView* _msg = _internal_mutable_mil_view();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.mil_view)
  return _msg;
}
inline void Entity::set_allocated_mil_view(::anduril::entitymanager::v1::MilView* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mil_view_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.mil_view_ = reinterpret_cast<::anduril::entitymanager::v1::MilView*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.mil_view)
}

// .anduril.entitymanager.v1.Ontology ontology = 11 [json_name = "ontology"];
inline bool Entity::has_ontology() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ontology_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Ontology& Entity::_internal_ontology() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Ontology* p = _impl_.ontology_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Ontology&>(::anduril::entitymanager::v1::_Ontology_default_instance_);
}
inline const ::anduril::entitymanager::v1::Ontology& Entity::ontology() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.ontology)
  return _internal_ontology();
}
inline void Entity::unsafe_arena_set_allocated_ontology(::anduril::entitymanager::v1::Ontology* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ontology_);
  }
  _impl_.ontology_ = reinterpret_cast<::anduril::entitymanager::v1::Ontology*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.ontology)
}
inline ::anduril::entitymanager::v1::Ontology* Entity::release_ontology() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::anduril::entitymanager::v1::Ontology* released = _impl_.ontology_;
  _impl_.ontology_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Ontology* Entity::unsafe_arena_release_ontology() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.ontology)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::anduril::entitymanager::v1::Ontology* temp = _impl_.ontology_;
  _impl_.ontology_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Ontology* Entity::_internal_mutable_ontology() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ontology_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Ontology>(GetArena());
    _impl_.ontology_ = reinterpret_cast<::anduril::entitymanager::v1::Ontology*>(p);
  }
  return _impl_.ontology_;
}
inline ::anduril::entitymanager::v1::Ontology* Entity::mutable_ontology() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::anduril::entitymanager::v1::Ontology* _msg = _internal_mutable_ontology();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.ontology)
  return _msg;
}
inline void Entity::set_allocated_ontology(::anduril::entitymanager::v1::Ontology* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ontology_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.ontology_ = reinterpret_cast<::anduril::entitymanager::v1::Ontology*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.ontology)
}

// .anduril.entitymanager.v1.Sensors sensors = 20 [json_name = "sensors"];
inline bool Entity::has_sensors() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sensors_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Sensors& Entity::_internal_sensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Sensors* p = _impl_.sensors_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Sensors&>(::anduril::entitymanager::v1::_Sensors_default_instance_);
}
inline const ::anduril::entitymanager::v1::Sensors& Entity::sensors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.sensors)
  return _internal_sensors();
}
inline void Entity::unsafe_arena_set_allocated_sensors(::anduril::entitymanager::v1::Sensors* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensors_);
  }
  _impl_.sensors_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.sensors)
}
inline ::anduril::entitymanager::v1::Sensors* Entity::release_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::anduril::entitymanager::v1::Sensors* released = _impl_.sensors_;
  _impl_.sensors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Sensors* Entity::unsafe_arena_release_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.sensors)

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::anduril::entitymanager::v1::Sensors* temp = _impl_.sensors_;
  _impl_.sensors_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Sensors* Entity::_internal_mutable_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sensors_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Sensors>(GetArena());
    _impl_.sensors_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(p);
  }
  return _impl_.sensors_;
}
inline ::anduril::entitymanager::v1::Sensors* Entity::mutable_sensors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00001000u;
  ::anduril::entitymanager::v1::Sensors* _msg = _internal_mutable_sensors();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.sensors)
  return _msg;
}
inline void Entity::set_allocated_sensors(::anduril::entitymanager::v1::Sensors* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }

  _impl_.sensors_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.sensors)
}

// .anduril.entitymanager.v1.Payloads payloads = 21 [json_name = "payloads"];
inline bool Entity::has_payloads() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payloads_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Payloads& Entity::_internal_payloads() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Payloads* p = _impl_.payloads_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Payloads&>(::anduril::entitymanager::v1::_Payloads_default_instance_);
}
inline const ::anduril::entitymanager::v1::Payloads& Entity::payloads() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.payloads)
  return _internal_payloads();
}
inline void Entity::unsafe_arena_set_allocated_payloads(::anduril::entitymanager::v1::Payloads* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payloads_);
  }
  _impl_.payloads_ = reinterpret_cast<::anduril::entitymanager::v1::Payloads*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.payloads)
}
inline ::anduril::entitymanager::v1::Payloads* Entity::release_payloads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::anduril::entitymanager::v1::Payloads* released = _impl_.payloads_;
  _impl_.payloads_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Payloads* Entity::unsafe_arena_release_payloads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.payloads)

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::anduril::entitymanager::v1::Payloads* temp = _impl_.payloads_;
  _impl_.payloads_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Payloads* Entity::_internal_mutable_payloads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.payloads_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Payloads>(GetArena());
    _impl_.payloads_ = reinterpret_cast<::anduril::entitymanager::v1::Payloads*>(p);
  }
  return _impl_.payloads_;
}
inline ::anduril::entitymanager::v1::Payloads* Entity::mutable_payloads() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00002000u;
  ::anduril::entitymanager::v1::Payloads* _msg = _internal_mutable_payloads();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.payloads)
  return _msg;
}
inline void Entity::set_allocated_payloads(::anduril::entitymanager::v1::Payloads* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payloads_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }

  _impl_.payloads_ = reinterpret_cast<::anduril::entitymanager::v1::Payloads*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.payloads)
}

// .anduril.entitymanager.v1.PowerState power_state = 30 [json_name = "powerState"];
inline bool Entity::has_power_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.power_state_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::PowerState& Entity::_internal_power_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::PowerState* p = _impl_.power_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::PowerState&>(::anduril::entitymanager::v1::_PowerState_default_instance_);
}
inline const ::anduril::entitymanager::v1::PowerState& Entity::power_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.power_state)
  return _internal_power_state();
}
inline void Entity::unsafe_arena_set_allocated_power_state(::anduril::entitymanager::v1::PowerState* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.power_state_);
  }
  _impl_.power_state_ = reinterpret_cast<::anduril::entitymanager::v1::PowerState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.power_state)
}
inline ::anduril::entitymanager::v1::PowerState* Entity::release_power_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00100000u;
  ::anduril::entitymanager::v1::PowerState* released = _impl_.power_state_;
  _impl_.power_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::PowerState* Entity::unsafe_arena_release_power_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.power_state)

  _impl_._has_bits_[0] &= ~0x00100000u;
  ::anduril::entitymanager::v1::PowerState* temp = _impl_.power_state_;
  _impl_.power_state_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::PowerState* Entity::_internal_mutable_power_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.power_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::PowerState>(GetArena());
    _impl_.power_state_ = reinterpret_cast<::anduril::entitymanager::v1::PowerState*>(p);
  }
  return _impl_.power_state_;
}
inline ::anduril::entitymanager::v1::PowerState* Entity::mutable_power_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00100000u;
  ::anduril::entitymanager::v1::PowerState* _msg = _internal_mutable_power_state();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.power_state)
  return _msg;
}
inline void Entity::set_allocated_power_state(::anduril::entitymanager::v1::PowerState* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.power_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }

  _impl_.power_state_ = reinterpret_cast<::anduril::entitymanager::v1::PowerState*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.power_state)
}

// .anduril.entitymanager.v1.Provenance provenance = 12 [json_name = "provenance"];
inline bool Entity::has_provenance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.provenance_ != nullptr);
  return value;
}
inline void Entity::clear_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.provenance_ != nullptr) _impl_.provenance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::anduril::entitymanager::v1::Provenance& Entity::_internal_provenance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Provenance* p = _impl_.provenance_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Provenance&>(::anduril::entitymanager::v1::_Provenance_default_instance_);
}
inline const ::anduril::entitymanager::v1::Provenance& Entity::provenance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.provenance)
  return _internal_provenance();
}
inline void Entity::unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.provenance_);
  }
  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.provenance)
}
inline ::anduril::entitymanager::v1::Provenance* Entity::release_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::anduril::entitymanager::v1::Provenance* released = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Provenance* Entity::unsafe_arena_release_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.provenance)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::anduril::entitymanager::v1::Provenance* temp = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Provenance* Entity::_internal_mutable_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.provenance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Provenance>(GetArena());
    _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(p);
  }
  return _impl_.provenance_;
}
inline ::anduril::entitymanager::v1::Provenance* Entity::mutable_provenance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::anduril::entitymanager::v1::Provenance* _msg = _internal_mutable_provenance();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.provenance)
  return _msg;
}
inline void Entity::set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.provenance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.provenance)
}

// .anduril.entitymanager.v1.Overrides overrides = 13 [json_name = "overrides"];
inline bool Entity::has_overrides() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.overrides_ != nullptr);
  return value;
}
inline void Entity::clear_overrides() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.overrides_ != nullptr) _impl_.overrides_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::anduril::entitymanager::v1::Overrides& Entity::_internal_overrides() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Overrides* p = _impl_.overrides_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Overrides&>(::anduril::entitymanager::v1::_Overrides_default_instance_);
}
inline const ::anduril::entitymanager::v1::Overrides& Entity::overrides() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.overrides)
  return _internal_overrides();
}
inline void Entity::unsafe_arena_set_allocated_overrides(::anduril::entitymanager::v1::Overrides* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.overrides_);
  }
  _impl_.overrides_ = reinterpret_cast<::anduril::entitymanager::v1::Overrides*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.overrides)
}
inline ::anduril::entitymanager::v1::Overrides* Entity::release_overrides() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::anduril::entitymanager::v1::Overrides* released = _impl_.overrides_;
  _impl_.overrides_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Overrides* Entity::unsafe_arena_release_overrides() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.overrides)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::anduril::entitymanager::v1::Overrides* temp = _impl_.overrides_;
  _impl_.overrides_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Overrides* Entity::_internal_mutable_overrides() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.overrides_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Overrides>(GetArena());
    _impl_.overrides_ = reinterpret_cast<::anduril::entitymanager::v1::Overrides*>(p);
  }
  return _impl_.overrides_;
}
inline ::anduril::entitymanager::v1::Overrides* Entity::mutable_overrides() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::anduril::entitymanager::v1::Overrides* _msg = _internal_mutable_overrides();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.overrides)
  return _msg;
}
inline void Entity::set_allocated_overrides(::anduril::entitymanager::v1::Overrides* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.overrides_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.overrides_ = reinterpret_cast<::anduril::entitymanager::v1::Overrides*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.overrides)
}

// .anduril.entitymanager.v1.Indicators indicators = 14 [json_name = "indicators"];
inline bool Entity::has_indicators() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.indicators_ != nullptr);
  return value;
}
inline void Entity::clear_indicators() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.indicators_ != nullptr) _impl_.indicators_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::anduril::entitymanager::v1::Indicators& Entity::_internal_indicators() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Indicators* p = _impl_.indicators_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Indicators&>(::anduril::entitymanager::v1::_Indicators_default_instance_);
}
inline const ::anduril::entitymanager::v1::Indicators& Entity::indicators() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.indicators)
  return _internal_indicators();
}
inline void Entity::unsafe_arena_set_allocated_indicators(::anduril::entitymanager::v1::Indicators* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indicators_);
  }
  _impl_.indicators_ = reinterpret_cast<::anduril::entitymanager::v1::Indicators*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.indicators)
}
inline ::anduril::entitymanager::v1::Indicators* Entity::release_indicators() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::anduril::entitymanager::v1::Indicators* released = _impl_.indicators_;
  _impl_.indicators_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Indicators* Entity::unsafe_arena_release_indicators() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.indicators)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::anduril::entitymanager::v1::Indicators* temp = _impl_.indicators_;
  _impl_.indicators_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Indicators* Entity::_internal_mutable_indicators() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.indicators_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Indicators>(GetArena());
    _impl_.indicators_ = reinterpret_cast<::anduril::entitymanager::v1::Indicators*>(p);
  }
  return _impl_.indicators_;
}
inline ::anduril::entitymanager::v1::Indicators* Entity::mutable_indicators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::anduril::entitymanager::v1::Indicators* _msg = _internal_mutable_indicators();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.indicators)
  return _msg;
}
inline void Entity::set_allocated_indicators(::anduril::entitymanager::v1::Indicators* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.indicators_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.indicators_ = reinterpret_cast<::anduril::entitymanager::v1::Indicators*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.indicators)
}

// .anduril.entitymanager.v1.TargetPriority target_priority = 22 [json_name = "targetPriority"];
inline bool Entity::has_target_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_priority_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::TargetPriority& Entity::_internal_target_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::TargetPriority* p = _impl_.target_priority_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::TargetPriority&>(::anduril::entitymanager::v1::_TargetPriority_default_instance_);
}
inline const ::anduril::entitymanager::v1::TargetPriority& Entity::target_priority() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.target_priority)
  return _internal_target_priority();
}
inline void Entity::unsafe_arena_set_allocated_target_priority(::anduril::entitymanager::v1::TargetPriority* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_priority_);
  }
  _impl_.target_priority_ = reinterpret_cast<::anduril::entitymanager::v1::TargetPriority*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.target_priority)
}
inline ::anduril::entitymanager::v1::TargetPriority* Entity::release_target_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::anduril::entitymanager::v1::TargetPriority* released = _impl_.target_priority_;
  _impl_.target_priority_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::TargetPriority* Entity::unsafe_arena_release_target_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.target_priority)

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::anduril::entitymanager::v1::TargetPriority* temp = _impl_.target_priority_;
  _impl_.target_priority_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::TargetPriority* Entity::_internal_mutable_target_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_priority_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::TargetPriority>(GetArena());
    _impl_.target_priority_ = reinterpret_cast<::anduril::entitymanager::v1::TargetPriority*>(p);
  }
  return _impl_.target_priority_;
}
inline ::anduril::entitymanager::v1::TargetPriority* Entity::mutable_target_priority() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00004000u;
  ::anduril::entitymanager::v1::TargetPriority* _msg = _internal_mutable_target_priority();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.target_priority)
  return _msg;
}
inline void Entity::set_allocated_target_priority(::anduril::entitymanager::v1::TargetPriority* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_priority_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }

  _impl_.target_priority_ = reinterpret_cast<::anduril::entitymanager::v1::TargetPriority*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.target_priority)
}

// .anduril.entitymanager.v1.Signal signal = 25 [json_name = "signal"];
inline bool Entity::has_signal() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.signal_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Signal& Entity::_internal_signal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Signal* p = _impl_.signal_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Signal&>(::anduril::entitymanager::v1::_Signal_default_instance_);
}
inline const ::anduril::entitymanager::v1::Signal& Entity::signal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.signal)
  return _internal_signal();
}
inline void Entity::unsafe_arena_set_allocated_signal(::anduril::entitymanager::v1::Signal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.signal_);
  }
  _impl_.signal_ = reinterpret_cast<::anduril::entitymanager::v1::Signal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.signal)
}
inline ::anduril::entitymanager::v1::Signal* Entity::release_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00020000u;
  ::anduril::entitymanager::v1::Signal* released = _impl_.signal_;
  _impl_.signal_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Signal* Entity::unsafe_arena_release_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.signal)

  _impl_._has_bits_[0] &= ~0x00020000u;
  ::anduril::entitymanager::v1::Signal* temp = _impl_.signal_;
  _impl_.signal_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Signal* Entity::_internal_mutable_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.signal_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Signal>(GetArena());
    _impl_.signal_ = reinterpret_cast<::anduril::entitymanager::v1::Signal*>(p);
  }
  return _impl_.signal_;
}
inline ::anduril::entitymanager::v1::Signal* Entity::mutable_signal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00020000u;
  ::anduril::entitymanager::v1::Signal* _msg = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.signal)
  return _msg;
}
inline void Entity::set_allocated_signal(::anduril::entitymanager::v1::Signal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.signal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }

  _impl_.signal_ = reinterpret_cast<::anduril::entitymanager::v1::Signal*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.signal)
}

// .anduril.entitymanager.v1.TransponderCodes transponder_codes = 26 [json_name = "transponderCodes"];
inline bool Entity::has_transponder_codes() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transponder_codes_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::TransponderCodes& Entity::_internal_transponder_codes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::TransponderCodes* p = _impl_.transponder_codes_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::TransponderCodes&>(::anduril::entitymanager::v1::_TransponderCodes_default_instance_);
}
inline const ::anduril::entitymanager::v1::TransponderCodes& Entity::transponder_codes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.transponder_codes)
  return _internal_transponder_codes();
}
inline void Entity::unsafe_arena_set_allocated_transponder_codes(::anduril::entitymanager::v1::TransponderCodes* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transponder_codes_);
  }
  _impl_.transponder_codes_ = reinterpret_cast<::anduril::entitymanager::v1::TransponderCodes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.transponder_codes)
}
inline ::anduril::entitymanager::v1::TransponderCodes* Entity::release_transponder_codes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00040000u;
  ::anduril::entitymanager::v1::TransponderCodes* released = _impl_.transponder_codes_;
  _impl_.transponder_codes_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::TransponderCodes* Entity::unsafe_arena_release_transponder_codes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.transponder_codes)

  _impl_._has_bits_[0] &= ~0x00040000u;
  ::anduril::entitymanager::v1::TransponderCodes* temp = _impl_.transponder_codes_;
  _impl_.transponder_codes_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::TransponderCodes* Entity::_internal_mutable_transponder_codes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transponder_codes_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::TransponderCodes>(GetArena());
    _impl_.transponder_codes_ = reinterpret_cast<::anduril::entitymanager::v1::TransponderCodes*>(p);
  }
  return _impl_.transponder_codes_;
}
inline ::anduril::entitymanager::v1::TransponderCodes* Entity::mutable_transponder_codes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00040000u;
  ::anduril::entitymanager::v1::TransponderCodes* _msg = _internal_mutable_transponder_codes();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.transponder_codes)
  return _msg;
}
inline void Entity::set_allocated_transponder_codes(::anduril::entitymanager::v1::TransponderCodes* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transponder_codes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }

  _impl_.transponder_codes_ = reinterpret_cast<::anduril::entitymanager::v1::TransponderCodes*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.transponder_codes)
}

// .anduril.entitymanager.v1.Classification data_classification = 29 [json_name = "dataClassification"];
inline bool Entity::has_data_classification() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_classification_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Classification& Entity::_internal_data_classification() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Classification* p = _impl_.data_classification_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Classification&>(::anduril::entitymanager::v1::_Classification_default_instance_);
}
inline const ::anduril::entitymanager::v1::Classification& Entity::data_classification() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.data_classification)
  return _internal_data_classification();
}
inline void Entity::unsafe_arena_set_allocated_data_classification(::anduril::entitymanager::v1::Classification* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_classification_);
  }
  _impl_.data_classification_ = reinterpret_cast<::anduril::entitymanager::v1::Classification*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.data_classification)
}
inline ::anduril::entitymanager::v1::Classification* Entity::release_data_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00080000u;
  ::anduril::entitymanager::v1::Classification* released = _impl_.data_classification_;
  _impl_.data_classification_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Classification* Entity::unsafe_arena_release_data_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.data_classification)

  _impl_._has_bits_[0] &= ~0x00080000u;
  ::anduril::entitymanager::v1::Classification* temp = _impl_.data_classification_;
  _impl_.data_classification_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Classification* Entity::_internal_mutable_data_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_classification_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Classification>(GetArena());
    _impl_.data_classification_ = reinterpret_cast<::anduril::entitymanager::v1::Classification*>(p);
  }
  return _impl_.data_classification_;
}
inline ::anduril::entitymanager::v1::Classification* Entity::mutable_data_classification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00080000u;
  ::anduril::entitymanager::v1::Classification* _msg = _internal_mutable_data_classification();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.data_classification)
  return _msg;
}
inline void Entity::set_allocated_data_classification(::anduril::entitymanager::v1::Classification* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_classification_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }

  _impl_.data_classification_ = reinterpret_cast<::anduril::entitymanager::v1::Classification*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.data_classification)
}

// .anduril.tasks.v2.TaskCatalog task_catalog = 31 [json_name = "taskCatalog", (.anduril.entitymanager.v1.overridable) = true];
inline bool Entity::has_task_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_catalog_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::TaskCatalog& Entity::_internal_task_catalog() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::TaskCatalog* p = _impl_.task_catalog_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::TaskCatalog&>(::anduril::tasks::v2::_TaskCatalog_default_instance_);
}
inline const ::anduril::tasks::v2::TaskCatalog& Entity::task_catalog() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.task_catalog)
  return _internal_task_catalog();
}
inline void Entity::unsafe_arena_set_allocated_task_catalog(::anduril::tasks::v2::TaskCatalog* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_catalog_);
  }
  _impl_.task_catalog_ = reinterpret_cast<::anduril::tasks::v2::TaskCatalog*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.task_catalog)
}
inline ::anduril::tasks::v2::TaskCatalog* Entity::release_task_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00200000u;
  ::anduril::tasks::v2::TaskCatalog* released = _impl_.task_catalog_;
  _impl_.task_catalog_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::tasks::v2::TaskCatalog* Entity::unsafe_arena_release_task_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.task_catalog)

  _impl_._has_bits_[0] &= ~0x00200000u;
  ::anduril::tasks::v2::TaskCatalog* temp = _impl_.task_catalog_;
  _impl_.task_catalog_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::TaskCatalog* Entity::_internal_mutable_task_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_catalog_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::TaskCatalog>(GetArena());
    _impl_.task_catalog_ = reinterpret_cast<::anduril::tasks::v2::TaskCatalog*>(p);
  }
  return _impl_.task_catalog_;
}
inline ::anduril::tasks::v2::TaskCatalog* Entity::mutable_task_catalog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00200000u;
  ::anduril::tasks::v2::TaskCatalog* _msg = _internal_mutable_task_catalog();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.task_catalog)
  return _msg;
}
inline void Entity::set_allocated_task_catalog(::anduril::tasks::v2::TaskCatalog* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_catalog_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }

  _impl_.task_catalog_ = reinterpret_cast<::anduril::tasks::v2::TaskCatalog*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.task_catalog)
}

// .anduril.entitymanager.v1.Relationships relationships = 33 [json_name = "relationships"];
inline bool Entity::has_relationships() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relationships_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Relationships& Entity::_internal_relationships() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Relationships* p = _impl_.relationships_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Relationships&>(::anduril::entitymanager::v1::_Relationships_default_instance_);
}
inline const ::anduril::entitymanager::v1::Relationships& Entity::relationships() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.relationships)
  return _internal_relationships();
}
inline void Entity::unsafe_arena_set_allocated_relationships(::anduril::entitymanager::v1::Relationships* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relationships_);
  }
  _impl_.relationships_ = reinterpret_cast<::anduril::entitymanager::v1::Relationships*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.relationships)
}
inline ::anduril::entitymanager::v1::Relationships* Entity::release_relationships() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00400000u;
  ::anduril::entitymanager::v1::Relationships* released = _impl_.relationships_;
  _impl_.relationships_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Relationships* Entity::unsafe_arena_release_relationships() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.relationships)

  _impl_._has_bits_[0] &= ~0x00400000u;
  ::anduril::entitymanager::v1::Relationships* temp = _impl_.relationships_;
  _impl_.relationships_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Relationships* Entity::_internal_mutable_relationships() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.relationships_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Relationships>(GetArena());
    _impl_.relationships_ = reinterpret_cast<::anduril::entitymanager::v1::Relationships*>(p);
  }
  return _impl_.relationships_;
}
inline ::anduril::entitymanager::v1::Relationships* Entity::mutable_relationships() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00400000u;
  ::anduril::entitymanager::v1::Relationships* _msg = _internal_mutable_relationships();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.relationships)
  return _msg;
}
inline void Entity::set_allocated_relationships(::anduril::entitymanager::v1::Relationships* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relationships_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }

  _impl_.relationships_ = reinterpret_cast<::anduril::entitymanager::v1::Relationships*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.relationships)
}

// .anduril.entitymanager.v1.VisualDetails visual_details = 34 [json_name = "visualDetails"];
inline bool Entity::has_visual_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.visual_details_ != nullptr);
  return value;
}
inline void Entity::clear_visual_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.visual_details_ != nullptr) _impl_.visual_details_->Clear();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const ::anduril::entitymanager::v1::VisualDetails& Entity::_internal_visual_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::VisualDetails* p = _impl_.visual_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::VisualDetails&>(::anduril::entitymanager::v1::_VisualDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::VisualDetails& Entity::visual_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.visual_details)
  return _internal_visual_details();
}
inline void Entity::unsafe_arena_set_allocated_visual_details(::anduril::entitymanager::v1::VisualDetails* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.visual_details_);
  }
  _impl_.visual_details_ = reinterpret_cast<::anduril::entitymanager::v1::VisualDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.visual_details)
}
inline ::anduril::entitymanager::v1::VisualDetails* Entity::release_visual_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00800000u;
  ::anduril::entitymanager::v1::VisualDetails* released = _impl_.visual_details_;
  _impl_.visual_details_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::VisualDetails* Entity::unsafe_arena_release_visual_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.visual_details)

  _impl_._has_bits_[0] &= ~0x00800000u;
  ::anduril::entitymanager::v1::VisualDetails* temp = _impl_.visual_details_;
  _impl_.visual_details_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::VisualDetails* Entity::_internal_mutable_visual_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.visual_details_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::VisualDetails>(GetArena());
    _impl_.visual_details_ = reinterpret_cast<::anduril::entitymanager::v1::VisualDetails*>(p);
  }
  return _impl_.visual_details_;
}
inline ::anduril::entitymanager::v1::VisualDetails* Entity::mutable_visual_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00800000u;
  ::anduril::entitymanager::v1::VisualDetails* _msg = _internal_mutable_visual_details();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.visual_details)
  return _msg;
}
inline void Entity::set_allocated_visual_details(::anduril::entitymanager::v1::VisualDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.visual_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }

  _impl_.visual_details_ = reinterpret_cast<::anduril::entitymanager::v1::VisualDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.visual_details)
}

// .anduril.entitymanager.v1.Dimensions dimensions = 36 [json_name = "dimensions"];
inline bool Entity::has_dimensions() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimensions_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Dimensions& Entity::_internal_dimensions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Dimensions* p = _impl_.dimensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Dimensions&>(::anduril::entitymanager::v1::_Dimensions_default_instance_);
}
inline const ::anduril::entitymanager::v1::Dimensions& Entity::dimensions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.dimensions)
  return _internal_dimensions();
}
inline void Entity::unsafe_arena_set_allocated_dimensions(::anduril::entitymanager::v1::Dimensions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimensions_);
  }
  _impl_.dimensions_ = reinterpret_cast<::anduril::entitymanager::v1::Dimensions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.dimensions)
}
inline ::anduril::entitymanager::v1::Dimensions* Entity::release_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x01000000u;
  ::anduril::entitymanager::v1::Dimensions* released = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Dimensions* Entity::unsafe_arena_release_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.dimensions)

  _impl_._has_bits_[0] &= ~0x01000000u;
  ::anduril::entitymanager::v1::Dimensions* temp = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Dimensions* Entity::_internal_mutable_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dimensions_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Dimensions>(GetArena());
    _impl_.dimensions_ = reinterpret_cast<::anduril::entitymanager::v1::Dimensions*>(p);
  }
  return _impl_.dimensions_;
}
inline ::anduril::entitymanager::v1::Dimensions* Entity::mutable_dimensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x01000000u;
  ::anduril::entitymanager::v1::Dimensions* _msg = _internal_mutable_dimensions();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.dimensions)
  return _msg;
}
inline void Entity::set_allocated_dimensions(::anduril::entitymanager::v1::Dimensions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }

  _impl_.dimensions_ = reinterpret_cast<::anduril::entitymanager::v1::Dimensions*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.dimensions)
}

// .anduril.entitymanager.v1.RouteDetails route_details = 37 [json_name = "routeDetails"];
inline bool Entity::has_route_details() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.route_details_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::RouteDetails& Entity::_internal_route_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::RouteDetails* p = _impl_.route_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::RouteDetails&>(::anduril::entitymanager::v1::_RouteDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::RouteDetails& Entity::route_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.route_details)
  return _internal_route_details();
}
inline void Entity::unsafe_arena_set_allocated_route_details(::anduril::entitymanager::v1::RouteDetails* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.route_details_);
  }
  _impl_.route_details_ = reinterpret_cast<::anduril::entitymanager::v1::RouteDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.route_details)
}
inline ::anduril::entitymanager::v1::RouteDetails* Entity::release_route_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x02000000u;
  ::anduril::entitymanager::v1::RouteDetails* released = _impl_.route_details_;
  _impl_.route_details_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::RouteDetails* Entity::unsafe_arena_release_route_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.route_details)

  _impl_._has_bits_[0] &= ~0x02000000u;
  ::anduril::entitymanager::v1::RouteDetails* temp = _impl_.route_details_;
  _impl_.route_details_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::RouteDetails* Entity::_internal_mutable_route_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.route_details_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::RouteDetails>(GetArena());
    _impl_.route_details_ = reinterpret_cast<::anduril::entitymanager::v1::RouteDetails*>(p);
  }
  return _impl_.route_details_;
}
inline ::anduril::entitymanager::v1::RouteDetails* Entity::mutable_route_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x02000000u;
  ::anduril::entitymanager::v1::RouteDetails* _msg = _internal_mutable_route_details();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.route_details)
  return _msg;
}
inline void Entity::set_allocated_route_details(::anduril::entitymanager::v1::RouteDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.route_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }

  _impl_.route_details_ = reinterpret_cast<::anduril::entitymanager::v1::RouteDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.route_details)
}

// .anduril.entitymanager.v1.Schedules schedules = 38 [json_name = "schedules"];
inline bool Entity::has_schedules() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schedules_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Schedules& Entity::_internal_schedules() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Schedules* p = _impl_.schedules_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Schedules&>(::anduril::entitymanager::v1::_Schedules_default_instance_);
}
inline const ::anduril::entitymanager::v1::Schedules& Entity::schedules() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.schedules)
  return _internal_schedules();
}
inline void Entity::unsafe_arena_set_allocated_schedules(::anduril::entitymanager::v1::Schedules* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.schedules_);
  }
  _impl_.schedules_ = reinterpret_cast<::anduril::entitymanager::v1::Schedules*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.schedules)
}
inline ::anduril::entitymanager::v1::Schedules* Entity::release_schedules() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x04000000u;
  ::anduril::entitymanager::v1::Schedules* released = _impl_.schedules_;
  _impl_.schedules_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Schedules* Entity::unsafe_arena_release_schedules() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.schedules)

  _impl_._has_bits_[0] &= ~0x04000000u;
  ::anduril::entitymanager::v1::Schedules* temp = _impl_.schedules_;
  _impl_.schedules_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Schedules* Entity::_internal_mutable_schedules() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.schedules_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Schedules>(GetArena());
    _impl_.schedules_ = reinterpret_cast<::anduril::entitymanager::v1::Schedules*>(p);
  }
  return _impl_.schedules_;
}
inline ::anduril::entitymanager::v1::Schedules* Entity::mutable_schedules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x04000000u;
  ::anduril::entitymanager::v1::Schedules* _msg = _internal_mutable_schedules();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.schedules)
  return _msg;
}
inline void Entity::set_allocated_schedules(::anduril::entitymanager::v1::Schedules* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.schedules_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }

  _impl_.schedules_ = reinterpret_cast<::anduril::entitymanager::v1::Schedules*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.schedules)
}

// .anduril.entitymanager.v1.Health health = 39 [json_name = "health"];
inline bool Entity::has_health() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.health_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Health& Entity::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Health* p = _impl_.health_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Health&>(::anduril::entitymanager::v1::_Health_default_instance_);
}
inline const ::anduril::entitymanager::v1::Health& Entity::health() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.health)
  return _internal_health();
}
inline void Entity::unsafe_arena_set_allocated_health(::anduril::entitymanager::v1::Health* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.health_);
  }
  _impl_.health_ = reinterpret_cast<::anduril::entitymanager::v1::Health*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.health)
}
inline ::anduril::entitymanager::v1::Health* Entity::release_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x08000000u;
  ::anduril::entitymanager::v1::Health* released = _impl_.health_;
  _impl_.health_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Health* Entity::unsafe_arena_release_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.health)

  _impl_._has_bits_[0] &= ~0x08000000u;
  ::anduril::entitymanager::v1::Health* temp = _impl_.health_;
  _impl_.health_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Health* Entity::_internal_mutable_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.health_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Health>(GetArena());
    _impl_.health_ = reinterpret_cast<::anduril::entitymanager::v1::Health*>(p);
  }
  return _impl_.health_;
}
inline ::anduril::entitymanager::v1::Health* Entity::mutable_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x08000000u;
  ::anduril::entitymanager::v1::Health* _msg = _internal_mutable_health();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.health)
  return _msg;
}
inline void Entity::set_allocated_health(::anduril::entitymanager::v1::Health* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.health_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }

  _impl_.health_ = reinterpret_cast<::anduril::entitymanager::v1::Health*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.health)
}

// .anduril.entitymanager.v1.GroupDetails group_details = 40 [json_name = "groupDetails"];
inline bool Entity::has_group_details() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_details_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::GroupDetails& Entity::_internal_group_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::GroupDetails* p = _impl_.group_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::GroupDetails&>(::anduril::entitymanager::v1::_GroupDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::GroupDetails& Entity::group_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.group_details)
  return _internal_group_details();
}
inline void Entity::unsafe_arena_set_allocated_group_details(::anduril::entitymanager::v1::GroupDetails* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_details_);
  }
  _impl_.group_details_ = reinterpret_cast<::anduril::entitymanager::v1::GroupDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.group_details)
}
inline ::anduril::entitymanager::v1::GroupDetails* Entity::release_group_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x10000000u;
  ::anduril::entitymanager::v1::GroupDetails* released = _impl_.group_details_;
  _impl_.group_details_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::GroupDetails* Entity::unsafe_arena_release_group_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.group_details)

  _impl_._has_bits_[0] &= ~0x10000000u;
  ::anduril::entitymanager::v1::GroupDetails* temp = _impl_.group_details_;
  _impl_.group_details_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::GroupDetails* Entity::_internal_mutable_group_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.group_details_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::GroupDetails>(GetArena());
    _impl_.group_details_ = reinterpret_cast<::anduril::entitymanager::v1::GroupDetails*>(p);
  }
  return _impl_.group_details_;
}
inline ::anduril::entitymanager::v1::GroupDetails* Entity::mutable_group_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x10000000u;
  ::anduril::entitymanager::v1::GroupDetails* _msg = _internal_mutable_group_details();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.group_details)
  return _msg;
}
inline void Entity::set_allocated_group_details(::anduril::entitymanager::v1::GroupDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }

  _impl_.group_details_ = reinterpret_cast<::anduril::entitymanager::v1::GroupDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.group_details)
}

// .anduril.entitymanager.v1.Supplies supplies = 42 [json_name = "supplies"];
inline bool Entity::has_supplies() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.supplies_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Supplies& Entity::_internal_supplies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Supplies* p = _impl_.supplies_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Supplies&>(::anduril::entitymanager::v1::_Supplies_default_instance_);
}
inline const ::anduril::entitymanager::v1::Supplies& Entity::supplies() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.supplies)
  return _internal_supplies();
}
inline void Entity::unsafe_arena_set_allocated_supplies(::anduril::entitymanager::v1::Supplies* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.supplies_);
  }
  _impl_.supplies_ = reinterpret_cast<::anduril::entitymanager::v1::Supplies*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.supplies)
}
inline ::anduril::entitymanager::v1::Supplies* Entity::release_supplies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x20000000u;
  ::anduril::entitymanager::v1::Supplies* released = _impl_.supplies_;
  _impl_.supplies_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Supplies* Entity::unsafe_arena_release_supplies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.supplies)

  _impl_._has_bits_[0] &= ~0x20000000u;
  ::anduril::entitymanager::v1::Supplies* temp = _impl_.supplies_;
  _impl_.supplies_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Supplies* Entity::_internal_mutable_supplies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.supplies_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Supplies>(GetArena());
    _impl_.supplies_ = reinterpret_cast<::anduril::entitymanager::v1::Supplies*>(p);
  }
  return _impl_.supplies_;
}
inline ::anduril::entitymanager::v1::Supplies* Entity::mutable_supplies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x20000000u;
  ::anduril::entitymanager::v1::Supplies* _msg = _internal_mutable_supplies();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.supplies)
  return _msg;
}
inline void Entity::set_allocated_supplies(::anduril::entitymanager::v1::Supplies* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.supplies_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }

  _impl_.supplies_ = reinterpret_cast<::anduril::entitymanager::v1::Supplies*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.supplies)
}

// .anduril.entitymanager.v1.Orbit orbit = 46 [json_name = "orbit"];
inline bool Entity::has_orbit() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orbit_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Orbit& Entity::_internal_orbit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Orbit* p = _impl_.orbit_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Orbit&>(::anduril::entitymanager::v1::_Orbit_default_instance_);
}
inline const ::anduril::entitymanager::v1::Orbit& Entity::orbit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.orbit)
  return _internal_orbit();
}
inline void Entity::unsafe_arena_set_allocated_orbit(::anduril::entitymanager::v1::Orbit* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orbit_);
  }
  _impl_.orbit_ = reinterpret_cast<::anduril::entitymanager::v1::Orbit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.orbit)
}
inline ::anduril::entitymanager::v1::Orbit* Entity::release_orbit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x40000000u;
  ::anduril::entitymanager::v1::Orbit* released = _impl_.orbit_;
  _impl_.orbit_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Orbit* Entity::unsafe_arena_release_orbit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.orbit)

  _impl_._has_bits_[0] &= ~0x40000000u;
  ::anduril::entitymanager::v1::Orbit* temp = _impl_.orbit_;
  _impl_.orbit_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Orbit* Entity::_internal_mutable_orbit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orbit_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Orbit>(GetArena());
    _impl_.orbit_ = reinterpret_cast<::anduril::entitymanager::v1::Orbit*>(p);
  }
  return _impl_.orbit_;
}
inline ::anduril::entitymanager::v1::Orbit* Entity::mutable_orbit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x40000000u;
  ::anduril::entitymanager::v1::Orbit* _msg = _internal_mutable_orbit();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.orbit)
  return _msg;
}
inline void Entity::set_allocated_orbit(::anduril::entitymanager::v1::Orbit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orbit_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }

  _impl_.orbit_ = reinterpret_cast<::anduril::entitymanager::v1::Orbit*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.orbit)
}

// -------------------------------------------------------------------

// Status

// string platform_activity = 1 [json_name = "platformActivity"];
inline void Status::clear_platform_activity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_activity_.ClearToEmpty();
}
inline const std::string& Status::platform_activity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Status.platform_activity)
  return _internal_platform_activity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Status::set_platform_activity(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_activity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Status.platform_activity)
}
inline std::string* Status::mutable_platform_activity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_platform_activity();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Status.platform_activity)
  return _s;
}
inline const std::string& Status::_internal_platform_activity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.platform_activity_.Get();
}
inline void Status::_internal_set_platform_activity(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_activity_.Set(value, GetArena());
}
inline std::string* Status::_internal_mutable_platform_activity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.platform_activity_.Mutable( GetArena());
}
inline std::string* Status::release_platform_activity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Status.platform_activity)
  return _impl_.platform_activity_.Release();
}
inline void Status::set_allocated_platform_activity(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.platform_activity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.platform_activity_.IsDefault()) {
    _impl_.platform_activity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Status.platform_activity)
}

// string role = 2 [json_name = "role"];
inline void Status::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.ClearToEmpty();
}
inline const std::string& Status::role() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Status.role)
  return _internal_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Status::set_role(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Status.role)
}
inline std::string* Status::mutable_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Status.role)
  return _s;
}
inline const std::string& Status::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.role_.Get();
}
inline void Status::_internal_set_role(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.Set(value, GetArena());
}
inline std::string* Status::_internal_mutable_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.role_.Mutable( GetArena());
}
inline std::string* Status::release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Status.role)
  return _impl_.role_.Release();
}
inline void Status::set_allocated_role(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.role_.IsDefault()) {
    _impl_.role_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Status.role)
}

// -------------------------------------------------------------------

// Aliases

// repeated .anduril.entitymanager.v1.AlternateId alternate_ids = 1 [json_name = "alternateIds", (.anduril.entitymanager.v1.overridable) = true];
inline int Aliases::_internal_alternate_ids_size() const {
  return _internal_alternate_ids().size();
}
inline int Aliases::alternate_ids_size() const {
  return _internal_alternate_ids_size();
}
inline void Aliases::clear_alternate_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alternate_ids_.Clear();
}
inline ::anduril::entitymanager::v1::AlternateId* Aliases::mutable_alternate_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Aliases.alternate_ids)
  return _internal_mutable_alternate_ids()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>* Aliases::mutable_alternate_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.Aliases.alternate_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_alternate_ids();
}
inline const ::anduril::entitymanager::v1::AlternateId& Aliases::alternate_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Aliases.alternate_ids)
  return _internal_alternate_ids().Get(index);
}
inline ::anduril::entitymanager::v1::AlternateId* Aliases::add_alternate_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::AlternateId* _add = _internal_mutable_alternate_ids()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.Aliases.alternate_ids)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>& Aliases::alternate_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.Aliases.alternate_ids)
  return _internal_alternate_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>&
Aliases::_internal_alternate_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alternate_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>*
Aliases::_internal_mutable_alternate_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.alternate_ids_;
}

// string name = 2 [json_name = "name", (.anduril.entitymanager.v1.overridable) = true];
inline void Aliases::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Aliases::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Aliases.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Aliases::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Aliases.name)
}
inline std::string* Aliases::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Aliases.name)
  return _s;
}
inline const std::string& Aliases::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Aliases::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Aliases::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Aliases::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Aliases.name)
  return _impl_.name_.Release();
}
inline void Aliases::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Aliases.name)
}

// -------------------------------------------------------------------

// Tracked

// .google.protobuf.Int32Value track_quality_wrapper = 2 [json_name = "trackQualityWrapper"];
inline bool Tracked::has_track_quality_wrapper() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.track_quality_wrapper_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int32Value& Tracked::_internal_track_quality_wrapper() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int32Value* p = _impl_.track_quality_wrapper_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int32Value&>(::google::protobuf::_Int32Value_default_instance_);
}
inline const ::google::protobuf::Int32Value& Tracked::track_quality_wrapper() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.track_quality_wrapper)
  return _internal_track_quality_wrapper();
}
inline void Tracked::unsafe_arena_set_allocated_track_quality_wrapper(::google::protobuf::Int32Value* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.track_quality_wrapper_);
  }
  _impl_.track_quality_wrapper_ = reinterpret_cast<::google::protobuf::Int32Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.track_quality_wrapper)
}
inline ::google::protobuf::Int32Value* Tracked::release_track_quality_wrapper() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int32Value* released = _impl_.track_quality_wrapper_;
  _impl_.track_quality_wrapper_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int32Value* Tracked::unsafe_arena_release_track_quality_wrapper() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.track_quality_wrapper)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int32Value* temp = _impl_.track_quality_wrapper_;
  _impl_.track_quality_wrapper_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* Tracked::_internal_mutable_track_quality_wrapper() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.track_quality_wrapper_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int32Value>(GetArena());
    _impl_.track_quality_wrapper_ = reinterpret_cast<::google::protobuf::Int32Value*>(p);
  }
  return _impl_.track_quality_wrapper_;
}
inline ::google::protobuf::Int32Value* Tracked::mutable_track_quality_wrapper() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Int32Value* _msg = _internal_mutable_track_quality_wrapper();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.track_quality_wrapper)
  return _msg;
}
inline void Tracked::set_allocated_track_quality_wrapper(::google::protobuf::Int32Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.track_quality_wrapper_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.track_quality_wrapper_ = reinterpret_cast<::google::protobuf::Int32Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.track_quality_wrapper)
}

// .google.protobuf.Int32Value sensor_hits = 3 [json_name = "sensorHits"];
inline bool Tracked::has_sensor_hits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sensor_hits_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int32Value& Tracked::_internal_sensor_hits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int32Value* p = _impl_.sensor_hits_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int32Value&>(::google::protobuf::_Int32Value_default_instance_);
}
inline const ::google::protobuf::Int32Value& Tracked::sensor_hits() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.sensor_hits)
  return _internal_sensor_hits();
}
inline void Tracked::unsafe_arena_set_allocated_sensor_hits(::google::protobuf::Int32Value* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensor_hits_);
  }
  _impl_.sensor_hits_ = reinterpret_cast<::google::protobuf::Int32Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.sensor_hits)
}
inline ::google::protobuf::Int32Value* Tracked::release_sensor_hits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int32Value* released = _impl_.sensor_hits_;
  _impl_.sensor_hits_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int32Value* Tracked::unsafe_arena_release_sensor_hits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.sensor_hits)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int32Value* temp = _impl_.sensor_hits_;
  _impl_.sensor_hits_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* Tracked::_internal_mutable_sensor_hits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sensor_hits_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int32Value>(GetArena());
    _impl_.sensor_hits_ = reinterpret_cast<::google::protobuf::Int32Value*>(p);
  }
  return _impl_.sensor_hits_;
}
inline ::google::protobuf::Int32Value* Tracked::mutable_sensor_hits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int32Value* _msg = _internal_mutable_sensor_hits();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.sensor_hits)
  return _msg;
}
inline void Tracked::set_allocated_sensor_hits(::google::protobuf::Int32Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensor_hits_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.sensor_hits_ = reinterpret_cast<::google::protobuf::Int32Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.sensor_hits)
}

// .anduril.entitymanager.v1.UInt32Range number_of_objects = 4 [json_name = "numberOfObjects"];
inline bool Tracked::has_number_of_objects() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.number_of_objects_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::UInt32Range& Tracked::_internal_number_of_objects() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::UInt32Range* p = _impl_.number_of_objects_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::UInt32Range&>(::anduril::entitymanager::v1::_UInt32Range_default_instance_);
}
inline const ::anduril::entitymanager::v1::UInt32Range& Tracked::number_of_objects() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.number_of_objects)
  return _internal_number_of_objects();
}
inline void Tracked::unsafe_arena_set_allocated_number_of_objects(::anduril::entitymanager::v1::UInt32Range* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.number_of_objects_);
  }
  _impl_.number_of_objects_ = reinterpret_cast<::anduril::entitymanager::v1::UInt32Range*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.number_of_objects)
}
inline ::anduril::entitymanager::v1::UInt32Range* Tracked::release_number_of_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::entitymanager::v1::UInt32Range* released = _impl_.number_of_objects_;
  _impl_.number_of_objects_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::UInt32Range* Tracked::unsafe_arena_release_number_of_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.number_of_objects)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::entitymanager::v1::UInt32Range* temp = _impl_.number_of_objects_;
  _impl_.number_of_objects_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::UInt32Range* Tracked::_internal_mutable_number_of_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.number_of_objects_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::UInt32Range>(GetArena());
    _impl_.number_of_objects_ = reinterpret_cast<::anduril::entitymanager::v1::UInt32Range*>(p);
  }
  return _impl_.number_of_objects_;
}
inline ::anduril::entitymanager::v1::UInt32Range* Tracked::mutable_number_of_objects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::anduril::entitymanager::v1::UInt32Range* _msg = _internal_mutable_number_of_objects();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.number_of_objects)
  return _msg;
}
inline void Tracked::set_allocated_number_of_objects(::anduril::entitymanager::v1::UInt32Range* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.number_of_objects_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.number_of_objects_ = reinterpret_cast<::anduril::entitymanager::v1::UInt32Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.number_of_objects)
}

// .google.protobuf.DoubleValue radar_cross_section = 6 [json_name = "radarCrossSection"];
inline bool Tracked::has_radar_cross_section() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.radar_cross_section_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& Tracked::_internal_radar_cross_section() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.radar_cross_section_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& Tracked::radar_cross_section() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.radar_cross_section)
  return _internal_radar_cross_section();
}
inline void Tracked::unsafe_arena_set_allocated_radar_cross_section(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.radar_cross_section_);
  }
  _impl_.radar_cross_section_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.radar_cross_section)
}
inline ::google::protobuf::DoubleValue* Tracked::release_radar_cross_section() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::DoubleValue* released = _impl_.radar_cross_section_;
  _impl_.radar_cross_section_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::DoubleValue* Tracked::unsafe_arena_release_radar_cross_section() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.radar_cross_section)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::DoubleValue* temp = _impl_.radar_cross_section_;
  _impl_.radar_cross_section_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* Tracked::_internal_mutable_radar_cross_section() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.radar_cross_section_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.radar_cross_section_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.radar_cross_section_;
}
inline ::google::protobuf::DoubleValue* Tracked::mutable_radar_cross_section() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_radar_cross_section();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.radar_cross_section)
  return _msg;
}
inline void Tracked::set_allocated_radar_cross_section(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.radar_cross_section_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.radar_cross_section_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.radar_cross_section)
}

// .google.protobuf.Timestamp last_measurement_time = 7 [json_name = "lastMeasurementTime"];
inline bool Tracked::has_last_measurement_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_measurement_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Tracked::_internal_last_measurement_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.last_measurement_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Tracked::last_measurement_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.last_measurement_time)
  return _internal_last_measurement_time();
}
inline void Tracked::unsafe_arena_set_allocated_last_measurement_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_measurement_time_);
  }
  _impl_.last_measurement_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.last_measurement_time)
}
inline ::google::protobuf::Timestamp* Tracked::release_last_measurement_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Timestamp* released = _impl_.last_measurement_time_;
  _impl_.last_measurement_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Tracked::unsafe_arena_release_last_measurement_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.last_measurement_time)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Timestamp* temp = _impl_.last_measurement_time_;
  _impl_.last_measurement_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Tracked::_internal_mutable_last_measurement_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_measurement_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_measurement_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_measurement_time_;
}
inline ::google::protobuf::Timestamp* Tracked::mutable_last_measurement_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_measurement_time();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.last_measurement_time)
  return _msg;
}
inline void Tracked::set_allocated_last_measurement_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_measurement_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.last_measurement_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.last_measurement_time)
}

// .anduril.entitymanager.v1.LineOfBearing line_of_bearing = 9 [json_name = "lineOfBearing"];
inline bool Tracked::has_line_of_bearing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.line_of_bearing_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::LineOfBearing& Tracked::_internal_line_of_bearing() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::LineOfBearing* p = _impl_.line_of_bearing_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::LineOfBearing&>(::anduril::entitymanager::v1::_LineOfBearing_default_instance_);
}
inline const ::anduril::entitymanager::v1::LineOfBearing& Tracked::line_of_bearing() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.line_of_bearing)
  return _internal_line_of_bearing();
}
inline void Tracked::unsafe_arena_set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.line_of_bearing_);
  }
  _impl_.line_of_bearing_ = reinterpret_cast<::anduril::entitymanager::v1::LineOfBearing*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.line_of_bearing)
}
inline ::anduril::entitymanager::v1::LineOfBearing* Tracked::release_line_of_bearing() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::anduril::entitymanager::v1::LineOfBearing* released = _impl_.line_of_bearing_;
  _impl_.line_of_bearing_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::LineOfBearing* Tracked::unsafe_arena_release_line_of_bearing() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.line_of_bearing)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::anduril::entitymanager::v1::LineOfBearing* temp = _impl_.line_of_bearing_;
  _impl_.line_of_bearing_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::LineOfBearing* Tracked::_internal_mutable_line_of_bearing() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.line_of_bearing_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::LineOfBearing>(GetArena());
    _impl_.line_of_bearing_ = reinterpret_cast<::anduril::entitymanager::v1::LineOfBearing*>(p);
  }
  return _impl_.line_of_bearing_;
}
inline ::anduril::entitymanager::v1::LineOfBearing* Tracked::mutable_line_of_bearing() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::anduril::entitymanager::v1::LineOfBearing* _msg = _internal_mutable_line_of_bearing();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.line_of_bearing)
  return _msg;
}
inline void Tracked::set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.line_of_bearing_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.line_of_bearing_ = reinterpret_cast<::anduril::entitymanager::v1::LineOfBearing*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.line_of_bearing)
}

// -------------------------------------------------------------------

// Provenance

// string integration_name = 5 [json_name = "integrationName"];
inline void Provenance::clear_integration_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integration_name_.ClearToEmpty();
}
inline const std::string& Provenance::integration_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.integration_name)
  return _internal_integration_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Provenance::set_integration_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integration_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Provenance.integration_name)
}
inline std::string* Provenance::mutable_integration_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_integration_name();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Provenance.integration_name)
  return _s;
}
inline const std::string& Provenance::_internal_integration_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.integration_name_.Get();
}
inline void Provenance::_internal_set_integration_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integration_name_.Set(value, GetArena());
}
inline std::string* Provenance::_internal_mutable_integration_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.integration_name_.Mutable( GetArena());
}
inline std::string* Provenance::release_integration_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Provenance.integration_name)
  return _impl_.integration_name_.Release();
}
inline void Provenance::set_allocated_integration_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integration_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.integration_name_.IsDefault()) {
    _impl_.integration_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Provenance.integration_name)
}

// string data_type = 6 [json_name = "dataType"];
inline void Provenance::clear_data_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_type_.ClearToEmpty();
}
inline const std::string& Provenance::data_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.data_type)
  return _internal_data_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Provenance::set_data_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Provenance.data_type)
}
inline std::string* Provenance::mutable_data_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Provenance.data_type)
  return _s;
}
inline const std::string& Provenance::_internal_data_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_type_.Get();
}
inline void Provenance::_internal_set_data_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_type_.Set(value, GetArena());
}
inline std::string* Provenance::_internal_mutable_data_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_type_.Mutable( GetArena());
}
inline std::string* Provenance::release_data_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Provenance.data_type)
  return _impl_.data_type_.Release();
}
inline void Provenance::set_allocated_data_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_type_.IsDefault()) {
    _impl_.data_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Provenance.data_type)
}

// string source_id = 3 [json_name = "sourceId"];
inline void Provenance::clear_source_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_id_.ClearToEmpty();
}
inline const std::string& Provenance::source_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.source_id)
  return _internal_source_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Provenance::set_source_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Provenance.source_id)
}
inline std::string* Provenance::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Provenance.source_id)
  return _s;
}
inline const std::string& Provenance::_internal_source_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_id_.Get();
}
inline void Provenance::_internal_set_source_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_id_.Set(value, GetArena());
}
inline std::string* Provenance::_internal_mutable_source_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.source_id_.Mutable( GetArena());
}
inline std::string* Provenance::release_source_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Provenance.source_id)
  return _impl_.source_id_.Release();
}
inline void Provenance::set_allocated_source_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.source_id_.IsDefault()) {
    _impl_.source_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Provenance.source_id)
}

// .google.protobuf.Timestamp source_update_time = 2 [json_name = "sourceUpdateTime"];
inline bool Provenance::has_source_update_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_update_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Provenance::_internal_source_update_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.source_update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Provenance::source_update_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.source_update_time)
  return _internal_source_update_time();
}
inline void Provenance::unsafe_arena_set_allocated_source_update_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_update_time_);
  }
  _impl_.source_update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Provenance.source_update_time)
}
inline ::google::protobuf::Timestamp* Provenance::release_source_update_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.source_update_time_;
  _impl_.source_update_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Provenance::unsafe_arena_release_source_update_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Provenance.source_update_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.source_update_time_;
  _impl_.source_update_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Provenance::_internal_mutable_source_update_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_update_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.source_update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.source_update_time_;
}
inline ::google::protobuf::Timestamp* Provenance::mutable_source_update_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_source_update_time();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Provenance.source_update_time)
  return _msg;
}
inline void Provenance::set_allocated_source_update_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_update_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Provenance.source_update_time)
}

// string source_description = 4 [json_name = "sourceDescription"];
inline void Provenance::clear_source_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_description_.ClearToEmpty();
}
inline const std::string& Provenance::source_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.source_description)
  return _internal_source_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Provenance::set_source_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Provenance.source_description)
}
inline std::string* Provenance::mutable_source_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_description();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Provenance.source_description)
  return _s;
}
inline const std::string& Provenance::_internal_source_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_description_.Get();
}
inline void Provenance::_internal_set_source_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_description_.Set(value, GetArena());
}
inline std::string* Provenance::_internal_mutable_source_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.source_description_.Mutable( GetArena());
}
inline std::string* Provenance::release_source_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Provenance.source_description)
  return _impl_.source_description_.Release();
}
inline void Provenance::set_allocated_source_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.source_description_.IsDefault()) {
    _impl_.source_description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Provenance.source_description)
}

// -------------------------------------------------------------------

// Indicators

// .google.protobuf.BoolValue simulated = 1 [json_name = "simulated"];
inline bool Indicators::has_simulated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.simulated_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_simulated() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::BoolValue* p = _impl_.simulated_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::simulated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.simulated)
  return _internal_simulated();
}
inline void Indicators::unsafe_arena_set_allocated_simulated(::google::protobuf::BoolValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.simulated_);
  }
  _impl_.simulated_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.simulated)
}
inline ::google::protobuf::BoolValue* Indicators::release_simulated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::BoolValue* released = _impl_.simulated_;
  _impl_.simulated_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_simulated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.simulated)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::BoolValue* temp = _impl_.simulated_;
  _impl_.simulated_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_simulated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.simulated_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::BoolValue>(GetArena());
    _impl_.simulated_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.simulated_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_simulated() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::BoolValue* _msg = _internal_mutable_simulated();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.simulated)
  return _msg;
}
inline void Indicators::set_allocated_simulated(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.simulated_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.simulated_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.simulated)
}

// .google.protobuf.BoolValue exercise = 2 [json_name = "exercise"];
inline bool Indicators::has_exercise() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.exercise_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_exercise() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::BoolValue* p = _impl_.exercise_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::exercise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.exercise)
  return _internal_exercise();
}
inline void Indicators::unsafe_arena_set_allocated_exercise(::google::protobuf::BoolValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exercise_);
  }
  _impl_.exercise_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.exercise)
}
inline ::google::protobuf::BoolValue* Indicators::release_exercise() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::BoolValue* released = _impl_.exercise_;
  _impl_.exercise_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_exercise() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.exercise)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::BoolValue* temp = _impl_.exercise_;
  _impl_.exercise_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_exercise() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.exercise_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::BoolValue>(GetArena());
    _impl_.exercise_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.exercise_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_exercise() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::BoolValue* _msg = _internal_mutable_exercise();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.exercise)
  return _msg;
}
inline void Indicators::set_allocated_exercise(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exercise_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.exercise_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.exercise)
}

// .google.protobuf.BoolValue emergency = 3 [json_name = "emergency"];
inline bool Indicators::has_emergency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.emergency_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_emergency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::BoolValue* p = _impl_.emergency_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::emergency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.emergency)
  return _internal_emergency();
}
inline void Indicators::unsafe_arena_set_allocated_emergency(::google::protobuf::BoolValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.emergency_);
  }
  _impl_.emergency_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.emergency)
}
inline ::google::protobuf::BoolValue* Indicators::release_emergency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::BoolValue* released = _impl_.emergency_;
  _impl_.emergency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_emergency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.emergency)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::BoolValue* temp = _impl_.emergency_;
  _impl_.emergency_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_emergency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.emergency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::BoolValue>(GetArena());
    _impl_.emergency_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.emergency_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_emergency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::BoolValue* _msg = _internal_mutable_emergency();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.emergency)
  return _msg;
}
inline void Indicators::set_allocated_emergency(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.emergency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.emergency_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.emergency)
}

// .google.protobuf.BoolValue c2 = 4 [json_name = "c2"];
inline bool Indicators::has_c2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.c2_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_c2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::BoolValue* p = _impl_.c2_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::c2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.c2)
  return _internal_c2();
}
inline void Indicators::unsafe_arena_set_allocated_c2(::google::protobuf::BoolValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.c2_);
  }
  _impl_.c2_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.c2)
}
inline ::google::protobuf::BoolValue* Indicators::release_c2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::BoolValue* released = _impl_.c2_;
  _impl_.c2_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_c2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.c2)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::BoolValue* temp = _impl_.c2_;
  _impl_.c2_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_c2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.c2_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::BoolValue>(GetArena());
    _impl_.c2_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.c2_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_c2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::BoolValue* _msg = _internal_mutable_c2();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.c2)
  return _msg;
}
inline void Indicators::set_allocated_c2(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.c2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.c2_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.c2)
}

// .google.protobuf.BoolValue egressable = 6 [json_name = "egressable", (.anduril.entitymanager.v1.overridable) = true];
inline bool Indicators::has_egressable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.egressable_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_egressable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::BoolValue* p = _impl_.egressable_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::egressable() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.egressable)
  return _internal_egressable();
}
inline void Indicators::unsafe_arena_set_allocated_egressable(::google::protobuf::BoolValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.egressable_);
  }
  _impl_.egressable_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.egressable)
}
inline ::google::protobuf::BoolValue* Indicators::release_egressable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::BoolValue* released = _impl_.egressable_;
  _impl_.egressable_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_egressable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.egressable)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::BoolValue* temp = _impl_.egressable_;
  _impl_.egressable_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_egressable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.egressable_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::BoolValue>(GetArena());
    _impl_.egressable_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.egressable_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_egressable() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::google::protobuf::BoolValue* _msg = _internal_mutable_egressable();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.egressable)
  return _msg;
}
inline void Indicators::set_allocated_egressable(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.egressable_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.egressable_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.egressable)
}

// .google.protobuf.BoolValue starred = 7 [json_name = "starred", (.anduril.entitymanager.v1.overridable) = true];
inline bool Indicators::has_starred() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.starred_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_starred() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::BoolValue* p = _impl_.starred_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::starred() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.starred)
  return _internal_starred();
}
inline void Indicators::unsafe_arena_set_allocated_starred(::google::protobuf::BoolValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starred_);
  }
  _impl_.starred_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.starred)
}
inline ::google::protobuf::BoolValue* Indicators::release_starred() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::BoolValue* released = _impl_.starred_;
  _impl_.starred_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_starred() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.starred)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::BoolValue* temp = _impl_.starred_;
  _impl_.starred_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_starred() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.starred_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::BoolValue>(GetArena());
    _impl_.starred_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.starred_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_starred() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::google::protobuf::BoolValue* _msg = _internal_mutable_starred();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.starred)
  return _msg;
}
inline void Indicators::set_allocated_starred(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starred_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.starred_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.starred)
}

// -------------------------------------------------------------------

// Overrides

// repeated .anduril.entitymanager.v1.Override override = 2 [json_name = "override"];
inline int Overrides::_internal_override_size() const {
  return _internal_override().size();
}
inline int Overrides::override_size() const {
  return _internal_override_size();
}
inline void Overrides::clear_override() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.override_.Clear();
}
inline ::anduril::entitymanager::v1::Override* Overrides::mutable_override(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Overrides.override)
  return _internal_mutable_override()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>* Overrides::mutable_override()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.Overrides.override)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_override();
}
inline const ::anduril::entitymanager::v1::Override& Overrides::override(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Overrides.override)
  return _internal_override().Get(index);
}
inline ::anduril::entitymanager::v1::Override* Overrides::add_override() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::Override* _add = _internal_mutable_override()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.Overrides.override)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>& Overrides::override() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.Overrides.override)
  return _internal_override();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>&
Overrides::_internal_override() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.override_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>*
Overrides::_internal_mutable_override() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.override_;
}

// -------------------------------------------------------------------

// Override

// string request_id = 1 [json_name = "requestId"];
inline void Override::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& Override::request_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.request_id)
  return _internal_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Override::set_request_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Override.request_id)
}
inline std::string* Override::mutable_request_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Override.request_id)
  return _s;
}
inline const std::string& Override::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_.Get();
}
inline void Override::_internal_set_request_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(value, GetArena());
}
inline std::string* Override::_internal_mutable_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.request_id_.Mutable( GetArena());
}
inline std::string* Override::release_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Override.request_id)
  return _impl_.request_id_.Release();
}
inline void Override::set_allocated_request_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Override.request_id)
}

// string field_path = 2 [json_name = "fieldPath"];
inline void Override::clear_field_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_path_.ClearToEmpty();
}
inline const std::string& Override::field_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.field_path)
  return _internal_field_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Override::set_field_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Override.field_path)
}
inline std::string* Override::mutable_field_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_field_path();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Override.field_path)
  return _s;
}
inline const std::string& Override::_internal_field_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_path_.Get();
}
inline void Override::_internal_set_field_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_path_.Set(value, GetArena());
}
inline std::string* Override::_internal_mutable_field_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.field_path_.Mutable( GetArena());
}
inline std::string* Override::release_field_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Override.field_path)
  return _impl_.field_path_.Release();
}
inline void Override::set_allocated_field_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.field_path_.IsDefault()) {
    _impl_.field_path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Override.field_path)
}

// .anduril.entitymanager.v1.Entity masked_field_value = 3 [json_name = "maskedFieldValue"];
inline bool Override::has_masked_field_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.masked_field_value_ != nullptr);
  return value;
}
inline void Override::clear_masked_field_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.masked_field_value_ != nullptr) _impl_.masked_field_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::Entity& Override::_internal_masked_field_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Entity* p = _impl_.masked_field_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Entity&>(::anduril::entitymanager::v1::_Entity_default_instance_);
}
inline const ::anduril::entitymanager::v1::Entity& Override::masked_field_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.masked_field_value)
  return _internal_masked_field_value();
}
inline void Override::unsafe_arena_set_allocated_masked_field_value(::anduril::entitymanager::v1::Entity* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.masked_field_value_);
  }
  _impl_.masked_field_value_ = reinterpret_cast<::anduril::entitymanager::v1::Entity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Override.masked_field_value)
}
inline ::anduril::entitymanager::v1::Entity* Override::release_masked_field_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Entity* released = _impl_.masked_field_value_;
  _impl_.masked_field_value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Entity* Override::unsafe_arena_release_masked_field_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Override.masked_field_value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Entity* temp = _impl_.masked_field_value_;
  _impl_.masked_field_value_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Entity* Override::_internal_mutable_masked_field_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.masked_field_value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Entity>(GetArena());
    _impl_.masked_field_value_ = reinterpret_cast<::anduril::entitymanager::v1::Entity*>(p);
  }
  return _impl_.masked_field_value_;
}
inline ::anduril::entitymanager::v1::Entity* Override::mutable_masked_field_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Entity* _msg = _internal_mutable_masked_field_value();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Override.masked_field_value)
  return _msg;
}
inline void Override::set_allocated_masked_field_value(::anduril::entitymanager::v1::Entity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.masked_field_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.masked_field_value_ = reinterpret_cast<::anduril::entitymanager::v1::Entity*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Override.masked_field_value)
}

// .anduril.entitymanager.v1.OverrideStatus status = 4 [json_name = "status"];
inline void Override::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::anduril::entitymanager::v1::OverrideStatus Override::status() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.status)
  return _internal_status();
}
inline void Override::set_status(::anduril::entitymanager::v1::OverrideStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Override.status)
}
inline ::anduril::entitymanager::v1::OverrideStatus Override::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::OverrideStatus>(_impl_.status_);
}
inline void Override::_internal_set_status(::anduril::entitymanager::v1::OverrideStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// .anduril.entitymanager.v1.Provenance provenance = 5 [json_name = "provenance"];
inline bool Override::has_provenance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.provenance_ != nullptr);
  return value;
}
inline void Override::clear_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.provenance_ != nullptr) _impl_.provenance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::entitymanager::v1::Provenance& Override::_internal_provenance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Provenance* p = _impl_.provenance_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Provenance&>(::anduril::entitymanager::v1::_Provenance_default_instance_);
}
inline const ::anduril::entitymanager::v1::Provenance& Override::provenance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.provenance)
  return _internal_provenance();
}
inline void Override::unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.provenance_);
  }
  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Override.provenance)
}
inline ::anduril::entitymanager::v1::Provenance* Override::release_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entitymanager::v1::Provenance* released = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Provenance* Override::unsafe_arena_release_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Override.provenance)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entitymanager::v1::Provenance* temp = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Provenance* Override::_internal_mutable_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.provenance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Provenance>(GetArena());
    _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(p);
  }
  return _impl_.provenance_;
}
inline ::anduril::entitymanager::v1::Provenance* Override::mutable_provenance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::entitymanager::v1::Provenance* _msg = _internal_mutable_provenance();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Override.provenance)
  return _msg;
}
inline void Override::set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.provenance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Override.provenance)
}

// .anduril.entitymanager.v1.OverrideType type = 6 [json_name = "type"];
inline void Override::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::anduril::entitymanager::v1::OverrideType Override::type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.type)
  return _internal_type();
}
inline void Override::set_type(::anduril::entitymanager::v1::OverrideType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Override.type)
}
inline ::anduril::entitymanager::v1::OverrideType Override::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::OverrideType>(_impl_.type_);
}
inline void Override::_internal_set_type(::anduril::entitymanager::v1::OverrideType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .google.protobuf.Timestamp request_timestamp = 7 [json_name = "requestTimestamp"];
inline bool Override::has_request_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Override::_internal_request_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.request_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Override::request_timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.request_timestamp)
  return _internal_request_timestamp();
}
inline void Override::unsafe_arena_set_allocated_request_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.request_timestamp_);
  }
  _impl_.request_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Override.request_timestamp)
}
inline ::google::protobuf::Timestamp* Override::release_request_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.request_timestamp_;
  _impl_.request_timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Override::unsafe_arena_release_request_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Override.request_timestamp)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.request_timestamp_;
  _impl_.request_timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Override::_internal_mutable_request_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.request_timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.request_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.request_timestamp_;
}
inline ::google::protobuf::Timestamp* Override::mutable_request_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_request_timestamp();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Override.request_timestamp)
  return _msg;
}
inline void Override::set_allocated_request_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.request_timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.request_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Override.request_timestamp)
}

// -------------------------------------------------------------------

// AlternateId

// string id = 2 [json_name = "id"];
inline void AlternateId::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AlternateId::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.AlternateId.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AlternateId::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.AlternateId.id)
}
inline std::string* AlternateId::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.AlternateId.id)
  return _s;
}
inline const std::string& AlternateId::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void AlternateId::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* AlternateId::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* AlternateId::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.AlternateId.id)
  return _impl_.id_.Release();
}
inline void AlternateId::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.AlternateId.id)
}

// .anduril.entitymanager.v1.AltIdType type = 3 [json_name = "type"];
inline void AlternateId::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::anduril::entitymanager::v1::AltIdType AlternateId::type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.AlternateId.type)
  return _internal_type();
}
inline void AlternateId::set_type(::anduril::entitymanager::v1::AltIdType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.AlternateId.type)
}
inline ::anduril::entitymanager::v1::AltIdType AlternateId::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::AltIdType>(_impl_.type_);
}
inline void AlternateId::_internal_set_type(::anduril::entitymanager::v1::AltIdType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// VisualDetails

// .anduril.entitymanager.v1.RangeRings range_rings = 1 [json_name = "rangeRings", (.anduril.entitymanager.v1.overridable) = true];
inline bool VisualDetails::has_range_rings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.range_rings_ != nullptr);
  return value;
}
inline void VisualDetails::clear_range_rings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.range_rings_ != nullptr) _impl_.range_rings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::RangeRings& VisualDetails::_internal_range_rings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::RangeRings* p = _impl_.range_rings_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::RangeRings&>(::anduril::entitymanager::v1::_RangeRings_default_instance_);
}
inline const ::anduril::entitymanager::v1::RangeRings& VisualDetails::range_rings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.VisualDetails.range_rings)
  return _internal_range_rings();
}
inline void VisualDetails::unsafe_arena_set_allocated_range_rings(::anduril::entitymanager::v1::RangeRings* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.range_rings_);
  }
  _impl_.range_rings_ = reinterpret_cast<::anduril::entitymanager::v1::RangeRings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.VisualDetails.range_rings)
}
inline ::anduril::entitymanager::v1::RangeRings* VisualDetails::release_range_rings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::RangeRings* released = _impl_.range_rings_;
  _impl_.range_rings_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::RangeRings* VisualDetails::unsafe_arena_release_range_rings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.VisualDetails.range_rings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::RangeRings* temp = _impl_.range_rings_;
  _impl_.range_rings_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::RangeRings* VisualDetails::_internal_mutable_range_rings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.range_rings_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::RangeRings>(GetArena());
    _impl_.range_rings_ = reinterpret_cast<::anduril::entitymanager::v1::RangeRings*>(p);
  }
  return _impl_.range_rings_;
}
inline ::anduril::entitymanager::v1::RangeRings* VisualDetails::mutable_range_rings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::RangeRings* _msg = _internal_mutable_range_rings();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.VisualDetails.range_rings)
  return _msg;
}
inline void VisualDetails::set_allocated_range_rings(::anduril::entitymanager::v1::RangeRings* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.range_rings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.range_rings_ = reinterpret_cast<::anduril::entitymanager::v1::RangeRings*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.VisualDetails.range_rings)
}

// -------------------------------------------------------------------

// RangeRings

// .google.protobuf.DoubleValue min_distance_m = 1 [json_name = "minDistanceM"];
inline bool RangeRings::has_min_distance_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_distance_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& RangeRings::_internal_min_distance_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.min_distance_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& RangeRings::min_distance_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RangeRings.min_distance_m)
  return _internal_min_distance_m();
}
inline void RangeRings::unsafe_arena_set_allocated_min_distance_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_distance_m_);
  }
  _impl_.min_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RangeRings.min_distance_m)
}
inline ::google::protobuf::DoubleValue* RangeRings::release_min_distance_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.min_distance_m_;
  _impl_.min_distance_m_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::DoubleValue* RangeRings::unsafe_arena_release_min_distance_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RangeRings.min_distance_m)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.min_distance_m_;
  _impl_.min_distance_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* RangeRings::_internal_mutable_min_distance_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.min_distance_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.min_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.min_distance_m_;
}
inline ::google::protobuf::DoubleValue* RangeRings::mutable_min_distance_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_min_distance_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RangeRings.min_distance_m)
  return _msg;
}
inline void RangeRings::set_allocated_min_distance_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_distance_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.min_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.RangeRings.min_distance_m)
}

// .google.protobuf.DoubleValue max_distance_m = 2 [json_name = "maxDistanceM"];
inline bool RangeRings::has_max_distance_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_distance_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& RangeRings::_internal_max_distance_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.max_distance_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& RangeRings::max_distance_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RangeRings.max_distance_m)
  return _internal_max_distance_m();
}
inline void RangeRings::unsafe_arena_set_allocated_max_distance_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_distance_m_);
  }
  _impl_.max_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RangeRings.max_distance_m)
}
inline ::google::protobuf::DoubleValue* RangeRings::release_max_distance_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* released = _impl_.max_distance_m_;
  _impl_.max_distance_m_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::DoubleValue* RangeRings::unsafe_arena_release_max_distance_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RangeRings.max_distance_m)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* temp = _impl_.max_distance_m_;
  _impl_.max_distance_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* RangeRings::_internal_mutable_max_distance_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.max_distance_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.max_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.max_distance_m_;
}
inline ::google::protobuf::DoubleValue* RangeRings::mutable_max_distance_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_max_distance_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RangeRings.max_distance_m)
  return _msg;
}
inline void RangeRings::set_allocated_max_distance_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_distance_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.max_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.RangeRings.max_distance_m)
}

// uint32 ring_count = 3 [json_name = "ringCount"];
inline void RangeRings::clear_ring_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ring_count_ = 0u;
}
inline ::uint32_t RangeRings::ring_count() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RangeRings.ring_count)
  return _internal_ring_count();
}
inline void RangeRings::set_ring_count(::uint32_t value) {
  _internal_set_ring_count(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.RangeRings.ring_count)
}
inline ::uint32_t RangeRings::_internal_ring_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ring_count_;
}
inline void RangeRings::_internal_set_ring_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ring_count_ = value;
}

// .anduril.type.Color ring_line_color = 4 [json_name = "ringLineColor"];
inline bool RangeRings::has_ring_line_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ring_line_color_ != nullptr);
  return value;
}
inline const ::anduril::type::Color& RangeRings::_internal_ring_line_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::type::Color* p = _impl_.ring_line_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::type::Color&>(::anduril::type::_Color_default_instance_);
}
inline const ::anduril::type::Color& RangeRings::ring_line_color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RangeRings.ring_line_color)
  return _internal_ring_line_color();
}
inline void RangeRings::unsafe_arena_set_allocated_ring_line_color(::anduril::type::Color* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ring_line_color_);
  }
  _impl_.ring_line_color_ = reinterpret_cast<::anduril::type::Color*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RangeRings.ring_line_color)
}
inline ::anduril::type::Color* RangeRings::release_ring_line_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::type::Color* released = _impl_.ring_line_color_;
  _impl_.ring_line_color_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::type::Color* RangeRings::unsafe_arena_release_ring_line_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RangeRings.ring_line_color)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::type::Color* temp = _impl_.ring_line_color_;
  _impl_.ring_line_color_ = nullptr;
  return temp;
}
inline ::anduril::type::Color* RangeRings::_internal_mutable_ring_line_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ring_line_color_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::type::Color>(GetArena());
    _impl_.ring_line_color_ = reinterpret_cast<::anduril::type::Color*>(p);
  }
  return _impl_.ring_line_color_;
}
inline ::anduril::type::Color* RangeRings::mutable_ring_line_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::anduril::type::Color* _msg = _internal_mutable_ring_line_color();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RangeRings.ring_line_color)
  return _msg;
}
inline void RangeRings::set_allocated_ring_line_color(::anduril::type::Color* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ring_line_color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ring_line_color_ = reinterpret_cast<::anduril::type::Color*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.RangeRings.ring_line_color)
}

// -------------------------------------------------------------------

// Correlation

// .anduril.entitymanager.v1.PrimaryCorrelation primary = 1 [json_name = "primary"];
inline bool Correlation::has_primary() const {
  return correlation_case() == kPrimary;
}
inline bool Correlation::_internal_has_primary() const {
  return correlation_case() == kPrimary;
}
inline void Correlation::set_has_primary() {
  _impl_._oneof_case_[0] = kPrimary;
}
inline void Correlation::clear_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (correlation_case() == kPrimary) {
    if (GetArena() == nullptr) {
      delete _impl_.correlation_.primary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.correlation_.primary_);
    }
    clear_has_correlation();
  }
}
inline ::anduril::entitymanager::v1::PrimaryCorrelation* Correlation::release_primary() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Correlation.primary)
  if (correlation_case() == kPrimary) {
    clear_has_correlation();
    auto* temp = _impl_.correlation_.primary_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.correlation_.primary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::PrimaryCorrelation& Correlation::_internal_primary() const {
  return correlation_case() == kPrimary ? *_impl_.correlation_.primary_ : reinterpret_cast<::anduril::entitymanager::v1::PrimaryCorrelation&>(::anduril::entitymanager::v1::_PrimaryCorrelation_default_instance_);
}
inline const ::anduril::entitymanager::v1::PrimaryCorrelation& Correlation::primary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Correlation.primary)
  return _internal_primary();
}
inline ::anduril::entitymanager::v1::PrimaryCorrelation* Correlation::unsafe_arena_release_primary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Correlation.primary)
  if (correlation_case() == kPrimary) {
    clear_has_correlation();
    auto* temp = _impl_.correlation_.primary_;
    _impl_.correlation_.primary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Correlation::unsafe_arena_set_allocated_primary(::anduril::entitymanager::v1::PrimaryCorrelation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_correlation();
  if (value) {
    set_has_primary();
    _impl_.correlation_.primary_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Correlation.primary)
}
inline ::anduril::entitymanager::v1::PrimaryCorrelation* Correlation::_internal_mutable_primary() {
  if (correlation_case() != kPrimary) {
    clear_correlation();
    set_has_primary();
    _impl_.correlation_.primary_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::PrimaryCorrelation>(GetArena());
  }
  return _impl_.correlation_.primary_;
}
inline ::anduril::entitymanager::v1::PrimaryCorrelation* Correlation::mutable_primary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::PrimaryCorrelation* _msg = _internal_mutable_primary();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Correlation.primary)
  return _msg;
}

// .anduril.entitymanager.v1.SecondaryCorrelation secondary = 2 [json_name = "secondary"];
inline bool Correlation::has_secondary() const {
  return correlation_case() == kSecondary;
}
inline bool Correlation::_internal_has_secondary() const {
  return correlation_case() == kSecondary;
}
inline void Correlation::set_has_secondary() {
  _impl_._oneof_case_[0] = kSecondary;
}
inline void Correlation::clear_secondary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (correlation_case() == kSecondary) {
    if (GetArena() == nullptr) {
      delete _impl_.correlation_.secondary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.correlation_.secondary_);
    }
    clear_has_correlation();
  }
}
inline ::anduril::entitymanager::v1::SecondaryCorrelation* Correlation::release_secondary() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Correlation.secondary)
  if (correlation_case() == kSecondary) {
    clear_has_correlation();
    auto* temp = _impl_.correlation_.secondary_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.correlation_.secondary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::SecondaryCorrelation& Correlation::_internal_secondary() const {
  return correlation_case() == kSecondary ? *_impl_.correlation_.secondary_ : reinterpret_cast<::anduril::entitymanager::v1::SecondaryCorrelation&>(::anduril::entitymanager::v1::_SecondaryCorrelation_default_instance_);
}
inline const ::anduril::entitymanager::v1::SecondaryCorrelation& Correlation::secondary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Correlation.secondary)
  return _internal_secondary();
}
inline ::anduril::entitymanager::v1::SecondaryCorrelation* Correlation::unsafe_arena_release_secondary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.Correlation.secondary)
  if (correlation_case() == kSecondary) {
    clear_has_correlation();
    auto* temp = _impl_.correlation_.secondary_;
    _impl_.correlation_.secondary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Correlation::unsafe_arena_set_allocated_secondary(::anduril::entitymanager::v1::SecondaryCorrelation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_correlation();
  if (value) {
    set_has_secondary();
    _impl_.correlation_.secondary_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Correlation.secondary)
}
inline ::anduril::entitymanager::v1::SecondaryCorrelation* Correlation::_internal_mutable_secondary() {
  if (correlation_case() != kSecondary) {
    clear_correlation();
    set_has_secondary();
    _impl_.correlation_.secondary_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::SecondaryCorrelation>(GetArena());
  }
  return _impl_.correlation_.secondary_;
}
inline ::anduril::entitymanager::v1::SecondaryCorrelation* Correlation::mutable_secondary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::SecondaryCorrelation* _msg = _internal_mutable_secondary();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Correlation.secondary)
  return _msg;
}

// .anduril.entitymanager.v1.CorrelationMembership membership = 4 [json_name = "membership"];
inline bool Correlation::has_membership() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.membership_ != nullptr);
  return value;
}
inline void Correlation::clear_membership() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.membership_ != nullptr) _impl_.membership_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::entitymanager::v1::CorrelationMembership& Correlation::_internal_membership() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::CorrelationMembership* p = _impl_.membership_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::CorrelationMembership&>(::anduril::entitymanager::v1::_CorrelationMembership_default_instance_);
}
inline const ::anduril::entitymanager::v1::CorrelationMembership& Correlation::membership() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Correlation.membership)
  return _internal_membership();
}
inline void Correlation::unsafe_arena_set_allocated_membership(::anduril::entitymanager::v1::CorrelationMembership* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.membership_);
  }
  _impl_.membership_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMembership*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Correlation.membership)
}
inline ::anduril::entitymanager::v1::CorrelationMembership* Correlation::release_membership() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entitymanager::v1::CorrelationMembership* released = _impl_.membership_;
  _impl_.membership_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::CorrelationMembership* Correlation::unsafe_arena_release_membership() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Correlation.membership)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entitymanager::v1::CorrelationMembership* temp = _impl_.membership_;
  _impl_.membership_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::CorrelationMembership* Correlation::_internal_mutable_membership() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.membership_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::CorrelationMembership>(GetArena());
    _impl_.membership_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMembership*>(p);
  }
  return _impl_.membership_;
}
inline ::anduril::entitymanager::v1::CorrelationMembership* Correlation::mutable_membership() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::entitymanager::v1::CorrelationMembership* _msg = _internal_mutable_membership();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Correlation.membership)
  return _msg;
}
inline void Correlation::set_allocated_membership(::anduril::entitymanager::v1::CorrelationMembership* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.membership_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.membership_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMembership*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Correlation.membership)
}

// .anduril.entitymanager.v1.Decorrelation decorrelation = 3 [json_name = "decorrelation"];
inline bool Correlation::has_decorrelation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.decorrelation_ != nullptr);
  return value;
}
inline void Correlation::clear_decorrelation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.decorrelation_ != nullptr) _impl_.decorrelation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::Decorrelation& Correlation::_internal_decorrelation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Decorrelation* p = _impl_.decorrelation_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Decorrelation&>(::anduril::entitymanager::v1::_Decorrelation_default_instance_);
}
inline const ::anduril::entitymanager::v1::Decorrelation& Correlation::decorrelation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Correlation.decorrelation)
  return _internal_decorrelation();
}
inline void Correlation::unsafe_arena_set_allocated_decorrelation(::anduril::entitymanager::v1::Decorrelation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.decorrelation_);
  }
  _impl_.decorrelation_ = reinterpret_cast<::anduril::entitymanager::v1::Decorrelation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Correlation.decorrelation)
}
inline ::anduril::entitymanager::v1::Decorrelation* Correlation::release_decorrelation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Decorrelation* released = _impl_.decorrelation_;
  _impl_.decorrelation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Decorrelation* Correlation::unsafe_arena_release_decorrelation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Correlation.decorrelation)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Decorrelation* temp = _impl_.decorrelation_;
  _impl_.decorrelation_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Decorrelation* Correlation::_internal_mutable_decorrelation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.decorrelation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Decorrelation>(GetArena());
    _impl_.decorrelation_ = reinterpret_cast<::anduril::entitymanager::v1::Decorrelation*>(p);
  }
  return _impl_.decorrelation_;
}
inline ::anduril::entitymanager::v1::Decorrelation* Correlation::mutable_decorrelation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Decorrelation* _msg = _internal_mutable_decorrelation();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Correlation.decorrelation)
  return _msg;
}
inline void Correlation::set_allocated_decorrelation(::anduril::entitymanager::v1::Decorrelation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.decorrelation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.decorrelation_ = reinterpret_cast<::anduril::entitymanager::v1::Decorrelation*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Correlation.decorrelation)
}

inline bool Correlation::has_correlation() const {
  return correlation_case() != CORRELATION_NOT_SET;
}
inline void Correlation::clear_has_correlation() {
  _impl_._oneof_case_[0] = CORRELATION_NOT_SET;
}
inline Correlation::CorrelationCase Correlation::correlation_case() const {
  return Correlation::CorrelationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PrimaryCorrelation

// repeated string secondary_entity_ids = 1 [json_name = "secondaryEntityIds"];
inline int PrimaryCorrelation::_internal_secondary_entity_ids_size() const {
  return _internal_secondary_entity_ids().size();
}
inline int PrimaryCorrelation::secondary_entity_ids_size() const {
  return _internal_secondary_entity_ids_size();
}
inline void PrimaryCorrelation::clear_secondary_entity_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_entity_ids_.Clear();
}
inline std::string* PrimaryCorrelation::add_secondary_entity_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_secondary_entity_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:anduril.entitymanager.v1.PrimaryCorrelation.secondary_entity_ids)
  return _s;
}
inline const std::string& PrimaryCorrelation::secondary_entity_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.PrimaryCorrelation.secondary_entity_ids)
  return _internal_secondary_entity_ids().Get(index);
}
inline std::string* PrimaryCorrelation::mutable_secondary_entity_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.PrimaryCorrelation.secondary_entity_ids)
  return _internal_mutable_secondary_entity_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void PrimaryCorrelation::set_secondary_entity_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_secondary_entity_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.PrimaryCorrelation.secondary_entity_ids)
}
template <typename Arg_, typename... Args_>
inline void PrimaryCorrelation::add_secondary_entity_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_secondary_entity_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.PrimaryCorrelation.secondary_entity_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PrimaryCorrelation::secondary_entity_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.PrimaryCorrelation.secondary_entity_ids)
  return _internal_secondary_entity_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PrimaryCorrelation::mutable_secondary_entity_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.PrimaryCorrelation.secondary_entity_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_secondary_entity_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PrimaryCorrelation::_internal_secondary_entity_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secondary_entity_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PrimaryCorrelation::_internal_mutable_secondary_entity_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.secondary_entity_ids_;
}

// -------------------------------------------------------------------

// SecondaryCorrelation

// string primary_entity_id = 1 [json_name = "primaryEntityId"];
inline void SecondaryCorrelation::clear_primary_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_entity_id_.ClearToEmpty();
}
inline const std::string& SecondaryCorrelation::primary_entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.SecondaryCorrelation.primary_entity_id)
  return _internal_primary_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SecondaryCorrelation::set_primary_entity_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.SecondaryCorrelation.primary_entity_id)
}
inline std::string* SecondaryCorrelation::mutable_primary_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_primary_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.SecondaryCorrelation.primary_entity_id)
  return _s;
}
inline const std::string& SecondaryCorrelation::_internal_primary_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.primary_entity_id_.Get();
}
inline void SecondaryCorrelation::_internal_set_primary_entity_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_entity_id_.Set(value, GetArena());
}
inline std::string* SecondaryCorrelation::_internal_mutable_primary_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.primary_entity_id_.Mutable( GetArena());
}
inline std::string* SecondaryCorrelation::release_primary_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.SecondaryCorrelation.primary_entity_id)
  return _impl_.primary_entity_id_.Release();
}
inline void SecondaryCorrelation::set_allocated_primary_entity_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.primary_entity_id_.IsDefault()) {
    _impl_.primary_entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.SecondaryCorrelation.primary_entity_id)
}

// .anduril.entitymanager.v1.CorrelationMetadata metadata = 2 [json_name = "metadata"];
inline bool SecondaryCorrelation::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline void SecondaryCorrelation::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::CorrelationMetadata& SecondaryCorrelation::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::CorrelationMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::CorrelationMetadata&>(::anduril::entitymanager::v1::_CorrelationMetadata_default_instance_);
}
inline const ::anduril::entitymanager::v1::CorrelationMetadata& SecondaryCorrelation::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.SecondaryCorrelation.metadata)
  return _internal_metadata();
}
inline void SecondaryCorrelation::unsafe_arena_set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.SecondaryCorrelation.metadata)
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* SecondaryCorrelation::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* SecondaryCorrelation::unsafe_arena_release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.SecondaryCorrelation.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* SecondaryCorrelation::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::CorrelationMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* SecondaryCorrelation::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.SecondaryCorrelation.metadata)
  return _msg;
}
inline void SecondaryCorrelation::set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.SecondaryCorrelation.metadata)
}

// -------------------------------------------------------------------

// CorrelationMembership

// string correlation_set_id = 1 [json_name = "correlationSetId"];
inline void CorrelationMembership::clear_correlation_set_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.correlation_set_id_.ClearToEmpty();
}
inline const std::string& CorrelationMembership::correlation_set_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.CorrelationMembership.correlation_set_id)
  return _internal_correlation_set_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CorrelationMembership::set_correlation_set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.correlation_set_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.CorrelationMembership.correlation_set_id)
}
inline std::string* CorrelationMembership::mutable_correlation_set_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_correlation_set_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.CorrelationMembership.correlation_set_id)
  return _s;
}
inline const std::string& CorrelationMembership::_internal_correlation_set_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.correlation_set_id_.Get();
}
inline void CorrelationMembership::_internal_set_correlation_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.correlation_set_id_.Set(value, GetArena());
}
inline std::string* CorrelationMembership::_internal_mutable_correlation_set_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.correlation_set_id_.Mutable( GetArena());
}
inline std::string* CorrelationMembership::release_correlation_set_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.CorrelationMembership.correlation_set_id)
  return _impl_.correlation_set_id_.Release();
}
inline void CorrelationMembership::set_allocated_correlation_set_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.correlation_set_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.correlation_set_id_.IsDefault()) {
    _impl_.correlation_set_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.CorrelationMembership.correlation_set_id)
}

// .anduril.entitymanager.v1.PrimaryMembership primary = 2 [json_name = "primary"];
inline bool CorrelationMembership::has_primary() const {
  return membership_case() == kPrimary;
}
inline bool CorrelationMembership::_internal_has_primary() const {
  return membership_case() == kPrimary;
}
inline void CorrelationMembership::set_has_primary() {
  _impl_._oneof_case_[0] = kPrimary;
}
inline void CorrelationMembership::clear_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (membership_case() == kPrimary) {
    if (GetArena() == nullptr) {
      delete _impl_.membership_.primary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.membership_.primary_);
    }
    clear_has_membership();
  }
}
inline ::anduril::entitymanager::v1::PrimaryMembership* CorrelationMembership::release_primary() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.CorrelationMembership.primary)
  if (membership_case() == kPrimary) {
    clear_has_membership();
    auto* temp = _impl_.membership_.primary_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.membership_.primary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::PrimaryMembership& CorrelationMembership::_internal_primary() const {
  return membership_case() == kPrimary ? *_impl_.membership_.primary_ : reinterpret_cast<::anduril::entitymanager::v1::PrimaryMembership&>(::anduril::entitymanager::v1::_PrimaryMembership_default_instance_);
}
inline const ::anduril::entitymanager::v1::PrimaryMembership& CorrelationMembership::primary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.CorrelationMembership.primary)
  return _internal_primary();
}
inline ::anduril::entitymanager::v1::PrimaryMembership* CorrelationMembership::unsafe_arena_release_primary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.CorrelationMembership.primary)
  if (membership_case() == kPrimary) {
    clear_has_membership();
    auto* temp = _impl_.membership_.primary_;
    _impl_.membership_.primary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CorrelationMembership::unsafe_arena_set_allocated_primary(::anduril::entitymanager::v1::PrimaryMembership* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_membership();
  if (value) {
    set_has_primary();
    _impl_.membership_.primary_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.CorrelationMembership.primary)
}
inline ::anduril::entitymanager::v1::PrimaryMembership* CorrelationMembership::_internal_mutable_primary() {
  if (membership_case() != kPrimary) {
    clear_membership();
    set_has_primary();
    _impl_.membership_.primary_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::PrimaryMembership>(GetArena());
  }
  return _impl_.membership_.primary_;
}
inline ::anduril::entitymanager::v1::PrimaryMembership* CorrelationMembership::mutable_primary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::PrimaryMembership* _msg = _internal_mutable_primary();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.CorrelationMembership.primary)
  return _msg;
}

// .anduril.entitymanager.v1.NonPrimaryMembership non_primary = 3 [json_name = "nonPrimary"];
inline bool CorrelationMembership::has_non_primary() const {
  return membership_case() == kNonPrimary;
}
inline bool CorrelationMembership::_internal_has_non_primary() const {
  return membership_case() == kNonPrimary;
}
inline void CorrelationMembership::set_has_non_primary() {
  _impl_._oneof_case_[0] = kNonPrimary;
}
inline void CorrelationMembership::clear_non_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (membership_case() == kNonPrimary) {
    if (GetArena() == nullptr) {
      delete _impl_.membership_.non_primary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.membership_.non_primary_);
    }
    clear_has_membership();
  }
}
inline ::anduril::entitymanager::v1::NonPrimaryMembership* CorrelationMembership::release_non_primary() {
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.CorrelationMembership.non_primary)
  if (membership_case() == kNonPrimary) {
    clear_has_membership();
    auto* temp = _impl_.membership_.non_primary_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.membership_.non_primary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entitymanager::v1::NonPrimaryMembership& CorrelationMembership::_internal_non_primary() const {
  return membership_case() == kNonPrimary ? *_impl_.membership_.non_primary_ : reinterpret_cast<::anduril::entitymanager::v1::NonPrimaryMembership&>(::anduril::entitymanager::v1::_NonPrimaryMembership_default_instance_);
}
inline const ::anduril::entitymanager::v1::NonPrimaryMembership& CorrelationMembership::non_primary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.CorrelationMembership.non_primary)
  return _internal_non_primary();
}
inline ::anduril::entitymanager::v1::NonPrimaryMembership* CorrelationMembership::unsafe_arena_release_non_primary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entitymanager.v1.CorrelationMembership.non_primary)
  if (membership_case() == kNonPrimary) {
    clear_has_membership();
    auto* temp = _impl_.membership_.non_primary_;
    _impl_.membership_.non_primary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CorrelationMembership::unsafe_arena_set_allocated_non_primary(::anduril::entitymanager::v1::NonPrimaryMembership* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_membership();
  if (value) {
    set_has_non_primary();
    _impl_.membership_.non_primary_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.CorrelationMembership.non_primary)
}
inline ::anduril::entitymanager::v1::NonPrimaryMembership* CorrelationMembership::_internal_mutable_non_primary() {
  if (membership_case() != kNonPrimary) {
    clear_membership();
    set_has_non_primary();
    _impl_.membership_.non_primary_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::NonPrimaryMembership>(GetArena());
  }
  return _impl_.membership_.non_primary_;
}
inline ::anduril::entitymanager::v1::NonPrimaryMembership* CorrelationMembership::mutable_non_primary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::NonPrimaryMembership* _msg = _internal_mutable_non_primary();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.CorrelationMembership.non_primary)
  return _msg;
}

// .anduril.entitymanager.v1.CorrelationMetadata metadata = 4 [json_name = "metadata"];
inline bool CorrelationMembership::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline void CorrelationMembership::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::CorrelationMetadata& CorrelationMembership::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::CorrelationMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::CorrelationMetadata&>(::anduril::entitymanager::v1::_CorrelationMetadata_default_instance_);
}
inline const ::anduril::entitymanager::v1::CorrelationMetadata& CorrelationMembership::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.CorrelationMembership.metadata)
  return _internal_metadata();
}
inline void CorrelationMembership::unsafe_arena_set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.CorrelationMembership.metadata)
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* CorrelationMembership::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* CorrelationMembership::unsafe_arena_release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.CorrelationMembership.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* CorrelationMembership::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::CorrelationMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* CorrelationMembership::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.CorrelationMembership.metadata)
  return _msg;
}
inline void CorrelationMembership::set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.CorrelationMembership.metadata)
}

inline bool CorrelationMembership::has_membership() const {
  return membership_case() != MEMBERSHIP_NOT_SET;
}
inline void CorrelationMembership::clear_has_membership() {
  _impl_._oneof_case_[0] = MEMBERSHIP_NOT_SET;
}
inline CorrelationMembership::MembershipCase CorrelationMembership::membership_case() const {
  return CorrelationMembership::MembershipCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PrimaryMembership

// -------------------------------------------------------------------

// NonPrimaryMembership

// -------------------------------------------------------------------

// Decorrelation

// .anduril.entitymanager.v1.DecorrelatedAll all = 1 [json_name = "all"];
inline bool Decorrelation::has_all() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.all_ != nullptr);
  return value;
}
inline void Decorrelation::clear_all() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.all_ != nullptr) _impl_.all_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::DecorrelatedAll& Decorrelation::_internal_all() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::DecorrelatedAll* p = _impl_.all_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::DecorrelatedAll&>(::anduril::entitymanager::v1::_DecorrelatedAll_default_instance_);
}
inline const ::anduril::entitymanager::v1::DecorrelatedAll& Decorrelation::all() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Decorrelation.all)
  return _internal_all();
}
inline void Decorrelation::unsafe_arena_set_allocated_all(::anduril::entitymanager::v1::DecorrelatedAll* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.all_);
  }
  _impl_.all_ = reinterpret_cast<::anduril::entitymanager::v1::DecorrelatedAll*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Decorrelation.all)
}
inline ::anduril::entitymanager::v1::DecorrelatedAll* Decorrelation::release_all() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::DecorrelatedAll* released = _impl_.all_;
  _impl_.all_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::DecorrelatedAll* Decorrelation::unsafe_arena_release_all() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Decorrelation.all)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::DecorrelatedAll* temp = _impl_.all_;
  _impl_.all_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::DecorrelatedAll* Decorrelation::_internal_mutable_all() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.all_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::DecorrelatedAll>(GetArena());
    _impl_.all_ = reinterpret_cast<::anduril::entitymanager::v1::DecorrelatedAll*>(p);
  }
  return _impl_.all_;
}
inline ::anduril::entitymanager::v1::DecorrelatedAll* Decorrelation::mutable_all() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::DecorrelatedAll* _msg = _internal_mutable_all();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Decorrelation.all)
  return _msg;
}
inline void Decorrelation::set_allocated_all(::anduril::entitymanager::v1::DecorrelatedAll* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.all_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.all_ = reinterpret_cast<::anduril::entitymanager::v1::DecorrelatedAll*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Decorrelation.all)
}

// repeated .anduril.entitymanager.v1.DecorrelatedSingle decorrelated_entities = 2 [json_name = "decorrelatedEntities"];
inline int Decorrelation::_internal_decorrelated_entities_size() const {
  return _internal_decorrelated_entities().size();
}
inline int Decorrelation::decorrelated_entities_size() const {
  return _internal_decorrelated_entities_size();
}
inline void Decorrelation::clear_decorrelated_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.decorrelated_entities_.Clear();
}
inline ::anduril::entitymanager::v1::DecorrelatedSingle* Decorrelation::mutable_decorrelated_entities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Decorrelation.decorrelated_entities)
  return _internal_mutable_decorrelated_entities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::DecorrelatedSingle>* Decorrelation::mutable_decorrelated_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.Decorrelation.decorrelated_entities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_decorrelated_entities();
}
inline const ::anduril::entitymanager::v1::DecorrelatedSingle& Decorrelation::decorrelated_entities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Decorrelation.decorrelated_entities)
  return _internal_decorrelated_entities().Get(index);
}
inline ::anduril::entitymanager::v1::DecorrelatedSingle* Decorrelation::add_decorrelated_entities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::entitymanager::v1::DecorrelatedSingle* _add = _internal_mutable_decorrelated_entities()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.Decorrelation.decorrelated_entities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::DecorrelatedSingle>& Decorrelation::decorrelated_entities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.Decorrelation.decorrelated_entities)
  return _internal_decorrelated_entities();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::DecorrelatedSingle>&
Decorrelation::_internal_decorrelated_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.decorrelated_entities_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::DecorrelatedSingle>*
Decorrelation::_internal_mutable_decorrelated_entities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.decorrelated_entities_;
}

// -------------------------------------------------------------------

// DecorrelatedAll

// .anduril.entitymanager.v1.CorrelationMetadata metadata = 1 [json_name = "metadata"];
inline bool DecorrelatedAll::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline void DecorrelatedAll::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::CorrelationMetadata& DecorrelatedAll::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::CorrelationMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::CorrelationMetadata&>(::anduril::entitymanager::v1::_CorrelationMetadata_default_instance_);
}
inline const ::anduril::entitymanager::v1::CorrelationMetadata& DecorrelatedAll::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.DecorrelatedAll.metadata)
  return _internal_metadata();
}
inline void DecorrelatedAll::unsafe_arena_set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.DecorrelatedAll.metadata)
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* DecorrelatedAll::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* DecorrelatedAll::unsafe_arena_release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.DecorrelatedAll.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* DecorrelatedAll::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::CorrelationMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* DecorrelatedAll::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.DecorrelatedAll.metadata)
  return _msg;
}
inline void DecorrelatedAll::set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.DecorrelatedAll.metadata)
}

// -------------------------------------------------------------------

// DecorrelatedSingle

// string entity_id = 1 [json_name = "entityId"];
inline void DecorrelatedSingle::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& DecorrelatedSingle::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.DecorrelatedSingle.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DecorrelatedSingle::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.DecorrelatedSingle.entity_id)
}
inline std::string* DecorrelatedSingle::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.DecorrelatedSingle.entity_id)
  return _s;
}
inline const std::string& DecorrelatedSingle::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void DecorrelatedSingle::_internal_set_entity_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* DecorrelatedSingle::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* DecorrelatedSingle::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.DecorrelatedSingle.entity_id)
  return _impl_.entity_id_.Release();
}
inline void DecorrelatedSingle::set_allocated_entity_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.DecorrelatedSingle.entity_id)
}

// .anduril.entitymanager.v1.CorrelationMetadata metadata = 2 [json_name = "metadata"];
inline bool DecorrelatedSingle::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline void DecorrelatedSingle::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::CorrelationMetadata& DecorrelatedSingle::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::CorrelationMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::CorrelationMetadata&>(::anduril::entitymanager::v1::_CorrelationMetadata_default_instance_);
}
inline const ::anduril::entitymanager::v1::CorrelationMetadata& DecorrelatedSingle::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.DecorrelatedSingle.metadata)
  return _internal_metadata();
}
inline void DecorrelatedSingle::unsafe_arena_set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.DecorrelatedSingle.metadata)
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* DecorrelatedSingle::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* DecorrelatedSingle::unsafe_arena_release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.DecorrelatedSingle.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* DecorrelatedSingle::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::CorrelationMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::anduril::entitymanager::v1::CorrelationMetadata* DecorrelatedSingle::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::CorrelationMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.DecorrelatedSingle.metadata)
  return _msg;
}
inline void DecorrelatedSingle::set_allocated_metadata(::anduril::entitymanager::v1::CorrelationMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::anduril::entitymanager::v1::CorrelationMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.DecorrelatedSingle.metadata)
}

// -------------------------------------------------------------------

// CorrelationMetadata

// .anduril.entitymanager.v1.Provenance provenance = 1 [json_name = "provenance"];
inline bool CorrelationMetadata::has_provenance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.provenance_ != nullptr);
  return value;
}
inline void CorrelationMetadata::clear_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.provenance_ != nullptr) _impl_.provenance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::Provenance& CorrelationMetadata::_internal_provenance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Provenance* p = _impl_.provenance_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Provenance&>(::anduril::entitymanager::v1::_Provenance_default_instance_);
}
inline const ::anduril::entitymanager::v1::Provenance& CorrelationMetadata::provenance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.CorrelationMetadata.provenance)
  return _internal_provenance();
}
inline void CorrelationMetadata::unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.provenance_);
  }
  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.CorrelationMetadata.provenance)
}
inline ::anduril::entitymanager::v1::Provenance* CorrelationMetadata::release_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Provenance* released = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Provenance* CorrelationMetadata::unsafe_arena_release_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.CorrelationMetadata.provenance)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Provenance* temp = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Provenance* CorrelationMetadata::_internal_mutable_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.provenance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Provenance>(GetArena());
    _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(p);
  }
  return _impl_.provenance_;
}
inline ::anduril::entitymanager::v1::Provenance* CorrelationMetadata::mutable_provenance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Provenance* _msg = _internal_mutable_provenance();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.CorrelationMetadata.provenance)
  return _msg;
}
inline void CorrelationMetadata::set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.provenance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.CorrelationMetadata.provenance)
}

// .anduril.entitymanager.v1.CorrelationReplicationMode replication_mode = 2 [json_name = "replicationMode"];
inline void CorrelationMetadata::clear_replication_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_mode_ = 0;
}
inline ::anduril::entitymanager::v1::CorrelationReplicationMode CorrelationMetadata::replication_mode() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.CorrelationMetadata.replication_mode)
  return _internal_replication_mode();
}
inline void CorrelationMetadata::set_replication_mode(::anduril::entitymanager::v1::CorrelationReplicationMode value) {
  _internal_set_replication_mode(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.CorrelationMetadata.replication_mode)
}
inline ::anduril::entitymanager::v1::CorrelationReplicationMode CorrelationMetadata::_internal_replication_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::CorrelationReplicationMode>(_impl_.replication_mode_);
}
inline void CorrelationMetadata::_internal_set_replication_mode(::anduril::entitymanager::v1::CorrelationReplicationMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_mode_ = value;
}

// .anduril.entitymanager.v1.CorrelationType type = 3 [json_name = "type"];
inline void CorrelationMetadata::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::anduril::entitymanager::v1::CorrelationType CorrelationMetadata::type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.CorrelationMetadata.type)
  return _internal_type();
}
inline void CorrelationMetadata::set_type(::anduril::entitymanager::v1::CorrelationType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.CorrelationMetadata.type)
}
inline ::anduril::entitymanager::v1::CorrelationType CorrelationMetadata::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::entitymanager::v1::CorrelationType>(_impl_.type_);
}
inline void CorrelationMetadata::_internal_set_type(::anduril::entitymanager::v1::CorrelationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::anduril::entitymanager::v1::CorrelationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::CorrelationType>() {
  return ::anduril::entitymanager::v1::CorrelationType_descriptor();
}
template <>
struct is_proto_enum<::anduril::entitymanager::v1::CorrelationReplicationMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::CorrelationReplicationMode>() {
  return ::anduril::entitymanager::v1::CorrelationReplicationMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto_2epb_2eh
