// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: anduril/entitymanager/v1/entity.pub.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "anduril/entitymanager/v1/classification.pub.pb.h"
#include "anduril/entitymanager/v1/contact_details.pub.pb.h"
#include "anduril/entitymanager/v1/correlations.pub.pb.h"
#include "anduril/entitymanager/v1/dimensions.pub.pb.h"
#include "anduril/entitymanager/v1/geoentity.pub.pb.h"
#include "anduril/entitymanager/v1/group.pub.pb.h"
#include "anduril/entitymanager/v1/health_status.pub.pb.h"
#include "anduril/entitymanager/v1/location.pub.pb.h"
#include "anduril/entitymanager/v1/media.pub.pb.h"
#include "anduril/entitymanager/v1/ontology.pub.pb.h"
#include "anduril/entitymanager/v1/options.pub.pb.h"
#include "anduril/entitymanager/v1/payloads.pub.pb.h"
#include "anduril/entitymanager/v1/power.pub.pb.h"
#include "anduril/entitymanager/v1/prototype.pub.pb.h"
#include "anduril/entitymanager/v1/relationship.pub.pb.h"
#include "anduril/entitymanager/v1/route_details.pub.pb.h"
#include "anduril/entitymanager/v1/schedule.pub.pb.h"
#include "anduril/entitymanager/v1/sensors.pub.pb.h"
#include "anduril/entitymanager/v1/signal.pub.pb.h"
#include "anduril/entitymanager/v1/supplies.pub.pb.h"
#include "anduril/entitymanager/v1/target_priority.pub.pb.h"
#include "anduril/entitymanager/v1/transponder_codes.pub.pb.h"
#include "anduril/entitymanager/v1/types.pub.pb.h"
#include "anduril/tasks/v2/catalog.pub.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
namespace anduril {
namespace entitymanager {
namespace v1 {
class Aliases;
struct AliasesDefaultTypeInternal;
extern AliasesDefaultTypeInternal _Aliases_default_instance_;
class AlternateId;
struct AlternateIdDefaultTypeInternal;
extern AlternateIdDefaultTypeInternal _AlternateId_default_instance_;
class Entities;
struct EntitiesDefaultTypeInternal;
extern EntitiesDefaultTypeInternal _Entities_default_instance_;
class Entity;
struct EntityDefaultTypeInternal;
extern EntityDefaultTypeInternal _Entity_default_instance_;
class Indicators;
struct IndicatorsDefaultTypeInternal;
extern IndicatorsDefaultTypeInternal _Indicators_default_instance_;
class OriginalData;
struct OriginalDataDefaultTypeInternal;
extern OriginalDataDefaultTypeInternal _OriginalData_default_instance_;
class OriginalData_TLE;
struct OriginalData_TLEDefaultTypeInternal;
extern OriginalData_TLEDefaultTypeInternal _OriginalData_TLE_default_instance_;
class Override;
struct OverrideDefaultTypeInternal;
extern OverrideDefaultTypeInternal _Override_default_instance_;
class OverrideProvenance;
struct OverrideProvenanceDefaultTypeInternal;
extern OverrideProvenanceDefaultTypeInternal _OverrideProvenance_default_instance_;
class Overrides;
struct OverridesDefaultTypeInternal;
extern OverridesDefaultTypeInternal _Overrides_default_instance_;
class Provenance;
struct ProvenanceDefaultTypeInternal;
extern ProvenanceDefaultTypeInternal _Provenance_default_instance_;
class RangeRings;
struct RangeRingsDefaultTypeInternal;
extern RangeRingsDefaultTypeInternal _RangeRings_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class TeamStatus;
struct TeamStatusDefaultTypeInternal;
extern TeamStatusDefaultTypeInternal _TeamStatus_default_instance_;
class Tracked;
struct TrackedDefaultTypeInternal;
extern TrackedDefaultTypeInternal _Tracked_default_instance_;
class VisualDetails;
struct VisualDetailsDefaultTypeInternal;
extern VisualDetailsDefaultTypeInternal _VisualDetails_default_instance_;
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace entitymanager {
namespace v1 {
enum Deletable : int {
  DELETABLE_INVALID = 0,
  DELETABLE_TRUE = 1,
  DELETABLE_FALSE = 2,
  DELETABLE_REQUEST = 3,
  Deletable_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Deletable_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Deletable_IsValid(int value);
extern const uint32_t Deletable_internal_data_[];
constexpr Deletable Deletable_MIN = static_cast<Deletable>(0);
constexpr Deletable Deletable_MAX = static_cast<Deletable>(3);
constexpr int Deletable_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Deletable_descriptor();
template <typename T>
const std::string& Deletable_Name(T value) {
  static_assert(std::is_same<T, Deletable>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Deletable_Name().");
  return Deletable_Name(static_cast<Deletable>(value));
}
template <>
inline const std::string& Deletable_Name(Deletable value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Deletable_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Deletable_Parse(absl::string_view name, Deletable* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Deletable>(
      Deletable_descriptor(), name, value);
}
enum InteractivityMode : int {
  INTERACTIVITY_MODE_INVALID = 0,
  INTERACTIVITY_MODE_DEFAULT = 1,
  INTERACTIVITY_MODE_DISABLED_ON_MAP = 2,
  InteractivityMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  InteractivityMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool InteractivityMode_IsValid(int value);
extern const uint32_t InteractivityMode_internal_data_[];
constexpr InteractivityMode InteractivityMode_MIN = static_cast<InteractivityMode>(0);
constexpr InteractivityMode InteractivityMode_MAX = static_cast<InteractivityMode>(2);
constexpr int InteractivityMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
InteractivityMode_descriptor();
template <typename T>
const std::string& InteractivityMode_Name(T value) {
  static_assert(std::is_same<T, InteractivityMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InteractivityMode_Name().");
  return InteractivityMode_Name(static_cast<InteractivityMode>(value));
}
template <>
inline const std::string& InteractivityMode_Name(InteractivityMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InteractivityMode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool InteractivityMode_Parse(absl::string_view name, InteractivityMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InteractivityMode>(
      InteractivityMode_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TeamStatus final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.TeamStatus) */ {
 public:
  inline TeamStatus() : TeamStatus(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TeamStatus(::google::protobuf::internal::ConstantInitialized);

  inline TeamStatus(const TeamStatus& from)
      : TeamStatus(nullptr, from) {}
  TeamStatus(TeamStatus&& from) noexcept
    : TeamStatus() {
    *this = ::std::move(from);
  }

  inline TeamStatus& operator=(const TeamStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeamStatus& operator=(TeamStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeamStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeamStatus* internal_default_instance() {
    return reinterpret_cast<const TeamStatus*>(
               &_TeamStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TeamStatus& a, TeamStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TeamStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeamStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TeamStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TeamStatus>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TeamStatus& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TeamStatus& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.TeamStatus";
  }
  protected:
  explicit TeamStatus(::google::protobuf::Arena* arena);
  TeamStatus(::google::protobuf::Arena* arena, const TeamStatus& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.TeamStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class Status final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Status(::google::protobuf::internal::ConstantInitialized);

  inline Status(const Status& from)
      : Status(nullptr, from) {}
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Status* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.Status";
  }
  protected:
  explicit Status(::google::protobuf::Arena* arena);
  Status(::google::protobuf::Arena* arena, const Status& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformActivityFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // string platform_activity = 1 [json_name = "platformActivity"];
  void clear_platform_activity() ;
  const std::string& platform_activity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform_activity(Arg_&& arg, Args_... args);
  std::string* mutable_platform_activity();
  PROTOBUF_NODISCARD std::string* release_platform_activity();
  void set_allocated_platform_activity(std::string* value);

  private:
  const std::string& _internal_platform_activity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform_activity(
      const std::string& value);
  std::string* _internal_mutable_platform_activity();

  public:
  // string role = 2 [json_name = "role"];
  void clear_role() ;
  const std::string& role() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role(Arg_&& arg, Args_... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* value);

  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(
      const std::string& value);
  std::string* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Status)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr platform_activity_;
    ::google::protobuf::internal::ArenaStringPtr role_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class OriginalData_TLE final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.OriginalData.TLE) */ {
 public:
  inline OriginalData_TLE() : OriginalData_TLE(nullptr) {}
  ~OriginalData_TLE() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OriginalData_TLE(::google::protobuf::internal::ConstantInitialized);

  inline OriginalData_TLE(const OriginalData_TLE& from)
      : OriginalData_TLE(nullptr, from) {}
  OriginalData_TLE(OriginalData_TLE&& from) noexcept
    : OriginalData_TLE() {
    *this = ::std::move(from);
  }

  inline OriginalData_TLE& operator=(const OriginalData_TLE& from) {
    CopyFrom(from);
    return *this;
  }
  inline OriginalData_TLE& operator=(OriginalData_TLE&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OriginalData_TLE& default_instance() {
    return *internal_default_instance();
  }
  static inline const OriginalData_TLE* internal_default_instance() {
    return reinterpret_cast<const OriginalData_TLE*>(
               &_OriginalData_TLE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OriginalData_TLE& a, OriginalData_TLE& b) {
    a.Swap(&b);
  }
  inline void Swap(OriginalData_TLE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OriginalData_TLE* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OriginalData_TLE* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OriginalData_TLE>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OriginalData_TLE& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OriginalData_TLE& from) {
    OriginalData_TLE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OriginalData_TLE* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.OriginalData.TLE";
  }
  protected:
  explicit OriginalData_TLE(::google::protobuf::Arena* arena);
  OriginalData_TLE(::google::protobuf::Arena* arena, const OriginalData_TLE& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLine1FieldNumber = 1,
    kLine2FieldNumber = 2,
  };
  // string line1 = 1 [json_name = "line1"];
  void clear_line1() ;
  const std::string& line1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_line1(Arg_&& arg, Args_... args);
  std::string* mutable_line1();
  PROTOBUF_NODISCARD std::string* release_line1();
  void set_allocated_line1(std::string* value);

  private:
  const std::string& _internal_line1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line1(
      const std::string& value);
  std::string* _internal_mutable_line1();

  public:
  // string line2 = 2 [json_name = "line2"];
  void clear_line2() ;
  const std::string& line2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_line2(Arg_&& arg, Args_... args);
  std::string* mutable_line2();
  PROTOBUF_NODISCARD std::string* release_line2();
  void set_allocated_line2(std::string* value);

  private:
  const std::string& _internal_line2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line2(
      const std::string& value);
  std::string* _internal_mutable_line2();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.OriginalData.TLE)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr line1_;
    ::google::protobuf::internal::ArenaStringPtr line2_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class AlternateId final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.AlternateId) */ {
 public:
  inline AlternateId() : AlternateId(nullptr) {}
  ~AlternateId() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AlternateId(::google::protobuf::internal::ConstantInitialized);

  inline AlternateId(const AlternateId& from)
      : AlternateId(nullptr, from) {}
  AlternateId(AlternateId&& from) noexcept
    : AlternateId() {
    *this = ::std::move(from);
  }

  inline AlternateId& operator=(const AlternateId& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlternateId& operator=(AlternateId&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlternateId& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlternateId* internal_default_instance() {
    return reinterpret_cast<const AlternateId*>(
               &_AlternateId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AlternateId& a, AlternateId& b) {
    a.Swap(&b);
  }
  inline void Swap(AlternateId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlternateId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlternateId* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlternateId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AlternateId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AlternateId& from) {
    AlternateId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AlternateId* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.AlternateId";
  }
  protected:
  explicit AlternateId(::google::protobuf::Arena* arena);
  AlternateId(::google::protobuf::Arena* arena, const AlternateId& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kIdFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string source = 1 [json_name = "source", deprecated = true];
  [[deprecated]]  void clear_source() ;
  [[deprecated]] const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_source(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_source();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_source();
  [[deprecated]] void set_allocated_source(std::string* value);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // string id = 2 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .anduril.entitymanager.v1.AltIdType type = 3 [json_name = "type", (.anduril.entitymanager.v1.componentIdentifier) = true];
  void clear_type() ;
  ::anduril::entitymanager::v1::AltIdType type() const;
  void set_type(::anduril::entitymanager::v1::AltIdType value);

  private:
  ::anduril::entitymanager::v1::AltIdType _internal_type() const;
  void _internal_set_type(::anduril::entitymanager::v1::AltIdType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.AlternateId)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr source_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class RangeRings final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.RangeRings) */ {
 public:
  inline RangeRings() : RangeRings(nullptr) {}
  ~RangeRings() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RangeRings(::google::protobuf::internal::ConstantInitialized);

  inline RangeRings(const RangeRings& from)
      : RangeRings(nullptr, from) {}
  RangeRings(RangeRings&& from) noexcept
    : RangeRings() {
    *this = ::std::move(from);
  }

  inline RangeRings& operator=(const RangeRings& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeRings& operator=(RangeRings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeRings& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeRings* internal_default_instance() {
    return reinterpret_cast<const RangeRings*>(
               &_RangeRings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RangeRings& a, RangeRings& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeRings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeRings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeRings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeRings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RangeRings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RangeRings& from) {
    RangeRings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RangeRings* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.RangeRings";
  }
  protected:
  explicit RangeRings(::google::protobuf::Arena* arena);
  RangeRings(::google::protobuf::Arena* arena, const RangeRings& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinDistanceMFieldNumber = 1,
    kMaxDistanceMFieldNumber = 2,
    kRingCountFieldNumber = 3,
  };
  // .google.protobuf.DoubleValue min_distance_m = 1 [json_name = "minDistanceM"];
  bool has_min_distance_m() const;
  void clear_min_distance_m() ;
  const ::google::protobuf::DoubleValue& min_distance_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_min_distance_m();
  ::google::protobuf::DoubleValue* mutable_min_distance_m();
  void set_allocated_min_distance_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_min_distance_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_min_distance_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_min_distance_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_min_distance_m();

  public:
  // .google.protobuf.DoubleValue max_distance_m = 2 [json_name = "maxDistanceM"];
  bool has_max_distance_m() const;
  void clear_max_distance_m() ;
  const ::google::protobuf::DoubleValue& max_distance_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_max_distance_m();
  ::google::protobuf::DoubleValue* mutable_max_distance_m();
  void set_allocated_max_distance_m(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_max_distance_m(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_max_distance_m();

  private:
  const ::google::protobuf::DoubleValue& _internal_max_distance_m() const;
  ::google::protobuf::DoubleValue* _internal_mutable_max_distance_m();

  public:
  // uint32 ring_count = 3 [json_name = "ringCount"];
  void clear_ring_count() ;
  ::uint32_t ring_count() const;
  void set_ring_count(::uint32_t value);

  private:
  ::uint32_t _internal_ring_count() const;
  void _internal_set_ring_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.RangeRings)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::DoubleValue* min_distance_m_;
    ::google::protobuf::DoubleValue* max_distance_m_;
    ::uint32_t ring_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class Provenance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Provenance) */ {
 public:
  inline Provenance() : Provenance(nullptr) {}
  ~Provenance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Provenance(::google::protobuf::internal::ConstantInitialized);

  inline Provenance(const Provenance& from)
      : Provenance(nullptr, from) {}
  Provenance(Provenance&& from) noexcept
    : Provenance() {
    *this = ::std::move(from);
  }

  inline Provenance& operator=(const Provenance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Provenance& operator=(Provenance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Provenance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Provenance* internal_default_instance() {
    return reinterpret_cast<const Provenance*>(
               &_Provenance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Provenance& a, Provenance& b) {
    a.Swap(&b);
  }
  inline void Swap(Provenance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Provenance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Provenance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Provenance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Provenance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Provenance& from) {
    Provenance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Provenance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.Provenance";
  }
  protected:
  explicit Provenance(::google::protobuf::Arena* arena);
  Provenance(::google::protobuf::Arena* arena, const Provenance& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 3,
    kSourceDescriptionFieldNumber = 4,
    kIntegrationNameFieldNumber = 5,
    kDataTypeFieldNumber = 6,
    kSourceUpdateTimeFieldNumber = 2,
    kSourceFieldNumber = 1,
  };
  // string source_id = 3 [json_name = "sourceId"];
  void clear_source_id() ;
  const std::string& source_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_id();
  PROTOBUF_NODISCARD std::string* release_source_id();
  void set_allocated_source_id(std::string* value);

  private:
  const std::string& _internal_source_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_id(
      const std::string& value);
  std::string* _internal_mutable_source_id();

  public:
  // string source_description = 4 [json_name = "sourceDescription"];
  void clear_source_description() ;
  const std::string& source_description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_description(Arg_&& arg, Args_... args);
  std::string* mutable_source_description();
  PROTOBUF_NODISCARD std::string* release_source_description();
  void set_allocated_source_description(std::string* value);

  private:
  const std::string& _internal_source_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_description(
      const std::string& value);
  std::string* _internal_mutable_source_description();

  public:
  // string integration_name = 5 [json_name = "integrationName"];
  void clear_integration_name() ;
  const std::string& integration_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_integration_name(Arg_&& arg, Args_... args);
  std::string* mutable_integration_name();
  PROTOBUF_NODISCARD std::string* release_integration_name();
  void set_allocated_integration_name(std::string* value);

  private:
  const std::string& _internal_integration_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration_name(
      const std::string& value);
  std::string* _internal_mutable_integration_name();

  public:
  // string data_type = 6 [json_name = "dataType"];
  void clear_data_type() ;
  const std::string& data_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_type(Arg_&& arg, Args_... args);
  std::string* mutable_data_type();
  PROTOBUF_NODISCARD std::string* release_data_type();
  void set_allocated_data_type(std::string* value);

  private:
  const std::string& _internal_data_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_type(
      const std::string& value);
  std::string* _internal_mutable_data_type();

  public:
  // .google.protobuf.Timestamp source_update_time = 2 [json_name = "sourceUpdateTime"];
  bool has_source_update_time() const;
  void clear_source_update_time() ;
  const ::google::protobuf::Timestamp& source_update_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_source_update_time();
  ::google::protobuf::Timestamp* mutable_source_update_time();
  void set_allocated_source_update_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_source_update_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_source_update_time();

  private:
  const ::google::protobuf::Timestamp& _internal_source_update_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_source_update_time();

  public:
  // .anduril.entitymanager.v1.Source source = 1 [json_name = "source"];
  void clear_source() ;
  ::anduril::entitymanager::v1::Source source() const;
  void set_source(::anduril::entitymanager::v1::Source value);

  private:
  ::anduril::entitymanager::v1::Source _internal_source() const;
  void _internal_set_source(::anduril::entitymanager::v1::Source value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Provenance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      96, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr source_id_;
    ::google::protobuf::internal::ArenaStringPtr source_description_;
    ::google::protobuf::internal::ArenaStringPtr integration_name_;
    ::google::protobuf::internal::ArenaStringPtr data_type_;
    ::google::protobuf::Timestamp* source_update_time_;
    int source_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class OriginalData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.OriginalData) */ {
 public:
  inline OriginalData() : OriginalData(nullptr) {}
  ~OriginalData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OriginalData(::google::protobuf::internal::ConstantInitialized);

  inline OriginalData(const OriginalData& from)
      : OriginalData(nullptr, from) {}
  OriginalData(OriginalData&& from) noexcept
    : OriginalData() {
    *this = ::std::move(from);
  }

  inline OriginalData& operator=(const OriginalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline OriginalData& operator=(OriginalData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OriginalData& default_instance() {
    return *internal_default_instance();
  }
  static inline const OriginalData* internal_default_instance() {
    return reinterpret_cast<const OriginalData*>(
               &_OriginalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(OriginalData& a, OriginalData& b) {
    a.Swap(&b);
  }
  inline void Swap(OriginalData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OriginalData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OriginalData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OriginalData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OriginalData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OriginalData& from) {
    OriginalData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OriginalData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.OriginalData";
  }
  protected:
  explicit OriginalData(::google::protobuf::Arena* arena);
  OriginalData(::google::protobuf::Arena* arena, const OriginalData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TLE = OriginalData_TLE;

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kTleFieldNumber = 2,
  };
  // string url = 1 [json_name = "url"];
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* value);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // .anduril.entitymanager.v1.OriginalData.TLE tle = 2 [json_name = "tle"];
  bool has_tle() const;
  void clear_tle() ;
  const ::anduril::entitymanager::v1::OriginalData_TLE& tle() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::OriginalData_TLE* release_tle();
  ::anduril::entitymanager::v1::OriginalData_TLE* mutable_tle();
  void set_allocated_tle(::anduril::entitymanager::v1::OriginalData_TLE* value);
  void unsafe_arena_set_allocated_tle(::anduril::entitymanager::v1::OriginalData_TLE* value);
  ::anduril::entitymanager::v1::OriginalData_TLE* unsafe_arena_release_tle();

  private:
  const ::anduril::entitymanager::v1::OriginalData_TLE& _internal_tle() const;
  ::anduril::entitymanager::v1::OriginalData_TLE* _internal_mutable_tle();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.OriginalData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::anduril::entitymanager::v1::OriginalData_TLE* tle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class Indicators final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Indicators) */ {
 public:
  inline Indicators() : Indicators(nullptr) {}
  ~Indicators() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Indicators(::google::protobuf::internal::ConstantInitialized);

  inline Indicators(const Indicators& from)
      : Indicators(nullptr, from) {}
  Indicators(Indicators&& from) noexcept
    : Indicators() {
    *this = ::std::move(from);
  }

  inline Indicators& operator=(const Indicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline Indicators& operator=(Indicators&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Indicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const Indicators* internal_default_instance() {
    return reinterpret_cast<const Indicators*>(
               &_Indicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Indicators& a, Indicators& b) {
    a.Swap(&b);
  }
  inline void Swap(Indicators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Indicators* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Indicators* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Indicators>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Indicators& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Indicators& from) {
    Indicators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Indicators* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.Indicators";
  }
  protected:
  explicit Indicators(::google::protobuf::Arena* arena);
  Indicators(::google::protobuf::Arena* arena, const Indicators& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulatedFieldNumber = 1,
    kExerciseFieldNumber = 2,
    kEmergencyFieldNumber = 3,
    kC2FieldNumber = 4,
    kEgressableFieldNumber = 6,
    kStarredFieldNumber = 7,
    kDeletableFieldNumber = 5,
  };
  // .google.protobuf.BoolValue simulated = 1 [json_name = "simulated"];
  bool has_simulated() const;
  void clear_simulated() ;
  const ::google::protobuf::BoolValue& simulated() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_simulated();
  ::google::protobuf::BoolValue* mutable_simulated();
  void set_allocated_simulated(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_simulated(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_simulated();

  private:
  const ::google::protobuf::BoolValue& _internal_simulated() const;
  ::google::protobuf::BoolValue* _internal_mutable_simulated();

  public:
  // .google.protobuf.BoolValue exercise = 2 [json_name = "exercise"];
  bool has_exercise() const;
  void clear_exercise() ;
  const ::google::protobuf::BoolValue& exercise() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_exercise();
  ::google::protobuf::BoolValue* mutable_exercise();
  void set_allocated_exercise(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_exercise(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_exercise();

  private:
  const ::google::protobuf::BoolValue& _internal_exercise() const;
  ::google::protobuf::BoolValue* _internal_mutable_exercise();

  public:
  // .google.protobuf.BoolValue emergency = 3 [json_name = "emergency"];
  bool has_emergency() const;
  void clear_emergency() ;
  const ::google::protobuf::BoolValue& emergency() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_emergency();
  ::google::protobuf::BoolValue* mutable_emergency();
  void set_allocated_emergency(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_emergency(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_emergency();

  private:
  const ::google::protobuf::BoolValue& _internal_emergency() const;
  ::google::protobuf::BoolValue* _internal_mutable_emergency();

  public:
  // .google.protobuf.BoolValue c2 = 4 [json_name = "c2"];
  bool has_c2() const;
  void clear_c2() ;
  const ::google::protobuf::BoolValue& c2() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_c2();
  ::google::protobuf::BoolValue* mutable_c2();
  void set_allocated_c2(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_c2(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_c2();

  private:
  const ::google::protobuf::BoolValue& _internal_c2() const;
  ::google::protobuf::BoolValue* _internal_mutable_c2();

  public:
  // .google.protobuf.BoolValue egressable = 6 [json_name = "egressable", (.anduril.entitymanager.v1.overridable) = true];
  bool has_egressable() const;
  void clear_egressable() ;
  const ::google::protobuf::BoolValue& egressable() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_egressable();
  ::google::protobuf::BoolValue* mutable_egressable();
  void set_allocated_egressable(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_egressable(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_egressable();

  private:
  const ::google::protobuf::BoolValue& _internal_egressable() const;
  ::google::protobuf::BoolValue* _internal_mutable_egressable();

  public:
  // .google.protobuf.BoolValue starred = 7 [json_name = "starred", (.anduril.entitymanager.v1.overridable) = true];
  bool has_starred() const;
  void clear_starred() ;
  const ::google::protobuf::BoolValue& starred() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_starred();
  ::google::protobuf::BoolValue* mutable_starred();
  void set_allocated_starred(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_starred(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_starred();

  private:
  const ::google::protobuf::BoolValue& _internal_starred() const;
  ::google::protobuf::BoolValue* _internal_mutable_starred();

  public:
  // .anduril.entitymanager.v1.Deletable deletable = 5 [json_name = "deletable"];
  void clear_deletable() ;
  ::anduril::entitymanager::v1::Deletable deletable() const;
  void set_deletable(::anduril::entitymanager::v1::Deletable value);

  private:
  ::anduril::entitymanager::v1::Deletable _internal_deletable() const;
  void _internal_set_deletable(::anduril::entitymanager::v1::Deletable value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Indicators)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 6,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::BoolValue* simulated_;
    ::google::protobuf::BoolValue* exercise_;
    ::google::protobuf::BoolValue* emergency_;
    ::google::protobuf::BoolValue* c2_;
    ::google::protobuf::BoolValue* egressable_;
    ::google::protobuf::BoolValue* starred_;
    int deletable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class Aliases final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Aliases) */ {
 public:
  inline Aliases() : Aliases(nullptr) {}
  ~Aliases() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Aliases(::google::protobuf::internal::ConstantInitialized);

  inline Aliases(const Aliases& from)
      : Aliases(nullptr, from) {}
  Aliases(Aliases&& from) noexcept
    : Aliases() {
    *this = ::std::move(from);
  }

  inline Aliases& operator=(const Aliases& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aliases& operator=(Aliases&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aliases& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aliases* internal_default_instance() {
    return reinterpret_cast<const Aliases*>(
               &_Aliases_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Aliases& a, Aliases& b) {
    a.Swap(&b);
  }
  inline void Swap(Aliases* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aliases* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aliases* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aliases>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Aliases& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Aliases& from) {
    Aliases::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Aliases* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.Aliases";
  }
  protected:
  explicit Aliases(::google::protobuf::Arena* arena);
  Aliases(::google::protobuf::Arena* arena, const Aliases& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlternateIdsFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // repeated .anduril.entitymanager.v1.AlternateId alternate_ids = 1 [json_name = "alternateIds", (.anduril.entitymanager.v1.overridable) = true];
  int alternate_ids_size() const;
  private:
  int _internal_alternate_ids_size() const;

  public:
  void clear_alternate_ids() ;
  ::anduril::entitymanager::v1::AlternateId* mutable_alternate_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::AlternateId >*
      mutable_alternate_ids();
  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>& _internal_alternate_ids() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>* _internal_mutable_alternate_ids();
  public:
  const ::anduril::entitymanager::v1::AlternateId& alternate_ids(int index) const;
  ::anduril::entitymanager::v1::AlternateId* add_alternate_ids();
  const ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::AlternateId >&
      alternate_ids() const;
  // string name = 2 [json_name = "name", (.anduril.entitymanager.v1.overridable) = true];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Aliases)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::AlternateId > alternate_ids_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class VisualDetails final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.VisualDetails) */ {
 public:
  inline VisualDetails() : VisualDetails(nullptr) {}
  ~VisualDetails() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisualDetails(::google::protobuf::internal::ConstantInitialized);

  inline VisualDetails(const VisualDetails& from)
      : VisualDetails(nullptr, from) {}
  VisualDetails(VisualDetails&& from) noexcept
    : VisualDetails() {
    *this = ::std::move(from);
  }

  inline VisualDetails& operator=(const VisualDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisualDetails& operator=(VisualDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisualDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisualDetails* internal_default_instance() {
    return reinterpret_cast<const VisualDetails*>(
               &_VisualDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VisualDetails& a, VisualDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(VisualDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisualDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisualDetails* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisualDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisualDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisualDetails& from) {
    VisualDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisualDetails* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.VisualDetails";
  }
  protected:
  explicit VisualDetails(::google::protobuf::Arena* arena);
  VisualDetails(::google::protobuf::Arena* arena, const VisualDetails& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRangeRingsFieldNumber = 1,
    kInteractivityModeFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.RangeRings range_rings = 1 [json_name = "rangeRings", (.anduril.entitymanager.v1.overridable) = true];
  bool has_range_rings() const;
  void clear_range_rings() ;
  const ::anduril::entitymanager::v1::RangeRings& range_rings() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::RangeRings* release_range_rings();
  ::anduril::entitymanager::v1::RangeRings* mutable_range_rings();
  void set_allocated_range_rings(::anduril::entitymanager::v1::RangeRings* value);
  void unsafe_arena_set_allocated_range_rings(::anduril::entitymanager::v1::RangeRings* value);
  ::anduril::entitymanager::v1::RangeRings* unsafe_arena_release_range_rings();

  private:
  const ::anduril::entitymanager::v1::RangeRings& _internal_range_rings() const;
  ::anduril::entitymanager::v1::RangeRings* _internal_mutable_range_rings();

  public:
  // .anduril.entitymanager.v1.InteractivityMode interactivity_mode = 2 [json_name = "interactivityMode"];
  void clear_interactivity_mode() ;
  ::anduril::entitymanager::v1::InteractivityMode interactivity_mode() const;
  void set_interactivity_mode(::anduril::entitymanager::v1::InteractivityMode value);

  private:
  ::anduril::entitymanager::v1::InteractivityMode _internal_interactivity_mode() const;
  void _internal_set_interactivity_mode(::anduril::entitymanager::v1::InteractivityMode value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.VisualDetails)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::RangeRings* range_rings_;
    int interactivity_mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class OverrideProvenance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.OverrideProvenance) */ {
 public:
  inline OverrideProvenance() : OverrideProvenance(nullptr) {}
  ~OverrideProvenance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OverrideProvenance(::google::protobuf::internal::ConstantInitialized);

  inline OverrideProvenance(const OverrideProvenance& from)
      : OverrideProvenance(nullptr, from) {}
  OverrideProvenance(OverrideProvenance&& from) noexcept
    : OverrideProvenance() {
    *this = ::std::move(from);
  }

  inline OverrideProvenance& operator=(const OverrideProvenance& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverrideProvenance& operator=(OverrideProvenance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverrideProvenance& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverrideProvenance* internal_default_instance() {
    return reinterpret_cast<const OverrideProvenance*>(
               &_OverrideProvenance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OverrideProvenance& a, OverrideProvenance& b) {
    a.Swap(&b);
  }
  inline void Swap(OverrideProvenance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverrideProvenance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverrideProvenance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OverrideProvenance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OverrideProvenance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OverrideProvenance& from) {
    OverrideProvenance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OverrideProvenance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.OverrideProvenance";
  }
  protected:
  explicit OverrideProvenance(::google::protobuf::Arena* arena);
  OverrideProvenance(::google::protobuf::Arena* arena, const OverrideProvenance& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldPathFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kProvenanceFieldNumber = 3,
  };
  // string field_path = 1 [json_name = "fieldPath"];
  void clear_field_path() ;
  const std::string& field_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_field_path(Arg_&& arg, Args_... args);
  std::string* mutable_field_path();
  PROTOBUF_NODISCARD std::string* release_field_path();
  void set_allocated_field_path(std::string* value);

  private:
  const std::string& _internal_field_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_path(
      const std::string& value);
  std::string* _internal_mutable_field_path();

  public:
  // string source_id = 2 [json_name = "sourceId", deprecated = true];
  [[deprecated]]  void clear_source_id() ;
  [[deprecated]] const std::string& source_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_source_id(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_source_id();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_source_id();
  [[deprecated]] void set_allocated_source_id(std::string* value);

  private:
  const std::string& _internal_source_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_id(
      const std::string& value);
  std::string* _internal_mutable_source_id();

  public:
  // .anduril.entitymanager.v1.Provenance provenance = 3 [json_name = "provenance"];
  bool has_provenance() const;
  void clear_provenance() ;
  const ::anduril::entitymanager::v1::Provenance& provenance() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Provenance* release_provenance();
  ::anduril::entitymanager::v1::Provenance* mutable_provenance();
  void set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  void unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  ::anduril::entitymanager::v1::Provenance* unsafe_arena_release_provenance();

  private:
  const ::anduril::entitymanager::v1::Provenance& _internal_provenance() const;
  ::anduril::entitymanager::v1::Provenance* _internal_mutable_provenance();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.OverrideProvenance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr field_path_;
    ::google::protobuf::internal::ArenaStringPtr source_id_;
    ::anduril::entitymanager::v1::Provenance* provenance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class Tracked final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Tracked) */ {
 public:
  inline Tracked() : Tracked(nullptr) {}
  ~Tracked() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Tracked(::google::protobuf::internal::ConstantInitialized);

  inline Tracked(const Tracked& from)
      : Tracked(nullptr, from) {}
  Tracked(Tracked&& from) noexcept
    : Tracked() {
    *this = ::std::move(from);
  }

  inline Tracked& operator=(const Tracked& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tracked& operator=(Tracked&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tracked& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tracked* internal_default_instance() {
    return reinterpret_cast<const Tracked*>(
               &_Tracked_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Tracked& a, Tracked& b) {
    a.Swap(&b);
  }
  inline void Swap(Tracked* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tracked* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tracked* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tracked>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Tracked& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Tracked& from) {
    Tracked::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Tracked* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.Tracked";
  }
  protected:
  explicit Tracked(::google::protobuf::Arena* arena);
  Tracked(::google::protobuf::Arena* arena, const Tracked& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackQualityWrapperFieldNumber = 2,
    kSensorHitsFieldNumber = 3,
    kNumberOfObjectsFieldNumber = 4,
    kSensorDetailsFieldNumber = 5,
    kRadarCrossSectionFieldNumber = 6,
    kLastMeasurementTimeFieldNumber = 7,
    kLineOfBearingFieldNumber = 9,
    kTrackQualityFieldNumber = 1,
  };
  // .google.protobuf.Int32Value track_quality_wrapper = 2 [json_name = "trackQualityWrapper"];
  bool has_track_quality_wrapper() const;
  void clear_track_quality_wrapper() ;
  const ::google::protobuf::Int32Value& track_quality_wrapper() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int32Value* release_track_quality_wrapper();
  ::google::protobuf::Int32Value* mutable_track_quality_wrapper();
  void set_allocated_track_quality_wrapper(::google::protobuf::Int32Value* value);
  void unsafe_arena_set_allocated_track_quality_wrapper(::google::protobuf::Int32Value* value);
  ::google::protobuf::Int32Value* unsafe_arena_release_track_quality_wrapper();

  private:
  const ::google::protobuf::Int32Value& _internal_track_quality_wrapper() const;
  ::google::protobuf::Int32Value* _internal_mutable_track_quality_wrapper();

  public:
  // .google.protobuf.Int32Value sensor_hits = 3 [json_name = "sensorHits"];
  bool has_sensor_hits() const;
  void clear_sensor_hits() ;
  const ::google::protobuf::Int32Value& sensor_hits() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int32Value* release_sensor_hits();
  ::google::protobuf::Int32Value* mutable_sensor_hits();
  void set_allocated_sensor_hits(::google::protobuf::Int32Value* value);
  void unsafe_arena_set_allocated_sensor_hits(::google::protobuf::Int32Value* value);
  ::google::protobuf::Int32Value* unsafe_arena_release_sensor_hits();

  private:
  const ::google::protobuf::Int32Value& _internal_sensor_hits() const;
  ::google::protobuf::Int32Value* _internal_mutable_sensor_hits();

  public:
  // .anduril.entitymanager.v1.UInt32Range number_of_objects = 4 [json_name = "numberOfObjects"];
  bool has_number_of_objects() const;
  void clear_number_of_objects() ;
  const ::anduril::entitymanager::v1::UInt32Range& number_of_objects() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::UInt32Range* release_number_of_objects();
  ::anduril::entitymanager::v1::UInt32Range* mutable_number_of_objects();
  void set_allocated_number_of_objects(::anduril::entitymanager::v1::UInt32Range* value);
  void unsafe_arena_set_allocated_number_of_objects(::anduril::entitymanager::v1::UInt32Range* value);
  ::anduril::entitymanager::v1::UInt32Range* unsafe_arena_release_number_of_objects();

  private:
  const ::anduril::entitymanager::v1::UInt32Range& _internal_number_of_objects() const;
  ::anduril::entitymanager::v1::UInt32Range* _internal_mutable_number_of_objects();

  public:
  // .anduril.entitymanager.v1.Sensors sensor_details = 5 [json_name = "sensorDetails", deprecated = true];
  [[deprecated]]  bool has_sensor_details() const;
  [[deprecated]]  void clear_sensor_details() ;
  [[deprecated]] const ::anduril::entitymanager::v1::Sensors& sensor_details() const;
  [[deprecated]] PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Sensors* release_sensor_details();
  [[deprecated]] ::anduril::entitymanager::v1::Sensors* mutable_sensor_details();
  [[deprecated]] void set_allocated_sensor_details(::anduril::entitymanager::v1::Sensors* value);
  [[deprecated]] void unsafe_arena_set_allocated_sensor_details(::anduril::entitymanager::v1::Sensors* value);
  [[deprecated]] ::anduril::entitymanager::v1::Sensors* unsafe_arena_release_sensor_details();

  private:
  const ::anduril::entitymanager::v1::Sensors& _internal_sensor_details() const;
  ::anduril::entitymanager::v1::Sensors* _internal_mutable_sensor_details();

  public:
  // .google.protobuf.DoubleValue radar_cross_section = 6 [json_name = "radarCrossSection"];
  bool has_radar_cross_section() const;
  void clear_radar_cross_section() ;
  const ::google::protobuf::DoubleValue& radar_cross_section() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_radar_cross_section();
  ::google::protobuf::DoubleValue* mutable_radar_cross_section();
  void set_allocated_radar_cross_section(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_radar_cross_section(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_radar_cross_section();

  private:
  const ::google::protobuf::DoubleValue& _internal_radar_cross_section() const;
  ::google::protobuf::DoubleValue* _internal_mutable_radar_cross_section();

  public:
  // .google.protobuf.Timestamp last_measurement_time = 7 [json_name = "lastMeasurementTime"];
  bool has_last_measurement_time() const;
  void clear_last_measurement_time() ;
  const ::google::protobuf::Timestamp& last_measurement_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_measurement_time();
  ::google::protobuf::Timestamp* mutable_last_measurement_time();
  void set_allocated_last_measurement_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_measurement_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_measurement_time();

  private:
  const ::google::protobuf::Timestamp& _internal_last_measurement_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_measurement_time();

  public:
  // .anduril.entitymanager.v1.LineOfBearing line_of_bearing = 9 [json_name = "lineOfBearing"];
  bool has_line_of_bearing() const;
  void clear_line_of_bearing() ;
  const ::anduril::entitymanager::v1::LineOfBearing& line_of_bearing() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::LineOfBearing* release_line_of_bearing();
  ::anduril::entitymanager::v1::LineOfBearing* mutable_line_of_bearing();
  void set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value);
  void unsafe_arena_set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value);
  ::anduril::entitymanager::v1::LineOfBearing* unsafe_arena_release_line_of_bearing();

  private:
  const ::anduril::entitymanager::v1::LineOfBearing& _internal_line_of_bearing() const;
  ::anduril::entitymanager::v1::LineOfBearing* _internal_mutable_line_of_bearing();

  public:
  // uint32 track_quality = 1 [json_name = "trackQuality", deprecated = true];
  [[deprecated]]  void clear_track_quality() ;
  [[deprecated]] ::uint32_t track_quality() const;
  [[deprecated]] void set_track_quality(::uint32_t value);

  private:
  ::uint32_t _internal_track_quality() const;
  void _internal_set_track_quality(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Tracked)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 8, 7,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int32Value* track_quality_wrapper_;
    ::google::protobuf::Int32Value* sensor_hits_;
    ::anduril::entitymanager::v1::UInt32Range* number_of_objects_;
    ::anduril::entitymanager::v1::Sensors* sensor_details_;
    ::google::protobuf::DoubleValue* radar_cross_section_;
    ::google::protobuf::Timestamp* last_measurement_time_;
    ::anduril::entitymanager::v1::LineOfBearing* line_of_bearing_;
    ::uint32_t track_quality_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class Entity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Entity) */ {
 public:
  inline Entity() : Entity(nullptr) {}
  ~Entity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Entity(::google::protobuf::internal::ConstantInitialized);

  inline Entity(const Entity& from)
      : Entity(nullptr, from) {}
  Entity(Entity&& from) noexcept
    : Entity() {
    *this = ::std::move(from);
  }

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity& operator=(Entity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity* internal_default_instance() {
    return reinterpret_cast<const Entity*>(
               &_Entity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Entity& a, Entity& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Entity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Entity& from) {
    Entity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Entity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.Entity";
  }
  protected:
  explicit Entity(::google::protobuf::Arena* arena);
  Entity(::google::protobuf::Arena* arena, const Entity& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kCreatedTimeFieldNumber = 4,
    kExpiryTimeFieldNumber = 5,
    kLocationFieldNumber = 6,
    kAliasesFieldNumber = 7,
    kTrackedFieldNumber = 8,
    kCorrelatedFieldNumber = 9,
    kMilViewFieldNumber = 10,
    kOntologyFieldNumber = 11,
    kProvenanceFieldNumber = 12,
    kOverridesFieldNumber = 13,
    kIndicatorsFieldNumber = 14,
    kLocationUncertaintyFieldNumber = 15,
    kGeopolygonFieldNumber = 17,
    kOriginalDataFieldNumber = 18,
    kStatusFieldNumber = 19,
    kSensorsFieldNumber = 20,
    kPayloadsFieldNumber = 21,
    kTargetPriorityFieldNumber = 22,
    kGeoShapeFieldNumber = 23,
    kGeoDetailsFieldNumber = 24,
    kSignalFieldNumber = 25,
    kTransponderCodesFieldNumber = 26,
    kContactFieldNumber = 27,
    kDataClassificationFieldNumber = 29,
    kPowerStateFieldNumber = 30,
    kTaskCatalogFieldNumber = 31,
    kMediaFieldNumber = 32,
    kRelationshipsFieldNumber = 33,
    kVisualDetailsFieldNumber = 34,
    kPrototypeExtensionsFieldNumber = 35,
    kDimensionsFieldNumber = 36,
    kRouteDetailsFieldNumber = 37,
    kSchedulesFieldNumber = 38,
    kHealthFieldNumber = 39,
    kGroupDetailsFieldNumber = 40,
    kTeamStatusFieldNumber = 41,
    kSuppliesFieldNumber = 42,
    kIsLiveFieldNumber = 3,
    kNoExpiryFieldNumber = 43,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .google.protobuf.Timestamp created_time = 4 [json_name = "createdTime"];
  bool has_created_time() const;
  void clear_created_time() ;
  const ::google::protobuf::Timestamp& created_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_time();
  ::google::protobuf::Timestamp* mutable_created_time();
  void set_allocated_created_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_time();

  private:
  const ::google::protobuf::Timestamp& _internal_created_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_time();

  public:
  // .google.protobuf.Timestamp expiry_time = 5 [json_name = "expiryTime"];
  bool has_expiry_time() const;
  void clear_expiry_time() ;
  const ::google::protobuf::Timestamp& expiry_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_expiry_time();
  ::google::protobuf::Timestamp* mutable_expiry_time();
  void set_allocated_expiry_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_expiry_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_expiry_time();

  private:
  const ::google::protobuf::Timestamp& _internal_expiry_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_expiry_time();

  public:
  // .anduril.entitymanager.v1.Location location = 6 [json_name = "location"];
  bool has_location() const;
  void clear_location() ;
  const ::anduril::entitymanager::v1::Location& location() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Location* release_location();
  ::anduril::entitymanager::v1::Location* mutable_location();
  void set_allocated_location(::anduril::entitymanager::v1::Location* value);
  void unsafe_arena_set_allocated_location(::anduril::entitymanager::v1::Location* value);
  ::anduril::entitymanager::v1::Location* unsafe_arena_release_location();

  private:
  const ::anduril::entitymanager::v1::Location& _internal_location() const;
  ::anduril::entitymanager::v1::Location* _internal_mutable_location();

  public:
  // .anduril.entitymanager.v1.Aliases aliases = 7 [json_name = "aliases"];
  bool has_aliases() const;
  void clear_aliases() ;
  const ::anduril::entitymanager::v1::Aliases& aliases() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Aliases* release_aliases();
  ::anduril::entitymanager::v1::Aliases* mutable_aliases();
  void set_allocated_aliases(::anduril::entitymanager::v1::Aliases* value);
  void unsafe_arena_set_allocated_aliases(::anduril::entitymanager::v1::Aliases* value);
  ::anduril::entitymanager::v1::Aliases* unsafe_arena_release_aliases();

  private:
  const ::anduril::entitymanager::v1::Aliases& _internal_aliases() const;
  ::anduril::entitymanager::v1::Aliases* _internal_mutable_aliases();

  public:
  // .anduril.entitymanager.v1.Tracked tracked = 8 [json_name = "tracked"];
  bool has_tracked() const;
  void clear_tracked() ;
  const ::anduril::entitymanager::v1::Tracked& tracked() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Tracked* release_tracked();
  ::anduril::entitymanager::v1::Tracked* mutable_tracked();
  void set_allocated_tracked(::anduril::entitymanager::v1::Tracked* value);
  void unsafe_arena_set_allocated_tracked(::anduril::entitymanager::v1::Tracked* value);
  ::anduril::entitymanager::v1::Tracked* unsafe_arena_release_tracked();

  private:
  const ::anduril::entitymanager::v1::Tracked& _internal_tracked() const;
  ::anduril::entitymanager::v1::Tracked* _internal_mutable_tracked();

  public:
  // .anduril.entitymanager.v1.Correlated correlated = 9 [json_name = "correlated"];
  bool has_correlated() const;
  void clear_correlated() ;
  const ::anduril::entitymanager::v1::Correlated& correlated() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Correlated* release_correlated();
  ::anduril::entitymanager::v1::Correlated* mutable_correlated();
  void set_allocated_correlated(::anduril::entitymanager::v1::Correlated* value);
  void unsafe_arena_set_allocated_correlated(::anduril::entitymanager::v1::Correlated* value);
  ::anduril::entitymanager::v1::Correlated* unsafe_arena_release_correlated();

  private:
  const ::anduril::entitymanager::v1::Correlated& _internal_correlated() const;
  ::anduril::entitymanager::v1::Correlated* _internal_mutable_correlated();

  public:
  // .anduril.entitymanager.v1.MilView mil_view = 10 [json_name = "milView"];
  bool has_mil_view() const;
  void clear_mil_view() ;
  const ::anduril::entitymanager::v1::MilView& mil_view() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::MilView* release_mil_view();
  ::anduril::entitymanager::v1::MilView* mutable_mil_view();
  void set_allocated_mil_view(::anduril::entitymanager::v1::MilView* value);
  void unsafe_arena_set_allocated_mil_view(::anduril::entitymanager::v1::MilView* value);
  ::anduril::entitymanager::v1::MilView* unsafe_arena_release_mil_view();

  private:
  const ::anduril::entitymanager::v1::MilView& _internal_mil_view() const;
  ::anduril::entitymanager::v1::MilView* _internal_mutable_mil_view();

  public:
  // .anduril.entitymanager.v1.Ontology ontology = 11 [json_name = "ontology"];
  bool has_ontology() const;
  void clear_ontology() ;
  const ::anduril::entitymanager::v1::Ontology& ontology() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Ontology* release_ontology();
  ::anduril::entitymanager::v1::Ontology* mutable_ontology();
  void set_allocated_ontology(::anduril::entitymanager::v1::Ontology* value);
  void unsafe_arena_set_allocated_ontology(::anduril::entitymanager::v1::Ontology* value);
  ::anduril::entitymanager::v1::Ontology* unsafe_arena_release_ontology();

  private:
  const ::anduril::entitymanager::v1::Ontology& _internal_ontology() const;
  ::anduril::entitymanager::v1::Ontology* _internal_mutable_ontology();

  public:
  // .anduril.entitymanager.v1.Provenance provenance = 12 [json_name = "provenance"];
  bool has_provenance() const;
  void clear_provenance() ;
  const ::anduril::entitymanager::v1::Provenance& provenance() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Provenance* release_provenance();
  ::anduril::entitymanager::v1::Provenance* mutable_provenance();
  void set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  void unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  ::anduril::entitymanager::v1::Provenance* unsafe_arena_release_provenance();

  private:
  const ::anduril::entitymanager::v1::Provenance& _internal_provenance() const;
  ::anduril::entitymanager::v1::Provenance* _internal_mutable_provenance();

  public:
  // .anduril.entitymanager.v1.Overrides overrides = 13 [json_name = "overrides"];
  bool has_overrides() const;
  void clear_overrides() ;
  const ::anduril::entitymanager::v1::Overrides& overrides() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Overrides* release_overrides();
  ::anduril::entitymanager::v1::Overrides* mutable_overrides();
  void set_allocated_overrides(::anduril::entitymanager::v1::Overrides* value);
  void unsafe_arena_set_allocated_overrides(::anduril::entitymanager::v1::Overrides* value);
  ::anduril::entitymanager::v1::Overrides* unsafe_arena_release_overrides();

  private:
  const ::anduril::entitymanager::v1::Overrides& _internal_overrides() const;
  ::anduril::entitymanager::v1::Overrides* _internal_mutable_overrides();

  public:
  // .anduril.entitymanager.v1.Indicators indicators = 14 [json_name = "indicators"];
  bool has_indicators() const;
  void clear_indicators() ;
  const ::anduril::entitymanager::v1::Indicators& indicators() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Indicators* release_indicators();
  ::anduril::entitymanager::v1::Indicators* mutable_indicators();
  void set_allocated_indicators(::anduril::entitymanager::v1::Indicators* value);
  void unsafe_arena_set_allocated_indicators(::anduril::entitymanager::v1::Indicators* value);
  ::anduril::entitymanager::v1::Indicators* unsafe_arena_release_indicators();

  private:
  const ::anduril::entitymanager::v1::Indicators& _internal_indicators() const;
  ::anduril::entitymanager::v1::Indicators* _internal_mutable_indicators();

  public:
  // .anduril.entitymanager.v1.LocationUncertainty location_uncertainty = 15 [json_name = "locationUncertainty"];
  bool has_location_uncertainty() const;
  void clear_location_uncertainty() ;
  const ::anduril::entitymanager::v1::LocationUncertainty& location_uncertainty() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::LocationUncertainty* release_location_uncertainty();
  ::anduril::entitymanager::v1::LocationUncertainty* mutable_location_uncertainty();
  void set_allocated_location_uncertainty(::anduril::entitymanager::v1::LocationUncertainty* value);
  void unsafe_arena_set_allocated_location_uncertainty(::anduril::entitymanager::v1::LocationUncertainty* value);
  ::anduril::entitymanager::v1::LocationUncertainty* unsafe_arena_release_location_uncertainty();

  private:
  const ::anduril::entitymanager::v1::LocationUncertainty& _internal_location_uncertainty() const;
  ::anduril::entitymanager::v1::LocationUncertainty* _internal_mutable_location_uncertainty();

  public:
  // .anduril.entitymanager.v1.GeoPolygon geopolygon = 17 [json_name = "geopolygon", deprecated = true];
  [[deprecated]]  bool has_geopolygon() const;
  [[deprecated]]  void clear_geopolygon() ;
  [[deprecated]] const ::anduril::entitymanager::v1::GeoPolygon& geopolygon() const;
  [[deprecated]] PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoPolygon* release_geopolygon();
  [[deprecated]] ::anduril::entitymanager::v1::GeoPolygon* mutable_geopolygon();
  [[deprecated]] void set_allocated_geopolygon(::anduril::entitymanager::v1::GeoPolygon* value);
  [[deprecated]] void unsafe_arena_set_allocated_geopolygon(::anduril::entitymanager::v1::GeoPolygon* value);
  [[deprecated]] ::anduril::entitymanager::v1::GeoPolygon* unsafe_arena_release_geopolygon();

  private:
  const ::anduril::entitymanager::v1::GeoPolygon& _internal_geopolygon() const;
  ::anduril::entitymanager::v1::GeoPolygon* _internal_mutable_geopolygon();

  public:
  // .anduril.entitymanager.v1.OriginalData original_data = 18 [json_name = "originalData"];
  bool has_original_data() const;
  void clear_original_data() ;
  const ::anduril::entitymanager::v1::OriginalData& original_data() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::OriginalData* release_original_data();
  ::anduril::entitymanager::v1::OriginalData* mutable_original_data();
  void set_allocated_original_data(::anduril::entitymanager::v1::OriginalData* value);
  void unsafe_arena_set_allocated_original_data(::anduril::entitymanager::v1::OriginalData* value);
  ::anduril::entitymanager::v1::OriginalData* unsafe_arena_release_original_data();

  private:
  const ::anduril::entitymanager::v1::OriginalData& _internal_original_data() const;
  ::anduril::entitymanager::v1::OriginalData* _internal_mutable_original_data();

  public:
  // .anduril.entitymanager.v1.Status status = 19 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::anduril::entitymanager::v1::Status& status() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Status* release_status();
  ::anduril::entitymanager::v1::Status* mutable_status();
  void set_allocated_status(::anduril::entitymanager::v1::Status* value);
  void unsafe_arena_set_allocated_status(::anduril::entitymanager::v1::Status* value);
  ::anduril::entitymanager::v1::Status* unsafe_arena_release_status();

  private:
  const ::anduril::entitymanager::v1::Status& _internal_status() const;
  ::anduril::entitymanager::v1::Status* _internal_mutable_status();

  public:
  // .anduril.entitymanager.v1.Sensors sensors = 20 [json_name = "sensors"];
  bool has_sensors() const;
  void clear_sensors() ;
  const ::anduril::entitymanager::v1::Sensors& sensors() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Sensors* release_sensors();
  ::anduril::entitymanager::v1::Sensors* mutable_sensors();
  void set_allocated_sensors(::anduril::entitymanager::v1::Sensors* value);
  void unsafe_arena_set_allocated_sensors(::anduril::entitymanager::v1::Sensors* value);
  ::anduril::entitymanager::v1::Sensors* unsafe_arena_release_sensors();

  private:
  const ::anduril::entitymanager::v1::Sensors& _internal_sensors() const;
  ::anduril::entitymanager::v1::Sensors* _internal_mutable_sensors();

  public:
  // .anduril.entitymanager.v1.Payloads payloads = 21 [json_name = "payloads"];
  bool has_payloads() const;
  void clear_payloads() ;
  const ::anduril::entitymanager::v1::Payloads& payloads() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Payloads* release_payloads();
  ::anduril::entitymanager::v1::Payloads* mutable_payloads();
  void set_allocated_payloads(::anduril::entitymanager::v1::Payloads* value);
  void unsafe_arena_set_allocated_payloads(::anduril::entitymanager::v1::Payloads* value);
  ::anduril::entitymanager::v1::Payloads* unsafe_arena_release_payloads();

  private:
  const ::anduril::entitymanager::v1::Payloads& _internal_payloads() const;
  ::anduril::entitymanager::v1::Payloads* _internal_mutable_payloads();

  public:
  // .anduril.entitymanager.v1.TargetPriority target_priority = 22 [json_name = "targetPriority"];
  bool has_target_priority() const;
  void clear_target_priority() ;
  const ::anduril::entitymanager::v1::TargetPriority& target_priority() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::TargetPriority* release_target_priority();
  ::anduril::entitymanager::v1::TargetPriority* mutable_target_priority();
  void set_allocated_target_priority(::anduril::entitymanager::v1::TargetPriority* value);
  void unsafe_arena_set_allocated_target_priority(::anduril::entitymanager::v1::TargetPriority* value);
  ::anduril::entitymanager::v1::TargetPriority* unsafe_arena_release_target_priority();

  private:
  const ::anduril::entitymanager::v1::TargetPriority& _internal_target_priority() const;
  ::anduril::entitymanager::v1::TargetPriority* _internal_mutable_target_priority();

  public:
  // .anduril.entitymanager.v1.GeoShape geo_shape = 23 [json_name = "geoShape"];
  bool has_geo_shape() const;
  void clear_geo_shape() ;
  const ::anduril::entitymanager::v1::GeoShape& geo_shape() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoShape* release_geo_shape();
  ::anduril::entitymanager::v1::GeoShape* mutable_geo_shape();
  void set_allocated_geo_shape(::anduril::entitymanager::v1::GeoShape* value);
  void unsafe_arena_set_allocated_geo_shape(::anduril::entitymanager::v1::GeoShape* value);
  ::anduril::entitymanager::v1::GeoShape* unsafe_arena_release_geo_shape();

  private:
  const ::anduril::entitymanager::v1::GeoShape& _internal_geo_shape() const;
  ::anduril::entitymanager::v1::GeoShape* _internal_mutable_geo_shape();

  public:
  // .anduril.entitymanager.v1.GeoDetails geo_details = 24 [json_name = "geoDetails"];
  bool has_geo_details() const;
  void clear_geo_details() ;
  const ::anduril::entitymanager::v1::GeoDetails& geo_details() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GeoDetails* release_geo_details();
  ::anduril::entitymanager::v1::GeoDetails* mutable_geo_details();
  void set_allocated_geo_details(::anduril::entitymanager::v1::GeoDetails* value);
  void unsafe_arena_set_allocated_geo_details(::anduril::entitymanager::v1::GeoDetails* value);
  ::anduril::entitymanager::v1::GeoDetails* unsafe_arena_release_geo_details();

  private:
  const ::anduril::entitymanager::v1::GeoDetails& _internal_geo_details() const;
  ::anduril::entitymanager::v1::GeoDetails* _internal_mutable_geo_details();

  public:
  // .anduril.entitymanager.v1.Signal signal = 25 [json_name = "signal"];
  bool has_signal() const;
  void clear_signal() ;
  const ::anduril::entitymanager::v1::Signal& signal() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Signal* release_signal();
  ::anduril::entitymanager::v1::Signal* mutable_signal();
  void set_allocated_signal(::anduril::entitymanager::v1::Signal* value);
  void unsafe_arena_set_allocated_signal(::anduril::entitymanager::v1::Signal* value);
  ::anduril::entitymanager::v1::Signal* unsafe_arena_release_signal();

  private:
  const ::anduril::entitymanager::v1::Signal& _internal_signal() const;
  ::anduril::entitymanager::v1::Signal* _internal_mutable_signal();

  public:
  // .anduril.entitymanager.v1.TransponderCodes transponder_codes = 26 [json_name = "transponderCodes"];
  bool has_transponder_codes() const;
  void clear_transponder_codes() ;
  const ::anduril::entitymanager::v1::TransponderCodes& transponder_codes() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::TransponderCodes* release_transponder_codes();
  ::anduril::entitymanager::v1::TransponderCodes* mutable_transponder_codes();
  void set_allocated_transponder_codes(::anduril::entitymanager::v1::TransponderCodes* value);
  void unsafe_arena_set_allocated_transponder_codes(::anduril::entitymanager::v1::TransponderCodes* value);
  ::anduril::entitymanager::v1::TransponderCodes* unsafe_arena_release_transponder_codes();

  private:
  const ::anduril::entitymanager::v1::TransponderCodes& _internal_transponder_codes() const;
  ::anduril::entitymanager::v1::TransponderCodes* _internal_mutable_transponder_codes();

  public:
  // .anduril.entitymanager.v1.ContactDetails contact = 27 [json_name = "contact"];
  bool has_contact() const;
  void clear_contact() ;
  const ::anduril::entitymanager::v1::ContactDetails& contact() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::ContactDetails* release_contact();
  ::anduril::entitymanager::v1::ContactDetails* mutable_contact();
  void set_allocated_contact(::anduril::entitymanager::v1::ContactDetails* value);
  void unsafe_arena_set_allocated_contact(::anduril::entitymanager::v1::ContactDetails* value);
  ::anduril::entitymanager::v1::ContactDetails* unsafe_arena_release_contact();

  private:
  const ::anduril::entitymanager::v1::ContactDetails& _internal_contact() const;
  ::anduril::entitymanager::v1::ContactDetails* _internal_mutable_contact();

  public:
  // .anduril.entitymanager.v1.Classification data_classification = 29 [json_name = "dataClassification"];
  bool has_data_classification() const;
  void clear_data_classification() ;
  const ::anduril::entitymanager::v1::Classification& data_classification() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Classification* release_data_classification();
  ::anduril::entitymanager::v1::Classification* mutable_data_classification();
  void set_allocated_data_classification(::anduril::entitymanager::v1::Classification* value);
  void unsafe_arena_set_allocated_data_classification(::anduril::entitymanager::v1::Classification* value);
  ::anduril::entitymanager::v1::Classification* unsafe_arena_release_data_classification();

  private:
  const ::anduril::entitymanager::v1::Classification& _internal_data_classification() const;
  ::anduril::entitymanager::v1::Classification* _internal_mutable_data_classification();

  public:
  // .anduril.entitymanager.v1.PowerState power_state = 30 [json_name = "powerState"];
  bool has_power_state() const;
  void clear_power_state() ;
  const ::anduril::entitymanager::v1::PowerState& power_state() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::PowerState* release_power_state();
  ::anduril::entitymanager::v1::PowerState* mutable_power_state();
  void set_allocated_power_state(::anduril::entitymanager::v1::PowerState* value);
  void unsafe_arena_set_allocated_power_state(::anduril::entitymanager::v1::PowerState* value);
  ::anduril::entitymanager::v1::PowerState* unsafe_arena_release_power_state();

  private:
  const ::anduril::entitymanager::v1::PowerState& _internal_power_state() const;
  ::anduril::entitymanager::v1::PowerState* _internal_mutable_power_state();

  public:
  // .anduril.tasks.v2.TaskCatalog task_catalog = 31 [json_name = "taskCatalog"];
  bool has_task_catalog() const;
  void clear_task_catalog() ;
  const ::anduril::tasks::v2::TaskCatalog& task_catalog() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::TaskCatalog* release_task_catalog();
  ::anduril::tasks::v2::TaskCatalog* mutable_task_catalog();
  void set_allocated_task_catalog(::anduril::tasks::v2::TaskCatalog* value);
  void unsafe_arena_set_allocated_task_catalog(::anduril::tasks::v2::TaskCatalog* value);
  ::anduril::tasks::v2::TaskCatalog* unsafe_arena_release_task_catalog();

  private:
  const ::anduril::tasks::v2::TaskCatalog& _internal_task_catalog() const;
  ::anduril::tasks::v2::TaskCatalog* _internal_mutable_task_catalog();

  public:
  // .anduril.entitymanager.v1.Media media = 32 [json_name = "media"];
  bool has_media() const;
  void clear_media() ;
  const ::anduril::entitymanager::v1::Media& media() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Media* release_media();
  ::anduril::entitymanager::v1::Media* mutable_media();
  void set_allocated_media(::anduril::entitymanager::v1::Media* value);
  void unsafe_arena_set_allocated_media(::anduril::entitymanager::v1::Media* value);
  ::anduril::entitymanager::v1::Media* unsafe_arena_release_media();

  private:
  const ::anduril::entitymanager::v1::Media& _internal_media() const;
  ::anduril::entitymanager::v1::Media* _internal_mutable_media();

  public:
  // .anduril.entitymanager.v1.Relationships relationships = 33 [json_name = "relationships"];
  bool has_relationships() const;
  void clear_relationships() ;
  const ::anduril::entitymanager::v1::Relationships& relationships() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Relationships* release_relationships();
  ::anduril::entitymanager::v1::Relationships* mutable_relationships();
  void set_allocated_relationships(::anduril::entitymanager::v1::Relationships* value);
  void unsafe_arena_set_allocated_relationships(::anduril::entitymanager::v1::Relationships* value);
  ::anduril::entitymanager::v1::Relationships* unsafe_arena_release_relationships();

  private:
  const ::anduril::entitymanager::v1::Relationships& _internal_relationships() const;
  ::anduril::entitymanager::v1::Relationships* _internal_mutable_relationships();

  public:
  // .anduril.entitymanager.v1.VisualDetails visual_details = 34 [json_name = "visualDetails"];
  bool has_visual_details() const;
  void clear_visual_details() ;
  const ::anduril::entitymanager::v1::VisualDetails& visual_details() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::VisualDetails* release_visual_details();
  ::anduril::entitymanager::v1::VisualDetails* mutable_visual_details();
  void set_allocated_visual_details(::anduril::entitymanager::v1::VisualDetails* value);
  void unsafe_arena_set_allocated_visual_details(::anduril::entitymanager::v1::VisualDetails* value);
  ::anduril::entitymanager::v1::VisualDetails* unsafe_arena_release_visual_details();

  private:
  const ::anduril::entitymanager::v1::VisualDetails& _internal_visual_details() const;
  ::anduril::entitymanager::v1::VisualDetails* _internal_mutable_visual_details();

  public:
  // .anduril.entitymanager.v1.PrototypeExtensions prototype_extensions = 35 [json_name = "prototypeExtensions"];
  bool has_prototype_extensions() const;
  void clear_prototype_extensions() ;
  const ::anduril::entitymanager::v1::PrototypeExtensions& prototype_extensions() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::PrototypeExtensions* release_prototype_extensions();
  ::anduril::entitymanager::v1::PrototypeExtensions* mutable_prototype_extensions();
  void set_allocated_prototype_extensions(::anduril::entitymanager::v1::PrototypeExtensions* value);
  void unsafe_arena_set_allocated_prototype_extensions(::anduril::entitymanager::v1::PrototypeExtensions* value);
  ::anduril::entitymanager::v1::PrototypeExtensions* unsafe_arena_release_prototype_extensions();

  private:
  const ::anduril::entitymanager::v1::PrototypeExtensions& _internal_prototype_extensions() const;
  ::anduril::entitymanager::v1::PrototypeExtensions* _internal_mutable_prototype_extensions();

  public:
  // .anduril.entitymanager.v1.Dimensions dimensions = 36 [json_name = "dimensions"];
  bool has_dimensions() const;
  void clear_dimensions() ;
  const ::anduril::entitymanager::v1::Dimensions& dimensions() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Dimensions* release_dimensions();
  ::anduril::entitymanager::v1::Dimensions* mutable_dimensions();
  void set_allocated_dimensions(::anduril::entitymanager::v1::Dimensions* value);
  void unsafe_arena_set_allocated_dimensions(::anduril::entitymanager::v1::Dimensions* value);
  ::anduril::entitymanager::v1::Dimensions* unsafe_arena_release_dimensions();

  private:
  const ::anduril::entitymanager::v1::Dimensions& _internal_dimensions() const;
  ::anduril::entitymanager::v1::Dimensions* _internal_mutable_dimensions();

  public:
  // .anduril.entitymanager.v1.RouteDetails route_details = 37 [json_name = "routeDetails"];
  bool has_route_details() const;
  void clear_route_details() ;
  const ::anduril::entitymanager::v1::RouteDetails& route_details() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::RouteDetails* release_route_details();
  ::anduril::entitymanager::v1::RouteDetails* mutable_route_details();
  void set_allocated_route_details(::anduril::entitymanager::v1::RouteDetails* value);
  void unsafe_arena_set_allocated_route_details(::anduril::entitymanager::v1::RouteDetails* value);
  ::anduril::entitymanager::v1::RouteDetails* unsafe_arena_release_route_details();

  private:
  const ::anduril::entitymanager::v1::RouteDetails& _internal_route_details() const;
  ::anduril::entitymanager::v1::RouteDetails* _internal_mutable_route_details();

  public:
  // .anduril.entitymanager.v1.Schedules schedules = 38 [json_name = "schedules"];
  bool has_schedules() const;
  void clear_schedules() ;
  const ::anduril::entitymanager::v1::Schedules& schedules() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Schedules* release_schedules();
  ::anduril::entitymanager::v1::Schedules* mutable_schedules();
  void set_allocated_schedules(::anduril::entitymanager::v1::Schedules* value);
  void unsafe_arena_set_allocated_schedules(::anduril::entitymanager::v1::Schedules* value);
  ::anduril::entitymanager::v1::Schedules* unsafe_arena_release_schedules();

  private:
  const ::anduril::entitymanager::v1::Schedules& _internal_schedules() const;
  ::anduril::entitymanager::v1::Schedules* _internal_mutable_schedules();

  public:
  // .anduril.entitymanager.v1.Health health = 39 [json_name = "health"];
  bool has_health() const;
  void clear_health() ;
  const ::anduril::entitymanager::v1::Health& health() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Health* release_health();
  ::anduril::entitymanager::v1::Health* mutable_health();
  void set_allocated_health(::anduril::entitymanager::v1::Health* value);
  void unsafe_arena_set_allocated_health(::anduril::entitymanager::v1::Health* value);
  ::anduril::entitymanager::v1::Health* unsafe_arena_release_health();

  private:
  const ::anduril::entitymanager::v1::Health& _internal_health() const;
  ::anduril::entitymanager::v1::Health* _internal_mutable_health();

  public:
  // .anduril.entitymanager.v1.GroupDetails group_details = 40 [json_name = "groupDetails"];
  bool has_group_details() const;
  void clear_group_details() ;
  const ::anduril::entitymanager::v1::GroupDetails& group_details() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::GroupDetails* release_group_details();
  ::anduril::entitymanager::v1::GroupDetails* mutable_group_details();
  void set_allocated_group_details(::anduril::entitymanager::v1::GroupDetails* value);
  void unsafe_arena_set_allocated_group_details(::anduril::entitymanager::v1::GroupDetails* value);
  ::anduril::entitymanager::v1::GroupDetails* unsafe_arena_release_group_details();

  private:
  const ::anduril::entitymanager::v1::GroupDetails& _internal_group_details() const;
  ::anduril::entitymanager::v1::GroupDetails* _internal_mutable_group_details();

  public:
  // .anduril.entitymanager.v1.TeamStatus team_status = 41 [json_name = "teamStatus"];
  bool has_team_status() const;
  void clear_team_status() ;
  const ::anduril::entitymanager::v1::TeamStatus& team_status() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::TeamStatus* release_team_status();
  ::anduril::entitymanager::v1::TeamStatus* mutable_team_status();
  void set_allocated_team_status(::anduril::entitymanager::v1::TeamStatus* value);
  void unsafe_arena_set_allocated_team_status(::anduril::entitymanager::v1::TeamStatus* value);
  ::anduril::entitymanager::v1::TeamStatus* unsafe_arena_release_team_status();

  private:
  const ::anduril::entitymanager::v1::TeamStatus& _internal_team_status() const;
  ::anduril::entitymanager::v1::TeamStatus* _internal_mutable_team_status();

  public:
  // .anduril.entitymanager.v1.Supplies supplies = 42 [json_name = "supplies"];
  bool has_supplies() const;
  void clear_supplies() ;
  const ::anduril::entitymanager::v1::Supplies& supplies() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Supplies* release_supplies();
  ::anduril::entitymanager::v1::Supplies* mutable_supplies();
  void set_allocated_supplies(::anduril::entitymanager::v1::Supplies* value);
  void unsafe_arena_set_allocated_supplies(::anduril::entitymanager::v1::Supplies* value);
  ::anduril::entitymanager::v1::Supplies* unsafe_arena_release_supplies();

  private:
  const ::anduril::entitymanager::v1::Supplies& _internal_supplies() const;
  ::anduril::entitymanager::v1::Supplies* _internal_mutable_supplies();

  public:
  // bool is_live = 3 [json_name = "isLive"];
  void clear_is_live() ;
  bool is_live() const;
  void set_is_live(bool value);

  private:
  bool _internal_is_live() const;
  void _internal_set_is_live(bool value);

  public:
  // bool no_expiry = 43 [json_name = "noExpiry"];
  void clear_no_expiry() ;
  bool no_expiry() const;
  void set_no_expiry(bool value);

  private:
  bool _internal_no_expiry() const;
  void _internal_set_no_expiry(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Entity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 41, 37,
      100, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<2> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::Timestamp* created_time_;
    ::google::protobuf::Timestamp* expiry_time_;
    ::anduril::entitymanager::v1::Location* location_;
    ::anduril::entitymanager::v1::Aliases* aliases_;
    ::anduril::entitymanager::v1::Tracked* tracked_;
    ::anduril::entitymanager::v1::Correlated* correlated_;
    ::anduril::entitymanager::v1::MilView* mil_view_;
    ::anduril::entitymanager::v1::Ontology* ontology_;
    ::anduril::entitymanager::v1::Provenance* provenance_;
    ::anduril::entitymanager::v1::Overrides* overrides_;
    ::anduril::entitymanager::v1::Indicators* indicators_;
    ::anduril::entitymanager::v1::LocationUncertainty* location_uncertainty_;
    ::anduril::entitymanager::v1::GeoPolygon* geopolygon_;
    ::anduril::entitymanager::v1::OriginalData* original_data_;
    ::anduril::entitymanager::v1::Status* status_;
    ::anduril::entitymanager::v1::Sensors* sensors_;
    ::anduril::entitymanager::v1::Payloads* payloads_;
    ::anduril::entitymanager::v1::TargetPriority* target_priority_;
    ::anduril::entitymanager::v1::GeoShape* geo_shape_;
    ::anduril::entitymanager::v1::GeoDetails* geo_details_;
    ::anduril::entitymanager::v1::Signal* signal_;
    ::anduril::entitymanager::v1::TransponderCodes* transponder_codes_;
    ::anduril::entitymanager::v1::ContactDetails* contact_;
    ::anduril::entitymanager::v1::Classification* data_classification_;
    ::anduril::entitymanager::v1::PowerState* power_state_;
    ::anduril::tasks::v2::TaskCatalog* task_catalog_;
    ::anduril::entitymanager::v1::Media* media_;
    ::anduril::entitymanager::v1::Relationships* relationships_;
    ::anduril::entitymanager::v1::VisualDetails* visual_details_;
    ::anduril::entitymanager::v1::PrototypeExtensions* prototype_extensions_;
    ::anduril::entitymanager::v1::Dimensions* dimensions_;
    ::anduril::entitymanager::v1::RouteDetails* route_details_;
    ::anduril::entitymanager::v1::Schedules* schedules_;
    ::anduril::entitymanager::v1::Health* health_;
    ::anduril::entitymanager::v1::GroupDetails* group_details_;
    ::anduril::entitymanager::v1::TeamStatus* team_status_;
    ::anduril::entitymanager::v1::Supplies* supplies_;
    bool is_live_;
    bool no_expiry_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class Override final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Override) */ {
 public:
  inline Override() : Override(nullptr) {}
  ~Override() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Override(::google::protobuf::internal::ConstantInitialized);

  inline Override(const Override& from)
      : Override(nullptr, from) {}
  Override(Override&& from) noexcept
    : Override() {
    *this = ::std::move(from);
  }

  inline Override& operator=(const Override& from) {
    CopyFrom(from);
    return *this;
  }
  inline Override& operator=(Override&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Override& default_instance() {
    return *internal_default_instance();
  }
  static inline const Override* internal_default_instance() {
    return reinterpret_cast<const Override*>(
               &_Override_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Override& a, Override& b) {
    a.Swap(&b);
  }
  inline void Swap(Override* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Override* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Override* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Override>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Override& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Override& from) {
    Override::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Override* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.Override";
  }
  protected:
  explicit Override(::google::protobuf::Arena* arena);
  Override(::google::protobuf::Arena* arena, const Override& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kFieldPathFieldNumber = 2,
    kMaskedFieldValueFieldNumber = 3,
    kProvenanceFieldNumber = 5,
    kRequestTimestampFieldNumber = 7,
    kStatusFieldNumber = 4,
    kTypeFieldNumber = 6,
  };
  // string request_id = 1 [json_name = "requestId"];
  void clear_request_id() ;
  const std::string& request_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* value);

  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(
      const std::string& value);
  std::string* _internal_mutable_request_id();

  public:
  // string field_path = 2 [json_name = "fieldPath"];
  void clear_field_path() ;
  const std::string& field_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_field_path(Arg_&& arg, Args_... args);
  std::string* mutable_field_path();
  PROTOBUF_NODISCARD std::string* release_field_path();
  void set_allocated_field_path(std::string* value);

  private:
  const std::string& _internal_field_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_path(
      const std::string& value);
  std::string* _internal_mutable_field_path();

  public:
  // .anduril.entitymanager.v1.Entity masked_field_value = 3 [json_name = "maskedFieldValue"];
  bool has_masked_field_value() const;
  void clear_masked_field_value() ;
  const ::anduril::entitymanager::v1::Entity& masked_field_value() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Entity* release_masked_field_value();
  ::anduril::entitymanager::v1::Entity* mutable_masked_field_value();
  void set_allocated_masked_field_value(::anduril::entitymanager::v1::Entity* value);
  void unsafe_arena_set_allocated_masked_field_value(::anduril::entitymanager::v1::Entity* value);
  ::anduril::entitymanager::v1::Entity* unsafe_arena_release_masked_field_value();

  private:
  const ::anduril::entitymanager::v1::Entity& _internal_masked_field_value() const;
  ::anduril::entitymanager::v1::Entity* _internal_mutable_masked_field_value();

  public:
  // .anduril.entitymanager.v1.Provenance provenance = 5 [json_name = "provenance"];
  bool has_provenance() const;
  void clear_provenance() ;
  const ::anduril::entitymanager::v1::Provenance& provenance() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Provenance* release_provenance();
  ::anduril::entitymanager::v1::Provenance* mutable_provenance();
  void set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  void unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value);
  ::anduril::entitymanager::v1::Provenance* unsafe_arena_release_provenance();

  private:
  const ::anduril::entitymanager::v1::Provenance& _internal_provenance() const;
  ::anduril::entitymanager::v1::Provenance* _internal_mutable_provenance();

  public:
  // .google.protobuf.Timestamp request_timestamp = 7 [json_name = "requestTimestamp"];
  bool has_request_timestamp() const;
  void clear_request_timestamp() ;
  const ::google::protobuf::Timestamp& request_timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_request_timestamp();
  ::google::protobuf::Timestamp* mutable_request_timestamp();
  void set_allocated_request_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_request_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_request_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_request_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_request_timestamp();

  public:
  // .anduril.entitymanager.v1.OverrideStatus status = 4 [json_name = "status"];
  void clear_status() ;
  ::anduril::entitymanager::v1::OverrideStatus status() const;
  void set_status(::anduril::entitymanager::v1::OverrideStatus value);

  private:
  ::anduril::entitymanager::v1::OverrideStatus _internal_status() const;
  void _internal_set_status(::anduril::entitymanager::v1::OverrideStatus value);

  public:
  // .anduril.entitymanager.v1.OverrideType type = 6 [json_name = "type"];
  void clear_type() ;
  ::anduril::entitymanager::v1::OverrideType type() const;
  void set_type(::anduril::entitymanager::v1::OverrideType value);

  private:
  ::anduril::entitymanager::v1::OverrideType _internal_type() const;
  void _internal_set_type(::anduril::entitymanager::v1::OverrideType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Override)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr request_id_;
    ::google::protobuf::internal::ArenaStringPtr field_path_;
    ::anduril::entitymanager::v1::Entity* masked_field_value_;
    ::anduril::entitymanager::v1::Provenance* provenance_;
    ::google::protobuf::Timestamp* request_timestamp_;
    int status_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class Overrides final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Overrides) */ {
 public:
  inline Overrides() : Overrides(nullptr) {}
  ~Overrides() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Overrides(::google::protobuf::internal::ConstantInitialized);

  inline Overrides(const Overrides& from)
      : Overrides(nullptr, from) {}
  Overrides(Overrides&& from) noexcept
    : Overrides() {
    *this = ::std::move(from);
  }

  inline Overrides& operator=(const Overrides& from) {
    CopyFrom(from);
    return *this;
  }
  inline Overrides& operator=(Overrides&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Overrides& default_instance() {
    return *internal_default_instance();
  }
  static inline const Overrides* internal_default_instance() {
    return reinterpret_cast<const Overrides*>(
               &_Overrides_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Overrides& a, Overrides& b) {
    a.Swap(&b);
  }
  inline void Swap(Overrides* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Overrides* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Overrides* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Overrides>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Overrides& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Overrides& from) {
    Overrides::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Overrides* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.Overrides";
  }
  protected:
  explicit Overrides(::google::protobuf::Arena* arena);
  Overrides(::google::protobuf::Arena* arena, const Overrides& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProvenanceFieldNumber = 1,
    kOverrideFieldNumber = 2,
  };
  // repeated .anduril.entitymanager.v1.OverrideProvenance provenance = 1 [json_name = "provenance", deprecated = true];
  [[deprecated]]  int provenance_size() const;
  private:
  int _internal_provenance_size() const;

  public:
  [[deprecated]]  void clear_provenance() ;
  [[deprecated]] ::anduril::entitymanager::v1::OverrideProvenance* mutable_provenance(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::OverrideProvenance >*
      mutable_provenance();
  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::OverrideProvenance>& _internal_provenance() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::OverrideProvenance>* _internal_mutable_provenance();
  public:
  [[deprecated]] const ::anduril::entitymanager::v1::OverrideProvenance& provenance(int index) const;
  [[deprecated]] ::anduril::entitymanager::v1::OverrideProvenance* add_provenance();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::OverrideProvenance >&
      provenance() const;
  // repeated .anduril.entitymanager.v1.Override override = 2 [json_name = "override"];
  int override_size() const;
  private:
  int _internal_override_size() const;

  public:
  void clear_override() ;
  ::anduril::entitymanager::v1::Override* mutable_override(int index);
  ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Override >*
      mutable_override();
  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>& _internal_override() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>* _internal_mutable_override();
  public:
  const ::anduril::entitymanager::v1::Override& override(int index) const;
  ::anduril::entitymanager::v1::Override* add_override();
  const ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Override >&
      override() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Overrides)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::OverrideProvenance > provenance_;
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Override > override_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};// -------------------------------------------------------------------

class Entities final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entitymanager.v1.Entities) */ {
 public:
  inline Entities() : Entities(nullptr) {}
  ~Entities() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Entities(::google::protobuf::internal::ConstantInitialized);

  inline Entities(const Entities& from)
      : Entities(nullptr, from) {}
  Entities(Entities&& from) noexcept
    : Entities() {
    *this = ::std::move(from);
  }

  inline Entities& operator=(const Entities& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entities& operator=(Entities&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entities& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entities* internal_default_instance() {
    return reinterpret_cast<const Entities*>(
               &_Entities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Entities& a, Entities& b) {
    a.Swap(&b);
  }
  inline void Swap(Entities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entities* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entities* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entities>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Entities& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Entities& from) {
    Entities::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Entities* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entitymanager.v1.Entities";
  }
  protected:
  explicit Entities(::google::protobuf::Arena* arena);
  Entities(::google::protobuf::Arena* arena, const Entities& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 1,
  };
  // repeated .anduril.entitymanager.v1.Entity entities = 1 [json_name = "entities"];
  int entities_size() const;
  private:
  int _internal_entities_size() const;

  public:
  void clear_entities() ;
  ::anduril::entitymanager::v1::Entity* mutable_entities(int index);
  ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Entity >*
      mutable_entities();
  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Entity>& _internal_entities() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Entity>* _internal_mutable_entities();
  public:
  const ::anduril::entitymanager::v1::Entity& entities(int index) const;
  ::anduril::entitymanager::v1::Entity* add_entities();
  const ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Entity >&
      entities() const;
  // @@protoc_insertion_point(class_scope:anduril.entitymanager.v1.Entities)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::anduril::entitymanager::v1::Entity > entities_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Entity

// string entity_id = 1 [json_name = "entityId"];
inline void Entity::clear_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& Entity::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Entity::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Entity.entity_id)
}
inline std::string* Entity::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.entity_id)
  return _s;
}
inline const std::string& Entity::_internal_entity_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entity_id_.Get();
}
inline void Entity::_internal_set_entity_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* Entity::_internal_mutable_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* Entity::release_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.entity_id)
  return _impl_.entity_id_.Release();
}
inline void Entity::set_allocated_entity_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entity_id_.IsDefault()) {
          _impl_.entity_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.entity_id)
}

// string description = 2 [json_name = "description"];
inline void Entity::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Entity::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Entity::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Entity.description)
}
inline std::string* Entity::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.description)
  return _s;
}
inline const std::string& Entity::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void Entity::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* Entity::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* Entity::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.description)
  return _impl_.description_.Release();
}
inline void Entity::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.description)
}

// bool is_live = 3 [json_name = "isLive"];
inline void Entity::clear_is_live() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_live_ = false;
}
inline bool Entity::is_live() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.is_live)
  return _internal_is_live();
}
inline void Entity::set_is_live(bool value) {
  _internal_set_is_live(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Entity.is_live)
}
inline bool Entity::_internal_is_live() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_live_;
}
inline void Entity::_internal_set_is_live(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_live_ = value;
}

// .google.protobuf.Timestamp created_time = 4 [json_name = "createdTime"];
inline bool Entity::has_created_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Entity::_internal_created_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Entity::created_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.created_time)
  return _internal_created_time();
}
inline void Entity::unsafe_arena_set_allocated_created_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_time_);
  }
  _impl_.created_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.created_time)
}
inline ::google::protobuf::Timestamp* Entity::release_created_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_time_;
  _impl_.created_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Entity::unsafe_arena_release_created_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.created_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_time_;
  _impl_.created_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Entity::_internal_mutable_created_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_time_;
}
inline ::google::protobuf::Timestamp* Entity::mutable_created_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_time();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.created_time)
  return _msg;
}
inline void Entity::set_allocated_created_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.created_time)
}

// .google.protobuf.Timestamp expiry_time = 5 [json_name = "expiryTime"];
inline bool Entity::has_expiry_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expiry_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Entity::_internal_expiry_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.expiry_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Entity::expiry_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.expiry_time)
  return _internal_expiry_time();
}
inline void Entity::unsafe_arena_set_allocated_expiry_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiry_time_);
  }
  _impl_.expiry_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.expiry_time)
}
inline ::google::protobuf::Timestamp* Entity::release_expiry_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.expiry_time_;
  _impl_.expiry_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Entity::unsafe_arena_release_expiry_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.expiry_time)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.expiry_time_;
  _impl_.expiry_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Entity::_internal_mutable_expiry_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.expiry_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.expiry_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.expiry_time_;
}
inline ::google::protobuf::Timestamp* Entity::mutable_expiry_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_expiry_time();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.expiry_time)
  return _msg;
}
inline void Entity::set_allocated_expiry_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiry_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.expiry_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.expiry_time)
}

// bool no_expiry = 43 [json_name = "noExpiry"];
inline void Entity::clear_no_expiry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.no_expiry_ = false;
}
inline bool Entity::no_expiry() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.no_expiry)
  return _internal_no_expiry();
}
inline void Entity::set_no_expiry(bool value) {
  _internal_set_no_expiry(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Entity.no_expiry)
}
inline bool Entity::_internal_no_expiry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.no_expiry_;
}
inline void Entity::_internal_set_no_expiry(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.no_expiry_ = value;
}

// .anduril.entitymanager.v1.Status status = 19 [json_name = "status"];
inline bool Entity::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void Entity::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::anduril::entitymanager::v1::Status& Entity::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Status&>(::anduril::entitymanager::v1::_Status_default_instance_);
}
inline const ::anduril::entitymanager::v1::Status& Entity::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.status)
  return _internal_status();
}
inline void Entity::unsafe_arena_set_allocated_status(::anduril::entitymanager::v1::Status* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::anduril::entitymanager::v1::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.status)
}
inline ::anduril::entitymanager::v1::Status* Entity::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::anduril::entitymanager::v1::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Status* Entity::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.status)

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::anduril::entitymanager::v1::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Status* Entity::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::anduril::entitymanager::v1::Status*>(p);
  }
  return _impl_.status_;
}
inline ::anduril::entitymanager::v1::Status* Entity::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.status)
  return _msg;
}
inline void Entity::set_allocated_status(::anduril::entitymanager::v1::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::Status*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::Status*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }

  _impl_.status_ = reinterpret_cast<::anduril::entitymanager::v1::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.status)
}

// .anduril.entitymanager.v1.Location location = 6 [json_name = "location"];
inline bool Entity::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Location& Entity::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Location* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Location&>(::anduril::entitymanager::v1::_Location_default_instance_);
}
inline const ::anduril::entitymanager::v1::Location& Entity::location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.location)
  return _internal_location();
}
inline void Entity::unsafe_arena_set_allocated_location(::anduril::entitymanager::v1::Location* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::anduril::entitymanager::v1::Location*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.location)
}
inline ::anduril::entitymanager::v1::Location* Entity::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::entitymanager::v1::Location* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Location* Entity::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.location)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::entitymanager::v1::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Location* Entity::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Location>(GetArena());
    _impl_.location_ = reinterpret_cast<::anduril::entitymanager::v1::Location*>(p);
  }
  return _impl_.location_;
}
inline ::anduril::entitymanager::v1::Location* Entity::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.location)
  return _msg;
}
inline void Entity::set_allocated_location(::anduril::entitymanager::v1::Location* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.location_ = reinterpret_cast<::anduril::entitymanager::v1::Location*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.location)
}

// .anduril.entitymanager.v1.LocationUncertainty location_uncertainty = 15 [json_name = "locationUncertainty"];
inline bool Entity::has_location_uncertainty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_uncertainty_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::LocationUncertainty& Entity::_internal_location_uncertainty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::LocationUncertainty* p = _impl_.location_uncertainty_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::LocationUncertainty&>(::anduril::entitymanager::v1::_LocationUncertainty_default_instance_);
}
inline const ::anduril::entitymanager::v1::LocationUncertainty& Entity::location_uncertainty() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.location_uncertainty)
  return _internal_location_uncertainty();
}
inline void Entity::unsafe_arena_set_allocated_location_uncertainty(::anduril::entitymanager::v1::LocationUncertainty* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_uncertainty_);
  }
  _impl_.location_uncertainty_ = reinterpret_cast<::anduril::entitymanager::v1::LocationUncertainty*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.location_uncertainty)
}
inline ::anduril::entitymanager::v1::LocationUncertainty* Entity::release_location_uncertainty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::anduril::entitymanager::v1::LocationUncertainty* released = _impl_.location_uncertainty_;
  _impl_.location_uncertainty_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::LocationUncertainty* Entity::unsafe_arena_release_location_uncertainty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.location_uncertainty)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::anduril::entitymanager::v1::LocationUncertainty* temp = _impl_.location_uncertainty_;
  _impl_.location_uncertainty_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::LocationUncertainty* Entity::_internal_mutable_location_uncertainty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.location_uncertainty_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::LocationUncertainty>(GetArena());
    _impl_.location_uncertainty_ = reinterpret_cast<::anduril::entitymanager::v1::LocationUncertainty*>(p);
  }
  return _impl_.location_uncertainty_;
}
inline ::anduril::entitymanager::v1::LocationUncertainty* Entity::mutable_location_uncertainty() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::LocationUncertainty* _msg = _internal_mutable_location_uncertainty();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.location_uncertainty)
  return _msg;
}
inline void Entity::set_allocated_location_uncertainty(::anduril::entitymanager::v1::LocationUncertainty* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_uncertainty_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.location_uncertainty_ = reinterpret_cast<::anduril::entitymanager::v1::LocationUncertainty*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.location_uncertainty)
}

// .anduril.entitymanager.v1.GeoPolygon geopolygon = 17 [json_name = "geopolygon", deprecated = true];
inline bool Entity::has_geopolygon() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geopolygon_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::GeoPolygon& Entity::_internal_geopolygon() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::GeoPolygon* p = _impl_.geopolygon_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::GeoPolygon&>(::anduril::entitymanager::v1::_GeoPolygon_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoPolygon& Entity::geopolygon() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.geopolygon)
  return _internal_geopolygon();
}
inline void Entity::unsafe_arena_set_allocated_geopolygon(::anduril::entitymanager::v1::GeoPolygon* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geopolygon_);
  }
  _impl_.geopolygon_ = reinterpret_cast<::anduril::entitymanager::v1::GeoPolygon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.geopolygon)
}
inline ::anduril::entitymanager::v1::GeoPolygon* Entity::release_geopolygon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::anduril::entitymanager::v1::GeoPolygon* released = _impl_.geopolygon_;
  _impl_.geopolygon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::GeoPolygon* Entity::unsafe_arena_release_geopolygon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.geopolygon)

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::anduril::entitymanager::v1::GeoPolygon* temp = _impl_.geopolygon_;
  _impl_.geopolygon_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::GeoPolygon* Entity::_internal_mutable_geopolygon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.geopolygon_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::GeoPolygon>(GetArena());
    _impl_.geopolygon_ = reinterpret_cast<::anduril::entitymanager::v1::GeoPolygon*>(p);
  }
  return _impl_.geopolygon_;
}
inline ::anduril::entitymanager::v1::GeoPolygon* Entity::mutable_geopolygon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoPolygon* _msg = _internal_mutable_geopolygon();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.geopolygon)
  return _msg;
}
inline void Entity::set_allocated_geopolygon(::anduril::entitymanager::v1::GeoPolygon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geopolygon_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }

  _impl_.geopolygon_ = reinterpret_cast<::anduril::entitymanager::v1::GeoPolygon*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.geopolygon)
}

// .anduril.entitymanager.v1.GeoShape geo_shape = 23 [json_name = "geoShape"];
inline bool Entity::has_geo_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geo_shape_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::GeoShape& Entity::_internal_geo_shape() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::GeoShape* p = _impl_.geo_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::GeoShape&>(::anduril::entitymanager::v1::_GeoShape_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoShape& Entity::geo_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.geo_shape)
  return _internal_geo_shape();
}
inline void Entity::unsafe_arena_set_allocated_geo_shape(::anduril::entitymanager::v1::GeoShape* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_shape_);
  }
  _impl_.geo_shape_ = reinterpret_cast<::anduril::entitymanager::v1::GeoShape*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.geo_shape)
}
inline ::anduril::entitymanager::v1::GeoShape* Entity::release_geo_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00040000u;
  ::anduril::entitymanager::v1::GeoShape* released = _impl_.geo_shape_;
  _impl_.geo_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::GeoShape* Entity::unsafe_arena_release_geo_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.geo_shape)

  _impl_._has_bits_[0] &= ~0x00040000u;
  ::anduril::entitymanager::v1::GeoShape* temp = _impl_.geo_shape_;
  _impl_.geo_shape_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::GeoShape* Entity::_internal_mutable_geo_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.geo_shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::GeoShape>(GetArena());
    _impl_.geo_shape_ = reinterpret_cast<::anduril::entitymanager::v1::GeoShape*>(p);
  }
  return _impl_.geo_shape_;
}
inline ::anduril::entitymanager::v1::GeoShape* Entity::mutable_geo_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoShape* _msg = _internal_mutable_geo_shape();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.geo_shape)
  return _msg;
}
inline void Entity::set_allocated_geo_shape(::anduril::entitymanager::v1::GeoShape* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }

  _impl_.geo_shape_ = reinterpret_cast<::anduril::entitymanager::v1::GeoShape*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.geo_shape)
}

// .anduril.entitymanager.v1.GeoDetails geo_details = 24 [json_name = "geoDetails"];
inline bool Entity::has_geo_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geo_details_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::GeoDetails& Entity::_internal_geo_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::GeoDetails* p = _impl_.geo_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::GeoDetails&>(::anduril::entitymanager::v1::_GeoDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::GeoDetails& Entity::geo_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.geo_details)
  return _internal_geo_details();
}
inline void Entity::unsafe_arena_set_allocated_geo_details(::anduril::entitymanager::v1::GeoDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_details_);
  }
  _impl_.geo_details_ = reinterpret_cast<::anduril::entitymanager::v1::GeoDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.geo_details)
}
inline ::anduril::entitymanager::v1::GeoDetails* Entity::release_geo_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00080000u;
  ::anduril::entitymanager::v1::GeoDetails* released = _impl_.geo_details_;
  _impl_.geo_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::GeoDetails* Entity::unsafe_arena_release_geo_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.geo_details)

  _impl_._has_bits_[0] &= ~0x00080000u;
  ::anduril::entitymanager::v1::GeoDetails* temp = _impl_.geo_details_;
  _impl_.geo_details_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::GeoDetails* Entity::_internal_mutable_geo_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.geo_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::GeoDetails>(GetArena());
    _impl_.geo_details_ = reinterpret_cast<::anduril::entitymanager::v1::GeoDetails*>(p);
  }
  return _impl_.geo_details_;
}
inline ::anduril::entitymanager::v1::GeoDetails* Entity::mutable_geo_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GeoDetails* _msg = _internal_mutable_geo_details();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.geo_details)
  return _msg;
}
inline void Entity::set_allocated_geo_details(::anduril::entitymanager::v1::GeoDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }

  _impl_.geo_details_ = reinterpret_cast<::anduril::entitymanager::v1::GeoDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.geo_details)
}

// .anduril.entitymanager.v1.Aliases aliases = 7 [json_name = "aliases"];
inline bool Entity::has_aliases() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.aliases_ != nullptr);
  return value;
}
inline void Entity::clear_aliases() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.aliases_ != nullptr) _impl_.aliases_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::anduril::entitymanager::v1::Aliases& Entity::_internal_aliases() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Aliases* p = _impl_.aliases_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Aliases&>(::anduril::entitymanager::v1::_Aliases_default_instance_);
}
inline const ::anduril::entitymanager::v1::Aliases& Entity::aliases() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.aliases)
  return _internal_aliases();
}
inline void Entity::unsafe_arena_set_allocated_aliases(::anduril::entitymanager::v1::Aliases* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.aliases_);
  }
  _impl_.aliases_ = reinterpret_cast<::anduril::entitymanager::v1::Aliases*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.aliases)
}
inline ::anduril::entitymanager::v1::Aliases* Entity::release_aliases() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::entitymanager::v1::Aliases* released = _impl_.aliases_;
  _impl_.aliases_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Aliases* Entity::unsafe_arena_release_aliases() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.aliases)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::entitymanager::v1::Aliases* temp = _impl_.aliases_;
  _impl_.aliases_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Aliases* Entity::_internal_mutable_aliases() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.aliases_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Aliases>(GetArena());
    _impl_.aliases_ = reinterpret_cast<::anduril::entitymanager::v1::Aliases*>(p);
  }
  return _impl_.aliases_;
}
inline ::anduril::entitymanager::v1::Aliases* Entity::mutable_aliases() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Aliases* _msg = _internal_mutable_aliases();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.aliases)
  return _msg;
}
inline void Entity::set_allocated_aliases(::anduril::entitymanager::v1::Aliases* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::Aliases*>(_impl_.aliases_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::Aliases*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.aliases_ = reinterpret_cast<::anduril::entitymanager::v1::Aliases*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.aliases)
}

// .anduril.entitymanager.v1.Tracked tracked = 8 [json_name = "tracked"];
inline bool Entity::has_tracked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tracked_ != nullptr);
  return value;
}
inline void Entity::clear_tracked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tracked_ != nullptr) _impl_.tracked_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::anduril::entitymanager::v1::Tracked& Entity::_internal_tracked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Tracked* p = _impl_.tracked_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Tracked&>(::anduril::entitymanager::v1::_Tracked_default_instance_);
}
inline const ::anduril::entitymanager::v1::Tracked& Entity::tracked() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.tracked)
  return _internal_tracked();
}
inline void Entity::unsafe_arena_set_allocated_tracked(::anduril::entitymanager::v1::Tracked* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tracked_);
  }
  _impl_.tracked_ = reinterpret_cast<::anduril::entitymanager::v1::Tracked*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.tracked)
}
inline ::anduril::entitymanager::v1::Tracked* Entity::release_tracked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::anduril::entitymanager::v1::Tracked* released = _impl_.tracked_;
  _impl_.tracked_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Tracked* Entity::unsafe_arena_release_tracked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.tracked)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::anduril::entitymanager::v1::Tracked* temp = _impl_.tracked_;
  _impl_.tracked_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Tracked* Entity::_internal_mutable_tracked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.tracked_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Tracked>(GetArena());
    _impl_.tracked_ = reinterpret_cast<::anduril::entitymanager::v1::Tracked*>(p);
  }
  return _impl_.tracked_;
}
inline ::anduril::entitymanager::v1::Tracked* Entity::mutable_tracked() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Tracked* _msg = _internal_mutable_tracked();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.tracked)
  return _msg;
}
inline void Entity::set_allocated_tracked(::anduril::entitymanager::v1::Tracked* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::Tracked*>(_impl_.tracked_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::Tracked*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.tracked_ = reinterpret_cast<::anduril::entitymanager::v1::Tracked*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.tracked)
}

// .anduril.entitymanager.v1.Correlated correlated = 9 [json_name = "correlated"];
inline bool Entity::has_correlated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.correlated_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Correlated& Entity::_internal_correlated() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Correlated* p = _impl_.correlated_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Correlated&>(::anduril::entitymanager::v1::_Correlated_default_instance_);
}
inline const ::anduril::entitymanager::v1::Correlated& Entity::correlated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.correlated)
  return _internal_correlated();
}
inline void Entity::unsafe_arena_set_allocated_correlated(::anduril::entitymanager::v1::Correlated* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.correlated_);
  }
  _impl_.correlated_ = reinterpret_cast<::anduril::entitymanager::v1::Correlated*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.correlated)
}
inline ::anduril::entitymanager::v1::Correlated* Entity::release_correlated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::anduril::entitymanager::v1::Correlated* released = _impl_.correlated_;
  _impl_.correlated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Correlated* Entity::unsafe_arena_release_correlated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.correlated)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::anduril::entitymanager::v1::Correlated* temp = _impl_.correlated_;
  _impl_.correlated_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Correlated* Entity::_internal_mutable_correlated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.correlated_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Correlated>(GetArena());
    _impl_.correlated_ = reinterpret_cast<::anduril::entitymanager::v1::Correlated*>(p);
  }
  return _impl_.correlated_;
}
inline ::anduril::entitymanager::v1::Correlated* Entity::mutable_correlated() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Correlated* _msg = _internal_mutable_correlated();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.correlated)
  return _msg;
}
inline void Entity::set_allocated_correlated(::anduril::entitymanager::v1::Correlated* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.correlated_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.correlated_ = reinterpret_cast<::anduril::entitymanager::v1::Correlated*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.correlated)
}

// .anduril.entitymanager.v1.MilView mil_view = 10 [json_name = "milView"];
inline bool Entity::has_mil_view() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mil_view_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::MilView& Entity::_internal_mil_view() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::MilView* p = _impl_.mil_view_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::MilView&>(::anduril::entitymanager::v1::_MilView_default_instance_);
}
inline const ::anduril::entitymanager::v1::MilView& Entity::mil_view() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.mil_view)
  return _internal_mil_view();
}
inline void Entity::unsafe_arena_set_allocated_mil_view(::anduril::entitymanager::v1::MilView* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mil_view_);
  }
  _impl_.mil_view_ = reinterpret_cast<::anduril::entitymanager::v1::MilView*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.mil_view)
}
inline ::anduril::entitymanager::v1::MilView* Entity::release_mil_view() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::anduril::entitymanager::v1::MilView* released = _impl_.mil_view_;
  _impl_.mil_view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::MilView* Entity::unsafe_arena_release_mil_view() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.mil_view)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::anduril::entitymanager::v1::MilView* temp = _impl_.mil_view_;
  _impl_.mil_view_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::MilView* Entity::_internal_mutable_mil_view() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.mil_view_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::MilView>(GetArena());
    _impl_.mil_view_ = reinterpret_cast<::anduril::entitymanager::v1::MilView*>(p);
  }
  return _impl_.mil_view_;
}
inline ::anduril::entitymanager::v1::MilView* Entity::mutable_mil_view() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::MilView* _msg = _internal_mutable_mil_view();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.mil_view)
  return _msg;
}
inline void Entity::set_allocated_mil_view(::anduril::entitymanager::v1::MilView* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mil_view_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.mil_view_ = reinterpret_cast<::anduril::entitymanager::v1::MilView*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.mil_view)
}

// .anduril.entitymanager.v1.Ontology ontology = 11 [json_name = "ontology"];
inline bool Entity::has_ontology() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ontology_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Ontology& Entity::_internal_ontology() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Ontology* p = _impl_.ontology_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Ontology&>(::anduril::entitymanager::v1::_Ontology_default_instance_);
}
inline const ::anduril::entitymanager::v1::Ontology& Entity::ontology() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.ontology)
  return _internal_ontology();
}
inline void Entity::unsafe_arena_set_allocated_ontology(::anduril::entitymanager::v1::Ontology* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ontology_);
  }
  _impl_.ontology_ = reinterpret_cast<::anduril::entitymanager::v1::Ontology*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.ontology)
}
inline ::anduril::entitymanager::v1::Ontology* Entity::release_ontology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::anduril::entitymanager::v1::Ontology* released = _impl_.ontology_;
  _impl_.ontology_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Ontology* Entity::unsafe_arena_release_ontology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.ontology)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::anduril::entitymanager::v1::Ontology* temp = _impl_.ontology_;
  _impl_.ontology_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Ontology* Entity::_internal_mutable_ontology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.ontology_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Ontology>(GetArena());
    _impl_.ontology_ = reinterpret_cast<::anduril::entitymanager::v1::Ontology*>(p);
  }
  return _impl_.ontology_;
}
inline ::anduril::entitymanager::v1::Ontology* Entity::mutable_ontology() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Ontology* _msg = _internal_mutable_ontology();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.ontology)
  return _msg;
}
inline void Entity::set_allocated_ontology(::anduril::entitymanager::v1::Ontology* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ontology_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.ontology_ = reinterpret_cast<::anduril::entitymanager::v1::Ontology*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.ontology)
}

// .anduril.entitymanager.v1.Sensors sensors = 20 [json_name = "sensors"];
inline bool Entity::has_sensors() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sensors_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Sensors& Entity::_internal_sensors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Sensors* p = _impl_.sensors_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Sensors&>(::anduril::entitymanager::v1::_Sensors_default_instance_);
}
inline const ::anduril::entitymanager::v1::Sensors& Entity::sensors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.sensors)
  return _internal_sensors();
}
inline void Entity::unsafe_arena_set_allocated_sensors(::anduril::entitymanager::v1::Sensors* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensors_);
  }
  _impl_.sensors_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.sensors)
}
inline ::anduril::entitymanager::v1::Sensors* Entity::release_sensors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::anduril::entitymanager::v1::Sensors* released = _impl_.sensors_;
  _impl_.sensors_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Sensors* Entity::unsafe_arena_release_sensors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.sensors)

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::anduril::entitymanager::v1::Sensors* temp = _impl_.sensors_;
  _impl_.sensors_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Sensors* Entity::_internal_mutable_sensors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.sensors_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Sensors>(GetArena());
    _impl_.sensors_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(p);
  }
  return _impl_.sensors_;
}
inline ::anduril::entitymanager::v1::Sensors* Entity::mutable_sensors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Sensors* _msg = _internal_mutable_sensors();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.sensors)
  return _msg;
}
inline void Entity::set_allocated_sensors(::anduril::entitymanager::v1::Sensors* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }

  _impl_.sensors_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.sensors)
}

// .anduril.entitymanager.v1.Payloads payloads = 21 [json_name = "payloads"];
inline bool Entity::has_payloads() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payloads_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Payloads& Entity::_internal_payloads() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Payloads* p = _impl_.payloads_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Payloads&>(::anduril::entitymanager::v1::_Payloads_default_instance_);
}
inline const ::anduril::entitymanager::v1::Payloads& Entity::payloads() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.payloads)
  return _internal_payloads();
}
inline void Entity::unsafe_arena_set_allocated_payloads(::anduril::entitymanager::v1::Payloads* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payloads_);
  }
  _impl_.payloads_ = reinterpret_cast<::anduril::entitymanager::v1::Payloads*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.payloads)
}
inline ::anduril::entitymanager::v1::Payloads* Entity::release_payloads() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00010000u;
  ::anduril::entitymanager::v1::Payloads* released = _impl_.payloads_;
  _impl_.payloads_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Payloads* Entity::unsafe_arena_release_payloads() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.payloads)

  _impl_._has_bits_[0] &= ~0x00010000u;
  ::anduril::entitymanager::v1::Payloads* temp = _impl_.payloads_;
  _impl_.payloads_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Payloads* Entity::_internal_mutable_payloads() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.payloads_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Payloads>(GetArena());
    _impl_.payloads_ = reinterpret_cast<::anduril::entitymanager::v1::Payloads*>(p);
  }
  return _impl_.payloads_;
}
inline ::anduril::entitymanager::v1::Payloads* Entity::mutable_payloads() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Payloads* _msg = _internal_mutable_payloads();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.payloads)
  return _msg;
}
inline void Entity::set_allocated_payloads(::anduril::entitymanager::v1::Payloads* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payloads_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }

  _impl_.payloads_ = reinterpret_cast<::anduril::entitymanager::v1::Payloads*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.payloads)
}

// .anduril.entitymanager.v1.PowerState power_state = 30 [json_name = "powerState"];
inline bool Entity::has_power_state() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.power_state_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::PowerState& Entity::_internal_power_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::PowerState* p = _impl_.power_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::PowerState&>(::anduril::entitymanager::v1::_PowerState_default_instance_);
}
inline const ::anduril::entitymanager::v1::PowerState& Entity::power_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.power_state)
  return _internal_power_state();
}
inline void Entity::unsafe_arena_set_allocated_power_state(::anduril::entitymanager::v1::PowerState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.power_state_);
  }
  _impl_.power_state_ = reinterpret_cast<::anduril::entitymanager::v1::PowerState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.power_state)
}
inline ::anduril::entitymanager::v1::PowerState* Entity::release_power_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x01000000u;
  ::anduril::entitymanager::v1::PowerState* released = _impl_.power_state_;
  _impl_.power_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::PowerState* Entity::unsafe_arena_release_power_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.power_state)

  _impl_._has_bits_[0] &= ~0x01000000u;
  ::anduril::entitymanager::v1::PowerState* temp = _impl_.power_state_;
  _impl_.power_state_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::PowerState* Entity::_internal_mutable_power_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x01000000u;
  if (_impl_.power_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::PowerState>(GetArena());
    _impl_.power_state_ = reinterpret_cast<::anduril::entitymanager::v1::PowerState*>(p);
  }
  return _impl_.power_state_;
}
inline ::anduril::entitymanager::v1::PowerState* Entity::mutable_power_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::PowerState* _msg = _internal_mutable_power_state();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.power_state)
  return _msg;
}
inline void Entity::set_allocated_power_state(::anduril::entitymanager::v1::PowerState* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.power_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }

  _impl_.power_state_ = reinterpret_cast<::anduril::entitymanager::v1::PowerState*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.power_state)
}

// .anduril.entitymanager.v1.Provenance provenance = 12 [json_name = "provenance"];
inline bool Entity::has_provenance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.provenance_ != nullptr);
  return value;
}
inline void Entity::clear_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.provenance_ != nullptr) _impl_.provenance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::anduril::entitymanager::v1::Provenance& Entity::_internal_provenance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Provenance* p = _impl_.provenance_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Provenance&>(::anduril::entitymanager::v1::_Provenance_default_instance_);
}
inline const ::anduril::entitymanager::v1::Provenance& Entity::provenance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.provenance)
  return _internal_provenance();
}
inline void Entity::unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.provenance_);
  }
  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.provenance)
}
inline ::anduril::entitymanager::v1::Provenance* Entity::release_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::anduril::entitymanager::v1::Provenance* released = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Provenance* Entity::unsafe_arena_release_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.provenance)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::anduril::entitymanager::v1::Provenance* temp = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Provenance* Entity::_internal_mutable_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.provenance_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Provenance>(GetArena());
    _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(p);
  }
  return _impl_.provenance_;
}
inline ::anduril::entitymanager::v1::Provenance* Entity::mutable_provenance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Provenance* _msg = _internal_mutable_provenance();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.provenance)
  return _msg;
}
inline void Entity::set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(_impl_.provenance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.provenance)
}

// .anduril.entitymanager.v1.Overrides overrides = 13 [json_name = "overrides"];
inline bool Entity::has_overrides() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.overrides_ != nullptr);
  return value;
}
inline void Entity::clear_overrides() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.overrides_ != nullptr) _impl_.overrides_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::anduril::entitymanager::v1::Overrides& Entity::_internal_overrides() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Overrides* p = _impl_.overrides_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Overrides&>(::anduril::entitymanager::v1::_Overrides_default_instance_);
}
inline const ::anduril::entitymanager::v1::Overrides& Entity::overrides() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.overrides)
  return _internal_overrides();
}
inline void Entity::unsafe_arena_set_allocated_overrides(::anduril::entitymanager::v1::Overrides* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.overrides_);
  }
  _impl_.overrides_ = reinterpret_cast<::anduril::entitymanager::v1::Overrides*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.overrides)
}
inline ::anduril::entitymanager::v1::Overrides* Entity::release_overrides() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::anduril::entitymanager::v1::Overrides* released = _impl_.overrides_;
  _impl_.overrides_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Overrides* Entity::unsafe_arena_release_overrides() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.overrides)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::anduril::entitymanager::v1::Overrides* temp = _impl_.overrides_;
  _impl_.overrides_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Overrides* Entity::_internal_mutable_overrides() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.overrides_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Overrides>(GetArena());
    _impl_.overrides_ = reinterpret_cast<::anduril::entitymanager::v1::Overrides*>(p);
  }
  return _impl_.overrides_;
}
inline ::anduril::entitymanager::v1::Overrides* Entity::mutable_overrides() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Overrides* _msg = _internal_mutable_overrides();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.overrides)
  return _msg;
}
inline void Entity::set_allocated_overrides(::anduril::entitymanager::v1::Overrides* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::Overrides*>(_impl_.overrides_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::Overrides*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.overrides_ = reinterpret_cast<::anduril::entitymanager::v1::Overrides*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.overrides)
}

// .anduril.entitymanager.v1.Indicators indicators = 14 [json_name = "indicators"];
inline bool Entity::has_indicators() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.indicators_ != nullptr);
  return value;
}
inline void Entity::clear_indicators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.indicators_ != nullptr) _impl_.indicators_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::anduril::entitymanager::v1::Indicators& Entity::_internal_indicators() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Indicators* p = _impl_.indicators_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Indicators&>(::anduril::entitymanager::v1::_Indicators_default_instance_);
}
inline const ::anduril::entitymanager::v1::Indicators& Entity::indicators() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.indicators)
  return _internal_indicators();
}
inline void Entity::unsafe_arena_set_allocated_indicators(::anduril::entitymanager::v1::Indicators* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indicators_);
  }
  _impl_.indicators_ = reinterpret_cast<::anduril::entitymanager::v1::Indicators*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.indicators)
}
inline ::anduril::entitymanager::v1::Indicators* Entity::release_indicators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::anduril::entitymanager::v1::Indicators* released = _impl_.indicators_;
  _impl_.indicators_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Indicators* Entity::unsafe_arena_release_indicators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.indicators)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::anduril::entitymanager::v1::Indicators* temp = _impl_.indicators_;
  _impl_.indicators_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Indicators* Entity::_internal_mutable_indicators() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.indicators_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Indicators>(GetArena());
    _impl_.indicators_ = reinterpret_cast<::anduril::entitymanager::v1::Indicators*>(p);
  }
  return _impl_.indicators_;
}
inline ::anduril::entitymanager::v1::Indicators* Entity::mutable_indicators() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Indicators* _msg = _internal_mutable_indicators();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.indicators)
  return _msg;
}
inline void Entity::set_allocated_indicators(::anduril::entitymanager::v1::Indicators* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::Indicators*>(_impl_.indicators_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::Indicators*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.indicators_ = reinterpret_cast<::anduril::entitymanager::v1::Indicators*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.indicators)
}

// .anduril.entitymanager.v1.OriginalData original_data = 18 [json_name = "originalData"];
inline bool Entity::has_original_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.original_data_ != nullptr);
  return value;
}
inline void Entity::clear_original_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.original_data_ != nullptr) _impl_.original_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::anduril::entitymanager::v1::OriginalData& Entity::_internal_original_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::OriginalData* p = _impl_.original_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::OriginalData&>(::anduril::entitymanager::v1::_OriginalData_default_instance_);
}
inline const ::anduril::entitymanager::v1::OriginalData& Entity::original_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.original_data)
  return _internal_original_data();
}
inline void Entity::unsafe_arena_set_allocated_original_data(::anduril::entitymanager::v1::OriginalData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.original_data_);
  }
  _impl_.original_data_ = reinterpret_cast<::anduril::entitymanager::v1::OriginalData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.original_data)
}
inline ::anduril::entitymanager::v1::OriginalData* Entity::release_original_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::anduril::entitymanager::v1::OriginalData* released = _impl_.original_data_;
  _impl_.original_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::OriginalData* Entity::unsafe_arena_release_original_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.original_data)

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::anduril::entitymanager::v1::OriginalData* temp = _impl_.original_data_;
  _impl_.original_data_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::OriginalData* Entity::_internal_mutable_original_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.original_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::OriginalData>(GetArena());
    _impl_.original_data_ = reinterpret_cast<::anduril::entitymanager::v1::OriginalData*>(p);
  }
  return _impl_.original_data_;
}
inline ::anduril::entitymanager::v1::OriginalData* Entity::mutable_original_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::OriginalData* _msg = _internal_mutable_original_data();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.original_data)
  return _msg;
}
inline void Entity::set_allocated_original_data(::anduril::entitymanager::v1::OriginalData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::OriginalData*>(_impl_.original_data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::OriginalData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }

  _impl_.original_data_ = reinterpret_cast<::anduril::entitymanager::v1::OriginalData*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.original_data)
}

// .anduril.entitymanager.v1.TargetPriority target_priority = 22 [json_name = "targetPriority"];
inline bool Entity::has_target_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_priority_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::TargetPriority& Entity::_internal_target_priority() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::TargetPriority* p = _impl_.target_priority_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::TargetPriority&>(::anduril::entitymanager::v1::_TargetPriority_default_instance_);
}
inline const ::anduril::entitymanager::v1::TargetPriority& Entity::target_priority() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.target_priority)
  return _internal_target_priority();
}
inline void Entity::unsafe_arena_set_allocated_target_priority(::anduril::entitymanager::v1::TargetPriority* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_priority_);
  }
  _impl_.target_priority_ = reinterpret_cast<::anduril::entitymanager::v1::TargetPriority*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.target_priority)
}
inline ::anduril::entitymanager::v1::TargetPriority* Entity::release_target_priority() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00020000u;
  ::anduril::entitymanager::v1::TargetPriority* released = _impl_.target_priority_;
  _impl_.target_priority_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::TargetPriority* Entity::unsafe_arena_release_target_priority() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.target_priority)

  _impl_._has_bits_[0] &= ~0x00020000u;
  ::anduril::entitymanager::v1::TargetPriority* temp = _impl_.target_priority_;
  _impl_.target_priority_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::TargetPriority* Entity::_internal_mutable_target_priority() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.target_priority_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::TargetPriority>(GetArena());
    _impl_.target_priority_ = reinterpret_cast<::anduril::entitymanager::v1::TargetPriority*>(p);
  }
  return _impl_.target_priority_;
}
inline ::anduril::entitymanager::v1::TargetPriority* Entity::mutable_target_priority() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::TargetPriority* _msg = _internal_mutable_target_priority();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.target_priority)
  return _msg;
}
inline void Entity::set_allocated_target_priority(::anduril::entitymanager::v1::TargetPriority* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_priority_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }

  _impl_.target_priority_ = reinterpret_cast<::anduril::entitymanager::v1::TargetPriority*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.target_priority)
}

// .anduril.entitymanager.v1.Signal signal = 25 [json_name = "signal"];
inline bool Entity::has_signal() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.signal_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Signal& Entity::_internal_signal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Signal* p = _impl_.signal_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Signal&>(::anduril::entitymanager::v1::_Signal_default_instance_);
}
inline const ::anduril::entitymanager::v1::Signal& Entity::signal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.signal)
  return _internal_signal();
}
inline void Entity::unsafe_arena_set_allocated_signal(::anduril::entitymanager::v1::Signal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.signal_);
  }
  _impl_.signal_ = reinterpret_cast<::anduril::entitymanager::v1::Signal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.signal)
}
inline ::anduril::entitymanager::v1::Signal* Entity::release_signal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00100000u;
  ::anduril::entitymanager::v1::Signal* released = _impl_.signal_;
  _impl_.signal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Signal* Entity::unsafe_arena_release_signal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.signal)

  _impl_._has_bits_[0] &= ~0x00100000u;
  ::anduril::entitymanager::v1::Signal* temp = _impl_.signal_;
  _impl_.signal_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Signal* Entity::_internal_mutable_signal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.signal_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Signal>(GetArena());
    _impl_.signal_ = reinterpret_cast<::anduril::entitymanager::v1::Signal*>(p);
  }
  return _impl_.signal_;
}
inline ::anduril::entitymanager::v1::Signal* Entity::mutable_signal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Signal* _msg = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.signal)
  return _msg;
}
inline void Entity::set_allocated_signal(::anduril::entitymanager::v1::Signal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.signal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }

  _impl_.signal_ = reinterpret_cast<::anduril::entitymanager::v1::Signal*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.signal)
}

// .anduril.entitymanager.v1.TransponderCodes transponder_codes = 26 [json_name = "transponderCodes"];
inline bool Entity::has_transponder_codes() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transponder_codes_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::TransponderCodes& Entity::_internal_transponder_codes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::TransponderCodes* p = _impl_.transponder_codes_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::TransponderCodes&>(::anduril::entitymanager::v1::_TransponderCodes_default_instance_);
}
inline const ::anduril::entitymanager::v1::TransponderCodes& Entity::transponder_codes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.transponder_codes)
  return _internal_transponder_codes();
}
inline void Entity::unsafe_arena_set_allocated_transponder_codes(::anduril::entitymanager::v1::TransponderCodes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transponder_codes_);
  }
  _impl_.transponder_codes_ = reinterpret_cast<::anduril::entitymanager::v1::TransponderCodes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.transponder_codes)
}
inline ::anduril::entitymanager::v1::TransponderCodes* Entity::release_transponder_codes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00200000u;
  ::anduril::entitymanager::v1::TransponderCodes* released = _impl_.transponder_codes_;
  _impl_.transponder_codes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::TransponderCodes* Entity::unsafe_arena_release_transponder_codes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.transponder_codes)

  _impl_._has_bits_[0] &= ~0x00200000u;
  ::anduril::entitymanager::v1::TransponderCodes* temp = _impl_.transponder_codes_;
  _impl_.transponder_codes_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::TransponderCodes* Entity::_internal_mutable_transponder_codes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.transponder_codes_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::TransponderCodes>(GetArena());
    _impl_.transponder_codes_ = reinterpret_cast<::anduril::entitymanager::v1::TransponderCodes*>(p);
  }
  return _impl_.transponder_codes_;
}
inline ::anduril::entitymanager::v1::TransponderCodes* Entity::mutable_transponder_codes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::TransponderCodes* _msg = _internal_mutable_transponder_codes();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.transponder_codes)
  return _msg;
}
inline void Entity::set_allocated_transponder_codes(::anduril::entitymanager::v1::TransponderCodes* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transponder_codes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }

  _impl_.transponder_codes_ = reinterpret_cast<::anduril::entitymanager::v1::TransponderCodes*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.transponder_codes)
}

// .anduril.entitymanager.v1.ContactDetails contact = 27 [json_name = "contact"];
inline bool Entity::has_contact() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contact_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::ContactDetails& Entity::_internal_contact() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::ContactDetails* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::ContactDetails&>(::anduril::entitymanager::v1::_ContactDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::ContactDetails& Entity::contact() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.contact)
  return _internal_contact();
}
inline void Entity::unsafe_arena_set_allocated_contact(::anduril::entitymanager::v1::ContactDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = reinterpret_cast<::anduril::entitymanager::v1::ContactDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.contact)
}
inline ::anduril::entitymanager::v1::ContactDetails* Entity::release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00400000u;
  ::anduril::entitymanager::v1::ContactDetails* released = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::ContactDetails* Entity::unsafe_arena_release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.contact)

  _impl_._has_bits_[0] &= ~0x00400000u;
  ::anduril::entitymanager::v1::ContactDetails* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::ContactDetails* Entity::_internal_mutable_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::ContactDetails>(GetArena());
    _impl_.contact_ = reinterpret_cast<::anduril::entitymanager::v1::ContactDetails*>(p);
  }
  return _impl_.contact_;
}
inline ::anduril::entitymanager::v1::ContactDetails* Entity::mutable_contact() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::ContactDetails* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.contact)
  return _msg;
}
inline void Entity::set_allocated_contact(::anduril::entitymanager::v1::ContactDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.contact_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }

  _impl_.contact_ = reinterpret_cast<::anduril::entitymanager::v1::ContactDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.contact)
}

// .anduril.entitymanager.v1.Classification data_classification = 29 [json_name = "dataClassification"];
inline bool Entity::has_data_classification() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_classification_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Classification& Entity::_internal_data_classification() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Classification* p = _impl_.data_classification_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Classification&>(::anduril::entitymanager::v1::_Classification_default_instance_);
}
inline const ::anduril::entitymanager::v1::Classification& Entity::data_classification() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.data_classification)
  return _internal_data_classification();
}
inline void Entity::unsafe_arena_set_allocated_data_classification(::anduril::entitymanager::v1::Classification* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_classification_);
  }
  _impl_.data_classification_ = reinterpret_cast<::anduril::entitymanager::v1::Classification*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.data_classification)
}
inline ::anduril::entitymanager::v1::Classification* Entity::release_data_classification() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00800000u;
  ::anduril::entitymanager::v1::Classification* released = _impl_.data_classification_;
  _impl_.data_classification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Classification* Entity::unsafe_arena_release_data_classification() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.data_classification)

  _impl_._has_bits_[0] &= ~0x00800000u;
  ::anduril::entitymanager::v1::Classification* temp = _impl_.data_classification_;
  _impl_.data_classification_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Classification* Entity::_internal_mutable_data_classification() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.data_classification_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Classification>(GetArena());
    _impl_.data_classification_ = reinterpret_cast<::anduril::entitymanager::v1::Classification*>(p);
  }
  return _impl_.data_classification_;
}
inline ::anduril::entitymanager::v1::Classification* Entity::mutable_data_classification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Classification* _msg = _internal_mutable_data_classification();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.data_classification)
  return _msg;
}
inline void Entity::set_allocated_data_classification(::anduril::entitymanager::v1::Classification* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_classification_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }

  _impl_.data_classification_ = reinterpret_cast<::anduril::entitymanager::v1::Classification*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.data_classification)
}

// .anduril.tasks.v2.TaskCatalog task_catalog = 31 [json_name = "taskCatalog"];
inline bool Entity::has_task_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_catalog_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::TaskCatalog& Entity::_internal_task_catalog() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::tasks::v2::TaskCatalog* p = _impl_.task_catalog_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::TaskCatalog&>(::anduril::tasks::v2::_TaskCatalog_default_instance_);
}
inline const ::anduril::tasks::v2::TaskCatalog& Entity::task_catalog() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.task_catalog)
  return _internal_task_catalog();
}
inline void Entity::unsafe_arena_set_allocated_task_catalog(::anduril::tasks::v2::TaskCatalog* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_catalog_);
  }
  _impl_.task_catalog_ = reinterpret_cast<::anduril::tasks::v2::TaskCatalog*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.task_catalog)
}
inline ::anduril::tasks::v2::TaskCatalog* Entity::release_task_catalog() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x02000000u;
  ::anduril::tasks::v2::TaskCatalog* released = _impl_.task_catalog_;
  _impl_.task_catalog_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::TaskCatalog* Entity::unsafe_arena_release_task_catalog() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.task_catalog)

  _impl_._has_bits_[0] &= ~0x02000000u;
  ::anduril::tasks::v2::TaskCatalog* temp = _impl_.task_catalog_;
  _impl_.task_catalog_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::TaskCatalog* Entity::_internal_mutable_task_catalog() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x02000000u;
  if (_impl_.task_catalog_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::tasks::v2::TaskCatalog>(GetArena());
    _impl_.task_catalog_ = reinterpret_cast<::anduril::tasks::v2::TaskCatalog*>(p);
  }
  return _impl_.task_catalog_;
}
inline ::anduril::tasks::v2::TaskCatalog* Entity::mutable_task_catalog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::TaskCatalog* _msg = _internal_mutable_task_catalog();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.task_catalog)
  return _msg;
}
inline void Entity::set_allocated_task_catalog(::anduril::tasks::v2::TaskCatalog* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_catalog_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }

  _impl_.task_catalog_ = reinterpret_cast<::anduril::tasks::v2::TaskCatalog*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.task_catalog)
}

// .anduril.entitymanager.v1.Media media = 32 [json_name = "media"];
inline bool Entity::has_media() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.media_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Media& Entity::_internal_media() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Media* p = _impl_.media_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Media&>(::anduril::entitymanager::v1::_Media_default_instance_);
}
inline const ::anduril::entitymanager::v1::Media& Entity::media() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.media)
  return _internal_media();
}
inline void Entity::unsafe_arena_set_allocated_media(::anduril::entitymanager::v1::Media* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.media_);
  }
  _impl_.media_ = reinterpret_cast<::anduril::entitymanager::v1::Media*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.media)
}
inline ::anduril::entitymanager::v1::Media* Entity::release_media() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x04000000u;
  ::anduril::entitymanager::v1::Media* released = _impl_.media_;
  _impl_.media_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Media* Entity::unsafe_arena_release_media() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.media)

  _impl_._has_bits_[0] &= ~0x04000000u;
  ::anduril::entitymanager::v1::Media* temp = _impl_.media_;
  _impl_.media_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Media* Entity::_internal_mutable_media() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x04000000u;
  if (_impl_.media_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Media>(GetArena());
    _impl_.media_ = reinterpret_cast<::anduril::entitymanager::v1::Media*>(p);
  }
  return _impl_.media_;
}
inline ::anduril::entitymanager::v1::Media* Entity::mutable_media() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Media* _msg = _internal_mutable_media();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.media)
  return _msg;
}
inline void Entity::set_allocated_media(::anduril::entitymanager::v1::Media* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.media_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }

  _impl_.media_ = reinterpret_cast<::anduril::entitymanager::v1::Media*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.media)
}

// .anduril.entitymanager.v1.Relationships relationships = 33 [json_name = "relationships"];
inline bool Entity::has_relationships() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relationships_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Relationships& Entity::_internal_relationships() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Relationships* p = _impl_.relationships_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Relationships&>(::anduril::entitymanager::v1::_Relationships_default_instance_);
}
inline const ::anduril::entitymanager::v1::Relationships& Entity::relationships() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.relationships)
  return _internal_relationships();
}
inline void Entity::unsafe_arena_set_allocated_relationships(::anduril::entitymanager::v1::Relationships* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relationships_);
  }
  _impl_.relationships_ = reinterpret_cast<::anduril::entitymanager::v1::Relationships*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.relationships)
}
inline ::anduril::entitymanager::v1::Relationships* Entity::release_relationships() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x08000000u;
  ::anduril::entitymanager::v1::Relationships* released = _impl_.relationships_;
  _impl_.relationships_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Relationships* Entity::unsafe_arena_release_relationships() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.relationships)

  _impl_._has_bits_[0] &= ~0x08000000u;
  ::anduril::entitymanager::v1::Relationships* temp = _impl_.relationships_;
  _impl_.relationships_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Relationships* Entity::_internal_mutable_relationships() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x08000000u;
  if (_impl_.relationships_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Relationships>(GetArena());
    _impl_.relationships_ = reinterpret_cast<::anduril::entitymanager::v1::Relationships*>(p);
  }
  return _impl_.relationships_;
}
inline ::anduril::entitymanager::v1::Relationships* Entity::mutable_relationships() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Relationships* _msg = _internal_mutable_relationships();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.relationships)
  return _msg;
}
inline void Entity::set_allocated_relationships(::anduril::entitymanager::v1::Relationships* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relationships_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }

  _impl_.relationships_ = reinterpret_cast<::anduril::entitymanager::v1::Relationships*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.relationships)
}

// .anduril.entitymanager.v1.VisualDetails visual_details = 34 [json_name = "visualDetails"];
inline bool Entity::has_visual_details() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.visual_details_ != nullptr);
  return value;
}
inline void Entity::clear_visual_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.visual_details_ != nullptr) _impl_.visual_details_->Clear();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const ::anduril::entitymanager::v1::VisualDetails& Entity::_internal_visual_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::VisualDetails* p = _impl_.visual_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::VisualDetails&>(::anduril::entitymanager::v1::_VisualDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::VisualDetails& Entity::visual_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.visual_details)
  return _internal_visual_details();
}
inline void Entity::unsafe_arena_set_allocated_visual_details(::anduril::entitymanager::v1::VisualDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.visual_details_);
  }
  _impl_.visual_details_ = reinterpret_cast<::anduril::entitymanager::v1::VisualDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.visual_details)
}
inline ::anduril::entitymanager::v1::VisualDetails* Entity::release_visual_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x10000000u;
  ::anduril::entitymanager::v1::VisualDetails* released = _impl_.visual_details_;
  _impl_.visual_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::VisualDetails* Entity::unsafe_arena_release_visual_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.visual_details)

  _impl_._has_bits_[0] &= ~0x10000000u;
  ::anduril::entitymanager::v1::VisualDetails* temp = _impl_.visual_details_;
  _impl_.visual_details_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::VisualDetails* Entity::_internal_mutable_visual_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x10000000u;
  if (_impl_.visual_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::VisualDetails>(GetArena());
    _impl_.visual_details_ = reinterpret_cast<::anduril::entitymanager::v1::VisualDetails*>(p);
  }
  return _impl_.visual_details_;
}
inline ::anduril::entitymanager::v1::VisualDetails* Entity::mutable_visual_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::VisualDetails* _msg = _internal_mutable_visual_details();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.visual_details)
  return _msg;
}
inline void Entity::set_allocated_visual_details(::anduril::entitymanager::v1::VisualDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::VisualDetails*>(_impl_.visual_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::VisualDetails*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }

  _impl_.visual_details_ = reinterpret_cast<::anduril::entitymanager::v1::VisualDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.visual_details)
}

// .anduril.entitymanager.v1.PrototypeExtensions prototype_extensions = 35 [json_name = "prototypeExtensions"];
inline bool Entity::has_prototype_extensions() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.prototype_extensions_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::PrototypeExtensions& Entity::_internal_prototype_extensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::PrototypeExtensions* p = _impl_.prototype_extensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::PrototypeExtensions&>(::anduril::entitymanager::v1::_PrototypeExtensions_default_instance_);
}
inline const ::anduril::entitymanager::v1::PrototypeExtensions& Entity::prototype_extensions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.prototype_extensions)
  return _internal_prototype_extensions();
}
inline void Entity::unsafe_arena_set_allocated_prototype_extensions(::anduril::entitymanager::v1::PrototypeExtensions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.prototype_extensions_);
  }
  _impl_.prototype_extensions_ = reinterpret_cast<::anduril::entitymanager::v1::PrototypeExtensions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.prototype_extensions)
}
inline ::anduril::entitymanager::v1::PrototypeExtensions* Entity::release_prototype_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x20000000u;
  ::anduril::entitymanager::v1::PrototypeExtensions* released = _impl_.prototype_extensions_;
  _impl_.prototype_extensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::PrototypeExtensions* Entity::unsafe_arena_release_prototype_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.prototype_extensions)

  _impl_._has_bits_[0] &= ~0x20000000u;
  ::anduril::entitymanager::v1::PrototypeExtensions* temp = _impl_.prototype_extensions_;
  _impl_.prototype_extensions_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::PrototypeExtensions* Entity::_internal_mutable_prototype_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x20000000u;
  if (_impl_.prototype_extensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::PrototypeExtensions>(GetArena());
    _impl_.prototype_extensions_ = reinterpret_cast<::anduril::entitymanager::v1::PrototypeExtensions*>(p);
  }
  return _impl_.prototype_extensions_;
}
inline ::anduril::entitymanager::v1::PrototypeExtensions* Entity::mutable_prototype_extensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::PrototypeExtensions* _msg = _internal_mutable_prototype_extensions();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.prototype_extensions)
  return _msg;
}
inline void Entity::set_allocated_prototype_extensions(::anduril::entitymanager::v1::PrototypeExtensions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.prototype_extensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }

  _impl_.prototype_extensions_ = reinterpret_cast<::anduril::entitymanager::v1::PrototypeExtensions*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.prototype_extensions)
}

// .anduril.entitymanager.v1.Dimensions dimensions = 36 [json_name = "dimensions"];
inline bool Entity::has_dimensions() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimensions_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Dimensions& Entity::_internal_dimensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Dimensions* p = _impl_.dimensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Dimensions&>(::anduril::entitymanager::v1::_Dimensions_default_instance_);
}
inline const ::anduril::entitymanager::v1::Dimensions& Entity::dimensions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.dimensions)
  return _internal_dimensions();
}
inline void Entity::unsafe_arena_set_allocated_dimensions(::anduril::entitymanager::v1::Dimensions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimensions_);
  }
  _impl_.dimensions_ = reinterpret_cast<::anduril::entitymanager::v1::Dimensions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.dimensions)
}
inline ::anduril::entitymanager::v1::Dimensions* Entity::release_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x40000000u;
  ::anduril::entitymanager::v1::Dimensions* released = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Dimensions* Entity::unsafe_arena_release_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.dimensions)

  _impl_._has_bits_[0] &= ~0x40000000u;
  ::anduril::entitymanager::v1::Dimensions* temp = _impl_.dimensions_;
  _impl_.dimensions_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Dimensions* Entity::_internal_mutable_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x40000000u;
  if (_impl_.dimensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Dimensions>(GetArena());
    _impl_.dimensions_ = reinterpret_cast<::anduril::entitymanager::v1::Dimensions*>(p);
  }
  return _impl_.dimensions_;
}
inline ::anduril::entitymanager::v1::Dimensions* Entity::mutable_dimensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Dimensions* _msg = _internal_mutable_dimensions();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.dimensions)
  return _msg;
}
inline void Entity::set_allocated_dimensions(::anduril::entitymanager::v1::Dimensions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }

  _impl_.dimensions_ = reinterpret_cast<::anduril::entitymanager::v1::Dimensions*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.dimensions)
}

// .anduril.entitymanager.v1.RouteDetails route_details = 37 [json_name = "routeDetails"];
inline bool Entity::has_route_details() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.route_details_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::RouteDetails& Entity::_internal_route_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::RouteDetails* p = _impl_.route_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::RouteDetails&>(::anduril::entitymanager::v1::_RouteDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::RouteDetails& Entity::route_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.route_details)
  return _internal_route_details();
}
inline void Entity::unsafe_arena_set_allocated_route_details(::anduril::entitymanager::v1::RouteDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.route_details_);
  }
  _impl_.route_details_ = reinterpret_cast<::anduril::entitymanager::v1::RouteDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.route_details)
}
inline ::anduril::entitymanager::v1::RouteDetails* Entity::release_route_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x80000000u;
  ::anduril::entitymanager::v1::RouteDetails* released = _impl_.route_details_;
  _impl_.route_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::RouteDetails* Entity::unsafe_arena_release_route_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.route_details)

  _impl_._has_bits_[0] &= ~0x80000000u;
  ::anduril::entitymanager::v1::RouteDetails* temp = _impl_.route_details_;
  _impl_.route_details_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::RouteDetails* Entity::_internal_mutable_route_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x80000000u;
  if (_impl_.route_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::RouteDetails>(GetArena());
    _impl_.route_details_ = reinterpret_cast<::anduril::entitymanager::v1::RouteDetails*>(p);
  }
  return _impl_.route_details_;
}
inline ::anduril::entitymanager::v1::RouteDetails* Entity::mutable_route_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::RouteDetails* _msg = _internal_mutable_route_details();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.route_details)
  return _msg;
}
inline void Entity::set_allocated_route_details(::anduril::entitymanager::v1::RouteDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.route_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }

  _impl_.route_details_ = reinterpret_cast<::anduril::entitymanager::v1::RouteDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.route_details)
}

// .anduril.entitymanager.v1.Schedules schedules = 38 [json_name = "schedules"];
inline bool Entity::has_schedules() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schedules_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Schedules& Entity::_internal_schedules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Schedules* p = _impl_.schedules_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Schedules&>(::anduril::entitymanager::v1::_Schedules_default_instance_);
}
inline const ::anduril::entitymanager::v1::Schedules& Entity::schedules() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.schedules)
  return _internal_schedules();
}
inline void Entity::unsafe_arena_set_allocated_schedules(::anduril::entitymanager::v1::Schedules* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.schedules_);
  }
  _impl_.schedules_ = reinterpret_cast<::anduril::entitymanager::v1::Schedules*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.schedules)
}
inline ::anduril::entitymanager::v1::Schedules* Entity::release_schedules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Schedules* released = _impl_.schedules_;
  _impl_.schedules_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Schedules* Entity::unsafe_arena_release_schedules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.schedules)

  _impl_._has_bits_[1] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Schedules* temp = _impl_.schedules_;
  _impl_.schedules_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Schedules* Entity::_internal_mutable_schedules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000001u;
  if (_impl_.schedules_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Schedules>(GetArena());
    _impl_.schedules_ = reinterpret_cast<::anduril::entitymanager::v1::Schedules*>(p);
  }
  return _impl_.schedules_;
}
inline ::anduril::entitymanager::v1::Schedules* Entity::mutable_schedules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Schedules* _msg = _internal_mutable_schedules();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.schedules)
  return _msg;
}
inline void Entity::set_allocated_schedules(::anduril::entitymanager::v1::Schedules* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.schedules_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }

  _impl_.schedules_ = reinterpret_cast<::anduril::entitymanager::v1::Schedules*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.schedules)
}

// .anduril.entitymanager.v1.Health health = 39 [json_name = "health"];
inline bool Entity::has_health() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.health_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Health& Entity::_internal_health() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Health* p = _impl_.health_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Health&>(::anduril::entitymanager::v1::_Health_default_instance_);
}
inline const ::anduril::entitymanager::v1::Health& Entity::health() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.health)
  return _internal_health();
}
inline void Entity::unsafe_arena_set_allocated_health(::anduril::entitymanager::v1::Health* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.health_);
  }
  _impl_.health_ = reinterpret_cast<::anduril::entitymanager::v1::Health*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.health)
}
inline ::anduril::entitymanager::v1::Health* Entity::release_health() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000002u;
  ::anduril::entitymanager::v1::Health* released = _impl_.health_;
  _impl_.health_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Health* Entity::unsafe_arena_release_health() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.health)

  _impl_._has_bits_[1] &= ~0x00000002u;
  ::anduril::entitymanager::v1::Health* temp = _impl_.health_;
  _impl_.health_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Health* Entity::_internal_mutable_health() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000002u;
  if (_impl_.health_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Health>(GetArena());
    _impl_.health_ = reinterpret_cast<::anduril::entitymanager::v1::Health*>(p);
  }
  return _impl_.health_;
}
inline ::anduril::entitymanager::v1::Health* Entity::mutable_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Health* _msg = _internal_mutable_health();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.health)
  return _msg;
}
inline void Entity::set_allocated_health(::anduril::entitymanager::v1::Health* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.health_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }

  _impl_.health_ = reinterpret_cast<::anduril::entitymanager::v1::Health*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.health)
}

// .anduril.entitymanager.v1.GroupDetails group_details = 40 [json_name = "groupDetails"];
inline bool Entity::has_group_details() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_details_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::GroupDetails& Entity::_internal_group_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::GroupDetails* p = _impl_.group_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::GroupDetails&>(::anduril::entitymanager::v1::_GroupDetails_default_instance_);
}
inline const ::anduril::entitymanager::v1::GroupDetails& Entity::group_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.group_details)
  return _internal_group_details();
}
inline void Entity::unsafe_arena_set_allocated_group_details(::anduril::entitymanager::v1::GroupDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_details_);
  }
  _impl_.group_details_ = reinterpret_cast<::anduril::entitymanager::v1::GroupDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.group_details)
}
inline ::anduril::entitymanager::v1::GroupDetails* Entity::release_group_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000004u;
  ::anduril::entitymanager::v1::GroupDetails* released = _impl_.group_details_;
  _impl_.group_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::GroupDetails* Entity::unsafe_arena_release_group_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.group_details)

  _impl_._has_bits_[1] &= ~0x00000004u;
  ::anduril::entitymanager::v1::GroupDetails* temp = _impl_.group_details_;
  _impl_.group_details_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::GroupDetails* Entity::_internal_mutable_group_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000004u;
  if (_impl_.group_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::GroupDetails>(GetArena());
    _impl_.group_details_ = reinterpret_cast<::anduril::entitymanager::v1::GroupDetails*>(p);
  }
  return _impl_.group_details_;
}
inline ::anduril::entitymanager::v1::GroupDetails* Entity::mutable_group_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::GroupDetails* _msg = _internal_mutable_group_details();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.group_details)
  return _msg;
}
inline void Entity::set_allocated_group_details(::anduril::entitymanager::v1::GroupDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }

  _impl_.group_details_ = reinterpret_cast<::anduril::entitymanager::v1::GroupDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.group_details)
}

// .anduril.entitymanager.v1.TeamStatus team_status = 41 [json_name = "teamStatus"];
inline bool Entity::has_team_status() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.team_status_ != nullptr);
  return value;
}
inline void Entity::clear_team_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.team_status_ != nullptr) _impl_.team_status_->Clear();
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline const ::anduril::entitymanager::v1::TeamStatus& Entity::_internal_team_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::TeamStatus* p = _impl_.team_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::TeamStatus&>(::anduril::entitymanager::v1::_TeamStatus_default_instance_);
}
inline const ::anduril::entitymanager::v1::TeamStatus& Entity::team_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.team_status)
  return _internal_team_status();
}
inline void Entity::unsafe_arena_set_allocated_team_status(::anduril::entitymanager::v1::TeamStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.team_status_);
  }
  _impl_.team_status_ = reinterpret_cast<::anduril::entitymanager::v1::TeamStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.team_status)
}
inline ::anduril::entitymanager::v1::TeamStatus* Entity::release_team_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000008u;
  ::anduril::entitymanager::v1::TeamStatus* released = _impl_.team_status_;
  _impl_.team_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::TeamStatus* Entity::unsafe_arena_release_team_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.team_status)

  _impl_._has_bits_[1] &= ~0x00000008u;
  ::anduril::entitymanager::v1::TeamStatus* temp = _impl_.team_status_;
  _impl_.team_status_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::TeamStatus* Entity::_internal_mutable_team_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000008u;
  if (_impl_.team_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::TeamStatus>(GetArena());
    _impl_.team_status_ = reinterpret_cast<::anduril::entitymanager::v1::TeamStatus*>(p);
  }
  return _impl_.team_status_;
}
inline ::anduril::entitymanager::v1::TeamStatus* Entity::mutable_team_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::TeamStatus* _msg = _internal_mutable_team_status();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.team_status)
  return _msg;
}
inline void Entity::set_allocated_team_status(::anduril::entitymanager::v1::TeamStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::TeamStatus*>(_impl_.team_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::TeamStatus*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }

  _impl_.team_status_ = reinterpret_cast<::anduril::entitymanager::v1::TeamStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.team_status)
}

// .anduril.entitymanager.v1.Supplies supplies = 42 [json_name = "supplies"];
inline bool Entity::has_supplies() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.supplies_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Supplies& Entity::_internal_supplies() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Supplies* p = _impl_.supplies_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Supplies&>(::anduril::entitymanager::v1::_Supplies_default_instance_);
}
inline const ::anduril::entitymanager::v1::Supplies& Entity::supplies() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entity.supplies)
  return _internal_supplies();
}
inline void Entity::unsafe_arena_set_allocated_supplies(::anduril::entitymanager::v1::Supplies* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.supplies_);
  }
  _impl_.supplies_ = reinterpret_cast<::anduril::entitymanager::v1::Supplies*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Entity.supplies)
}
inline ::anduril::entitymanager::v1::Supplies* Entity::release_supplies() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000010u;
  ::anduril::entitymanager::v1::Supplies* released = _impl_.supplies_;
  _impl_.supplies_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Supplies* Entity::unsafe_arena_release_supplies() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Entity.supplies)

  _impl_._has_bits_[1] &= ~0x00000010u;
  ::anduril::entitymanager::v1::Supplies* temp = _impl_.supplies_;
  _impl_.supplies_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Supplies* Entity::_internal_mutable_supplies() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000010u;
  if (_impl_.supplies_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Supplies>(GetArena());
    _impl_.supplies_ = reinterpret_cast<::anduril::entitymanager::v1::Supplies*>(p);
  }
  return _impl_.supplies_;
}
inline ::anduril::entitymanager::v1::Supplies* Entity::mutable_supplies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Supplies* _msg = _internal_mutable_supplies();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entity.supplies)
  return _msg;
}
inline void Entity::set_allocated_supplies(::anduril::entitymanager::v1::Supplies* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.supplies_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }

  _impl_.supplies_ = reinterpret_cast<::anduril::entitymanager::v1::Supplies*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Entity.supplies)
}

// -------------------------------------------------------------------

// Entities

// repeated .anduril.entitymanager.v1.Entity entities = 1 [json_name = "entities"];
inline int Entities::_internal_entities_size() const {
  return _internal_entities().size();
}
inline int Entities::entities_size() const {
  return _internal_entities_size();
}
inline void Entities::clear_entities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entities_.Clear();
}
inline ::anduril::entitymanager::v1::Entity* Entities::mutable_entities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Entities.entities)
  return _internal_mutable_entities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Entity>* Entities::mutable_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.Entities.entities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_entities();
}
inline const ::anduril::entitymanager::v1::Entity& Entities::entities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Entities.entities)
  return _internal_entities().Get(index);
}
inline ::anduril::entitymanager::v1::Entity* Entities::add_entities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::anduril::entitymanager::v1::Entity* _add = _internal_mutable_entities()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.Entities.entities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Entity>& Entities::entities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.Entities.entities)
  return _internal_entities();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Entity>&
Entities::_internal_entities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entities_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Entity>*
Entities::_internal_mutable_entities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.entities_;
}

// -------------------------------------------------------------------

// Status

// string platform_activity = 1 [json_name = "platformActivity"];
inline void Status::clear_platform_activity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_activity_.ClearToEmpty();
}
inline const std::string& Status::platform_activity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Status.platform_activity)
  return _internal_platform_activity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Status::set_platform_activity(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.platform_activity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Status.platform_activity)
}
inline std::string* Status::mutable_platform_activity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_platform_activity();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Status.platform_activity)
  return _s;
}
inline const std::string& Status::_internal_platform_activity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.platform_activity_.Get();
}
inline void Status::_internal_set_platform_activity(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.platform_activity_.Set(value, GetArena());
}
inline std::string* Status::_internal_mutable_platform_activity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.platform_activity_.Mutable( GetArena());
}
inline std::string* Status::release_platform_activity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Status.platform_activity)
  return _impl_.platform_activity_.Release();
}
inline void Status::set_allocated_platform_activity(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_activity_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.platform_activity_.IsDefault()) {
          _impl_.platform_activity_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Status.platform_activity)
}

// string role = 2 [json_name = "role"];
inline void Status::clear_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.role_.ClearToEmpty();
}
inline const std::string& Status::role() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Status.role)
  return _internal_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Status::set_role(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.role_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Status.role)
}
inline std::string* Status::mutable_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Status.role)
  return _s;
}
inline const std::string& Status::_internal_role() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.role_.Get();
}
inline void Status::_internal_set_role(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.role_.Set(value, GetArena());
}
inline std::string* Status::_internal_mutable_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.role_.Mutable( GetArena());
}
inline std::string* Status::release_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Status.role)
  return _impl_.role_.Release();
}
inline void Status::set_allocated_role(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.role_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.role_.IsDefault()) {
          _impl_.role_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Status.role)
}

// -------------------------------------------------------------------

// Aliases

// repeated .anduril.entitymanager.v1.AlternateId alternate_ids = 1 [json_name = "alternateIds", (.anduril.entitymanager.v1.overridable) = true];
inline int Aliases::_internal_alternate_ids_size() const {
  return _internal_alternate_ids().size();
}
inline int Aliases::alternate_ids_size() const {
  return _internal_alternate_ids_size();
}
inline void Aliases::clear_alternate_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alternate_ids_.Clear();
}
inline ::anduril::entitymanager::v1::AlternateId* Aliases::mutable_alternate_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Aliases.alternate_ids)
  return _internal_mutable_alternate_ids()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>* Aliases::mutable_alternate_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.Aliases.alternate_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_alternate_ids();
}
inline const ::anduril::entitymanager::v1::AlternateId& Aliases::alternate_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Aliases.alternate_ids)
  return _internal_alternate_ids().Get(index);
}
inline ::anduril::entitymanager::v1::AlternateId* Aliases::add_alternate_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::anduril::entitymanager::v1::AlternateId* _add = _internal_mutable_alternate_ids()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.Aliases.alternate_ids)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>& Aliases::alternate_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.Aliases.alternate_ids)
  return _internal_alternate_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>&
Aliases::_internal_alternate_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alternate_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::AlternateId>*
Aliases::_internal_mutable_alternate_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.alternate_ids_;
}

// string name = 2 [json_name = "name", (.anduril.entitymanager.v1.overridable) = true];
inline void Aliases::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Aliases::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Aliases.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Aliases::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Aliases.name)
}
inline std::string* Aliases::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Aliases.name)
  return _s;
}
inline const std::string& Aliases::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Aliases::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Aliases::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Aliases::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Aliases.name)
  return _impl_.name_.Release();
}
inline void Aliases::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Aliases.name)
}

// -------------------------------------------------------------------

// Tracked

// uint32 track_quality = 1 [json_name = "trackQuality", deprecated = true];
inline void Tracked::clear_track_quality() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.track_quality_ = 0u;
}
inline ::uint32_t Tracked::track_quality() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.track_quality)
  return _internal_track_quality();
}
inline void Tracked::set_track_quality(::uint32_t value) {
  _internal_set_track_quality(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Tracked.track_quality)
}
inline ::uint32_t Tracked::_internal_track_quality() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.track_quality_;
}
inline void Tracked::_internal_set_track_quality(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.track_quality_ = value;
}

// .google.protobuf.Int32Value track_quality_wrapper = 2 [json_name = "trackQualityWrapper"];
inline bool Tracked::has_track_quality_wrapper() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.track_quality_wrapper_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int32Value& Tracked::_internal_track_quality_wrapper() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int32Value* p = _impl_.track_quality_wrapper_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int32Value&>(::google::protobuf::_Int32Value_default_instance_);
}
inline const ::google::protobuf::Int32Value& Tracked::track_quality_wrapper() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.track_quality_wrapper)
  return _internal_track_quality_wrapper();
}
inline void Tracked::unsafe_arena_set_allocated_track_quality_wrapper(::google::protobuf::Int32Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.track_quality_wrapper_);
  }
  _impl_.track_quality_wrapper_ = reinterpret_cast<::google::protobuf::Int32Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.track_quality_wrapper)
}
inline ::google::protobuf::Int32Value* Tracked::release_track_quality_wrapper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int32Value* released = _impl_.track_quality_wrapper_;
  _impl_.track_quality_wrapper_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int32Value* Tracked::unsafe_arena_release_track_quality_wrapper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.track_quality_wrapper)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int32Value* temp = _impl_.track_quality_wrapper_;
  _impl_.track_quality_wrapper_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* Tracked::_internal_mutable_track_quality_wrapper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.track_quality_wrapper_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArena());
    _impl_.track_quality_wrapper_ = reinterpret_cast<::google::protobuf::Int32Value*>(p);
  }
  return _impl_.track_quality_wrapper_;
}
inline ::google::protobuf::Int32Value* Tracked::mutable_track_quality_wrapper() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int32Value* _msg = _internal_mutable_track_quality_wrapper();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.track_quality_wrapper)
  return _msg;
}
inline void Tracked::set_allocated_track_quality_wrapper(::google::protobuf::Int32Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.track_quality_wrapper_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.track_quality_wrapper_ = reinterpret_cast<::google::protobuf::Int32Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.track_quality_wrapper)
}

// .google.protobuf.Int32Value sensor_hits = 3 [json_name = "sensorHits"];
inline bool Tracked::has_sensor_hits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sensor_hits_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int32Value& Tracked::_internal_sensor_hits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int32Value* p = _impl_.sensor_hits_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int32Value&>(::google::protobuf::_Int32Value_default_instance_);
}
inline const ::google::protobuf::Int32Value& Tracked::sensor_hits() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.sensor_hits)
  return _internal_sensor_hits();
}
inline void Tracked::unsafe_arena_set_allocated_sensor_hits(::google::protobuf::Int32Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensor_hits_);
  }
  _impl_.sensor_hits_ = reinterpret_cast<::google::protobuf::Int32Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.sensor_hits)
}
inline ::google::protobuf::Int32Value* Tracked::release_sensor_hits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int32Value* released = _impl_.sensor_hits_;
  _impl_.sensor_hits_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int32Value* Tracked::unsafe_arena_release_sensor_hits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.sensor_hits)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int32Value* temp = _impl_.sensor_hits_;
  _impl_.sensor_hits_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* Tracked::_internal_mutable_sensor_hits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.sensor_hits_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArena());
    _impl_.sensor_hits_ = reinterpret_cast<::google::protobuf::Int32Value*>(p);
  }
  return _impl_.sensor_hits_;
}
inline ::google::protobuf::Int32Value* Tracked::mutable_sensor_hits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int32Value* _msg = _internal_mutable_sensor_hits();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.sensor_hits)
  return _msg;
}
inline void Tracked::set_allocated_sensor_hits(::google::protobuf::Int32Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensor_hits_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.sensor_hits_ = reinterpret_cast<::google::protobuf::Int32Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.sensor_hits)
}

// .anduril.entitymanager.v1.UInt32Range number_of_objects = 4 [json_name = "numberOfObjects"];
inline bool Tracked::has_number_of_objects() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.number_of_objects_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::UInt32Range& Tracked::_internal_number_of_objects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::UInt32Range* p = _impl_.number_of_objects_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::UInt32Range&>(::anduril::entitymanager::v1::_UInt32Range_default_instance_);
}
inline const ::anduril::entitymanager::v1::UInt32Range& Tracked::number_of_objects() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.number_of_objects)
  return _internal_number_of_objects();
}
inline void Tracked::unsafe_arena_set_allocated_number_of_objects(::anduril::entitymanager::v1::UInt32Range* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.number_of_objects_);
  }
  _impl_.number_of_objects_ = reinterpret_cast<::anduril::entitymanager::v1::UInt32Range*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.number_of_objects)
}
inline ::anduril::entitymanager::v1::UInt32Range* Tracked::release_number_of_objects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::entitymanager::v1::UInt32Range* released = _impl_.number_of_objects_;
  _impl_.number_of_objects_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::UInt32Range* Tracked::unsafe_arena_release_number_of_objects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.number_of_objects)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::entitymanager::v1::UInt32Range* temp = _impl_.number_of_objects_;
  _impl_.number_of_objects_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::UInt32Range* Tracked::_internal_mutable_number_of_objects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.number_of_objects_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::UInt32Range>(GetArena());
    _impl_.number_of_objects_ = reinterpret_cast<::anduril::entitymanager::v1::UInt32Range*>(p);
  }
  return _impl_.number_of_objects_;
}
inline ::anduril::entitymanager::v1::UInt32Range* Tracked::mutable_number_of_objects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::UInt32Range* _msg = _internal_mutable_number_of_objects();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.number_of_objects)
  return _msg;
}
inline void Tracked::set_allocated_number_of_objects(::anduril::entitymanager::v1::UInt32Range* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.number_of_objects_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.number_of_objects_ = reinterpret_cast<::anduril::entitymanager::v1::UInt32Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.number_of_objects)
}

// .anduril.entitymanager.v1.Sensors sensor_details = 5 [json_name = "sensorDetails", deprecated = true];
inline bool Tracked::has_sensor_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sensor_details_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Sensors& Tracked::_internal_sensor_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Sensors* p = _impl_.sensor_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Sensors&>(::anduril::entitymanager::v1::_Sensors_default_instance_);
}
inline const ::anduril::entitymanager::v1::Sensors& Tracked::sensor_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.sensor_details)
  return _internal_sensor_details();
}
inline void Tracked::unsafe_arena_set_allocated_sensor_details(::anduril::entitymanager::v1::Sensors* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensor_details_);
  }
  _impl_.sensor_details_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.sensor_details)
}
inline ::anduril::entitymanager::v1::Sensors* Tracked::release_sensor_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::entitymanager::v1::Sensors* released = _impl_.sensor_details_;
  _impl_.sensor_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Sensors* Tracked::unsafe_arena_release_sensor_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.sensor_details)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::entitymanager::v1::Sensors* temp = _impl_.sensor_details_;
  _impl_.sensor_details_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Sensors* Tracked::_internal_mutable_sensor_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.sensor_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Sensors>(GetArena());
    _impl_.sensor_details_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(p);
  }
  return _impl_.sensor_details_;
}
inline ::anduril::entitymanager::v1::Sensors* Tracked::mutable_sensor_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Sensors* _msg = _internal_mutable_sensor_details();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.sensor_details)
  return _msg;
}
inline void Tracked::set_allocated_sensor_details(::anduril::entitymanager::v1::Sensors* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensor_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.sensor_details_ = reinterpret_cast<::anduril::entitymanager::v1::Sensors*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.sensor_details)
}

// .google.protobuf.DoubleValue radar_cross_section = 6 [json_name = "radarCrossSection"];
inline bool Tracked::has_radar_cross_section() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.radar_cross_section_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& Tracked::_internal_radar_cross_section() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::DoubleValue* p = _impl_.radar_cross_section_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& Tracked::radar_cross_section() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.radar_cross_section)
  return _internal_radar_cross_section();
}
inline void Tracked::unsafe_arena_set_allocated_radar_cross_section(::google::protobuf::DoubleValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.radar_cross_section_);
  }
  _impl_.radar_cross_section_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.radar_cross_section)
}
inline ::google::protobuf::DoubleValue* Tracked::release_radar_cross_section() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::DoubleValue* released = _impl_.radar_cross_section_;
  _impl_.radar_cross_section_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* Tracked::unsafe_arena_release_radar_cross_section() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.radar_cross_section)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::DoubleValue* temp = _impl_.radar_cross_section_;
  _impl_.radar_cross_section_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* Tracked::_internal_mutable_radar_cross_section() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.radar_cross_section_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::DoubleValue>(GetArena());
    _impl_.radar_cross_section_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.radar_cross_section_;
}
inline ::google::protobuf::DoubleValue* Tracked::mutable_radar_cross_section() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_radar_cross_section();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.radar_cross_section)
  return _msg;
}
inline void Tracked::set_allocated_radar_cross_section(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.radar_cross_section_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.radar_cross_section_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.radar_cross_section)
}

// .google.protobuf.Timestamp last_measurement_time = 7 [json_name = "lastMeasurementTime"];
inline bool Tracked::has_last_measurement_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_measurement_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Tracked::_internal_last_measurement_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.last_measurement_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Tracked::last_measurement_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.last_measurement_time)
  return _internal_last_measurement_time();
}
inline void Tracked::unsafe_arena_set_allocated_last_measurement_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_measurement_time_);
  }
  _impl_.last_measurement_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.last_measurement_time)
}
inline ::google::protobuf::Timestamp* Tracked::release_last_measurement_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::Timestamp* released = _impl_.last_measurement_time_;
  _impl_.last_measurement_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Tracked::unsafe_arena_release_last_measurement_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.last_measurement_time)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::Timestamp* temp = _impl_.last_measurement_time_;
  _impl_.last_measurement_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Tracked::_internal_mutable_last_measurement_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.last_measurement_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_measurement_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_measurement_time_;
}
inline ::google::protobuf::Timestamp* Tracked::mutable_last_measurement_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_measurement_time();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.last_measurement_time)
  return _msg;
}
inline void Tracked::set_allocated_last_measurement_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_measurement_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.last_measurement_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.last_measurement_time)
}

// .anduril.entitymanager.v1.LineOfBearing line_of_bearing = 9 [json_name = "lineOfBearing"];
inline bool Tracked::has_line_of_bearing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.line_of_bearing_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::LineOfBearing& Tracked::_internal_line_of_bearing() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::LineOfBearing* p = _impl_.line_of_bearing_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::LineOfBearing&>(::anduril::entitymanager::v1::_LineOfBearing_default_instance_);
}
inline const ::anduril::entitymanager::v1::LineOfBearing& Tracked::line_of_bearing() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Tracked.line_of_bearing)
  return _internal_line_of_bearing();
}
inline void Tracked::unsafe_arena_set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.line_of_bearing_);
  }
  _impl_.line_of_bearing_ = reinterpret_cast<::anduril::entitymanager::v1::LineOfBearing*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Tracked.line_of_bearing)
}
inline ::anduril::entitymanager::v1::LineOfBearing* Tracked::release_line_of_bearing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::anduril::entitymanager::v1::LineOfBearing* released = _impl_.line_of_bearing_;
  _impl_.line_of_bearing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::LineOfBearing* Tracked::unsafe_arena_release_line_of_bearing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Tracked.line_of_bearing)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::anduril::entitymanager::v1::LineOfBearing* temp = _impl_.line_of_bearing_;
  _impl_.line_of_bearing_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::LineOfBearing* Tracked::_internal_mutable_line_of_bearing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.line_of_bearing_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::LineOfBearing>(GetArena());
    _impl_.line_of_bearing_ = reinterpret_cast<::anduril::entitymanager::v1::LineOfBearing*>(p);
  }
  return _impl_.line_of_bearing_;
}
inline ::anduril::entitymanager::v1::LineOfBearing* Tracked::mutable_line_of_bearing() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::LineOfBearing* _msg = _internal_mutable_line_of_bearing();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Tracked.line_of_bearing)
  return _msg;
}
inline void Tracked::set_allocated_line_of_bearing(::anduril::entitymanager::v1::LineOfBearing* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.line_of_bearing_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.line_of_bearing_ = reinterpret_cast<::anduril::entitymanager::v1::LineOfBearing*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Tracked.line_of_bearing)
}

// -------------------------------------------------------------------

// Provenance

// string integration_name = 5 [json_name = "integrationName"];
inline void Provenance::clear_integration_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.integration_name_.ClearToEmpty();
}
inline const std::string& Provenance::integration_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.integration_name)
  return _internal_integration_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Provenance::set_integration_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.integration_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Provenance.integration_name)
}
inline std::string* Provenance::mutable_integration_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_integration_name();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Provenance.integration_name)
  return _s;
}
inline const std::string& Provenance::_internal_integration_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.integration_name_.Get();
}
inline void Provenance::_internal_set_integration_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.integration_name_.Set(value, GetArena());
}
inline std::string* Provenance::_internal_mutable_integration_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.integration_name_.Mutable( GetArena());
}
inline std::string* Provenance::release_integration_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Provenance.integration_name)
  return _impl_.integration_name_.Release();
}
inline void Provenance::set_allocated_integration_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.integration_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.integration_name_.IsDefault()) {
          _impl_.integration_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Provenance.integration_name)
}

// string data_type = 6 [json_name = "dataType"];
inline void Provenance::clear_data_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_type_.ClearToEmpty();
}
inline const std::string& Provenance::data_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.data_type)
  return _internal_data_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Provenance::set_data_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Provenance.data_type)
}
inline std::string* Provenance::mutable_data_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data_type();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Provenance.data_type)
  return _s;
}
inline const std::string& Provenance::_internal_data_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_type_.Get();
}
inline void Provenance::_internal_set_data_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_type_.Set(value, GetArena());
}
inline std::string* Provenance::_internal_mutable_data_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_type_.Mutable( GetArena());
}
inline std::string* Provenance::release_data_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Provenance.data_type)
  return _impl_.data_type_.Release();
}
inline void Provenance::set_allocated_data_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_type_.IsDefault()) {
          _impl_.data_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Provenance.data_type)
}

// .anduril.entitymanager.v1.Source source = 1 [json_name = "source"];
inline void Provenance::clear_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_ = 0;
}
inline ::anduril::entitymanager::v1::Source Provenance::source() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.source)
  return _internal_source();
}
inline void Provenance::set_source(::anduril::entitymanager::v1::Source value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Provenance.source)
}
inline ::anduril::entitymanager::v1::Source Provenance::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::anduril::entitymanager::v1::Source>(_impl_.source_);
}
inline void Provenance::_internal_set_source(::anduril::entitymanager::v1::Source value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_ = value;
}

// string source_id = 3 [json_name = "sourceId"];
inline void Provenance::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_id_.ClearToEmpty();
}
inline const std::string& Provenance::source_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.source_id)
  return _internal_source_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Provenance::set_source_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Provenance.source_id)
}
inline std::string* Provenance::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Provenance.source_id)
  return _s;
}
inline const std::string& Provenance::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_id_.Get();
}
inline void Provenance::_internal_set_source_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_id_.Set(value, GetArena());
}
inline std::string* Provenance::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_id_.Mutable( GetArena());
}
inline std::string* Provenance::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Provenance.source_id)
  return _impl_.source_id_.Release();
}
inline void Provenance::set_allocated_source_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_id_.IsDefault()) {
          _impl_.source_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Provenance.source_id)
}

// .google.protobuf.Timestamp source_update_time = 2 [json_name = "sourceUpdateTime"];
inline bool Provenance::has_source_update_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_update_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Provenance::_internal_source_update_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.source_update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Provenance::source_update_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.source_update_time)
  return _internal_source_update_time();
}
inline void Provenance::unsafe_arena_set_allocated_source_update_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_update_time_);
  }
  _impl_.source_update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Provenance.source_update_time)
}
inline ::google::protobuf::Timestamp* Provenance::release_source_update_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.source_update_time_;
  _impl_.source_update_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Provenance::unsafe_arena_release_source_update_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Provenance.source_update_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.source_update_time_;
  _impl_.source_update_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Provenance::_internal_mutable_source_update_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.source_update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.source_update_time_;
}
inline ::google::protobuf::Timestamp* Provenance::mutable_source_update_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_source_update_time();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Provenance.source_update_time)
  return _msg;
}
inline void Provenance::set_allocated_source_update_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_update_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Provenance.source_update_time)
}

// string source_description = 4 [json_name = "sourceDescription"];
inline void Provenance::clear_source_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_description_.ClearToEmpty();
}
inline const std::string& Provenance::source_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Provenance.source_description)
  return _internal_source_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Provenance::set_source_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Provenance.source_description)
}
inline std::string* Provenance::mutable_source_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_description();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Provenance.source_description)
  return _s;
}
inline const std::string& Provenance::_internal_source_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_description_.Get();
}
inline void Provenance::_internal_set_source_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_description_.Set(value, GetArena());
}
inline std::string* Provenance::_internal_mutable_source_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_description_.Mutable( GetArena());
}
inline std::string* Provenance::release_source_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Provenance.source_description)
  return _impl_.source_description_.Release();
}
inline void Provenance::set_allocated_source_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_description_.IsDefault()) {
          _impl_.source_description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Provenance.source_description)
}

// -------------------------------------------------------------------

// Indicators

// .google.protobuf.BoolValue simulated = 1 [json_name = "simulated"];
inline bool Indicators::has_simulated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.simulated_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_simulated() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::BoolValue* p = _impl_.simulated_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::simulated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.simulated)
  return _internal_simulated();
}
inline void Indicators::unsafe_arena_set_allocated_simulated(::google::protobuf::BoolValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.simulated_);
  }
  _impl_.simulated_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.simulated)
}
inline ::google::protobuf::BoolValue* Indicators::release_simulated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::BoolValue* released = _impl_.simulated_;
  _impl_.simulated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_simulated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.simulated)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::BoolValue* temp = _impl_.simulated_;
  _impl_.simulated_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_simulated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.simulated_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArena());
    _impl_.simulated_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.simulated_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_simulated() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::BoolValue* _msg = _internal_mutable_simulated();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.simulated)
  return _msg;
}
inline void Indicators::set_allocated_simulated(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.simulated_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.simulated_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.simulated)
}

// .google.protobuf.BoolValue exercise = 2 [json_name = "exercise"];
inline bool Indicators::has_exercise() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.exercise_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_exercise() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::BoolValue* p = _impl_.exercise_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::exercise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.exercise)
  return _internal_exercise();
}
inline void Indicators::unsafe_arena_set_allocated_exercise(::google::protobuf::BoolValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exercise_);
  }
  _impl_.exercise_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.exercise)
}
inline ::google::protobuf::BoolValue* Indicators::release_exercise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::BoolValue* released = _impl_.exercise_;
  _impl_.exercise_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_exercise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.exercise)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::BoolValue* temp = _impl_.exercise_;
  _impl_.exercise_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_exercise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.exercise_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArena());
    _impl_.exercise_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.exercise_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_exercise() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::BoolValue* _msg = _internal_mutable_exercise();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.exercise)
  return _msg;
}
inline void Indicators::set_allocated_exercise(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exercise_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.exercise_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.exercise)
}

// .google.protobuf.BoolValue emergency = 3 [json_name = "emergency"];
inline bool Indicators::has_emergency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.emergency_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_emergency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::BoolValue* p = _impl_.emergency_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::emergency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.emergency)
  return _internal_emergency();
}
inline void Indicators::unsafe_arena_set_allocated_emergency(::google::protobuf::BoolValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.emergency_);
  }
  _impl_.emergency_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.emergency)
}
inline ::google::protobuf::BoolValue* Indicators::release_emergency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::BoolValue* released = _impl_.emergency_;
  _impl_.emergency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_emergency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.emergency)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::BoolValue* temp = _impl_.emergency_;
  _impl_.emergency_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_emergency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.emergency_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArena());
    _impl_.emergency_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.emergency_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_emergency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::BoolValue* _msg = _internal_mutable_emergency();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.emergency)
  return _msg;
}
inline void Indicators::set_allocated_emergency(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.emergency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.emergency_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.emergency)
}

// .google.protobuf.BoolValue c2 = 4 [json_name = "c2"];
inline bool Indicators::has_c2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.c2_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_c2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::BoolValue* p = _impl_.c2_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::c2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.c2)
  return _internal_c2();
}
inline void Indicators::unsafe_arena_set_allocated_c2(::google::protobuf::BoolValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.c2_);
  }
  _impl_.c2_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.c2)
}
inline ::google::protobuf::BoolValue* Indicators::release_c2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::BoolValue* released = _impl_.c2_;
  _impl_.c2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_c2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.c2)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::BoolValue* temp = _impl_.c2_;
  _impl_.c2_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_c2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.c2_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArena());
    _impl_.c2_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.c2_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_c2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::BoolValue* _msg = _internal_mutable_c2();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.c2)
  return _msg;
}
inline void Indicators::set_allocated_c2(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.c2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.c2_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.c2)
}

// .anduril.entitymanager.v1.Deletable deletable = 5 [json_name = "deletable"];
inline void Indicators::clear_deletable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deletable_ = 0;
}
inline ::anduril::entitymanager::v1::Deletable Indicators::deletable() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.deletable)
  return _internal_deletable();
}
inline void Indicators::set_deletable(::anduril::entitymanager::v1::Deletable value) {
  _internal_set_deletable(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Indicators.deletable)
}
inline ::anduril::entitymanager::v1::Deletable Indicators::_internal_deletable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::anduril::entitymanager::v1::Deletable>(_impl_.deletable_);
}
inline void Indicators::_internal_set_deletable(::anduril::entitymanager::v1::Deletable value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.deletable_ = value;
}

// .google.protobuf.BoolValue egressable = 6 [json_name = "egressable", (.anduril.entitymanager.v1.overridable) = true];
inline bool Indicators::has_egressable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.egressable_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_egressable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::BoolValue* p = _impl_.egressable_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::egressable() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.egressable)
  return _internal_egressable();
}
inline void Indicators::unsafe_arena_set_allocated_egressable(::google::protobuf::BoolValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.egressable_);
  }
  _impl_.egressable_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.egressable)
}
inline ::google::protobuf::BoolValue* Indicators::release_egressable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::BoolValue* released = _impl_.egressable_;
  _impl_.egressable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_egressable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.egressable)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::BoolValue* temp = _impl_.egressable_;
  _impl_.egressable_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_egressable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.egressable_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArena());
    _impl_.egressable_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.egressable_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_egressable() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::BoolValue* _msg = _internal_mutable_egressable();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.egressable)
  return _msg;
}
inline void Indicators::set_allocated_egressable(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.egressable_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.egressable_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.egressable)
}

// .google.protobuf.BoolValue starred = 7 [json_name = "starred", (.anduril.entitymanager.v1.overridable) = true];
inline bool Indicators::has_starred() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.starred_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& Indicators::_internal_starred() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::BoolValue* p = _impl_.starred_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& Indicators::starred() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Indicators.starred)
  return _internal_starred();
}
inline void Indicators::unsafe_arena_set_allocated_starred(::google::protobuf::BoolValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starred_);
  }
  _impl_.starred_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Indicators.starred)
}
inline ::google::protobuf::BoolValue* Indicators::release_starred() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::BoolValue* released = _impl_.starred_;
  _impl_.starred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::BoolValue* Indicators::unsafe_arena_release_starred() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Indicators.starred)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::BoolValue* temp = _impl_.starred_;
  _impl_.starred_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Indicators::_internal_mutable_starred() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.starred_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArena());
    _impl_.starred_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.starred_;
}
inline ::google::protobuf::BoolValue* Indicators::mutable_starred() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::BoolValue* _msg = _internal_mutable_starred();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Indicators.starred)
  return _msg;
}
inline void Indicators::set_allocated_starred(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starred_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.starred_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Indicators.starred)
}

// -------------------------------------------------------------------

// Overrides

// repeated .anduril.entitymanager.v1.Override override = 2 [json_name = "override"];
inline int Overrides::_internal_override_size() const {
  return _internal_override().size();
}
inline int Overrides::override_size() const {
  return _internal_override_size();
}
inline void Overrides::clear_override() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.override_.Clear();
}
inline ::anduril::entitymanager::v1::Override* Overrides::mutable_override(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Overrides.override)
  return _internal_mutable_override()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>* Overrides::mutable_override()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.Overrides.override)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_override();
}
inline const ::anduril::entitymanager::v1::Override& Overrides::override(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Overrides.override)
  return _internal_override().Get(index);
}
inline ::anduril::entitymanager::v1::Override* Overrides::add_override() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::anduril::entitymanager::v1::Override* _add = _internal_mutable_override()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.Overrides.override)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>& Overrides::override() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.Overrides.override)
  return _internal_override();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>&
Overrides::_internal_override() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.override_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::Override>*
Overrides::_internal_mutable_override() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.override_;
}

// repeated .anduril.entitymanager.v1.OverrideProvenance provenance = 1 [json_name = "provenance", deprecated = true];
inline int Overrides::_internal_provenance_size() const {
  return _internal_provenance().size();
}
inline int Overrides::provenance_size() const {
  return _internal_provenance_size();
}
inline void Overrides::clear_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.provenance_.Clear();
}
inline ::anduril::entitymanager::v1::OverrideProvenance* Overrides::mutable_provenance(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Overrides.provenance)
  return _internal_mutable_provenance()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::OverrideProvenance>* Overrides::mutable_provenance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entitymanager.v1.Overrides.provenance)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_provenance();
}
inline const ::anduril::entitymanager::v1::OverrideProvenance& Overrides::provenance(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Overrides.provenance)
  return _internal_provenance().Get(index);
}
inline ::anduril::entitymanager::v1::OverrideProvenance* Overrides::add_provenance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::anduril::entitymanager::v1::OverrideProvenance* _add = _internal_mutable_provenance()->Add();
  // @@protoc_insertion_point(field_add:anduril.entitymanager.v1.Overrides.provenance)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::OverrideProvenance>& Overrides::provenance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entitymanager.v1.Overrides.provenance)
  return _internal_provenance();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::OverrideProvenance>&
Overrides::_internal_provenance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.provenance_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entitymanager::v1::OverrideProvenance>*
Overrides::_internal_mutable_provenance() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.provenance_;
}

// -------------------------------------------------------------------

// Override

// string request_id = 1 [json_name = "requestId"];
inline void Override::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& Override::request_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.request_id)
  return _internal_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Override::set_request_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Override.request_id)
}
inline std::string* Override::mutable_request_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Override.request_id)
  return _s;
}
inline const std::string& Override::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_.Get();
}
inline void Override::_internal_set_request_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.request_id_.Set(value, GetArena());
}
inline std::string* Override::_internal_mutable_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.request_id_.Mutable( GetArena());
}
inline std::string* Override::release_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Override.request_id)
  return _impl_.request_id_.Release();
}
inline void Override::set_allocated_request_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.request_id_.IsDefault()) {
          _impl_.request_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Override.request_id)
}

// string field_path = 2 [json_name = "fieldPath"];
inline void Override::clear_field_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_path_.ClearToEmpty();
}
inline const std::string& Override::field_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.field_path)
  return _internal_field_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Override::set_field_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Override.field_path)
}
inline std::string* Override::mutable_field_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_field_path();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Override.field_path)
  return _s;
}
inline const std::string& Override::_internal_field_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.field_path_.Get();
}
inline void Override::_internal_set_field_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_path_.Set(value, GetArena());
}
inline std::string* Override::_internal_mutable_field_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.field_path_.Mutable( GetArena());
}
inline std::string* Override::release_field_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Override.field_path)
  return _impl_.field_path_.Release();
}
inline void Override::set_allocated_field_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.field_path_.IsDefault()) {
          _impl_.field_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Override.field_path)
}

// .anduril.entitymanager.v1.Entity masked_field_value = 3 [json_name = "maskedFieldValue"];
inline bool Override::has_masked_field_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.masked_field_value_ != nullptr);
  return value;
}
inline void Override::clear_masked_field_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.masked_field_value_ != nullptr) _impl_.masked_field_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::Entity& Override::_internal_masked_field_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Entity* p = _impl_.masked_field_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Entity&>(::anduril::entitymanager::v1::_Entity_default_instance_);
}
inline const ::anduril::entitymanager::v1::Entity& Override::masked_field_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.masked_field_value)
  return _internal_masked_field_value();
}
inline void Override::unsafe_arena_set_allocated_masked_field_value(::anduril::entitymanager::v1::Entity* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.masked_field_value_);
  }
  _impl_.masked_field_value_ = reinterpret_cast<::anduril::entitymanager::v1::Entity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Override.masked_field_value)
}
inline ::anduril::entitymanager::v1::Entity* Override::release_masked_field_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Entity* released = _impl_.masked_field_value_;
  _impl_.masked_field_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Entity* Override::unsafe_arena_release_masked_field_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Override.masked_field_value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Entity* temp = _impl_.masked_field_value_;
  _impl_.masked_field_value_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Entity* Override::_internal_mutable_masked_field_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.masked_field_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Entity>(GetArena());
    _impl_.masked_field_value_ = reinterpret_cast<::anduril::entitymanager::v1::Entity*>(p);
  }
  return _impl_.masked_field_value_;
}
inline ::anduril::entitymanager::v1::Entity* Override::mutable_masked_field_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Entity* _msg = _internal_mutable_masked_field_value();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Override.masked_field_value)
  return _msg;
}
inline void Override::set_allocated_masked_field_value(::anduril::entitymanager::v1::Entity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::Entity*>(_impl_.masked_field_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::Entity*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.masked_field_value_ = reinterpret_cast<::anduril::entitymanager::v1::Entity*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Override.masked_field_value)
}

// .anduril.entitymanager.v1.OverrideStatus status = 4 [json_name = "status"];
inline void Override::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
}
inline ::anduril::entitymanager::v1::OverrideStatus Override::status() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.status)
  return _internal_status();
}
inline void Override::set_status(::anduril::entitymanager::v1::OverrideStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Override.status)
}
inline ::anduril::entitymanager::v1::OverrideStatus Override::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::anduril::entitymanager::v1::OverrideStatus>(_impl_.status_);
}
inline void Override::_internal_set_status(::anduril::entitymanager::v1::OverrideStatus value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// .anduril.entitymanager.v1.Provenance provenance = 5 [json_name = "provenance"];
inline bool Override::has_provenance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.provenance_ != nullptr);
  return value;
}
inline void Override::clear_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.provenance_ != nullptr) _impl_.provenance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::entitymanager::v1::Provenance& Override::_internal_provenance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Provenance* p = _impl_.provenance_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Provenance&>(::anduril::entitymanager::v1::_Provenance_default_instance_);
}
inline const ::anduril::entitymanager::v1::Provenance& Override::provenance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.provenance)
  return _internal_provenance();
}
inline void Override::unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.provenance_);
  }
  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Override.provenance)
}
inline ::anduril::entitymanager::v1::Provenance* Override::release_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entitymanager::v1::Provenance* released = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Provenance* Override::unsafe_arena_release_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Override.provenance)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entitymanager::v1::Provenance* temp = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Provenance* Override::_internal_mutable_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.provenance_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Provenance>(GetArena());
    _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(p);
  }
  return _impl_.provenance_;
}
inline ::anduril::entitymanager::v1::Provenance* Override::mutable_provenance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Provenance* _msg = _internal_mutable_provenance();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Override.provenance)
  return _msg;
}
inline void Override::set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(_impl_.provenance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Override.provenance)
}

// .anduril.entitymanager.v1.OverrideType type = 6 [json_name = "type"];
inline void Override::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::anduril::entitymanager::v1::OverrideType Override::type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.type)
  return _internal_type();
}
inline void Override::set_type(::anduril::entitymanager::v1::OverrideType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.Override.type)
}
inline ::anduril::entitymanager::v1::OverrideType Override::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::anduril::entitymanager::v1::OverrideType>(_impl_.type_);
}
inline void Override::_internal_set_type(::anduril::entitymanager::v1::OverrideType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .google.protobuf.Timestamp request_timestamp = 7 [json_name = "requestTimestamp"];
inline bool Override::has_request_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Override::_internal_request_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.request_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Override::request_timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.Override.request_timestamp)
  return _internal_request_timestamp();
}
inline void Override::unsafe_arena_set_allocated_request_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.request_timestamp_);
  }
  _impl_.request_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.Override.request_timestamp)
}
inline ::google::protobuf::Timestamp* Override::release_request_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.request_timestamp_;
  _impl_.request_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Override::unsafe_arena_release_request_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.Override.request_timestamp)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.request_timestamp_;
  _impl_.request_timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Override::_internal_mutable_request_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.request_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.request_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.request_timestamp_;
}
inline ::google::protobuf::Timestamp* Override::mutable_request_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_request_timestamp();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.Override.request_timestamp)
  return _msg;
}
inline void Override::set_allocated_request_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.request_timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.request_timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.Override.request_timestamp)
}

// -------------------------------------------------------------------

// OverrideProvenance

// string field_path = 1 [json_name = "fieldPath"];
inline void OverrideProvenance::clear_field_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_path_.ClearToEmpty();
}
inline const std::string& OverrideProvenance::field_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.OverrideProvenance.field_path)
  return _internal_field_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OverrideProvenance::set_field_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.OverrideProvenance.field_path)
}
inline std::string* OverrideProvenance::mutable_field_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_field_path();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.OverrideProvenance.field_path)
  return _s;
}
inline const std::string& OverrideProvenance::_internal_field_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.field_path_.Get();
}
inline void OverrideProvenance::_internal_set_field_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_path_.Set(value, GetArena());
}
inline std::string* OverrideProvenance::_internal_mutable_field_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.field_path_.Mutable( GetArena());
}
inline std::string* OverrideProvenance::release_field_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.OverrideProvenance.field_path)
  return _impl_.field_path_.Release();
}
inline void OverrideProvenance::set_allocated_field_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.field_path_.IsDefault()) {
          _impl_.field_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.OverrideProvenance.field_path)
}

// string source_id = 2 [json_name = "sourceId", deprecated = true];
inline void OverrideProvenance::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_id_.ClearToEmpty();
}
inline const std::string& OverrideProvenance::source_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.OverrideProvenance.source_id)
  return _internal_source_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OverrideProvenance::set_source_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.OverrideProvenance.source_id)
}
inline std::string* OverrideProvenance::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.OverrideProvenance.source_id)
  return _s;
}
inline const std::string& OverrideProvenance::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_id_.Get();
}
inline void OverrideProvenance::_internal_set_source_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_id_.Set(value, GetArena());
}
inline std::string* OverrideProvenance::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_id_.Mutable( GetArena());
}
inline std::string* OverrideProvenance::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.OverrideProvenance.source_id)
  return _impl_.source_id_.Release();
}
inline void OverrideProvenance::set_allocated_source_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_id_.IsDefault()) {
          _impl_.source_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.OverrideProvenance.source_id)
}

// .anduril.entitymanager.v1.Provenance provenance = 3 [json_name = "provenance"];
inline bool OverrideProvenance::has_provenance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.provenance_ != nullptr);
  return value;
}
inline void OverrideProvenance::clear_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.provenance_ != nullptr) _impl_.provenance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::Provenance& OverrideProvenance::_internal_provenance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Provenance* p = _impl_.provenance_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Provenance&>(::anduril::entitymanager::v1::_Provenance_default_instance_);
}
inline const ::anduril::entitymanager::v1::Provenance& OverrideProvenance::provenance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.OverrideProvenance.provenance)
  return _internal_provenance();
}
inline void OverrideProvenance::unsafe_arena_set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.provenance_);
  }
  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.OverrideProvenance.provenance)
}
inline ::anduril::entitymanager::v1::Provenance* OverrideProvenance::release_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Provenance* released = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Provenance* OverrideProvenance::unsafe_arena_release_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.OverrideProvenance.provenance)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Provenance* temp = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Provenance* OverrideProvenance::_internal_mutable_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.provenance_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Provenance>(GetArena());
    _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(p);
  }
  return _impl_.provenance_;
}
inline ::anduril::entitymanager::v1::Provenance* OverrideProvenance::mutable_provenance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Provenance* _msg = _internal_mutable_provenance();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.OverrideProvenance.provenance)
  return _msg;
}
inline void OverrideProvenance::set_allocated_provenance(::anduril::entitymanager::v1::Provenance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(_impl_.provenance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.provenance_ = reinterpret_cast<::anduril::entitymanager::v1::Provenance*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.OverrideProvenance.provenance)
}

// -------------------------------------------------------------------

// OriginalData_TLE

// string line1 = 1 [json_name = "line1"];
inline void OriginalData_TLE::clear_line1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.line1_.ClearToEmpty();
}
inline const std::string& OriginalData_TLE::line1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.OriginalData.TLE.line1)
  return _internal_line1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OriginalData_TLE::set_line1(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.line1_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.OriginalData.TLE.line1)
}
inline std::string* OriginalData_TLE::mutable_line1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_line1();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.OriginalData.TLE.line1)
  return _s;
}
inline const std::string& OriginalData_TLE::_internal_line1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.line1_.Get();
}
inline void OriginalData_TLE::_internal_set_line1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.line1_.Set(value, GetArena());
}
inline std::string* OriginalData_TLE::_internal_mutable_line1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.line1_.Mutable( GetArena());
}
inline std::string* OriginalData_TLE::release_line1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.OriginalData.TLE.line1)
  return _impl_.line1_.Release();
}
inline void OriginalData_TLE::set_allocated_line1(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.line1_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.line1_.IsDefault()) {
          _impl_.line1_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.OriginalData.TLE.line1)
}

// string line2 = 2 [json_name = "line2"];
inline void OriginalData_TLE::clear_line2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.line2_.ClearToEmpty();
}
inline const std::string& OriginalData_TLE::line2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.OriginalData.TLE.line2)
  return _internal_line2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OriginalData_TLE::set_line2(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.line2_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.OriginalData.TLE.line2)
}
inline std::string* OriginalData_TLE::mutable_line2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_line2();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.OriginalData.TLE.line2)
  return _s;
}
inline const std::string& OriginalData_TLE::_internal_line2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.line2_.Get();
}
inline void OriginalData_TLE::_internal_set_line2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.line2_.Set(value, GetArena());
}
inline std::string* OriginalData_TLE::_internal_mutable_line2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.line2_.Mutable( GetArena());
}
inline std::string* OriginalData_TLE::release_line2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.OriginalData.TLE.line2)
  return _impl_.line2_.Release();
}
inline void OriginalData_TLE::set_allocated_line2(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.line2_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.line2_.IsDefault()) {
          _impl_.line2_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.OriginalData.TLE.line2)
}

// -------------------------------------------------------------------

// OriginalData

// string url = 1 [json_name = "url"];
inline void OriginalData::clear_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.url_.ClearToEmpty();
}
inline const std::string& OriginalData::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.OriginalData.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OriginalData::set_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.OriginalData.url)
}
inline std::string* OriginalData::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.OriginalData.url)
  return _s;
}
inline const std::string& OriginalData::_internal_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.url_.Get();
}
inline void OriginalData::_internal_set_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* OriginalData::_internal_mutable_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* OriginalData::release_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.OriginalData.url)
  return _impl_.url_.Release();
}
inline void OriginalData::set_allocated_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.url_.IsDefault()) {
          _impl_.url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.OriginalData.url)
}

// .anduril.entitymanager.v1.OriginalData.TLE tle = 2 [json_name = "tle"];
inline bool OriginalData::has_tle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tle_ != nullptr);
  return value;
}
inline void OriginalData::clear_tle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tle_ != nullptr) _impl_.tle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::OriginalData_TLE& OriginalData::_internal_tle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::OriginalData_TLE* p = _impl_.tle_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::OriginalData_TLE&>(::anduril::entitymanager::v1::_OriginalData_TLE_default_instance_);
}
inline const ::anduril::entitymanager::v1::OriginalData_TLE& OriginalData::tle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.OriginalData.tle)
  return _internal_tle();
}
inline void OriginalData::unsafe_arena_set_allocated_tle(::anduril::entitymanager::v1::OriginalData_TLE* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tle_);
  }
  _impl_.tle_ = reinterpret_cast<::anduril::entitymanager::v1::OriginalData_TLE*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.OriginalData.tle)
}
inline ::anduril::entitymanager::v1::OriginalData_TLE* OriginalData::release_tle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::OriginalData_TLE* released = _impl_.tle_;
  _impl_.tle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::OriginalData_TLE* OriginalData::unsafe_arena_release_tle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.OriginalData.tle)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::OriginalData_TLE* temp = _impl_.tle_;
  _impl_.tle_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::OriginalData_TLE* OriginalData::_internal_mutable_tle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tle_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::OriginalData_TLE>(GetArena());
    _impl_.tle_ = reinterpret_cast<::anduril::entitymanager::v1::OriginalData_TLE*>(p);
  }
  return _impl_.tle_;
}
inline ::anduril::entitymanager::v1::OriginalData_TLE* OriginalData::mutable_tle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::OriginalData_TLE* _msg = _internal_mutable_tle();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.OriginalData.tle)
  return _msg;
}
inline void OriginalData::set_allocated_tle(::anduril::entitymanager::v1::OriginalData_TLE* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::OriginalData_TLE*>(_impl_.tle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::OriginalData_TLE*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tle_ = reinterpret_cast<::anduril::entitymanager::v1::OriginalData_TLE*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.OriginalData.tle)
}

// -------------------------------------------------------------------

// AlternateId

// string source = 1 [json_name = "source", deprecated = true];
inline void AlternateId::clear_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.ClearToEmpty();
}
inline const std::string& AlternateId::source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.AlternateId.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AlternateId::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.AlternateId.source)
}
inline std::string* AlternateId::mutable_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.AlternateId.source)
  return _s;
}
inline const std::string& AlternateId::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void AlternateId::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_.Set(value, GetArena());
}
inline std::string* AlternateId::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_.Mutable( GetArena());
}
inline std::string* AlternateId::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.AlternateId.source)
  return _impl_.source_.Release();
}
inline void AlternateId::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.AlternateId.source)
}

// string id = 2 [json_name = "id"];
inline void AlternateId::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AlternateId::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.AlternateId.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AlternateId::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.AlternateId.id)
}
inline std::string* AlternateId::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.AlternateId.id)
  return _s;
}
inline const std::string& AlternateId::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void AlternateId::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* AlternateId::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* AlternateId::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.AlternateId.id)
  return _impl_.id_.Release();
}
inline void AlternateId::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.AlternateId.id)
}

// .anduril.entitymanager.v1.AltIdType type = 3 [json_name = "type", (.anduril.entitymanager.v1.componentIdentifier) = true];
inline void AlternateId::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::anduril::entitymanager::v1::AltIdType AlternateId::type() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.AlternateId.type)
  return _internal_type();
}
inline void AlternateId::set_type(::anduril::entitymanager::v1::AltIdType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.AlternateId.type)
}
inline ::anduril::entitymanager::v1::AltIdType AlternateId::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::anduril::entitymanager::v1::AltIdType>(_impl_.type_);
}
inline void AlternateId::_internal_set_type(::anduril::entitymanager::v1::AltIdType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// VisualDetails

// .anduril.entitymanager.v1.RangeRings range_rings = 1 [json_name = "rangeRings", (.anduril.entitymanager.v1.overridable) = true];
inline bool VisualDetails::has_range_rings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.range_rings_ != nullptr);
  return value;
}
inline void VisualDetails::clear_range_rings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.range_rings_ != nullptr) _impl_.range_rings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entitymanager::v1::RangeRings& VisualDetails::_internal_range_rings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::RangeRings* p = _impl_.range_rings_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::RangeRings&>(::anduril::entitymanager::v1::_RangeRings_default_instance_);
}
inline const ::anduril::entitymanager::v1::RangeRings& VisualDetails::range_rings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.VisualDetails.range_rings)
  return _internal_range_rings();
}
inline void VisualDetails::unsafe_arena_set_allocated_range_rings(::anduril::entitymanager::v1::RangeRings* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.range_rings_);
  }
  _impl_.range_rings_ = reinterpret_cast<::anduril::entitymanager::v1::RangeRings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.VisualDetails.range_rings)
}
inline ::anduril::entitymanager::v1::RangeRings* VisualDetails::release_range_rings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::RangeRings* released = _impl_.range_rings_;
  _impl_.range_rings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::RangeRings* VisualDetails::unsafe_arena_release_range_rings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.VisualDetails.range_rings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::RangeRings* temp = _impl_.range_rings_;
  _impl_.range_rings_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::RangeRings* VisualDetails::_internal_mutable_range_rings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.range_rings_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::RangeRings>(GetArena());
    _impl_.range_rings_ = reinterpret_cast<::anduril::entitymanager::v1::RangeRings*>(p);
  }
  return _impl_.range_rings_;
}
inline ::anduril::entitymanager::v1::RangeRings* VisualDetails::mutable_range_rings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::RangeRings* _msg = _internal_mutable_range_rings();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.VisualDetails.range_rings)
  return _msg;
}
inline void VisualDetails::set_allocated_range_rings(::anduril::entitymanager::v1::RangeRings* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entitymanager::v1::RangeRings*>(_impl_.range_rings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entitymanager::v1::RangeRings*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.range_rings_ = reinterpret_cast<::anduril::entitymanager::v1::RangeRings*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.VisualDetails.range_rings)
}

// .anduril.entitymanager.v1.InteractivityMode interactivity_mode = 2 [json_name = "interactivityMode"];
inline void VisualDetails::clear_interactivity_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interactivity_mode_ = 0;
}
inline ::anduril::entitymanager::v1::InteractivityMode VisualDetails::interactivity_mode() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.VisualDetails.interactivity_mode)
  return _internal_interactivity_mode();
}
inline void VisualDetails::set_interactivity_mode(::anduril::entitymanager::v1::InteractivityMode value) {
  _internal_set_interactivity_mode(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.VisualDetails.interactivity_mode)
}
inline ::anduril::entitymanager::v1::InteractivityMode VisualDetails::_internal_interactivity_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::anduril::entitymanager::v1::InteractivityMode>(_impl_.interactivity_mode_);
}
inline void VisualDetails::_internal_set_interactivity_mode(::anduril::entitymanager::v1::InteractivityMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interactivity_mode_ = value;
}

// -------------------------------------------------------------------

// RangeRings

// .google.protobuf.DoubleValue min_distance_m = 1 [json_name = "minDistanceM"];
inline bool RangeRings::has_min_distance_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_distance_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& RangeRings::_internal_min_distance_m() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::DoubleValue* p = _impl_.min_distance_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& RangeRings::min_distance_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RangeRings.min_distance_m)
  return _internal_min_distance_m();
}
inline void RangeRings::unsafe_arena_set_allocated_min_distance_m(::google::protobuf::DoubleValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_distance_m_);
  }
  _impl_.min_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RangeRings.min_distance_m)
}
inline ::google::protobuf::DoubleValue* RangeRings::release_min_distance_m() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.min_distance_m_;
  _impl_.min_distance_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* RangeRings::unsafe_arena_release_min_distance_m() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RangeRings.min_distance_m)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.min_distance_m_;
  _impl_.min_distance_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* RangeRings::_internal_mutable_min_distance_m() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.min_distance_m_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::DoubleValue>(GetArena());
    _impl_.min_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.min_distance_m_;
}
inline ::google::protobuf::DoubleValue* RangeRings::mutable_min_distance_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_min_distance_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RangeRings.min_distance_m)
  return _msg;
}
inline void RangeRings::set_allocated_min_distance_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_distance_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.min_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.RangeRings.min_distance_m)
}

// .google.protobuf.DoubleValue max_distance_m = 2 [json_name = "maxDistanceM"];
inline bool RangeRings::has_max_distance_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_distance_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& RangeRings::_internal_max_distance_m() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::DoubleValue* p = _impl_.max_distance_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& RangeRings::max_distance_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RangeRings.max_distance_m)
  return _internal_max_distance_m();
}
inline void RangeRings::unsafe_arena_set_allocated_max_distance_m(::google::protobuf::DoubleValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_distance_m_);
  }
  _impl_.max_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entitymanager.v1.RangeRings.max_distance_m)
}
inline ::google::protobuf::DoubleValue* RangeRings::release_max_distance_m() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* released = _impl_.max_distance_m_;
  _impl_.max_distance_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* RangeRings::unsafe_arena_release_max_distance_m() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entitymanager.v1.RangeRings.max_distance_m)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* temp = _impl_.max_distance_m_;
  _impl_.max_distance_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* RangeRings::_internal_mutable_max_distance_m() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.max_distance_m_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::DoubleValue>(GetArena());
    _impl_.max_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.max_distance_m_;
}
inline ::google::protobuf::DoubleValue* RangeRings::mutable_max_distance_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_max_distance_m();
  // @@protoc_insertion_point(field_mutable:anduril.entitymanager.v1.RangeRings.max_distance_m)
  return _msg;
}
inline void RangeRings::set_allocated_max_distance_m(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_distance_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.max_distance_m_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entitymanager.v1.RangeRings.max_distance_m)
}

// uint32 ring_count = 3 [json_name = "ringCount"];
inline void RangeRings::clear_ring_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ring_count_ = 0u;
}
inline ::uint32_t RangeRings::ring_count() const {
  // @@protoc_insertion_point(field_get:anduril.entitymanager.v1.RangeRings.ring_count)
  return _internal_ring_count();
}
inline void RangeRings::set_ring_count(::uint32_t value) {
  _internal_set_ring_count(value);
  // @@protoc_insertion_point(field_set:anduril.entitymanager.v1.RangeRings.ring_count)
}
inline ::uint32_t RangeRings::_internal_ring_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ring_count_;
}
inline void RangeRings::_internal_set_ring_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ring_count_ = value;
}

// -------------------------------------------------------------------

// TeamStatus

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace entitymanager
}  // namespace anduril


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::anduril::entitymanager::v1::Deletable> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::Deletable>() {
  return ::anduril::entitymanager::v1::Deletable_descriptor();
}
template <>
struct is_proto_enum<::anduril::entitymanager::v1::InteractivityMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::entitymanager::v1::InteractivityMode>() {
  return ::anduril::entitymanager::v1::InteractivityMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2fentitymanager_2fv1_2fentity_2epub_2eproto_2epb_2eh
