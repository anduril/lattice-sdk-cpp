// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/taskmanager/v1/task.pub.proto
// Protobuf C++ Version: 5.29.0

#ifndef anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto_2epb_2eh
#define anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "anduril/entitymanager/v1/entity.pub.pb.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
namespace anduril {
namespace taskmanager {
namespace v1 {
class Agent;
struct AgentDefaultTypeInternal;
extern AgentDefaultTypeInternal _Agent_default_instance_;
class Allocation;
struct AllocationDefaultTypeInternal;
extern AllocationDefaultTypeInternal _Allocation_default_instance_;
class DefinitionUpdate;
struct DefinitionUpdateDefaultTypeInternal;
extern DefinitionUpdateDefaultTypeInternal _DefinitionUpdate_default_instance_;
class Owner;
struct OwnerDefaultTypeInternal;
extern OwnerDefaultTypeInternal _Owner_default_instance_;
class Principal;
struct PrincipalDefaultTypeInternal;
extern PrincipalDefaultTypeInternal _Principal_default_instance_;
class Relations;
struct RelationsDefaultTypeInternal;
extern RelationsDefaultTypeInternal _Relations_default_instance_;
class Replication;
struct ReplicationDefaultTypeInternal;
extern ReplicationDefaultTypeInternal _Replication_default_instance_;
class StatusUpdate;
struct StatusUpdateDefaultTypeInternal;
extern StatusUpdateDefaultTypeInternal _StatusUpdate_default_instance_;
class System;
struct SystemDefaultTypeInternal;
extern SystemDefaultTypeInternal _System_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskEntity;
struct TaskEntityDefaultTypeInternal;
extern TaskEntityDefaultTypeInternal _TaskEntity_default_instance_;
class TaskError;
struct TaskErrorDefaultTypeInternal;
extern TaskErrorDefaultTypeInternal _TaskError_default_instance_;
class TaskEvent;
struct TaskEventDefaultTypeInternal;
extern TaskEventDefaultTypeInternal _TaskEvent_default_instance_;
class TaskStatus;
struct TaskStatusDefaultTypeInternal;
extern TaskStatusDefaultTypeInternal _TaskStatus_default_instance_;
class TaskVersion;
struct TaskVersionDefaultTypeInternal;
extern TaskVersionDefaultTypeInternal _TaskVersion_default_instance_;
class Team;
struct TeamDefaultTypeInternal;
extern TeamDefaultTypeInternal _Team_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace v1
}  // namespace taskmanager
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace taskmanager {
namespace v1 {
enum Status : int {
  STATUS_INVALID = 0,
  STATUS_CREATED = 1,
  STATUS_SCHEDULED_IN_MANAGER = 2,
  STATUS_SENT = 3,
  STATUS_MACHINE_RECEIPT = 4,
  STATUS_ACK = 5,
  STATUS_WILCO = 6,
  STATUS_EXECUTING = 7,
  STATUS_WAITING_FOR_UPDATE = 8,
  STATUS_DONE_OK = 9,
  STATUS_DONE_NOT_OK = 10,
  STATUS_REPLACED = 11,
  STATUS_CANCEL_REQUESTED = 12,
  STATUS_COMPLETE_REQUESTED = 13,
  STATUS_VERSION_REJECTED = 14,
  Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Status_IsValid(int value);
extern const uint32_t Status_internal_data_[];
constexpr Status Status_MIN = static_cast<Status>(0);
constexpr Status Status_MAX = static_cast<Status>(14);
constexpr int Status_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor*
Status_descriptor();
template <typename T>
const std::string& Status_Name(T value) {
  static_assert(std::is_same<T, Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return Status_Name(static_cast<Status>(value));
}
template <>
inline const std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Status_descriptor,
                                                 0, 14>(
      static_cast<int>(value));
}
inline bool Status_Parse(absl::string_view name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
      Status_descriptor(), name, value);
}
enum ErrorCode : int {
  ERROR_CODE_INVALID = 0,
  ERROR_CODE_CANCELLED = 1,
  ERROR_CODE_REJECTED = 2,
  ERROR_CODE_TIMEOUT = 3,
  ERROR_CODE_FAILED = 4,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ErrorCode_IsValid(int value);
extern const uint32_t ErrorCode_internal_data_[];
constexpr ErrorCode ErrorCode_MIN = static_cast<ErrorCode>(0);
constexpr ErrorCode ErrorCode_MAX = static_cast<ErrorCode>(4);
constexpr int ErrorCode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ErrorCode_descriptor();
template <typename T>
const std::string& ErrorCode_Name(T value) {
  static_assert(std::is_same<T, ErrorCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorCode_Name().");
  return ErrorCode_Name(static_cast<ErrorCode>(value));
}
template <>
inline const std::string& ErrorCode_Name(ErrorCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ErrorCode_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ErrorCode_Parse(absl::string_view name, ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorCode>(
      ErrorCode_descriptor(), name, value);
}
enum EventType : int {
  EVENT_TYPE_INVALID = 0,
  EVENT_TYPE_CREATED = 1,
  EVENT_TYPE_UPDATE = 2,
  EVENT_TYPE_PREEXISTING = 3,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EventType_IsValid(int value);
extern const uint32_t EventType_internal_data_[];
constexpr EventType EventType_MIN = static_cast<EventType>(0);
constexpr EventType EventType_MAX = static_cast<EventType>(3);
constexpr int EventType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
EventType_descriptor();
template <typename T>
const std::string& EventType_Name(T value) {
  static_assert(std::is_same<T, EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return EventType_Name(static_cast<EventType>(value));
}
template <>
inline const std::string& EventType_Name(EventType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EventType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool EventType_Parse(absl::string_view name, EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventType>(
      EventType_descriptor(), name, value);
}
enum TaskView : int {
  TASK_VIEW_INVALID = 0,
  TASK_VIEW_MANAGER = 1,
  TASK_VIEW_AGENT = 2,
  TaskView_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TaskView_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TaskView_IsValid(int value);
extern const uint32_t TaskView_internal_data_[];
constexpr TaskView TaskView_MIN = static_cast<TaskView>(0);
constexpr TaskView TaskView_MAX = static_cast<TaskView>(2);
constexpr int TaskView_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
TaskView_descriptor();
template <typename T>
const std::string& TaskView_Name(T value) {
  static_assert(std::is_same<T, TaskView>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskView_Name().");
  return TaskView_Name(static_cast<TaskView>(value));
}
template <>
inline const std::string& TaskView_Name(TaskView value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskView_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TaskView_Parse(absl::string_view name, TaskView* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskView>(
      TaskView_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class User final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(User* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(User));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR User(
      ::google::protobuf::internal::ConstantInitialized);

  inline User(const User& from) : User(nullptr, from) {}
  inline User(User&& from) noexcept
      : User(nullptr, std::move(from)) {}
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
        &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(User& a, User& b) { a.Swap(&b); }
  inline void Swap(User* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<User>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const User& from) { User::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(User* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.User"; }

 protected:
  explicit User(::google::protobuf::Arena* arena);
  User(::google::protobuf::Arena* arena, const User& from);
  User(::google::protobuf::Arena* arena, User&& from) noexcept
      : User(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.User)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      43, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const User& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class TaskVersion final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.TaskVersion) */ {
 public:
  inline TaskVersion() : TaskVersion(nullptr) {}
  ~TaskVersion() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaskVersion* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaskVersion));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskVersion(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskVersion(const TaskVersion& from) : TaskVersion(nullptr, from) {}
  inline TaskVersion(TaskVersion&& from) noexcept
      : TaskVersion(nullptr, std::move(from)) {}
  inline TaskVersion& operator=(const TaskVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskVersion& operator=(TaskVersion&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskVersion* internal_default_instance() {
    return reinterpret_cast<const TaskVersion*>(
        &_TaskVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(TaskVersion& a, TaskVersion& b) { a.Swap(&b); }
  inline void Swap(TaskVersion* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskVersion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskVersion* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaskVersion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskVersion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskVersion& from) { TaskVersion::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaskVersion* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.TaskVersion"; }

 protected:
  explicit TaskVersion(::google::protobuf::Arena* arena);
  TaskVersion(::google::protobuf::Arena* arena, const TaskVersion& from);
  TaskVersion(::google::protobuf::Arena* arena, TaskVersion&& from) noexcept
      : TaskVersion(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskIdFieldNumber = 1,
    kDefinitionVersionFieldNumber = 2,
    kStatusVersionFieldNumber = 3,
  };
  // string task_id = 1 [json_name = "taskId"];
  void clear_task_id() ;
  const std::string& task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* value);

  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(
      const std::string& value);
  std::string* _internal_mutable_task_id();

  public:
  // uint32 definition_version = 2 [json_name = "definitionVersion"];
  void clear_definition_version() ;
  ::uint32_t definition_version() const;
  void set_definition_version(::uint32_t value);

  private:
  ::uint32_t _internal_definition_version() const;
  void _internal_set_definition_version(::uint32_t value);

  public:
  // uint32 status_version = 3 [json_name = "statusVersion"];
  void clear_status_version() ;
  ::uint32_t status_version() const;
  void set_status_version(::uint32_t value);

  private:
  ::uint32_t _internal_status_version() const;
  void _internal_set_status_version(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.TaskVersion)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaskVersion& from_msg);
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    ::uint32_t definition_version_;
    ::uint32_t status_version_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class System final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.System) */ {
 public:
  inline System() : System(nullptr) {}
  ~System() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(System* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(System));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR System(
      ::google::protobuf::internal::ConstantInitialized);

  inline System(const System& from) : System(nullptr, from) {}
  inline System(System&& from) noexcept
      : System(nullptr, std::move(from)) {}
  inline System& operator=(const System& from) {
    CopyFrom(from);
    return *this;
  }
  inline System& operator=(System&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const System& default_instance() {
    return *internal_default_instance();
  }
  static inline const System* internal_default_instance() {
    return reinterpret_cast<const System*>(
        &_System_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(System& a, System& b) { a.Swap(&b); }
  inline void Swap(System* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(System* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  System* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<System>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const System& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const System& from) { System::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(System* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.System"; }

 protected:
  explicit System(::google::protobuf::Arena* arena);
  System(::google::protobuf::Arena* arena, const System& from);
  System(::google::protobuf::Arena* arena, System&& from) noexcept
      : System(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kServiceNameFieldNumber = 1,
    kEntityIdFieldNumber = 2,
    kManagesOwnSchedulingFieldNumber = 4,
  };
  // string service_name = 1 [json_name = "serviceName"];
  void clear_service_name() ;
  const std::string& service_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service_name(Arg_&& arg, Args_... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* value);

  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(
      const std::string& value);
  std::string* _internal_mutable_service_name();

  public:
  // string entity_id = 2 [json_name = "entityId"];
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // bool manages_own_scheduling = 4 [json_name = "managesOwnScheduling"];
  void clear_manages_own_scheduling() ;
  bool manages_own_scheduling() const;
  void set_manages_own_scheduling(bool value);

  private:
  bool _internal_manages_own_scheduling() const;
  void _internal_set_manages_own_scheduling(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.System)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      59, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const System& from_msg);
    ::google::protobuf::internal::ArenaStringPtr service_name_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    bool manages_own_scheduling_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class Owner final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.Owner) */ {
 public:
  inline Owner() : Owner(nullptr) {}
  ~Owner() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Owner* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Owner));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Owner(
      ::google::protobuf::internal::ConstantInitialized);

  inline Owner(const Owner& from) : Owner(nullptr, from) {}
  inline Owner(Owner&& from) noexcept
      : Owner(nullptr, std::move(from)) {}
  inline Owner& operator=(const Owner& from) {
    CopyFrom(from);
    return *this;
  }
  inline Owner& operator=(Owner&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Owner& default_instance() {
    return *internal_default_instance();
  }
  static inline const Owner* internal_default_instance() {
    return reinterpret_cast<const Owner*>(
        &_Owner_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Owner& a, Owner& b) { a.Swap(&b); }
  inline void Swap(Owner* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Owner* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Owner* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Owner>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Owner& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Owner& from) { Owner::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Owner* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.Owner"; }

 protected:
  explicit Owner(::google::protobuf::Arena* arena);
  Owner(::google::protobuf::Arena* arena, const Owner& from);
  Owner(::google::protobuf::Arena* arena, Owner&& from) noexcept
      : Owner(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 2,
  };
  // string entity_id = 2 [json_name = "entityId"];
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.Owner)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Owner& from_msg);
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class Agent final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.Agent) */ {
 public:
  inline Agent() : Agent(nullptr) {}
  ~Agent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Agent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Agent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Agent(
      ::google::protobuf::internal::ConstantInitialized);

  inline Agent(const Agent& from) : Agent(nullptr, from) {}
  inline Agent(Agent&& from) noexcept
      : Agent(nullptr, std::move(from)) {}
  inline Agent& operator=(const Agent& from) {
    CopyFrom(from);
    return *this;
  }
  inline Agent& operator=(Agent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Agent& default_instance() {
    return *internal_default_instance();
  }
  static inline const Agent* internal_default_instance() {
    return reinterpret_cast<const Agent*>(
        &_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(Agent& a, Agent& b) { a.Swap(&b); }
  inline void Swap(Agent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Agent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Agent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Agent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Agent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Agent& from) { Agent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Agent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.Agent"; }

 protected:
  explicit Agent(::google::protobuf::Arena* arena);
  Agent(::google::protobuf::Arena* arena, const Agent& from);
  Agent(::google::protobuf::Arena* arena, Agent&& from) noexcept
      : Agent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 2,
  };
  // string entity_id = 2 [json_name = "entityId"];
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.Agent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Agent& from_msg);
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class Team final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.Team) */ {
 public:
  inline Team() : Team(nullptr) {}
  ~Team() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Team* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Team));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Team(
      ::google::protobuf::internal::ConstantInitialized);

  inline Team(const Team& from) : Team(nullptr, from) {}
  inline Team(Team&& from) noexcept
      : Team(nullptr, std::move(from)) {}
  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }
  inline Team& operator=(Team&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Team& default_instance() {
    return *internal_default_instance();
  }
  static inline const Team* internal_default_instance() {
    return reinterpret_cast<const Team*>(
        &_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Team& a, Team& b) { a.Swap(&b); }
  inline void Swap(Team* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Team* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Team* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Team>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Team& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Team& from) { Team::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Team* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.Team"; }

 protected:
  explicit Team(::google::protobuf::Arena* arena);
  Team(::google::protobuf::Arena* arena, const Team& from);
  Team(::google::protobuf::Arena* arena, Team&& from) noexcept
      : Team(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMembersFieldNumber = 2,
    kEntityIdFieldNumber = 1,
  };
  // repeated .anduril.taskmanager.v1.Agent members = 2 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;

  public:
  void clear_members() ;
  ::anduril::taskmanager::v1::Agent* mutable_members(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>* mutable_members();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>& _internal_members() const;
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>* _internal_mutable_members();
  public:
  const ::anduril::taskmanager::v1::Agent& members(int index) const;
  ::anduril::taskmanager::v1::Agent* add_members();
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>& members() const;
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.Team)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      45, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Team& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::taskmanager::v1::Agent > members_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class TaskError final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.TaskError) */ {
 public:
  inline TaskError() : TaskError(nullptr) {}
  ~TaskError() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaskError* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaskError));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskError(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskError(const TaskError& from) : TaskError(nullptr, from) {}
  inline TaskError(TaskError&& from) noexcept
      : TaskError(nullptr, std::move(from)) {}
  inline TaskError& operator=(const TaskError& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskError& operator=(TaskError&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskError& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskError* internal_default_instance() {
    return reinterpret_cast<const TaskError*>(
        &_TaskError_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(TaskError& a, TaskError& b) { a.Swap(&b); }
  inline void Swap(TaskError* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskError* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskError* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaskError>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskError& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskError& from) { TaskError::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaskError* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.TaskError"; }

 protected:
  explicit TaskError(::google::protobuf::Arena* arena);
  TaskError(::google::protobuf::Arena* arena, const TaskError& from);
  TaskError(::google::protobuf::Arena* arena, TaskError&& from) noexcept
      : TaskError(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kErrorDetailsFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .google.protobuf.Any error_details = 3 [json_name = "errorDetails"];
  bool has_error_details() const;
  void clear_error_details() ;
  const ::google::protobuf::Any& error_details() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_error_details();
  ::google::protobuf::Any* mutable_error_details();
  void set_allocated_error_details(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_error_details(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_error_details();

  private:
  const ::google::protobuf::Any& _internal_error_details() const;
  ::google::protobuf::Any* _internal_mutable_error_details();

  public:
  // .anduril.taskmanager.v1.ErrorCode code = 1 [json_name = "code"];
  void clear_code() ;
  ::anduril::taskmanager::v1::ErrorCode code() const;
  void set_code(::anduril::taskmanager::v1::ErrorCode value);

  private:
  ::anduril::taskmanager::v1::ErrorCode _internal_code() const;
  void _internal_set_code(::anduril::taskmanager::v1::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.TaskError)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      48, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaskError& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::Any* error_details_;
    int code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class Replication final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.Replication) */ {
 public:
  inline Replication() : Replication(nullptr) {}
  ~Replication() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Replication* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Replication));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Replication(
      ::google::protobuf::internal::ConstantInitialized);

  inline Replication(const Replication& from) : Replication(nullptr, from) {}
  inline Replication(Replication&& from) noexcept
      : Replication(nullptr, std::move(from)) {}
  inline Replication& operator=(const Replication& from) {
    CopyFrom(from);
    return *this;
  }
  inline Replication& operator=(Replication&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Replication& default_instance() {
    return *internal_default_instance();
  }
  static inline const Replication* internal_default_instance() {
    return reinterpret_cast<const Replication*>(
        &_Replication_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Replication& a, Replication& b) { a.Swap(&b); }
  inline void Swap(Replication* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Replication* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Replication* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Replication>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Replication& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Replication& from) { Replication::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Replication* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.Replication"; }

 protected:
  explicit Replication(::google::protobuf::Arena* arena);
  Replication(::google::protobuf::Arena* arena, const Replication& from);
  Replication(::google::protobuf::Arena* arena, Replication&& from) noexcept
      : Replication(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStaleTimeFieldNumber = 1,
  };
  // .google.protobuf.Timestamp stale_time = 1 [json_name = "staleTime"];
  bool has_stale_time() const;
  void clear_stale_time() ;
  const ::google::protobuf::Timestamp& stale_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_stale_time();
  ::google::protobuf::Timestamp* mutable_stale_time();
  void set_allocated_stale_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_stale_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_stale_time();

  private:
  const ::google::protobuf::Timestamp& _internal_stale_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_stale_time();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.Replication)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Replication& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* stale_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class Allocation final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.Allocation) */ {
 public:
  inline Allocation() : Allocation(nullptr) {}
  ~Allocation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Allocation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Allocation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Allocation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Allocation(const Allocation& from) : Allocation(nullptr, from) {}
  inline Allocation(Allocation&& from) noexcept
      : Allocation(nullptr, std::move(from)) {}
  inline Allocation& operator=(const Allocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Allocation& operator=(Allocation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Allocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Allocation* internal_default_instance() {
    return reinterpret_cast<const Allocation*>(
        &_Allocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Allocation& a, Allocation& b) { a.Swap(&b); }
  inline void Swap(Allocation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Allocation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Allocation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Allocation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Allocation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Allocation& from) { Allocation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Allocation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.Allocation"; }

 protected:
  explicit Allocation(::google::protobuf::Arena* arena);
  Allocation(::google::protobuf::Arena* arena, const Allocation& from);
  Allocation(::google::protobuf::Arena* arena, Allocation&& from) noexcept
      : Allocation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActiveAgentsFieldNumber = 1,
  };
  // repeated .anduril.taskmanager.v1.Agent active_agents = 1 [json_name = "activeAgents"];
  int active_agents_size() const;
  private:
  int _internal_active_agents_size() const;

  public:
  void clear_active_agents() ;
  ::anduril::taskmanager::v1::Agent* mutable_active_agents(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>* mutable_active_agents();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>& _internal_active_agents() const;
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>* _internal_mutable_active_agents();
  public:
  const ::anduril::taskmanager::v1::Agent& active_agents(int index) const;
  ::anduril::taskmanager::v1::Agent* add_active_agents();
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>& active_agents() const;
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.Allocation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Allocation& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::taskmanager::v1::Agent > active_agents_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class TaskStatus final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.TaskStatus) */ {
 public:
  inline TaskStatus() : TaskStatus(nullptr) {}
  ~TaskStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaskStatus* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaskStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskStatus(const TaskStatus& from) : TaskStatus(nullptr, from) {}
  inline TaskStatus(TaskStatus&& from) noexcept
      : TaskStatus(nullptr, std::move(from)) {}
  inline TaskStatus& operator=(const TaskStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskStatus& operator=(TaskStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskStatus* internal_default_instance() {
    return reinterpret_cast<const TaskStatus*>(
        &_TaskStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(TaskStatus& a, TaskStatus& b) { a.Swap(&b); }
  inline void Swap(TaskStatus* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskStatus* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaskStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskStatus& from) { TaskStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaskStatus* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.TaskStatus"; }

 protected:
  explicit TaskStatus(::google::protobuf::Arena* arena);
  TaskStatus(::google::protobuf::Arena* arena, const TaskStatus& from);
  TaskStatus(::google::protobuf::Arena* arena, TaskStatus&& from) noexcept
      : TaskStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskErrorFieldNumber = 2,
    kProgressFieldNumber = 4,
    kResultFieldNumber = 5,
    kStartTimeFieldNumber = 6,
    kEstimateFieldNumber = 7,
    kAllocationFieldNumber = 8,
    kStatusFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.TaskError task_error = 2 [json_name = "taskError"];
  bool has_task_error() const;
  void clear_task_error() ;
  const ::anduril::taskmanager::v1::TaskError& task_error() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::TaskError* release_task_error();
  ::anduril::taskmanager::v1::TaskError* mutable_task_error();
  void set_allocated_task_error(::anduril::taskmanager::v1::TaskError* value);
  void unsafe_arena_set_allocated_task_error(::anduril::taskmanager::v1::TaskError* value);
  ::anduril::taskmanager::v1::TaskError* unsafe_arena_release_task_error();

  private:
  const ::anduril::taskmanager::v1::TaskError& _internal_task_error() const;
  ::anduril::taskmanager::v1::TaskError* _internal_mutable_task_error();

  public:
  // .google.protobuf.Any progress = 4 [json_name = "progress"];
  bool has_progress() const;
  void clear_progress() ;
  const ::google::protobuf::Any& progress() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_progress();
  ::google::protobuf::Any* mutable_progress();
  void set_allocated_progress(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_progress(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_progress();

  private:
  const ::google::protobuf::Any& _internal_progress() const;
  ::google::protobuf::Any* _internal_mutable_progress();

  public:
  // .google.protobuf.Any result = 5 [json_name = "result"];
  bool has_result() const;
  void clear_result() ;
  const ::google::protobuf::Any& result() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_result();
  ::google::protobuf::Any* mutable_result();
  void set_allocated_result(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_result(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_result();

  private:
  const ::google::protobuf::Any& _internal_result() const;
  ::google::protobuf::Any* _internal_mutable_result();

  public:
  // .google.protobuf.Timestamp start_time = 6 [json_name = "startTime"];
  bool has_start_time() const;
  void clear_start_time() ;
  const ::google::protobuf::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_start_time();
  ::google::protobuf::Timestamp* mutable_start_time();
  void set_allocated_start_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_start_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_start_time();

  private:
  const ::google::protobuf::Timestamp& _internal_start_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_start_time();

  public:
  // .google.protobuf.Any estimate = 7 [json_name = "estimate"];
  bool has_estimate() const;
  void clear_estimate() ;
  const ::google::protobuf::Any& estimate() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_estimate();
  ::google::protobuf::Any* mutable_estimate();
  void set_allocated_estimate(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_estimate(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_estimate();

  private:
  const ::google::protobuf::Any& _internal_estimate() const;
  ::google::protobuf::Any* _internal_mutable_estimate();

  public:
  // .anduril.taskmanager.v1.Allocation allocation = 8 [json_name = "allocation"];
  bool has_allocation() const;
  void clear_allocation() ;
  const ::anduril::taskmanager::v1::Allocation& allocation() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Allocation* release_allocation();
  ::anduril::taskmanager::v1::Allocation* mutable_allocation();
  void set_allocated_allocation(::anduril::taskmanager::v1::Allocation* value);
  void unsafe_arena_set_allocated_allocation(::anduril::taskmanager::v1::Allocation* value);
  ::anduril::taskmanager::v1::Allocation* unsafe_arena_release_allocation();

  private:
  const ::anduril::taskmanager::v1::Allocation& _internal_allocation() const;
  ::anduril::taskmanager::v1::Allocation* _internal_mutable_allocation();

  public:
  // .anduril.taskmanager.v1.Status status = 1 [json_name = "status"];
  void clear_status() ;
  ::anduril::taskmanager::v1::Status status() const;
  void set_status(::anduril::taskmanager::v1::Status value);

  private:
  ::anduril::taskmanager::v1::Status _internal_status() const;
  void _internal_set_status(::anduril::taskmanager::v1::Status value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.TaskStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaskStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::TaskError* task_error_;
    ::google::protobuf::Any* progress_;
    ::google::protobuf::Any* result_;
    ::google::protobuf::Timestamp* start_time_;
    ::google::protobuf::Any* estimate_;
    ::anduril::taskmanager::v1::Allocation* allocation_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class Principal final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.Principal) */ {
 public:
  inline Principal() : Principal(nullptr) {}
  ~Principal() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Principal* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Principal));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Principal(
      ::google::protobuf::internal::ConstantInitialized);

  inline Principal(const Principal& from) : Principal(nullptr, from) {}
  inline Principal(Principal&& from) noexcept
      : Principal(nullptr, std::move(from)) {}
  inline Principal& operator=(const Principal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Principal& operator=(Principal&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Principal& default_instance() {
    return *internal_default_instance();
  }
  enum AgentCase {
    kSystem = 1,
    kUser = 2,
    kTeam = 4,
    AGENT_NOT_SET = 0,
  };
  static inline const Principal* internal_default_instance() {
    return reinterpret_cast<const Principal*>(
        &_Principal_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Principal& a, Principal& b) { a.Swap(&b); }
  inline void Swap(Principal* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Principal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Principal* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Principal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Principal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Principal& from) { Principal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Principal* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.Principal"; }

 protected:
  explicit Principal(::google::protobuf::Arena* arena);
  Principal(::google::protobuf::Arena* arena, const Principal& from);
  Principal(::google::protobuf::Arena* arena, Principal&& from) noexcept
      : Principal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOnBehalfOfFieldNumber = 3,
    kSystemFieldNumber = 1,
    kUserFieldNumber = 2,
    kTeamFieldNumber = 4,
  };
  // .anduril.taskmanager.v1.Principal on_behalf_of = 3 [json_name = "onBehalfOf"];
  bool has_on_behalf_of() const;
  void clear_on_behalf_of() ;
  const ::anduril::taskmanager::v1::Principal& on_behalf_of() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Principal* release_on_behalf_of();
  ::anduril::taskmanager::v1::Principal* mutable_on_behalf_of();
  void set_allocated_on_behalf_of(::anduril::taskmanager::v1::Principal* value);
  void unsafe_arena_set_allocated_on_behalf_of(::anduril::taskmanager::v1::Principal* value);
  ::anduril::taskmanager::v1::Principal* unsafe_arena_release_on_behalf_of();

  private:
  const ::anduril::taskmanager::v1::Principal& _internal_on_behalf_of() const;
  ::anduril::taskmanager::v1::Principal* _internal_mutable_on_behalf_of();

  public:
  // .anduril.taskmanager.v1.System system = 1 [json_name = "system"];
  bool has_system() const;
  private:
  bool _internal_has_system() const;

  public:
  void clear_system() ;
  const ::anduril::taskmanager::v1::System& system() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::System* release_system();
  ::anduril::taskmanager::v1::System* mutable_system();
  void set_allocated_system(::anduril::taskmanager::v1::System* value);
  void unsafe_arena_set_allocated_system(::anduril::taskmanager::v1::System* value);
  ::anduril::taskmanager::v1::System* unsafe_arena_release_system();

  private:
  const ::anduril::taskmanager::v1::System& _internal_system() const;
  ::anduril::taskmanager::v1::System* _internal_mutable_system();

  public:
  // .anduril.taskmanager.v1.User user = 2 [json_name = "user"];
  bool has_user() const;
  private:
  bool _internal_has_user() const;

  public:
  void clear_user() ;
  const ::anduril::taskmanager::v1::User& user() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::User* release_user();
  ::anduril::taskmanager::v1::User* mutable_user();
  void set_allocated_user(::anduril::taskmanager::v1::User* value);
  void unsafe_arena_set_allocated_user(::anduril::taskmanager::v1::User* value);
  ::anduril::taskmanager::v1::User* unsafe_arena_release_user();

  private:
  const ::anduril::taskmanager::v1::User& _internal_user() const;
  ::anduril::taskmanager::v1::User* _internal_mutable_user();

  public:
  // .anduril.taskmanager.v1.Team team = 4 [json_name = "team"];
  bool has_team() const;
  private:
  bool _internal_has_team() const;

  public:
  void clear_team() ;
  const ::anduril::taskmanager::v1::Team& team() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Team* release_team();
  ::anduril::taskmanager::v1::Team* mutable_team();
  void set_allocated_team(::anduril::taskmanager::v1::Team* value);
  void unsafe_arena_set_allocated_team(::anduril::taskmanager::v1::Team* value);
  ::anduril::taskmanager::v1::Team* unsafe_arena_release_team();

  private:
  const ::anduril::taskmanager::v1::Team& _internal_team() const;
  ::anduril::taskmanager::v1::Team* _internal_mutable_team();

  public:
  void clear_agent();
  AgentCase agent_case() const;
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.Principal)
 private:
  class _Internal;
  void set_has_system();
  void set_has_user();
  void set_has_team();
  inline bool has_agent() const;
  inline void clear_has_agent();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Principal& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Principal* on_behalf_of_;
    union AgentUnion {
      constexpr AgentUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::taskmanager::v1::System* system_;
      ::anduril::taskmanager::v1::User* user_;
      ::anduril::taskmanager::v1::Team* team_;
    } agent_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class StatusUpdate final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.StatusUpdate) */ {
 public:
  inline StatusUpdate() : StatusUpdate(nullptr) {}
  ~StatusUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StatusUpdate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StatusUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StatusUpdate(
      ::google::protobuf::internal::ConstantInitialized);

  inline StatusUpdate(const StatusUpdate& from) : StatusUpdate(nullptr, from) {}
  inline StatusUpdate(StatusUpdate&& from) noexcept
      : StatusUpdate(nullptr, std::move(from)) {}
  inline StatusUpdate& operator=(const StatusUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusUpdate& operator=(StatusUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusUpdate* internal_default_instance() {
    return reinterpret_cast<const StatusUpdate*>(
        &_StatusUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(StatusUpdate& a, StatusUpdate& b) { a.Swap(&b); }
  inline void Swap(StatusUpdate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusUpdate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StatusUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatusUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StatusUpdate& from) { StatusUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StatusUpdate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.StatusUpdate"; }

 protected:
  explicit StatusUpdate(::google::protobuf::Arena* arena);
  StatusUpdate(::google::protobuf::Arena* arena, const StatusUpdate& from);
  StatusUpdate(::google::protobuf::Arena* arena, StatusUpdate&& from) noexcept
      : StatusUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVersionFieldNumber = 1,
    kStatusFieldNumber = 2,
    kAuthorFieldNumber = 3,
    kScheduledTimeFieldNumber = 4,
  };
  // .anduril.taskmanager.v1.TaskVersion version = 1 [json_name = "version"];
  bool has_version() const;
  void clear_version() ;
  const ::anduril::taskmanager::v1::TaskVersion& version() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::TaskVersion* release_version();
  ::anduril::taskmanager::v1::TaskVersion* mutable_version();
  void set_allocated_version(::anduril::taskmanager::v1::TaskVersion* value);
  void unsafe_arena_set_allocated_version(::anduril::taskmanager::v1::TaskVersion* value);
  ::anduril::taskmanager::v1::TaskVersion* unsafe_arena_release_version();

  private:
  const ::anduril::taskmanager::v1::TaskVersion& _internal_version() const;
  ::anduril::taskmanager::v1::TaskVersion* _internal_mutable_version();

  public:
  // .anduril.taskmanager.v1.TaskStatus status = 2 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::anduril::taskmanager::v1::TaskStatus& status() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::TaskStatus* release_status();
  ::anduril::taskmanager::v1::TaskStatus* mutable_status();
  void set_allocated_status(::anduril::taskmanager::v1::TaskStatus* value);
  void unsafe_arena_set_allocated_status(::anduril::taskmanager::v1::TaskStatus* value);
  ::anduril::taskmanager::v1::TaskStatus* unsafe_arena_release_status();

  private:
  const ::anduril::taskmanager::v1::TaskStatus& _internal_status() const;
  ::anduril::taskmanager::v1::TaskStatus* _internal_mutable_status();

  public:
  // .anduril.taskmanager.v1.Principal author = 3 [json_name = "author"];
  bool has_author() const;
  void clear_author() ;
  const ::anduril::taskmanager::v1::Principal& author() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Principal* release_author();
  ::anduril::taskmanager::v1::Principal* mutable_author();
  void set_allocated_author(::anduril::taskmanager::v1::Principal* value);
  void unsafe_arena_set_allocated_author(::anduril::taskmanager::v1::Principal* value);
  ::anduril::taskmanager::v1::Principal* unsafe_arena_release_author();

  private:
  const ::anduril::taskmanager::v1::Principal& _internal_author() const;
  ::anduril::taskmanager::v1::Principal* _internal_mutable_author();

  public:
  // .google.protobuf.Timestamp scheduled_time = 4 [json_name = "scheduledTime"];
  bool has_scheduled_time() const;
  void clear_scheduled_time() ;
  const ::google::protobuf::Timestamp& scheduled_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_scheduled_time();
  ::google::protobuf::Timestamp* mutable_scheduled_time();
  void set_allocated_scheduled_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_scheduled_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_scheduled_time();

  private:
  const ::google::protobuf::Timestamp& _internal_scheduled_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_scheduled_time();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.StatusUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StatusUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::TaskVersion* version_;
    ::anduril::taskmanager::v1::TaskStatus* status_;
    ::anduril::taskmanager::v1::Principal* author_;
    ::google::protobuf::Timestamp* scheduled_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class Relations final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.Relations) */ {
 public:
  inline Relations() : Relations(nullptr) {}
  ~Relations() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Relations* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Relations));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Relations(
      ::google::protobuf::internal::ConstantInitialized);

  inline Relations(const Relations& from) : Relations(nullptr, from) {}
  inline Relations(Relations&& from) noexcept
      : Relations(nullptr, std::move(from)) {}
  inline Relations& operator=(const Relations& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relations& operator=(Relations&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Relations& default_instance() {
    return *internal_default_instance();
  }
  static inline const Relations* internal_default_instance() {
    return reinterpret_cast<const Relations*>(
        &_Relations_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Relations& a, Relations& b) { a.Swap(&b); }
  inline void Swap(Relations* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relations* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Relations* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Relations>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Relations& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Relations& from) { Relations::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Relations* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.Relations"; }

 protected:
  explicit Relations(::google::protobuf::Arena* arena);
  Relations(::google::protobuf::Arena* arena, const Relations& from);
  Relations(::google::protobuf::Arena* arena, Relations&& from) noexcept
      : Relations(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParentTaskIdFieldNumber = 2,
    kAssigneeFieldNumber = 1,
  };
  // string parent_task_id = 2 [json_name = "parentTaskId"];
  void clear_parent_task_id() ;
  const std::string& parent_task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_parent_task_id();
  PROTOBUF_NODISCARD std::string* release_parent_task_id();
  void set_allocated_parent_task_id(std::string* value);

  private:
  const std::string& _internal_parent_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_task_id(
      const std::string& value);
  std::string* _internal_mutable_parent_task_id();

  public:
  // .anduril.taskmanager.v1.Principal assignee = 1 [json_name = "assignee"];
  bool has_assignee() const;
  void clear_assignee() ;
  const ::anduril::taskmanager::v1::Principal& assignee() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Principal* release_assignee();
  ::anduril::taskmanager::v1::Principal* mutable_assignee();
  void set_allocated_assignee(::anduril::taskmanager::v1::Principal* value);
  void unsafe_arena_set_allocated_assignee(::anduril::taskmanager::v1::Principal* value);
  ::anduril::taskmanager::v1::Principal* unsafe_arena_release_assignee();

  private:
  const ::anduril::taskmanager::v1::Principal& _internal_assignee() const;
  ::anduril::taskmanager::v1::Principal* _internal_mutable_assignee();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.Relations)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      55, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Relations& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr parent_task_id_;
    ::anduril::taskmanager::v1::Principal* assignee_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class TaskEntity final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.TaskEntity) */ {
 public:
  inline TaskEntity() : TaskEntity(nullptr) {}
  ~TaskEntity() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaskEntity* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaskEntity));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskEntity(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskEntity(const TaskEntity& from) : TaskEntity(nullptr, from) {}
  inline TaskEntity(TaskEntity&& from) noexcept
      : TaskEntity(nullptr, std::move(from)) {}
  inline TaskEntity& operator=(const TaskEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskEntity& operator=(TaskEntity&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskEntity* internal_default_instance() {
    return reinterpret_cast<const TaskEntity*>(
        &_TaskEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(TaskEntity& a, TaskEntity& b) { a.Swap(&b); }
  inline void Swap(TaskEntity* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskEntity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskEntity* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaskEntity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskEntity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskEntity& from) { TaskEntity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaskEntity* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.TaskEntity"; }

 protected:
  explicit TaskEntity(::google::protobuf::Arena* arena);
  TaskEntity(::google::protobuf::Arena* arena, const TaskEntity& from);
  TaskEntity(::google::protobuf::Arena* arena, TaskEntity&& from) noexcept
      : TaskEntity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityFieldNumber = 1,
    kSnapshotFieldNumber = 2,
  };
  // .anduril.entitymanager.v1.Entity entity = 1 [json_name = "entity"];
  bool has_entity() const;
  void clear_entity() ;
  const ::anduril::entitymanager::v1::Entity& entity() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Entity* release_entity();
  ::anduril::entitymanager::v1::Entity* mutable_entity();
  void set_allocated_entity(::anduril::entitymanager::v1::Entity* value);
  void unsafe_arena_set_allocated_entity(::anduril::entitymanager::v1::Entity* value);
  ::anduril::entitymanager::v1::Entity* unsafe_arena_release_entity();

  private:
  const ::anduril::entitymanager::v1::Entity& _internal_entity() const;
  ::anduril::entitymanager::v1::Entity* _internal_mutable_entity();

  public:
  // bool snapshot = 2 [json_name = "snapshot"];
  void clear_snapshot() ;
  bool snapshot() const;
  void set_snapshot(bool value);

  private:
  bool _internal_snapshot() const;
  void _internal_set_snapshot(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.TaskEntity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaskEntity& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::entitymanager::v1::Entity* entity_;
    bool snapshot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class Task final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Task* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Task));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Task(
      ::google::protobuf::internal::ConstantInitialized);

  inline Task(const Task& from) : Task(nullptr, from) {}
  inline Task(Task&& from) noexcept
      : Task(nullptr, std::move(from)) {}
  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
        &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Task& a, Task& b) { a.Swap(&b); }
  inline void Swap(Task* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Task>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Task& from) { Task::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Task* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.Task"; }

 protected:
  explicit Task(::google::protobuf::Arena* arena);
  Task(::google::protobuf::Arena* arena, const Task& from);
  Task(::google::protobuf::Arena* arena, Task&& from) noexcept
      : Task(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInitialEntitiesFieldNumber = 15,
    kDisplayNameFieldNumber = 2,
    kDescriptionFieldNumber = 10,
    kVersionFieldNumber = 1,
    kSpecificationFieldNumber = 3,
    kLastUpdatedByFieldNumber = 4,
    kStatusFieldNumber = 5,
    kScheduledTimeFieldNumber = 6,
    kRelationsFieldNumber = 8,
    kLastUpdateTimeFieldNumber = 9,
    kOwnerFieldNumber = 12,
    kCreateTimeFieldNumber = 13,
    kReplicationFieldNumber = 14,
    kCreatedByFieldNumber = 16,
    kIsExecutedElsewhereFieldNumber = 11,
  };
  // repeated .anduril.taskmanager.v1.TaskEntity initial_entities = 15 [json_name = "initialEntities"];
  int initial_entities_size() const;
  private:
  int _internal_initial_entities_size() const;

  public:
  void clear_initial_entities() ;
  ::anduril::taskmanager::v1::TaskEntity* mutable_initial_entities(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>* mutable_initial_entities();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>& _internal_initial_entities() const;
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>* _internal_mutable_initial_entities();
  public:
  const ::anduril::taskmanager::v1::TaskEntity& initial_entities(int index) const;
  ::anduril::taskmanager::v1::TaskEntity* add_initial_entities();
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>& initial_entities() const;
  // string display_name = 2 [json_name = "displayName"];
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // string description = 10 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .anduril.taskmanager.v1.TaskVersion version = 1 [json_name = "version"];
  bool has_version() const;
  void clear_version() ;
  const ::anduril::taskmanager::v1::TaskVersion& version() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::TaskVersion* release_version();
  ::anduril::taskmanager::v1::TaskVersion* mutable_version();
  void set_allocated_version(::anduril::taskmanager::v1::TaskVersion* value);
  void unsafe_arena_set_allocated_version(::anduril::taskmanager::v1::TaskVersion* value);
  ::anduril::taskmanager::v1::TaskVersion* unsafe_arena_release_version();

  private:
  const ::anduril::taskmanager::v1::TaskVersion& _internal_version() const;
  ::anduril::taskmanager::v1::TaskVersion* _internal_mutable_version();

  public:
  // .google.protobuf.Any specification = 3 [json_name = "specification"];
  bool has_specification() const;
  void clear_specification() ;
  const ::google::protobuf::Any& specification() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_specification();
  ::google::protobuf::Any* mutable_specification();
  void set_allocated_specification(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_specification(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_specification();

  private:
  const ::google::protobuf::Any& _internal_specification() const;
  ::google::protobuf::Any* _internal_mutable_specification();

  public:
  // .anduril.taskmanager.v1.Principal last_updated_by = 4 [json_name = "lastUpdatedBy"];
  bool has_last_updated_by() const;
  void clear_last_updated_by() ;
  const ::anduril::taskmanager::v1::Principal& last_updated_by() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Principal* release_last_updated_by();
  ::anduril::taskmanager::v1::Principal* mutable_last_updated_by();
  void set_allocated_last_updated_by(::anduril::taskmanager::v1::Principal* value);
  void unsafe_arena_set_allocated_last_updated_by(::anduril::taskmanager::v1::Principal* value);
  ::anduril::taskmanager::v1::Principal* unsafe_arena_release_last_updated_by();

  private:
  const ::anduril::taskmanager::v1::Principal& _internal_last_updated_by() const;
  ::anduril::taskmanager::v1::Principal* _internal_mutable_last_updated_by();

  public:
  // .anduril.taskmanager.v1.TaskStatus status = 5 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::anduril::taskmanager::v1::TaskStatus& status() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::TaskStatus* release_status();
  ::anduril::taskmanager::v1::TaskStatus* mutable_status();
  void set_allocated_status(::anduril::taskmanager::v1::TaskStatus* value);
  void unsafe_arena_set_allocated_status(::anduril::taskmanager::v1::TaskStatus* value);
  ::anduril::taskmanager::v1::TaskStatus* unsafe_arena_release_status();

  private:
  const ::anduril::taskmanager::v1::TaskStatus& _internal_status() const;
  ::anduril::taskmanager::v1::TaskStatus* _internal_mutable_status();

  public:
  // .google.protobuf.Timestamp scheduled_time = 6 [json_name = "scheduledTime"];
  bool has_scheduled_time() const;
  void clear_scheduled_time() ;
  const ::google::protobuf::Timestamp& scheduled_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_scheduled_time();
  ::google::protobuf::Timestamp* mutable_scheduled_time();
  void set_allocated_scheduled_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_scheduled_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_scheduled_time();

  private:
  const ::google::protobuf::Timestamp& _internal_scheduled_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_scheduled_time();

  public:
  // .anduril.taskmanager.v1.Relations relations = 8 [json_name = "relations"];
  bool has_relations() const;
  void clear_relations() ;
  const ::anduril::taskmanager::v1::Relations& relations() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Relations* release_relations();
  ::anduril::taskmanager::v1::Relations* mutable_relations();
  void set_allocated_relations(::anduril::taskmanager::v1::Relations* value);
  void unsafe_arena_set_allocated_relations(::anduril::taskmanager::v1::Relations* value);
  ::anduril::taskmanager::v1::Relations* unsafe_arena_release_relations();

  private:
  const ::anduril::taskmanager::v1::Relations& _internal_relations() const;
  ::anduril::taskmanager::v1::Relations* _internal_mutable_relations();

  public:
  // .google.protobuf.Timestamp last_update_time = 9 [json_name = "lastUpdateTime"];
  bool has_last_update_time() const;
  void clear_last_update_time() ;
  const ::google::protobuf::Timestamp& last_update_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_update_time();
  ::google::protobuf::Timestamp* mutable_last_update_time();
  void set_allocated_last_update_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_update_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_update_time();

  private:
  const ::google::protobuf::Timestamp& _internal_last_update_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_update_time();

  public:
  // .anduril.taskmanager.v1.Owner owner = 12 [json_name = "owner"];
  bool has_owner() const;
  void clear_owner() ;
  const ::anduril::taskmanager::v1::Owner& owner() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Owner* release_owner();
  ::anduril::taskmanager::v1::Owner* mutable_owner();
  void set_allocated_owner(::anduril::taskmanager::v1::Owner* value);
  void unsafe_arena_set_allocated_owner(::anduril::taskmanager::v1::Owner* value);
  ::anduril::taskmanager::v1::Owner* unsafe_arena_release_owner();

  private:
  const ::anduril::taskmanager::v1::Owner& _internal_owner() const;
  ::anduril::taskmanager::v1::Owner* _internal_mutable_owner();

  public:
  // .google.protobuf.Timestamp create_time = 13 [json_name = "createTime"];
  bool has_create_time() const;
  void clear_create_time() ;
  const ::google::protobuf::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_create_time();
  ::google::protobuf::Timestamp* mutable_create_time();
  void set_allocated_create_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_create_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_create_time();

  private:
  const ::google::protobuf::Timestamp& _internal_create_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_create_time();

  public:
  // .anduril.taskmanager.v1.Replication replication = 14 [json_name = "replication"];
  bool has_replication() const;
  void clear_replication() ;
  const ::anduril::taskmanager::v1::Replication& replication() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Replication* release_replication();
  ::anduril::taskmanager::v1::Replication* mutable_replication();
  void set_allocated_replication(::anduril::taskmanager::v1::Replication* value);
  void unsafe_arena_set_allocated_replication(::anduril::taskmanager::v1::Replication* value);
  ::anduril::taskmanager::v1::Replication* unsafe_arena_release_replication();

  private:
  const ::anduril::taskmanager::v1::Replication& _internal_replication() const;
  ::anduril::taskmanager::v1::Replication* _internal_mutable_replication();

  public:
  // .anduril.taskmanager.v1.Principal created_by = 16 [json_name = "createdBy"];
  bool has_created_by() const;
  void clear_created_by() ;
  const ::anduril::taskmanager::v1::Principal& created_by() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Principal* release_created_by();
  ::anduril::taskmanager::v1::Principal* mutable_created_by();
  void set_allocated_created_by(::anduril::taskmanager::v1::Principal* value);
  void unsafe_arena_set_allocated_created_by(::anduril::taskmanager::v1::Principal* value);
  ::anduril::taskmanager::v1::Principal* unsafe_arena_release_created_by();

  private:
  const ::anduril::taskmanager::v1::Principal& _internal_created_by() const;
  ::anduril::taskmanager::v1::Principal* _internal_mutable_created_by();

  public:
  // bool is_executed_elsewhere = 11 [json_name = "isExecutedElsewhere"];
  void clear_is_executed_elsewhere() ;
  bool is_executed_elsewhere() const;
  void set_is_executed_elsewhere(bool value);

  private:
  bool _internal_is_executed_elsewhere() const;
  void _internal_set_is_executed_elsewhere(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.Task)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 12,
      67, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Task& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::anduril::taskmanager::v1::TaskEntity > initial_entities_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::anduril::taskmanager::v1::TaskVersion* version_;
    ::google::protobuf::Any* specification_;
    ::anduril::taskmanager::v1::Principal* last_updated_by_;
    ::anduril::taskmanager::v1::TaskStatus* status_;
    ::google::protobuf::Timestamp* scheduled_time_;
    ::anduril::taskmanager::v1::Relations* relations_;
    ::google::protobuf::Timestamp* last_update_time_;
    ::anduril::taskmanager::v1::Owner* owner_;
    ::google::protobuf::Timestamp* create_time_;
    ::anduril::taskmanager::v1::Replication* replication_;
    ::anduril::taskmanager::v1::Principal* created_by_;
    bool is_executed_elsewhere_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class TaskEvent final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.TaskEvent) */ {
 public:
  inline TaskEvent() : TaskEvent(nullptr) {}
  ~TaskEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaskEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaskEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskEvent(const TaskEvent& from) : TaskEvent(nullptr, from) {}
  inline TaskEvent(TaskEvent&& from) noexcept
      : TaskEvent(nullptr, std::move(from)) {}
  inline TaskEvent& operator=(const TaskEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskEvent& operator=(TaskEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskEvent* internal_default_instance() {
    return reinterpret_cast<const TaskEvent*>(
        &_TaskEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(TaskEvent& a, TaskEvent& b) { a.Swap(&b); }
  inline void Swap(TaskEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaskEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskEvent& from) { TaskEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaskEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.TaskEvent"; }

 protected:
  explicit TaskEvent(::google::protobuf::Arena* arena);
  TaskEvent(::google::protobuf::Arena* arena, const TaskEvent& from);
  TaskEvent(::google::protobuf::Arena* arena, TaskEvent&& from) noexcept
      : TaskEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 2,
    kTimeFieldNumber = 4,
    kEventTypeFieldNumber = 1,
    kTaskViewFieldNumber = 3,
  };
  // .anduril.taskmanager.v1.Task task = 2 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::anduril::taskmanager::v1::Task& task() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Task* release_task();
  ::anduril::taskmanager::v1::Task* mutable_task();
  void set_allocated_task(::anduril::taskmanager::v1::Task* value);
  void unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value);
  ::anduril::taskmanager::v1::Task* unsafe_arena_release_task();

  private:
  const ::anduril::taskmanager::v1::Task& _internal_task() const;
  ::anduril::taskmanager::v1::Task* _internal_mutable_task();

  public:
  // .google.protobuf.Timestamp time = 4 [json_name = "time"];
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // .anduril.taskmanager.v1.EventType event_type = 1 [json_name = "eventType"];
  void clear_event_type() ;
  ::anduril::taskmanager::v1::EventType event_type() const;
  void set_event_type(::anduril::taskmanager::v1::EventType value);

  private:
  ::anduril::taskmanager::v1::EventType _internal_event_type() const;
  void _internal_set_event_type(::anduril::taskmanager::v1::EventType value);

  public:
  // .anduril.taskmanager.v1.TaskView task_view = 3 [json_name = "taskView"];
  void clear_task_view() ;
  ::anduril::taskmanager::v1::TaskView task_view() const;
  void set_task_view(::anduril::taskmanager::v1::TaskView value);

  private:
  ::anduril::taskmanager::v1::TaskView _internal_task_view() const;
  void _internal_set_task_view(::anduril::taskmanager::v1::TaskView value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.TaskEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaskEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Task* task_;
    ::google::protobuf::Timestamp* time_;
    int event_type_;
    int task_view_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};
// -------------------------------------------------------------------

class DefinitionUpdate final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.DefinitionUpdate) */ {
 public:
  inline DefinitionUpdate() : DefinitionUpdate(nullptr) {}
  ~DefinitionUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DefinitionUpdate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DefinitionUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DefinitionUpdate(
      ::google::protobuf::internal::ConstantInitialized);

  inline DefinitionUpdate(const DefinitionUpdate& from) : DefinitionUpdate(nullptr, from) {}
  inline DefinitionUpdate(DefinitionUpdate&& from) noexcept
      : DefinitionUpdate(nullptr, std::move(from)) {}
  inline DefinitionUpdate& operator=(const DefinitionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefinitionUpdate& operator=(DefinitionUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefinitionUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefinitionUpdate* internal_default_instance() {
    return reinterpret_cast<const DefinitionUpdate*>(
        &_DefinitionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(DefinitionUpdate& a, DefinitionUpdate& b) { a.Swap(&b); }
  inline void Swap(DefinitionUpdate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefinitionUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefinitionUpdate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DefinitionUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DefinitionUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DefinitionUpdate& from) { DefinitionUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DefinitionUpdate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.DefinitionUpdate"; }

 protected:
  explicit DefinitionUpdate(::google::protobuf::Arena* arena);
  DefinitionUpdate(::google::protobuf::Arena* arena, const DefinitionUpdate& from);
  DefinitionUpdate(::google::protobuf::Arena* arena, DefinitionUpdate&& from) noexcept
      : DefinitionUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::anduril::taskmanager::v1::Task& task() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Task* release_task();
  ::anduril::taskmanager::v1::Task* mutable_task();
  void set_allocated_task(::anduril::taskmanager::v1::Task* value);
  void unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value);
  ::anduril::taskmanager::v1::Task* unsafe_arena_release_task();

  private:
  const ::anduril::taskmanager::v1::Task& _internal_task() const;
  ::anduril::taskmanager::v1::Task* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.DefinitionUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DefinitionUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Task* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Task

// .anduril.taskmanager.v1.TaskVersion version = 1 [json_name = "version"];
inline bool Task::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.version_ != nullptr);
  return value;
}
inline void Task::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ != nullptr) _impl_.version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::taskmanager::v1::TaskVersion& Task::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::TaskVersion* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::TaskVersion&>(::anduril::taskmanager::v1::_TaskVersion_default_instance_);
}
inline const ::anduril::taskmanager::v1::TaskVersion& Task::version() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.version)
  return _internal_version();
}
inline void Task::unsafe_arena_set_allocated_version(::anduril::taskmanager::v1::TaskVersion* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = reinterpret_cast<::anduril::taskmanager::v1::TaskVersion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.version)
}
inline ::anduril::taskmanager::v1::TaskVersion* Task::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::TaskVersion* released = _impl_.version_;
  _impl_.version_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::TaskVersion* Task::unsafe_arena_release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.version)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::TaskVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::TaskVersion* Task::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::TaskVersion>(GetArena());
    _impl_.version_ = reinterpret_cast<::anduril::taskmanager::v1::TaskVersion*>(p);
  }
  return _impl_.version_;
}
inline ::anduril::taskmanager::v1::TaskVersion* Task::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::TaskVersion* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.version)
  return _msg;
}
inline void Task::set_allocated_version(::anduril::taskmanager::v1::TaskVersion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.version_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.version_ = reinterpret_cast<::anduril::taskmanager::v1::TaskVersion*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.version)
}

// string display_name = 2 [json_name = "displayName"];
inline void Task::clear_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Task::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.Task.display_name)
}
inline std::string* Task::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.display_name)
  return _s;
}
inline const std::string& Task::_internal_display_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.display_name_.Get();
}
inline void Task::_internal_set_display_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* Task::release_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.display_name)
  return _impl_.display_name_.Release();
}
inline void Task::set_allocated_display_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.display_name)
}

// .google.protobuf.Any specification = 3 [json_name = "specification"];
inline bool Task::has_specification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.specification_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& Task::_internal_specification() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.specification_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& Task::specification() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.specification)
  return _internal_specification();
}
inline void Task::unsafe_arena_set_allocated_specification(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.specification_);
  }
  _impl_.specification_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.specification)
}
inline ::google::protobuf::Any* Task::release_specification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* released = _impl_.specification_;
  _impl_.specification_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* Task::unsafe_arena_release_specification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.specification)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* temp = _impl_.specification_;
  _impl_.specification_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* Task::_internal_mutable_specification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.specification_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.specification_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.specification_;
}
inline ::google::protobuf::Any* Task::mutable_specification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Any* _msg = _internal_mutable_specification();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.specification)
  return _msg;
}
inline void Task::set_allocated_specification(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.specification_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.specification_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.specification)
}

// .anduril.taskmanager.v1.Principal created_by = 16 [json_name = "createdBy"];
inline bool Task::has_created_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_by_ != nullptr);
  return value;
}
inline void Task::clear_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_by_ != nullptr) _impl_.created_by_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::anduril::taskmanager::v1::Principal& Task::_internal_created_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Principal* p = _impl_.created_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Principal&>(::anduril::taskmanager::v1::_Principal_default_instance_);
}
inline const ::anduril::taskmanager::v1::Principal& Task::created_by() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.created_by)
  return _internal_created_by();
}
inline void Task::unsafe_arena_set_allocated_created_by(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_by_);
  }
  _impl_.created_by_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.created_by)
}
inline ::anduril::taskmanager::v1::Principal* Task::release_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::anduril::taskmanager::v1::Principal* released = _impl_.created_by_;
  _impl_.created_by_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Principal* Task::unsafe_arena_release_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.created_by)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::anduril::taskmanager::v1::Principal* temp = _impl_.created_by_;
  _impl_.created_by_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Principal* Task::_internal_mutable_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_by_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Principal>(GetArena());
    _impl_.created_by_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(p);
  }
  return _impl_.created_by_;
}
inline ::anduril::taskmanager::v1::Principal* Task::mutable_created_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::anduril::taskmanager::v1::Principal* _msg = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.created_by)
  return _msg;
}
inline void Task::set_allocated_created_by(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.created_by_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.created_by_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.created_by)
}

// .anduril.taskmanager.v1.Principal last_updated_by = 4 [json_name = "lastUpdatedBy"];
inline bool Task::has_last_updated_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_updated_by_ != nullptr);
  return value;
}
inline void Task::clear_last_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_updated_by_ != nullptr) _impl_.last_updated_by_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::anduril::taskmanager::v1::Principal& Task::_internal_last_updated_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Principal* p = _impl_.last_updated_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Principal&>(::anduril::taskmanager::v1::_Principal_default_instance_);
}
inline const ::anduril::taskmanager::v1::Principal& Task::last_updated_by() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.last_updated_by)
  return _internal_last_updated_by();
}
inline void Task::unsafe_arena_set_allocated_last_updated_by(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_updated_by_);
  }
  _impl_.last_updated_by_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.last_updated_by)
}
inline ::anduril::taskmanager::v1::Principal* Task::release_last_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::taskmanager::v1::Principal* released = _impl_.last_updated_by_;
  _impl_.last_updated_by_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Principal* Task::unsafe_arena_release_last_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.last_updated_by)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::taskmanager::v1::Principal* temp = _impl_.last_updated_by_;
  _impl_.last_updated_by_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Principal* Task::_internal_mutable_last_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_updated_by_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Principal>(GetArena());
    _impl_.last_updated_by_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(p);
  }
  return _impl_.last_updated_by_;
}
inline ::anduril::taskmanager::v1::Principal* Task::mutable_last_updated_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::anduril::taskmanager::v1::Principal* _msg = _internal_mutable_last_updated_by();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.last_updated_by)
  return _msg;
}
inline void Task::set_allocated_last_updated_by(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.last_updated_by_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.last_updated_by_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.last_updated_by)
}

// .google.protobuf.Timestamp last_update_time = 9 [json_name = "lastUpdateTime"];
inline bool Task::has_last_update_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_update_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Task::_internal_last_update_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.last_update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Task::last_update_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.last_update_time)
  return _internal_last_update_time();
}
inline void Task::unsafe_arena_set_allocated_last_update_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_update_time_);
  }
  _impl_.last_update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.last_update_time)
}
inline ::google::protobuf::Timestamp* Task::release_last_update_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::google::protobuf::Timestamp* released = _impl_.last_update_time_;
  _impl_.last_update_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Task::unsafe_arena_release_last_update_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.last_update_time)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::google::protobuf::Timestamp* temp = _impl_.last_update_time_;
  _impl_.last_update_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Task::_internal_mutable_last_update_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_update_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_update_time_;
}
inline ::google::protobuf::Timestamp* Task::mutable_last_update_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_update_time();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.last_update_time)
  return _msg;
}
inline void Task::set_allocated_last_update_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_update_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.last_update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.last_update_time)
}

// .anduril.taskmanager.v1.TaskStatus status = 5 [json_name = "status"];
inline bool Task::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void Task::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::anduril::taskmanager::v1::TaskStatus& Task::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::TaskStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::TaskStatus&>(::anduril::taskmanager::v1::_TaskStatus_default_instance_);
}
inline const ::anduril::taskmanager::v1::TaskStatus& Task::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.status)
  return _internal_status();
}
inline void Task::unsafe_arena_set_allocated_status(::anduril::taskmanager::v1::TaskStatus* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::anduril::taskmanager::v1::TaskStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.status)
}
inline ::anduril::taskmanager::v1::TaskStatus* Task::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::taskmanager::v1::TaskStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::TaskStatus* Task::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.status)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::taskmanager::v1::TaskStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::TaskStatus* Task::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::TaskStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::anduril::taskmanager::v1::TaskStatus*>(p);
  }
  return _impl_.status_;
}
inline ::anduril::taskmanager::v1::TaskStatus* Task::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::anduril::taskmanager::v1::TaskStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.status)
  return _msg;
}
inline void Task::set_allocated_status(::anduril::taskmanager::v1::TaskStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.status_ = reinterpret_cast<::anduril::taskmanager::v1::TaskStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.status)
}

// .google.protobuf.Timestamp scheduled_time = 6 [json_name = "scheduledTime"];
inline bool Task::has_scheduled_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scheduled_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Task::_internal_scheduled_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.scheduled_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Task::scheduled_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.scheduled_time)
  return _internal_scheduled_time();
}
inline void Task::unsafe_arena_set_allocated_scheduled_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scheduled_time_);
  }
  _impl_.scheduled_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.scheduled_time)
}
inline ::google::protobuf::Timestamp* Task::release_scheduled_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Timestamp* released = _impl_.scheduled_time_;
  _impl_.scheduled_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Task::unsafe_arena_release_scheduled_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.scheduled_time)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Timestamp* temp = _impl_.scheduled_time_;
  _impl_.scheduled_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Task::_internal_mutable_scheduled_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scheduled_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.scheduled_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.scheduled_time_;
}
inline ::google::protobuf::Timestamp* Task::mutable_scheduled_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_scheduled_time();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.scheduled_time)
  return _msg;
}
inline void Task::set_allocated_scheduled_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scheduled_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.scheduled_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.scheduled_time)
}

// .anduril.taskmanager.v1.Relations relations = 8 [json_name = "relations"];
inline bool Task::has_relations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relations_ != nullptr);
  return value;
}
inline void Task::clear_relations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.relations_ != nullptr) _impl_.relations_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::anduril::taskmanager::v1::Relations& Task::_internal_relations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Relations* p = _impl_.relations_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Relations&>(::anduril::taskmanager::v1::_Relations_default_instance_);
}
inline const ::anduril::taskmanager::v1::Relations& Task::relations() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.relations)
  return _internal_relations();
}
inline void Task::unsafe_arena_set_allocated_relations(::anduril::taskmanager::v1::Relations* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relations_);
  }
  _impl_.relations_ = reinterpret_cast<::anduril::taskmanager::v1::Relations*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.relations)
}
inline ::anduril::taskmanager::v1::Relations* Task::release_relations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::anduril::taskmanager::v1::Relations* released = _impl_.relations_;
  _impl_.relations_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Relations* Task::unsafe_arena_release_relations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.relations)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::anduril::taskmanager::v1::Relations* temp = _impl_.relations_;
  _impl_.relations_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Relations* Task::_internal_mutable_relations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.relations_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Relations>(GetArena());
    _impl_.relations_ = reinterpret_cast<::anduril::taskmanager::v1::Relations*>(p);
  }
  return _impl_.relations_;
}
inline ::anduril::taskmanager::v1::Relations* Task::mutable_relations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::anduril::taskmanager::v1::Relations* _msg = _internal_mutable_relations();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.relations)
  return _msg;
}
inline void Task::set_allocated_relations(::anduril::taskmanager::v1::Relations* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.relations_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.relations_ = reinterpret_cast<::anduril::taskmanager::v1::Relations*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.relations)
}

// string description = 10 [json_name = "description"];
inline void Task::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Task::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.Task.description)
}
inline std::string* Task::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.description)
  return _s;
}
inline const std::string& Task::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Task::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* Task::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.description)
  return _impl_.description_.Release();
}
inline void Task::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.description)
}

// bool is_executed_elsewhere = 11 [json_name = "isExecutedElsewhere"];
inline void Task::clear_is_executed_elsewhere() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_executed_elsewhere_ = false;
}
inline bool Task::is_executed_elsewhere() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.is_executed_elsewhere)
  return _internal_is_executed_elsewhere();
}
inline void Task::set_is_executed_elsewhere(bool value) {
  _internal_set_is_executed_elsewhere(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.Task.is_executed_elsewhere)
}
inline bool Task::_internal_is_executed_elsewhere() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_executed_elsewhere_;
}
inline void Task::_internal_set_is_executed_elsewhere(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_executed_elsewhere_ = value;
}

// .google.protobuf.Timestamp create_time = 13 [json_name = "createTime"];
inline bool Task::has_create_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.create_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Task::_internal_create_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Task::create_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.create_time)
  return _internal_create_time();
}
inline void Task::unsafe_arena_set_allocated_create_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.create_time)
}
inline ::google::protobuf::Timestamp* Task::release_create_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::google::protobuf::Timestamp* released = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Task::unsafe_arena_release_create_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.create_time)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::google::protobuf::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Task::_internal_mutable_create_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.create_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.create_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.create_time_;
}
inline ::google::protobuf::Timestamp* Task::mutable_create_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.create_time)
  return _msg;
}
inline void Task::set_allocated_create_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.create_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.create_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.create_time)
}

// .anduril.taskmanager.v1.Replication replication = 14 [json_name = "replication"];
inline bool Task::has_replication() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.replication_ != nullptr);
  return value;
}
inline void Task::clear_replication() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.replication_ != nullptr) _impl_.replication_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::anduril::taskmanager::v1::Replication& Task::_internal_replication() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Replication* p = _impl_.replication_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Replication&>(::anduril::taskmanager::v1::_Replication_default_instance_);
}
inline const ::anduril::taskmanager::v1::Replication& Task::replication() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.replication)
  return _internal_replication();
}
inline void Task::unsafe_arena_set_allocated_replication(::anduril::taskmanager::v1::Replication* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.replication_);
  }
  _impl_.replication_ = reinterpret_cast<::anduril::taskmanager::v1::Replication*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.replication)
}
inline ::anduril::taskmanager::v1::Replication* Task::release_replication() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::anduril::taskmanager::v1::Replication* released = _impl_.replication_;
  _impl_.replication_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Replication* Task::unsafe_arena_release_replication() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.replication)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::anduril::taskmanager::v1::Replication* temp = _impl_.replication_;
  _impl_.replication_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Replication* Task::_internal_mutable_replication() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.replication_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Replication>(GetArena());
    _impl_.replication_ = reinterpret_cast<::anduril::taskmanager::v1::Replication*>(p);
  }
  return _impl_.replication_;
}
inline ::anduril::taskmanager::v1::Replication* Task::mutable_replication() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::anduril::taskmanager::v1::Replication* _msg = _internal_mutable_replication();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.replication)
  return _msg;
}
inline void Task::set_allocated_replication(::anduril::taskmanager::v1::Replication* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.replication_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.replication_ = reinterpret_cast<::anduril::taskmanager::v1::Replication*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.replication)
}

// repeated .anduril.taskmanager.v1.TaskEntity initial_entities = 15 [json_name = "initialEntities"];
inline int Task::_internal_initial_entities_size() const {
  return _internal_initial_entities().size();
}
inline int Task::initial_entities_size() const {
  return _internal_initial_entities_size();
}
inline void Task::clear_initial_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initial_entities_.Clear();
}
inline ::anduril::taskmanager::v1::TaskEntity* Task::mutable_initial_entities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.initial_entities)
  return _internal_mutable_initial_entities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>* Task::mutable_initial_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.taskmanager.v1.Task.initial_entities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_initial_entities();
}
inline const ::anduril::taskmanager::v1::TaskEntity& Task::initial_entities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.initial_entities)
  return _internal_initial_entities().Get(index);
}
inline ::anduril::taskmanager::v1::TaskEntity* Task::add_initial_entities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::taskmanager::v1::TaskEntity* _add = _internal_mutable_initial_entities()->Add();
  // @@protoc_insertion_point(field_add:anduril.taskmanager.v1.Task.initial_entities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>& Task::initial_entities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.taskmanager.v1.Task.initial_entities)
  return _internal_initial_entities();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>&
Task::_internal_initial_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initial_entities_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>*
Task::_internal_mutable_initial_entities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.initial_entities_;
}

// .anduril.taskmanager.v1.Owner owner = 12 [json_name = "owner"];
inline bool Task::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.owner_ != nullptr);
  return value;
}
inline void Task::clear_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.owner_ != nullptr) _impl_.owner_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::anduril::taskmanager::v1::Owner& Task::_internal_owner() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Owner* p = _impl_.owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Owner&>(::anduril::taskmanager::v1::_Owner_default_instance_);
}
inline const ::anduril::taskmanager::v1::Owner& Task::owner() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Task.owner)
  return _internal_owner();
}
inline void Task::unsafe_arena_set_allocated_owner(::anduril::taskmanager::v1::Owner* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.owner_);
  }
  _impl_.owner_ = reinterpret_cast<::anduril::taskmanager::v1::Owner*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Task.owner)
}
inline ::anduril::taskmanager::v1::Owner* Task::release_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::anduril::taskmanager::v1::Owner* released = _impl_.owner_;
  _impl_.owner_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Owner* Task::unsafe_arena_release_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Task.owner)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::anduril::taskmanager::v1::Owner* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Owner* Task::_internal_mutable_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.owner_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Owner>(GetArena());
    _impl_.owner_ = reinterpret_cast<::anduril::taskmanager::v1::Owner*>(p);
  }
  return _impl_.owner_;
}
inline ::anduril::taskmanager::v1::Owner* Task::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::anduril::taskmanager::v1::Owner* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Task.owner)
  return _msg;
}
inline void Task::set_allocated_owner(::anduril::taskmanager::v1::Owner* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.owner_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.owner_ = reinterpret_cast<::anduril::taskmanager::v1::Owner*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Task.owner)
}

// -------------------------------------------------------------------

// TaskStatus

// .anduril.taskmanager.v1.Status status = 1 [json_name = "status"];
inline void TaskStatus::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::anduril::taskmanager::v1::Status TaskStatus::status() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskStatus.status)
  return _internal_status();
}
inline void TaskStatus::set_status(::anduril::taskmanager::v1::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.TaskStatus.status)
}
inline ::anduril::taskmanager::v1::Status TaskStatus::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::taskmanager::v1::Status>(_impl_.status_);
}
inline void TaskStatus::_internal_set_status(::anduril::taskmanager::v1::Status value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// .anduril.taskmanager.v1.TaskError task_error = 2 [json_name = "taskError"];
inline bool TaskStatus::has_task_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_error_ != nullptr);
  return value;
}
inline void TaskStatus::clear_task_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_error_ != nullptr) _impl_.task_error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::taskmanager::v1::TaskError& TaskStatus::_internal_task_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::TaskError* p = _impl_.task_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::TaskError&>(::anduril::taskmanager::v1::_TaskError_default_instance_);
}
inline const ::anduril::taskmanager::v1::TaskError& TaskStatus::task_error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskStatus.task_error)
  return _internal_task_error();
}
inline void TaskStatus::unsafe_arena_set_allocated_task_error(::anduril::taskmanager::v1::TaskError* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_error_);
  }
  _impl_.task_error_ = reinterpret_cast<::anduril::taskmanager::v1::TaskError*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.TaskStatus.task_error)
}
inline ::anduril::taskmanager::v1::TaskError* TaskStatus::release_task_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::TaskError* released = _impl_.task_error_;
  _impl_.task_error_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::TaskError* TaskStatus::unsafe_arena_release_task_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskStatus.task_error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::TaskError* temp = _impl_.task_error_;
  _impl_.task_error_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::TaskError* TaskStatus::_internal_mutable_task_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_error_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::TaskError>(GetArena());
    _impl_.task_error_ = reinterpret_cast<::anduril::taskmanager::v1::TaskError*>(p);
  }
  return _impl_.task_error_;
}
inline ::anduril::taskmanager::v1::TaskError* TaskStatus::mutable_task_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::TaskError* _msg = _internal_mutable_task_error();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskStatus.task_error)
  return _msg;
}
inline void TaskStatus::set_allocated_task_error(::anduril::taskmanager::v1::TaskError* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.task_error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_error_ = reinterpret_cast<::anduril::taskmanager::v1::TaskError*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskStatus.task_error)
}

// .google.protobuf.Any progress = 4 [json_name = "progress"];
inline bool TaskStatus::has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.progress_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& TaskStatus::_internal_progress() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& TaskStatus::progress() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskStatus.progress)
  return _internal_progress();
}
inline void TaskStatus::unsafe_arena_set_allocated_progress(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.TaskStatus.progress)
}
inline ::google::protobuf::Any* TaskStatus::release_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* released = _impl_.progress_;
  _impl_.progress_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* TaskStatus::unsafe_arena_release_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskStatus.progress)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* TaskStatus::_internal_mutable_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.progress_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.progress_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.progress_;
}
inline ::google::protobuf::Any* TaskStatus::mutable_progress() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Any* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskStatus.progress)
  return _msg;
}
inline void TaskStatus::set_allocated_progress(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.progress_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.progress_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskStatus.progress)
}

// .google.protobuf.Any result = 5 [json_name = "result"];
inline bool TaskStatus::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& TaskStatus::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& TaskStatus::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskStatus.result)
  return _internal_result();
}
inline void TaskStatus::unsafe_arena_set_allocated_result(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.TaskStatus.result)
}
inline ::google::protobuf::Any* TaskStatus::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Any* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* TaskStatus::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskStatus.result)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Any* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* TaskStatus::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.result_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.result_;
}
inline ::google::protobuf::Any* TaskStatus::mutable_result() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Any* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskStatus.result)
  return _msg;
}
inline void TaskStatus::set_allocated_result(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.result_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskStatus.result)
}

// .google.protobuf.Timestamp start_time = 6 [json_name = "startTime"];
inline bool TaskStatus::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TaskStatus::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TaskStatus::start_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskStatus.start_time)
  return _internal_start_time();
}
inline void TaskStatus::unsafe_arena_set_allocated_start_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.TaskStatus.start_time)
}
inline ::google::protobuf::Timestamp* TaskStatus::release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* released = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* TaskStatus::unsafe_arena_release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskStatus.start_time)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TaskStatus::_internal_mutable_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.start_time_;
}
inline ::google::protobuf::Timestamp* TaskStatus::mutable_start_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskStatus.start_time)
  return _msg;
}
inline void TaskStatus::set_allocated_start_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskStatus.start_time)
}

// .google.protobuf.Any estimate = 7 [json_name = "estimate"];
inline bool TaskStatus::has_estimate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.estimate_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& TaskStatus::_internal_estimate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.estimate_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& TaskStatus::estimate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskStatus.estimate)
  return _internal_estimate();
}
inline void TaskStatus::unsafe_arena_set_allocated_estimate(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.estimate_);
  }
  _impl_.estimate_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.TaskStatus.estimate)
}
inline ::google::protobuf::Any* TaskStatus::release_estimate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Any* released = _impl_.estimate_;
  _impl_.estimate_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* TaskStatus::unsafe_arena_release_estimate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskStatus.estimate)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Any* temp = _impl_.estimate_;
  _impl_.estimate_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* TaskStatus::_internal_mutable_estimate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.estimate_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.estimate_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.estimate_;
}
inline ::google::protobuf::Any* TaskStatus::mutable_estimate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::google::protobuf::Any* _msg = _internal_mutable_estimate();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskStatus.estimate)
  return _msg;
}
inline void TaskStatus::set_allocated_estimate(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.estimate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.estimate_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskStatus.estimate)
}

// .anduril.taskmanager.v1.Allocation allocation = 8 [json_name = "allocation"];
inline bool TaskStatus::has_allocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.allocation_ != nullptr);
  return value;
}
inline void TaskStatus::clear_allocation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.allocation_ != nullptr) _impl_.allocation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::anduril::taskmanager::v1::Allocation& TaskStatus::_internal_allocation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Allocation* p = _impl_.allocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Allocation&>(::anduril::taskmanager::v1::_Allocation_default_instance_);
}
inline const ::anduril::taskmanager::v1::Allocation& TaskStatus::allocation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskStatus.allocation)
  return _internal_allocation();
}
inline void TaskStatus::unsafe_arena_set_allocated_allocation(::anduril::taskmanager::v1::Allocation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.allocation_);
  }
  _impl_.allocation_ = reinterpret_cast<::anduril::taskmanager::v1::Allocation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.TaskStatus.allocation)
}
inline ::anduril::taskmanager::v1::Allocation* TaskStatus::release_allocation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::anduril::taskmanager::v1::Allocation* released = _impl_.allocation_;
  _impl_.allocation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Allocation* TaskStatus::unsafe_arena_release_allocation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskStatus.allocation)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::anduril::taskmanager::v1::Allocation* temp = _impl_.allocation_;
  _impl_.allocation_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Allocation* TaskStatus::_internal_mutable_allocation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.allocation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Allocation>(GetArena());
    _impl_.allocation_ = reinterpret_cast<::anduril::taskmanager::v1::Allocation*>(p);
  }
  return _impl_.allocation_;
}
inline ::anduril::taskmanager::v1::Allocation* TaskStatus::mutable_allocation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::anduril::taskmanager::v1::Allocation* _msg = _internal_mutable_allocation();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskStatus.allocation)
  return _msg;
}
inline void TaskStatus::set_allocated_allocation(::anduril::taskmanager::v1::Allocation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.allocation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.allocation_ = reinterpret_cast<::anduril::taskmanager::v1::Allocation*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskStatus.allocation)
}

// -------------------------------------------------------------------

// TaskError

// .anduril.taskmanager.v1.ErrorCode code = 1 [json_name = "code"];
inline void TaskError::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = 0;
}
inline ::anduril::taskmanager::v1::ErrorCode TaskError::code() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskError.code)
  return _internal_code();
}
inline void TaskError::set_code(::anduril::taskmanager::v1::ErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.TaskError.code)
}
inline ::anduril::taskmanager::v1::ErrorCode TaskError::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::taskmanager::v1::ErrorCode>(_impl_.code_);
}
inline void TaskError::_internal_set_code(::anduril::taskmanager::v1::ErrorCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = value;
}

// string message = 2 [json_name = "message"];
inline void TaskError::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& TaskError::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskError.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskError::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.TaskError.message)
}
inline std::string* TaskError::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskError.message)
  return _s;
}
inline const std::string& TaskError::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void TaskError::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* TaskError::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* TaskError::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskError.message)
  return _impl_.message_.Release();
}
inline void TaskError::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskError.message)
}

// .google.protobuf.Any error_details = 3 [json_name = "errorDetails"];
inline bool TaskError::has_error_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_details_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& TaskError::_internal_error_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.error_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& TaskError::error_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskError.error_details)
  return _internal_error_details();
}
inline void TaskError::unsafe_arena_set_allocated_error_details(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_details_);
  }
  _impl_.error_details_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.TaskError.error_details)
}
inline ::google::protobuf::Any* TaskError::release_error_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.error_details_;
  _impl_.error_details_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* TaskError::unsafe_arena_release_error_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskError.error_details)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.error_details_;
  _impl_.error_details_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* TaskError::_internal_mutable_error_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_details_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.error_details_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.error_details_;
}
inline ::google::protobuf::Any* TaskError::mutable_error_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Any* _msg = _internal_mutable_error_details();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskError.error_details)
  return _msg;
}
inline void TaskError::set_allocated_error_details(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_details_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskError.error_details)
}

// -------------------------------------------------------------------

// Principal

// .anduril.taskmanager.v1.System system = 1 [json_name = "system"];
inline bool Principal::has_system() const {
  return agent_case() == kSystem;
}
inline bool Principal::_internal_has_system() const {
  return agent_case() == kSystem;
}
inline void Principal::set_has_system() {
  _impl_._oneof_case_[0] = kSystem;
}
inline void Principal::clear_system() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (agent_case() == kSystem) {
    if (GetArena() == nullptr) {
      delete _impl_.agent_.system_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.agent_.system_);
    }
    clear_has_agent();
  }
}
inline ::anduril::taskmanager::v1::System* Principal::release_system() {
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Principal.system)
  if (agent_case() == kSystem) {
    clear_has_agent();
    auto* temp = _impl_.agent_.system_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.agent_.system_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::taskmanager::v1::System& Principal::_internal_system() const {
  return agent_case() == kSystem ? *_impl_.agent_.system_ : reinterpret_cast<::anduril::taskmanager::v1::System&>(::anduril::taskmanager::v1::_System_default_instance_);
}
inline const ::anduril::taskmanager::v1::System& Principal::system() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Principal.system)
  return _internal_system();
}
inline ::anduril::taskmanager::v1::System* Principal::unsafe_arena_release_system() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.taskmanager.v1.Principal.system)
  if (agent_case() == kSystem) {
    clear_has_agent();
    auto* temp = _impl_.agent_.system_;
    _impl_.agent_.system_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Principal::unsafe_arena_set_allocated_system(::anduril::taskmanager::v1::System* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_agent();
  if (value) {
    set_has_system();
    _impl_.agent_.system_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Principal.system)
}
inline ::anduril::taskmanager::v1::System* Principal::_internal_mutable_system() {
  if (agent_case() != kSystem) {
    clear_agent();
    set_has_system();
    _impl_.agent_.system_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::System>(GetArena());
  }
  return _impl_.agent_.system_;
}
inline ::anduril::taskmanager::v1::System* Principal::mutable_system() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::taskmanager::v1::System* _msg = _internal_mutable_system();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Principal.system)
  return _msg;
}

// .anduril.taskmanager.v1.User user = 2 [json_name = "user"];
inline bool Principal::has_user() const {
  return agent_case() == kUser;
}
inline bool Principal::_internal_has_user() const {
  return agent_case() == kUser;
}
inline void Principal::set_has_user() {
  _impl_._oneof_case_[0] = kUser;
}
inline void Principal::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (agent_case() == kUser) {
    if (GetArena() == nullptr) {
      delete _impl_.agent_.user_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.agent_.user_);
    }
    clear_has_agent();
  }
}
inline ::anduril::taskmanager::v1::User* Principal::release_user() {
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Principal.user)
  if (agent_case() == kUser) {
    clear_has_agent();
    auto* temp = _impl_.agent_.user_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.agent_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::taskmanager::v1::User& Principal::_internal_user() const {
  return agent_case() == kUser ? *_impl_.agent_.user_ : reinterpret_cast<::anduril::taskmanager::v1::User&>(::anduril::taskmanager::v1::_User_default_instance_);
}
inline const ::anduril::taskmanager::v1::User& Principal::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Principal.user)
  return _internal_user();
}
inline ::anduril::taskmanager::v1::User* Principal::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.taskmanager.v1.Principal.user)
  if (agent_case() == kUser) {
    clear_has_agent();
    auto* temp = _impl_.agent_.user_;
    _impl_.agent_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Principal::unsafe_arena_set_allocated_user(::anduril::taskmanager::v1::User* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_agent();
  if (value) {
    set_has_user();
    _impl_.agent_.user_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Principal.user)
}
inline ::anduril::taskmanager::v1::User* Principal::_internal_mutable_user() {
  if (agent_case() != kUser) {
    clear_agent();
    set_has_user();
    _impl_.agent_.user_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::User>(GetArena());
  }
  return _impl_.agent_.user_;
}
inline ::anduril::taskmanager::v1::User* Principal::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::taskmanager::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Principal.user)
  return _msg;
}

// .anduril.taskmanager.v1.Team team = 4 [json_name = "team"];
inline bool Principal::has_team() const {
  return agent_case() == kTeam;
}
inline bool Principal::_internal_has_team() const {
  return agent_case() == kTeam;
}
inline void Principal::set_has_team() {
  _impl_._oneof_case_[0] = kTeam;
}
inline void Principal::clear_team() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (agent_case() == kTeam) {
    if (GetArena() == nullptr) {
      delete _impl_.agent_.team_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.agent_.team_);
    }
    clear_has_agent();
  }
}
inline ::anduril::taskmanager::v1::Team* Principal::release_team() {
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Principal.team)
  if (agent_case() == kTeam) {
    clear_has_agent();
    auto* temp = _impl_.agent_.team_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.agent_.team_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::taskmanager::v1::Team& Principal::_internal_team() const {
  return agent_case() == kTeam ? *_impl_.agent_.team_ : reinterpret_cast<::anduril::taskmanager::v1::Team&>(::anduril::taskmanager::v1::_Team_default_instance_);
}
inline const ::anduril::taskmanager::v1::Team& Principal::team() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Principal.team)
  return _internal_team();
}
inline ::anduril::taskmanager::v1::Team* Principal::unsafe_arena_release_team() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.taskmanager.v1.Principal.team)
  if (agent_case() == kTeam) {
    clear_has_agent();
    auto* temp = _impl_.agent_.team_;
    _impl_.agent_.team_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Principal::unsafe_arena_set_allocated_team(::anduril::taskmanager::v1::Team* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_agent();
  if (value) {
    set_has_team();
    _impl_.agent_.team_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Principal.team)
}
inline ::anduril::taskmanager::v1::Team* Principal::_internal_mutable_team() {
  if (agent_case() != kTeam) {
    clear_agent();
    set_has_team();
    _impl_.agent_.team_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Team>(GetArena());
  }
  return _impl_.agent_.team_;
}
inline ::anduril::taskmanager::v1::Team* Principal::mutable_team() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::taskmanager::v1::Team* _msg = _internal_mutable_team();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Principal.team)
  return _msg;
}

// .anduril.taskmanager.v1.Principal on_behalf_of = 3 [json_name = "onBehalfOf"];
inline bool Principal::has_on_behalf_of() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.on_behalf_of_ != nullptr);
  return value;
}
inline void Principal::clear_on_behalf_of() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.on_behalf_of_ != nullptr) _impl_.on_behalf_of_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::taskmanager::v1::Principal& Principal::_internal_on_behalf_of() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Principal* p = _impl_.on_behalf_of_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Principal&>(::anduril::taskmanager::v1::_Principal_default_instance_);
}
inline const ::anduril::taskmanager::v1::Principal& Principal::on_behalf_of() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Principal.on_behalf_of)
  return _internal_on_behalf_of();
}
inline void Principal::unsafe_arena_set_allocated_on_behalf_of(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.on_behalf_of_);
  }
  _impl_.on_behalf_of_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Principal.on_behalf_of)
}
inline ::anduril::taskmanager::v1::Principal* Principal::release_on_behalf_of() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Principal* released = _impl_.on_behalf_of_;
  _impl_.on_behalf_of_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Principal* Principal::unsafe_arena_release_on_behalf_of() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Principal.on_behalf_of)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Principal* temp = _impl_.on_behalf_of_;
  _impl_.on_behalf_of_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Principal* Principal::_internal_mutable_on_behalf_of() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.on_behalf_of_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Principal>(GetArena());
    _impl_.on_behalf_of_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(p);
  }
  return _impl_.on_behalf_of_;
}
inline ::anduril::taskmanager::v1::Principal* Principal::mutable_on_behalf_of() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Principal* _msg = _internal_mutable_on_behalf_of();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Principal.on_behalf_of)
  return _msg;
}
inline void Principal::set_allocated_on_behalf_of(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.on_behalf_of_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.on_behalf_of_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Principal.on_behalf_of)
}

inline bool Principal::has_agent() const {
  return agent_case() != AGENT_NOT_SET;
}
inline void Principal::clear_has_agent() {
  _impl_._oneof_case_[0] = AGENT_NOT_SET;
}
inline Principal::AgentCase Principal::agent_case() const {
  return Principal::AgentCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// System

// string service_name = 1 [json_name = "serviceName"];
inline void System::clear_service_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& System::service_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.System.service_name)
  return _internal_service_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void System::set_service_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.System.service_name)
}
inline std::string* System::mutable_service_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.System.service_name)
  return _s;
}
inline const std::string& System::_internal_service_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.service_name_.Get();
}
inline void System::_internal_set_service_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_name_.Set(value, GetArena());
}
inline std::string* System::_internal_mutable_service_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.service_name_.Mutable( GetArena());
}
inline std::string* System::release_service_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.System.service_name)
  return _impl_.service_name_.Release();
}
inline void System::set_allocated_service_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.System.service_name)
}

// string entity_id = 2 [json_name = "entityId"];
inline void System::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& System::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.System.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void System::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.System.entity_id)
}
inline std::string* System::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.System.entity_id)
  return _s;
}
inline const std::string& System::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void System::_internal_set_entity_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* System::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* System::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.System.entity_id)
  return _impl_.entity_id_.Release();
}
inline void System::set_allocated_entity_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.System.entity_id)
}

// bool manages_own_scheduling = 4 [json_name = "managesOwnScheduling"];
inline void System::clear_manages_own_scheduling() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.manages_own_scheduling_ = false;
}
inline bool System::manages_own_scheduling() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.System.manages_own_scheduling)
  return _internal_manages_own_scheduling();
}
inline void System::set_manages_own_scheduling(bool value) {
  _internal_set_manages_own_scheduling(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.System.manages_own_scheduling)
}
inline bool System::_internal_manages_own_scheduling() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.manages_own_scheduling_;
}
inline void System::_internal_set_manages_own_scheduling(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.manages_own_scheduling_ = value;
}

// -------------------------------------------------------------------

// User

// string user_id = 1 [json_name = "userId"];
inline void User::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& User::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.User.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.User.user_id)
}
inline std::string* User::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.User.user_id)
  return _s;
}
inline const std::string& User::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void User::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* User::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.User.user_id)
  return _impl_.user_id_.Release();
}
inline void User::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.User.user_id)
}

// -------------------------------------------------------------------

// Relations

// .anduril.taskmanager.v1.Principal assignee = 1 [json_name = "assignee"];
inline bool Relations::has_assignee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.assignee_ != nullptr);
  return value;
}
inline void Relations::clear_assignee() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.assignee_ != nullptr) _impl_.assignee_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::taskmanager::v1::Principal& Relations::_internal_assignee() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Principal* p = _impl_.assignee_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Principal&>(::anduril::taskmanager::v1::_Principal_default_instance_);
}
inline const ::anduril::taskmanager::v1::Principal& Relations::assignee() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Relations.assignee)
  return _internal_assignee();
}
inline void Relations::unsafe_arena_set_allocated_assignee(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.assignee_);
  }
  _impl_.assignee_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Relations.assignee)
}
inline ::anduril::taskmanager::v1::Principal* Relations::release_assignee() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Principal* released = _impl_.assignee_;
  _impl_.assignee_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Principal* Relations::unsafe_arena_release_assignee() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Relations.assignee)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Principal* temp = _impl_.assignee_;
  _impl_.assignee_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Principal* Relations::_internal_mutable_assignee() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.assignee_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Principal>(GetArena());
    _impl_.assignee_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(p);
  }
  return _impl_.assignee_;
}
inline ::anduril::taskmanager::v1::Principal* Relations::mutable_assignee() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Principal* _msg = _internal_mutable_assignee();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Relations.assignee)
  return _msg;
}
inline void Relations::set_allocated_assignee(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.assignee_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.assignee_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Relations.assignee)
}

// string parent_task_id = 2 [json_name = "parentTaskId"];
inline void Relations::clear_parent_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_task_id_.ClearToEmpty();
}
inline const std::string& Relations::parent_task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Relations.parent_task_id)
  return _internal_parent_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Relations::set_parent_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.Relations.parent_task_id)
}
inline std::string* Relations::mutable_parent_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_task_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Relations.parent_task_id)
  return _s;
}
inline const std::string& Relations::_internal_parent_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_task_id_.Get();
}
inline void Relations::_internal_set_parent_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_task_id_.Set(value, GetArena());
}
inline std::string* Relations::_internal_mutable_parent_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parent_task_id_.Mutable( GetArena());
}
inline std::string* Relations::release_parent_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Relations.parent_task_id)
  return _impl_.parent_task_id_.Release();
}
inline void Relations::set_allocated_parent_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_task_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_task_id_.IsDefault()) {
    _impl_.parent_task_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Relations.parent_task_id)
}

// -------------------------------------------------------------------

// TaskEvent

// .anduril.taskmanager.v1.EventType event_type = 1 [json_name = "eventType"];
inline void TaskEvent::clear_event_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_type_ = 0;
}
inline ::anduril::taskmanager::v1::EventType TaskEvent::event_type() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskEvent.event_type)
  return _internal_event_type();
}
inline void TaskEvent::set_event_type(::anduril::taskmanager::v1::EventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.TaskEvent.event_type)
}
inline ::anduril::taskmanager::v1::EventType TaskEvent::_internal_event_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::taskmanager::v1::EventType>(_impl_.event_type_);
}
inline void TaskEvent::_internal_set_event_type(::anduril::taskmanager::v1::EventType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_type_ = value;
}

// .anduril.taskmanager.v1.Task task = 2 [json_name = "task"];
inline bool TaskEvent::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline void TaskEvent::clear_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ != nullptr) _impl_.task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::taskmanager::v1::Task& TaskEvent::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Task&>(::anduril::taskmanager::v1::_Task_default_instance_);
}
inline const ::anduril::taskmanager::v1::Task& TaskEvent::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskEvent.task)
  return _internal_task();
}
inline void TaskEvent::unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.TaskEvent.task)
}
inline ::anduril::taskmanager::v1::Task* TaskEvent::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Task* TaskEvent::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskEvent.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Task* TaskEvent::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::anduril::taskmanager::v1::Task* TaskEvent::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskEvent.task)
  return _msg;
}
inline void TaskEvent::set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskEvent.task)
}

// .anduril.taskmanager.v1.TaskView task_view = 3 [json_name = "taskView"];
inline void TaskEvent::clear_task_view() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_view_ = 0;
}
inline ::anduril::taskmanager::v1::TaskView TaskEvent::task_view() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskEvent.task_view)
  return _internal_task_view();
}
inline void TaskEvent::set_task_view(::anduril::taskmanager::v1::TaskView value) {
  _internal_set_task_view(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.TaskEvent.task_view)
}
inline ::anduril::taskmanager::v1::TaskView TaskEvent::_internal_task_view() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::taskmanager::v1::TaskView>(_impl_.task_view_);
}
inline void TaskEvent::_internal_set_task_view(::anduril::taskmanager::v1::TaskView value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_view_ = value;
}

// .google.protobuf.Timestamp time = 4 [json_name = "time"];
inline bool TaskEvent::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TaskEvent::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TaskEvent::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskEvent.time)
  return _internal_time();
}
inline void TaskEvent::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.TaskEvent.time)
}
inline ::google::protobuf::Timestamp* TaskEvent::release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* TaskEvent::unsafe_arena_release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskEvent.time)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TaskEvent::_internal_mutable_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* TaskEvent::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskEvent.time)
  return _msg;
}
inline void TaskEvent::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskEvent.time)
}

// -------------------------------------------------------------------

// TaskVersion

// string task_id = 1 [json_name = "taskId"];
inline void TaskVersion::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& TaskVersion::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskVersion.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskVersion::set_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.TaskVersion.task_id)
}
inline std::string* TaskVersion::mutable_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskVersion.task_id)
  return _s;
}
inline const std::string& TaskVersion::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_.Get();
}
inline void TaskVersion::_internal_set_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(value, GetArena());
}
inline std::string* TaskVersion::_internal_mutable_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_id_.Mutable( GetArena());
}
inline std::string* TaskVersion::release_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskVersion.task_id)
  return _impl_.task_id_.Release();
}
inline void TaskVersion::set_allocated_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.task_id_.IsDefault()) {
    _impl_.task_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskVersion.task_id)
}

// uint32 definition_version = 2 [json_name = "definitionVersion"];
inline void TaskVersion::clear_definition_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.definition_version_ = 0u;
}
inline ::uint32_t TaskVersion::definition_version() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskVersion.definition_version)
  return _internal_definition_version();
}
inline void TaskVersion::set_definition_version(::uint32_t value) {
  _internal_set_definition_version(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.TaskVersion.definition_version)
}
inline ::uint32_t TaskVersion::_internal_definition_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.definition_version_;
}
inline void TaskVersion::_internal_set_definition_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.definition_version_ = value;
}

// uint32 status_version = 3 [json_name = "statusVersion"];
inline void TaskVersion::clear_status_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_version_ = 0u;
}
inline ::uint32_t TaskVersion::status_version() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskVersion.status_version)
  return _internal_status_version();
}
inline void TaskVersion::set_status_version(::uint32_t value) {
  _internal_set_status_version(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.TaskVersion.status_version)
}
inline ::uint32_t TaskVersion::_internal_status_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_version_;
}
inline void TaskVersion::_internal_set_status_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_version_ = value;
}

// -------------------------------------------------------------------

// StatusUpdate

// .anduril.taskmanager.v1.TaskVersion version = 1 [json_name = "version"];
inline bool StatusUpdate::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.version_ != nullptr);
  return value;
}
inline void StatusUpdate::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ != nullptr) _impl_.version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::taskmanager::v1::TaskVersion& StatusUpdate::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::TaskVersion* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::TaskVersion&>(::anduril::taskmanager::v1::_TaskVersion_default_instance_);
}
inline const ::anduril::taskmanager::v1::TaskVersion& StatusUpdate::version() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.StatusUpdate.version)
  return _internal_version();
}
inline void StatusUpdate::unsafe_arena_set_allocated_version(::anduril::taskmanager::v1::TaskVersion* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = reinterpret_cast<::anduril::taskmanager::v1::TaskVersion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.StatusUpdate.version)
}
inline ::anduril::taskmanager::v1::TaskVersion* StatusUpdate::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::TaskVersion* released = _impl_.version_;
  _impl_.version_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::TaskVersion* StatusUpdate::unsafe_arena_release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.StatusUpdate.version)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::TaskVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::TaskVersion* StatusUpdate::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::TaskVersion>(GetArena());
    _impl_.version_ = reinterpret_cast<::anduril::taskmanager::v1::TaskVersion*>(p);
  }
  return _impl_.version_;
}
inline ::anduril::taskmanager::v1::TaskVersion* StatusUpdate::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::TaskVersion* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.StatusUpdate.version)
  return _msg;
}
inline void StatusUpdate::set_allocated_version(::anduril::taskmanager::v1::TaskVersion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.version_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.version_ = reinterpret_cast<::anduril::taskmanager::v1::TaskVersion*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.StatusUpdate.version)
}

// .anduril.taskmanager.v1.TaskStatus status = 2 [json_name = "status"];
inline bool StatusUpdate::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void StatusUpdate::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::taskmanager::v1::TaskStatus& StatusUpdate::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::TaskStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::TaskStatus&>(::anduril::taskmanager::v1::_TaskStatus_default_instance_);
}
inline const ::anduril::taskmanager::v1::TaskStatus& StatusUpdate::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.StatusUpdate.status)
  return _internal_status();
}
inline void StatusUpdate::unsafe_arena_set_allocated_status(::anduril::taskmanager::v1::TaskStatus* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::anduril::taskmanager::v1::TaskStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.StatusUpdate.status)
}
inline ::anduril::taskmanager::v1::TaskStatus* StatusUpdate::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::taskmanager::v1::TaskStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::TaskStatus* StatusUpdate::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.StatusUpdate.status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::taskmanager::v1::TaskStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::TaskStatus* StatusUpdate::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::TaskStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::anduril::taskmanager::v1::TaskStatus*>(p);
  }
  return _impl_.status_;
}
inline ::anduril::taskmanager::v1::TaskStatus* StatusUpdate::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::taskmanager::v1::TaskStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.StatusUpdate.status)
  return _msg;
}
inline void StatusUpdate::set_allocated_status(::anduril::taskmanager::v1::TaskStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.status_ = reinterpret_cast<::anduril::taskmanager::v1::TaskStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.StatusUpdate.status)
}

// .anduril.taskmanager.v1.Principal author = 3 [json_name = "author"];
inline bool StatusUpdate::has_author() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.author_ != nullptr);
  return value;
}
inline void StatusUpdate::clear_author() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.author_ != nullptr) _impl_.author_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::anduril::taskmanager::v1::Principal& StatusUpdate::_internal_author() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Principal* p = _impl_.author_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Principal&>(::anduril::taskmanager::v1::_Principal_default_instance_);
}
inline const ::anduril::taskmanager::v1::Principal& StatusUpdate::author() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.StatusUpdate.author)
  return _internal_author();
}
inline void StatusUpdate::unsafe_arena_set_allocated_author(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.author_);
  }
  _impl_.author_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.StatusUpdate.author)
}
inline ::anduril::taskmanager::v1::Principal* StatusUpdate::release_author() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::taskmanager::v1::Principal* released = _impl_.author_;
  _impl_.author_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Principal* StatusUpdate::unsafe_arena_release_author() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.StatusUpdate.author)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::taskmanager::v1::Principal* temp = _impl_.author_;
  _impl_.author_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Principal* StatusUpdate::_internal_mutable_author() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.author_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Principal>(GetArena());
    _impl_.author_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(p);
  }
  return _impl_.author_;
}
inline ::anduril::taskmanager::v1::Principal* StatusUpdate::mutable_author() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::anduril::taskmanager::v1::Principal* _msg = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.StatusUpdate.author)
  return _msg;
}
inline void StatusUpdate::set_allocated_author(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.author_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.author_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.StatusUpdate.author)
}

// .google.protobuf.Timestamp scheduled_time = 4 [json_name = "scheduledTime"];
inline bool StatusUpdate::has_scheduled_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scheduled_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& StatusUpdate::_internal_scheduled_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.scheduled_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& StatusUpdate::scheduled_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.StatusUpdate.scheduled_time)
  return _internal_scheduled_time();
}
inline void StatusUpdate::unsafe_arena_set_allocated_scheduled_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scheduled_time_);
  }
  _impl_.scheduled_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.StatusUpdate.scheduled_time)
}
inline ::google::protobuf::Timestamp* StatusUpdate::release_scheduled_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* released = _impl_.scheduled_time_;
  _impl_.scheduled_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* StatusUpdate::unsafe_arena_release_scheduled_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.StatusUpdate.scheduled_time)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* temp = _impl_.scheduled_time_;
  _impl_.scheduled_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* StatusUpdate::_internal_mutable_scheduled_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scheduled_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.scheduled_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.scheduled_time_;
}
inline ::google::protobuf::Timestamp* StatusUpdate::mutable_scheduled_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_scheduled_time();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.StatusUpdate.scheduled_time)
  return _msg;
}
inline void StatusUpdate::set_allocated_scheduled_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scheduled_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.scheduled_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.StatusUpdate.scheduled_time)
}

// -------------------------------------------------------------------

// DefinitionUpdate

// .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
inline bool DefinitionUpdate::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline void DefinitionUpdate::clear_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ != nullptr) _impl_.task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::taskmanager::v1::Task& DefinitionUpdate::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Task&>(::anduril::taskmanager::v1::_Task_default_instance_);
}
inline const ::anduril::taskmanager::v1::Task& DefinitionUpdate::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.DefinitionUpdate.task)
  return _internal_task();
}
inline void DefinitionUpdate::unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.DefinitionUpdate.task)
}
inline ::anduril::taskmanager::v1::Task* DefinitionUpdate::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::taskmanager::v1::Task* DefinitionUpdate::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.DefinitionUpdate.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Task* DefinitionUpdate::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::anduril::taskmanager::v1::Task* DefinitionUpdate::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.DefinitionUpdate.task)
  return _msg;
}
inline void DefinitionUpdate::set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.DefinitionUpdate.task)
}

// -------------------------------------------------------------------

// Owner

// string entity_id = 2 [json_name = "entityId"];
inline void Owner::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& Owner::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Owner.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Owner::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.Owner.entity_id)
}
inline std::string* Owner::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Owner.entity_id)
  return _s;
}
inline const std::string& Owner::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void Owner::_internal_set_entity_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* Owner::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* Owner::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Owner.entity_id)
  return _impl_.entity_id_.Release();
}
inline void Owner::set_allocated_entity_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Owner.entity_id)
}

// -------------------------------------------------------------------

// Replication

// .google.protobuf.Timestamp stale_time = 1 [json_name = "staleTime"];
inline bool Replication::has_stale_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stale_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Replication::_internal_stale_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.stale_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Replication::stale_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Replication.stale_time)
  return _internal_stale_time();
}
inline void Replication::unsafe_arena_set_allocated_stale_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stale_time_);
  }
  _impl_.stale_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Replication.stale_time)
}
inline ::google::protobuf::Timestamp* Replication::release_stale_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.stale_time_;
  _impl_.stale_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Replication::unsafe_arena_release_stale_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Replication.stale_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.stale_time_;
  _impl_.stale_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Replication::_internal_mutable_stale_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stale_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.stale_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.stale_time_;
}
inline ::google::protobuf::Timestamp* Replication::mutable_stale_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_stale_time();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Replication.stale_time)
  return _msg;
}
inline void Replication::set_allocated_stale_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stale_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stale_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Replication.stale_time)
}

// -------------------------------------------------------------------

// Allocation

// repeated .anduril.taskmanager.v1.Agent active_agents = 1 [json_name = "activeAgents"];
inline int Allocation::_internal_active_agents_size() const {
  return _internal_active_agents().size();
}
inline int Allocation::active_agents_size() const {
  return _internal_active_agents_size();
}
inline void Allocation::clear_active_agents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_agents_.Clear();
}
inline ::anduril::taskmanager::v1::Agent* Allocation::mutable_active_agents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Allocation.active_agents)
  return _internal_mutable_active_agents()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>* Allocation::mutable_active_agents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.taskmanager.v1.Allocation.active_agents)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_active_agents();
}
inline const ::anduril::taskmanager::v1::Agent& Allocation::active_agents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Allocation.active_agents)
  return _internal_active_agents().Get(index);
}
inline ::anduril::taskmanager::v1::Agent* Allocation::add_active_agents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::taskmanager::v1::Agent* _add = _internal_mutable_active_agents()->Add();
  // @@protoc_insertion_point(field_add:anduril.taskmanager.v1.Allocation.active_agents)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>& Allocation::active_agents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.taskmanager.v1.Allocation.active_agents)
  return _internal_active_agents();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>&
Allocation::_internal_active_agents() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_agents_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>*
Allocation::_internal_mutable_active_agents() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.active_agents_;
}

// -------------------------------------------------------------------

// Team

// string entity_id = 1 [json_name = "entityId"];
inline void Team::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& Team::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Team.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Team::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.Team.entity_id)
}
inline std::string* Team::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Team.entity_id)
  return _s;
}
inline const std::string& Team::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void Team::_internal_set_entity_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* Team::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* Team::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Team.entity_id)
  return _impl_.entity_id_.Release();
}
inline void Team::set_allocated_entity_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Team.entity_id)
}

// repeated .anduril.taskmanager.v1.Agent members = 2 [json_name = "members"];
inline int Team::_internal_members_size() const {
  return _internal_members().size();
}
inline int Team::members_size() const {
  return _internal_members_size();
}
inline void Team::clear_members() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.members_.Clear();
}
inline ::anduril::taskmanager::v1::Agent* Team::mutable_members(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Team.members)
  return _internal_mutable_members()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>* Team::mutable_members()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.taskmanager.v1.Team.members)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_members();
}
inline const ::anduril::taskmanager::v1::Agent& Team::members(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Team.members)
  return _internal_members().Get(index);
}
inline ::anduril::taskmanager::v1::Agent* Team::add_members() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::taskmanager::v1::Agent* _add = _internal_mutable_members()->Add();
  // @@protoc_insertion_point(field_add:anduril.taskmanager.v1.Team.members)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>& Team::members() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.taskmanager.v1.Team.members)
  return _internal_members();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>&
Team::_internal_members() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.members_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Agent>*
Team::_internal_mutable_members() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.members_;
}

// -------------------------------------------------------------------

// Agent

// string entity_id = 2 [json_name = "entityId"];
inline void Agent::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& Agent::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Agent.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.Agent.entity_id)
}
inline std::string* Agent::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Agent.entity_id)
  return _s;
}
inline const std::string& Agent::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void Agent::_internal_set_entity_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* Agent::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Agent.entity_id)
  return _impl_.entity_id_.Release();
}
inline void Agent::set_allocated_entity_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Agent.entity_id)
}

// -------------------------------------------------------------------

// TaskEntity

// .anduril.entitymanager.v1.Entity entity = 1 [json_name = "entity"];
inline bool TaskEntity::has_entity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.entity_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Entity& TaskEntity::_internal_entity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::entitymanager::v1::Entity* p = _impl_.entity_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Entity&>(::anduril::entitymanager::v1::_Entity_default_instance_);
}
inline const ::anduril::entitymanager::v1::Entity& TaskEntity::entity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskEntity.entity)
  return _internal_entity();
}
inline void TaskEntity::unsafe_arena_set_allocated_entity(::anduril::entitymanager::v1::Entity* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_);
  }
  _impl_.entity_ = reinterpret_cast<::anduril::entitymanager::v1::Entity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.TaskEntity.entity)
}
inline ::anduril::entitymanager::v1::Entity* TaskEntity::release_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Entity* released = _impl_.entity_;
  _impl_.entity_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::anduril::entitymanager::v1::Entity* TaskEntity::unsafe_arena_release_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.TaskEntity.entity)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entitymanager::v1::Entity* temp = _impl_.entity_;
  _impl_.entity_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Entity* TaskEntity::_internal_mutable_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.entity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::entitymanager::v1::Entity>(GetArena());
    _impl_.entity_ = reinterpret_cast<::anduril::entitymanager::v1::Entity*>(p);
  }
  return _impl_.entity_;
}
inline ::anduril::entitymanager::v1::Entity* TaskEntity::mutable_entity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::entitymanager::v1::Entity* _msg = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.TaskEntity.entity)
  return _msg;
}
inline void TaskEntity::set_allocated_entity(::anduril::entitymanager::v1::Entity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.entity_ = reinterpret_cast<::anduril::entitymanager::v1::Entity*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.TaskEntity.entity)
}

// bool snapshot = 2 [json_name = "snapshot"];
inline void TaskEntity::clear_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_ = false;
}
inline bool TaskEntity::snapshot() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.TaskEntity.snapshot)
  return _internal_snapshot();
}
inline void TaskEntity::set_snapshot(bool value) {
  _internal_set_snapshot(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.TaskEntity.snapshot)
}
inline bool TaskEntity::_internal_snapshot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snapshot_;
}
inline void TaskEntity::_internal_set_snapshot(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace taskmanager
}  // namespace anduril


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::anduril::taskmanager::v1::Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::taskmanager::v1::Status>() {
  return ::anduril::taskmanager::v1::Status_descriptor();
}
template <>
struct is_proto_enum<::anduril::taskmanager::v1::ErrorCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::taskmanager::v1::ErrorCode>() {
  return ::anduril::taskmanager::v1::ErrorCode_descriptor();
}
template <>
struct is_proto_enum<::anduril::taskmanager::v1::EventType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::taskmanager::v1::EventType>() {
  return ::anduril::taskmanager::v1::EventType_descriptor();
}
template <>
struct is_proto_enum<::anduril::taskmanager::v1::TaskView> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::taskmanager::v1::TaskView>() {
  return ::anduril::taskmanager::v1::TaskView_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // anduril_2ftaskmanager_2fv1_2ftask_2epub_2eproto_2epb_2eh
