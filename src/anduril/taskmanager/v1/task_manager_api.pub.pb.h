// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/taskmanager/v1/task_manager_api.pub.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "anduril/taskmanager/v1/task.pub.pb.h"
#include "anduril/taskmanager/v1/task_api.pub.pb.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
namespace anduril {
namespace taskmanager {
namespace v1 {
class CreateTaskRequest;
struct CreateTaskRequestDefaultTypeInternal;
extern CreateTaskRequestDefaultTypeInternal _CreateTaskRequest_default_instance_;
class CreateTaskResponse;
struct CreateTaskResponseDefaultTypeInternal;
extern CreateTaskResponseDefaultTypeInternal _CreateTaskResponse_default_instance_;
class EntityIds;
struct EntityIdsDefaultTypeInternal;
extern EntityIdsDefaultTypeInternal _EntityIds_default_instance_;
class GetTaskRequest;
struct GetTaskRequestDefaultTypeInternal;
extern GetTaskRequestDefaultTypeInternal _GetTaskRequest_default_instance_;
class GetTaskResponse;
struct GetTaskResponseDefaultTypeInternal;
extern GetTaskResponseDefaultTypeInternal _GetTaskResponse_default_instance_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class ListenAsAgentRequest;
struct ListenAsAgentRequestDefaultTypeInternal;
extern ListenAsAgentRequestDefaultTypeInternal _ListenAsAgentRequest_default_instance_;
class ListenAsAgentResponse;
struct ListenAsAgentResponseDefaultTypeInternal;
extern ListenAsAgentResponseDefaultTypeInternal _ListenAsAgentResponse_default_instance_;
class QueryTasksRequest;
struct QueryTasksRequestDefaultTypeInternal;
extern QueryTasksRequestDefaultTypeInternal _QueryTasksRequest_default_instance_;
class QueryTasksRequest_StatusFilter;
struct QueryTasksRequest_StatusFilterDefaultTypeInternal;
extern QueryTasksRequest_StatusFilterDefaultTypeInternal _QueryTasksRequest_StatusFilter_default_instance_;
class QueryTasksRequest_TimeRange;
struct QueryTasksRequest_TimeRangeDefaultTypeInternal;
extern QueryTasksRequest_TimeRangeDefaultTypeInternal _QueryTasksRequest_TimeRange_default_instance_;
class QueryTasksResponse;
struct QueryTasksResponseDefaultTypeInternal;
extern QueryTasksResponseDefaultTypeInternal _QueryTasksResponse_default_instance_;
class RateLimit;
struct RateLimitDefaultTypeInternal;
extern RateLimitDefaultTypeInternal _RateLimit_default_instance_;
class UpdateStatusRequest;
struct UpdateStatusRequestDefaultTypeInternal;
extern UpdateStatusRequestDefaultTypeInternal _UpdateStatusRequest_default_instance_;
class UpdateStatusResponse;
struct UpdateStatusResponseDefaultTypeInternal;
extern UpdateStatusResponseDefaultTypeInternal _UpdateStatusResponse_default_instance_;
}  // namespace v1
}  // namespace taskmanager
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace taskmanager {
namespace v1 {
enum QueryTasksRequest_FilterType : int {
  QueryTasksRequest_FilterType_FILTER_TYPE_INVALID = 0,
  QueryTasksRequest_FilterType_FILTER_TYPE_INCLUSIVE = 1,
  QueryTasksRequest_FilterType_FILTER_TYPE_EXCLUSIVE = 2,
  QueryTasksRequest_FilterType_QueryTasksRequest_FilterType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  QueryTasksRequest_FilterType_QueryTasksRequest_FilterType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool QueryTasksRequest_FilterType_IsValid(int value);
extern const uint32_t QueryTasksRequest_FilterType_internal_data_[];
constexpr QueryTasksRequest_FilterType QueryTasksRequest_FilterType_FilterType_MIN = static_cast<QueryTasksRequest_FilterType>(0);
constexpr QueryTasksRequest_FilterType QueryTasksRequest_FilterType_FilterType_MAX = static_cast<QueryTasksRequest_FilterType>(2);
constexpr int QueryTasksRequest_FilterType_FilterType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
QueryTasksRequest_FilterType_descriptor();
template <typename T>
const std::string& QueryTasksRequest_FilterType_Name(T value) {
  static_assert(std::is_same<T, QueryTasksRequest_FilterType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FilterType_Name().");
  return QueryTasksRequest_FilterType_Name(static_cast<QueryTasksRequest_FilterType>(value));
}
template <>
inline const std::string& QueryTasksRequest_FilterType_Name(QueryTasksRequest_FilterType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<QueryTasksRequest_FilterType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool QueryTasksRequest_FilterType_Parse(absl::string_view name, QueryTasksRequest_FilterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryTasksRequest_FilterType>(
      QueryTasksRequest_FilterType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RateLimit final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.RateLimit) */ {
 public:
  inline RateLimit() : RateLimit(nullptr) {}
  ~RateLimit() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RateLimit(
      ::google::protobuf::internal::ConstantInitialized);

  inline RateLimit(const RateLimit& from) : RateLimit(nullptr, from) {}
  inline RateLimit(RateLimit&& from) noexcept
      : RateLimit(nullptr, std::move(from)) {}
  inline RateLimit& operator=(const RateLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline RateLimit& operator=(RateLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RateLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const RateLimit* internal_default_instance() {
    return reinterpret_cast<const RateLimit*>(
        &_RateLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(RateLimit& a, RateLimit& b) { a.Swap(&b); }
  inline void Swap(RateLimit* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RateLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RateLimit* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RateLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RateLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RateLimit& from) { RateLimit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RateLimit* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.RateLimit"; }

 protected:
  explicit RateLimit(::google::protobuf::Arena* arena);
  RateLimit(::google::protobuf::Arena* arena, const RateLimit& from);
  RateLimit(::google::protobuf::Arena* arena, RateLimit&& from) noexcept
      : RateLimit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUpdatePerTaskLimitMsFieldNumber = 1,
  };
  // uint32 update_per_task_limit_ms = 1 [json_name = "updatePerTaskLimitMs"];
  void clear_update_per_task_limit_ms() ;
  ::uint32_t update_per_task_limit_ms() const;
  void set_update_per_task_limit_ms(::uint32_t value);

  private:
  ::uint32_t _internal_update_per_task_limit_ms() const;
  void _internal_set_update_per_task_limit_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.RateLimit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RateLimit_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RateLimit& from_msg);
    ::uint32_t update_per_task_limit_ms_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class QueryTasksRequest_StatusFilter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.QueryTasksRequest.StatusFilter) */ {
 public:
  inline QueryTasksRequest_StatusFilter() : QueryTasksRequest_StatusFilter(nullptr) {}
  ~QueryTasksRequest_StatusFilter() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTasksRequest_StatusFilter(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryTasksRequest_StatusFilter(const QueryTasksRequest_StatusFilter& from) : QueryTasksRequest_StatusFilter(nullptr, from) {}
  inline QueryTasksRequest_StatusFilter(QueryTasksRequest_StatusFilter&& from) noexcept
      : QueryTasksRequest_StatusFilter(nullptr, std::move(from)) {}
  inline QueryTasksRequest_StatusFilter& operator=(const QueryTasksRequest_StatusFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTasksRequest_StatusFilter& operator=(QueryTasksRequest_StatusFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTasksRequest_StatusFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTasksRequest_StatusFilter* internal_default_instance() {
    return reinterpret_cast<const QueryTasksRequest_StatusFilter*>(
        &_QueryTasksRequest_StatusFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(QueryTasksRequest_StatusFilter& a, QueryTasksRequest_StatusFilter& b) { a.Swap(&b); }
  inline void Swap(QueryTasksRequest_StatusFilter* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTasksRequest_StatusFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTasksRequest_StatusFilter* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<QueryTasksRequest_StatusFilter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryTasksRequest_StatusFilter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryTasksRequest_StatusFilter& from) { QueryTasksRequest_StatusFilter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryTasksRequest_StatusFilter* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.QueryTasksRequest.StatusFilter"; }

 protected:
  explicit QueryTasksRequest_StatusFilter(::google::protobuf::Arena* arena);
  QueryTasksRequest_StatusFilter(::google::protobuf::Arena* arena, const QueryTasksRequest_StatusFilter& from);
  QueryTasksRequest_StatusFilter(::google::protobuf::Arena* arena, QueryTasksRequest_StatusFilter&& from) noexcept
      : QueryTasksRequest_StatusFilter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
    kFilterTypeFieldNumber = 2,
  };
  // repeated .anduril.taskmanager.v1.Status status = 1 [json_name = "status"];
  int status_size() const;
  private:
  int _internal_status_size() const;

  public:
  void clear_status() ;
  public:
  ::anduril::taskmanager::v1::Status status(int index) const;
  void set_status(int index, ::anduril::taskmanager::v1::Status value);
  void add_status(::anduril::taskmanager::v1::Status value);
  const ::google::protobuf::RepeatedField<int>& status() const;
  ::google::protobuf::RepeatedField<int>* mutable_status();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_status() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_status();

  public:
  // .anduril.taskmanager.v1.QueryTasksRequest.FilterType filter_type = 2 [json_name = "filterType"];
  void clear_filter_type() ;
  ::anduril::taskmanager::v1::QueryTasksRequest_FilterType filter_type() const;
  void set_filter_type(::anduril::taskmanager::v1::QueryTasksRequest_FilterType value);

  private:
  ::anduril::taskmanager::v1::QueryTasksRequest_FilterType _internal_filter_type() const;
  void _internal_set_filter_type(::anduril::taskmanager::v1::QueryTasksRequest_FilterType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.QueryTasksRequest.StatusFilter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_QueryTasksRequest_StatusFilter_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const QueryTasksRequest_StatusFilter& from_msg);
    ::google::protobuf::RepeatedField<int> status_;
    mutable ::google::protobuf::internal::CachedSize _status_cached_byte_size_;
    int filter_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class GetTaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.GetTaskRequest) */ {
 public:
  inline GetTaskRequest() : GetTaskRequest(nullptr) {}
  ~GetTaskRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTaskRequest(const GetTaskRequest& from) : GetTaskRequest(nullptr, from) {}
  inline GetTaskRequest(GetTaskRequest&& from) noexcept
      : GetTaskRequest(nullptr, std::move(from)) {}
  inline GetTaskRequest& operator=(const GetTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTaskRequest& operator=(GetTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTaskRequest* internal_default_instance() {
    return reinterpret_cast<const GetTaskRequest*>(
        &_GetTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(GetTaskRequest& a, GetTaskRequest& b) { a.Swap(&b); }
  inline void Swap(GetTaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTaskRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetTaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTaskRequest& from) { GetTaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.GetTaskRequest"; }

 protected:
  explicit GetTaskRequest(::google::protobuf::Arena* arena);
  GetTaskRequest(::google::protobuf::Arena* arena, const GetTaskRequest& from);
  GetTaskRequest(::google::protobuf::Arena* arena, GetTaskRequest&& from) noexcept
      : GetTaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskIdFieldNumber = 1,
    kDefinitionVersionFieldNumber = 2,
    kTaskViewFieldNumber = 3,
  };
  // string task_id = 1 [json_name = "taskId"];
  void clear_task_id() ;
  const std::string& task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* value);

  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(
      const std::string& value);
  std::string* _internal_mutable_task_id();

  public:
  // uint32 definition_version = 2 [json_name = "definitionVersion"];
  void clear_definition_version() ;
  ::uint32_t definition_version() const;
  void set_definition_version(::uint32_t value);

  private:
  ::uint32_t _internal_definition_version() const;
  void _internal_set_definition_version(::uint32_t value);

  public:
  // .anduril.taskmanager.v1.TaskView task_view = 3 [json_name = "taskView"];
  void clear_task_view() ;
  ::anduril::taskmanager::v1::TaskView task_view() const;
  void set_task_view(::anduril::taskmanager::v1::TaskView value);

  private:
  ::anduril::taskmanager::v1::TaskView _internal_task_view() const;
  void _internal_set_task_view(::anduril::taskmanager::v1::TaskView value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.GetTaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      53, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetTaskRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTaskRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    ::uint32_t definition_version_;
    int task_view_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class EntityIds final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.EntityIds) */ {
 public:
  inline EntityIds() : EntityIds(nullptr) {}
  ~EntityIds() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntityIds(
      ::google::protobuf::internal::ConstantInitialized);

  inline EntityIds(const EntityIds& from) : EntityIds(nullptr, from) {}
  inline EntityIds(EntityIds&& from) noexcept
      : EntityIds(nullptr, std::move(from)) {}
  inline EntityIds& operator=(const EntityIds& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityIds& operator=(EntityIds&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityIds& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityIds* internal_default_instance() {
    return reinterpret_cast<const EntityIds*>(
        &_EntityIds_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(EntityIds& a, EntityIds& b) { a.Swap(&b); }
  inline void Swap(EntityIds* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityIds* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityIds* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<EntityIds>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityIds& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntityIds& from) { EntityIds::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntityIds* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.EntityIds"; }

 protected:
  explicit EntityIds(::google::protobuf::Arena* arena);
  EntityIds(::google::protobuf::Arena* arena, const EntityIds& from);
  EntityIds(::google::protobuf::Arena* arena, EntityIds&& from) noexcept
      : EntityIds(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdsFieldNumber = 1,
  };
  // repeated string entity_ids = 1 [json_name = "entityIds"];
  int entity_ids_size() const;
  private:
  int _internal_entity_ids_size() const;

  public:
  void clear_entity_ids() ;
  const std::string& entity_ids(int index) const;
  std::string* mutable_entity_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_ids(int index, Arg_&& value, Args_... args);
  std::string* add_entity_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_entity_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& entity_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_entity_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_entity_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_entity_ids();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.EntityIds)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      51, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EntityIds_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EntityIds& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> entity_ids_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class QueryTasksRequest_TimeRange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.QueryTasksRequest.TimeRange) */ {
 public:
  inline QueryTasksRequest_TimeRange() : QueryTasksRequest_TimeRange(nullptr) {}
  ~QueryTasksRequest_TimeRange() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTasksRequest_TimeRange(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryTasksRequest_TimeRange(const QueryTasksRequest_TimeRange& from) : QueryTasksRequest_TimeRange(nullptr, from) {}
  inline QueryTasksRequest_TimeRange(QueryTasksRequest_TimeRange&& from) noexcept
      : QueryTasksRequest_TimeRange(nullptr, std::move(from)) {}
  inline QueryTasksRequest_TimeRange& operator=(const QueryTasksRequest_TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTasksRequest_TimeRange& operator=(QueryTasksRequest_TimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTasksRequest_TimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTasksRequest_TimeRange* internal_default_instance() {
    return reinterpret_cast<const QueryTasksRequest_TimeRange*>(
        &_QueryTasksRequest_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(QueryTasksRequest_TimeRange& a, QueryTasksRequest_TimeRange& b) { a.Swap(&b); }
  inline void Swap(QueryTasksRequest_TimeRange* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTasksRequest_TimeRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTasksRequest_TimeRange* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<QueryTasksRequest_TimeRange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryTasksRequest_TimeRange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryTasksRequest_TimeRange& from) { QueryTasksRequest_TimeRange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryTasksRequest_TimeRange* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.QueryTasksRequest.TimeRange"; }

 protected:
  explicit QueryTasksRequest_TimeRange(::google::protobuf::Arena* arena);
  QueryTasksRequest_TimeRange(::google::protobuf::Arena* arena, const QueryTasksRequest_TimeRange& from);
  QueryTasksRequest_TimeRange(::google::protobuf::Arena* arena, QueryTasksRequest_TimeRange&& from) noexcept
      : QueryTasksRequest_TimeRange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUpdateStartTimeFieldNumber = 1,
    kUpdateEndTimeFieldNumber = 2,
  };
  // .google.protobuf.Timestamp update_start_time = 1 [json_name = "updateStartTime"];
  bool has_update_start_time() const;
  void clear_update_start_time() ;
  const ::google::protobuf::Timestamp& update_start_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_update_start_time();
  ::google::protobuf::Timestamp* mutable_update_start_time();
  void set_allocated_update_start_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_update_start_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_update_start_time();

  private:
  const ::google::protobuf::Timestamp& _internal_update_start_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_update_start_time();

  public:
  // .google.protobuf.Timestamp update_end_time = 2 [json_name = "updateEndTime"];
  bool has_update_end_time() const;
  void clear_update_end_time() ;
  const ::google::protobuf::Timestamp& update_end_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_update_end_time();
  ::google::protobuf::Timestamp* mutable_update_end_time();
  void set_allocated_update_end_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_update_end_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_update_end_time();

  private:
  const ::google::protobuf::Timestamp& _internal_update_end_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_update_end_time();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.QueryTasksRequest.TimeRange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_QueryTasksRequest_TimeRange_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const QueryTasksRequest_TimeRange& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* update_start_time_;
    ::google::protobuf::Timestamp* update_end_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class ListenAsAgentRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.ListenAsAgentRequest) */ {
 public:
  inline ListenAsAgentRequest() : ListenAsAgentRequest(nullptr) {}
  ~ListenAsAgentRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListenAsAgentRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListenAsAgentRequest(const ListenAsAgentRequest& from) : ListenAsAgentRequest(nullptr, from) {}
  inline ListenAsAgentRequest(ListenAsAgentRequest&& from) noexcept
      : ListenAsAgentRequest(nullptr, std::move(from)) {}
  inline ListenAsAgentRequest& operator=(const ListenAsAgentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenAsAgentRequest& operator=(ListenAsAgentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenAsAgentRequest& default_instance() {
    return *internal_default_instance();
  }
  enum AgentSelectorCase {
    kEntityIds = 1,
    AGENT_SELECTOR_NOT_SET = 0,
  };
  static inline const ListenAsAgentRequest* internal_default_instance() {
    return reinterpret_cast<const ListenAsAgentRequest*>(
        &_ListenAsAgentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ListenAsAgentRequest& a, ListenAsAgentRequest& b) { a.Swap(&b); }
  inline void Swap(ListenAsAgentRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenAsAgentRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenAsAgentRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ListenAsAgentRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListenAsAgentRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListenAsAgentRequest& from) { ListenAsAgentRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListenAsAgentRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.ListenAsAgentRequest"; }

 protected:
  explicit ListenAsAgentRequest(::google::protobuf::Arena* arena);
  ListenAsAgentRequest(::google::protobuf::Arena* arena, const ListenAsAgentRequest& from);
  ListenAsAgentRequest(::google::protobuf::Arena* arena, ListenAsAgentRequest&& from) noexcept
      : ListenAsAgentRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdsFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.EntityIds entity_ids = 1 [json_name = "entityIds"];
  bool has_entity_ids() const;
  private:
  bool _internal_has_entity_ids() const;

  public:
  void clear_entity_ids() ;
  const ::anduril::taskmanager::v1::EntityIds& entity_ids() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::EntityIds* release_entity_ids();
  ::anduril::taskmanager::v1::EntityIds* mutable_entity_ids();
  void set_allocated_entity_ids(::anduril::taskmanager::v1::EntityIds* value);
  void unsafe_arena_set_allocated_entity_ids(::anduril::taskmanager::v1::EntityIds* value);
  ::anduril::taskmanager::v1::EntityIds* unsafe_arena_release_entity_ids();

  private:
  const ::anduril::taskmanager::v1::EntityIds& _internal_entity_ids() const;
  ::anduril::taskmanager::v1::EntityIds* _internal_mutable_entity_ids();

  public:
  void clear_agent_selector();
  AgentSelectorCase agent_selector_case() const;
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.ListenAsAgentRequest)
 private:
  class _Internal;
  void set_has_entity_ids();
  inline bool has_agent_selector() const;
  inline void clear_has_agent_selector();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ListenAsAgentRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListenAsAgentRequest& from_msg);
    union AgentSelectorUnion {
      constexpr AgentSelectorUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::taskmanager::v1::EntityIds* entity_ids_;
    } agent_selector_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Heartbeat(
      ::google::protobuf::internal::ConstantInitialized);

  inline Heartbeat(const Heartbeat& from) : Heartbeat(nullptr, from) {}
  inline Heartbeat(Heartbeat&& from) noexcept
      : Heartbeat(nullptr, std::move(from)) {}
  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
        &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Heartbeat& a, Heartbeat& b) { a.Swap(&b); }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Heartbeat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Heartbeat& from) { Heartbeat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Heartbeat* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.Heartbeat"; }

 protected:
  explicit Heartbeat(::google::protobuf::Arena* arena);
  Heartbeat(::google::protobuf::Arena* arena, const Heartbeat& from);
  Heartbeat(::google::protobuf::Arena* arena, Heartbeat&& from) noexcept
      : Heartbeat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 1,
  };
  // .google.protobuf.Timestamp timestamp = 1 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.Heartbeat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Heartbeat_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Heartbeat& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class QueryTasksRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.QueryTasksRequest) */ {
 public:
  inline QueryTasksRequest() : QueryTasksRequest(nullptr) {}
  ~QueryTasksRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTasksRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryTasksRequest(const QueryTasksRequest& from) : QueryTasksRequest(nullptr, from) {}
  inline QueryTasksRequest(QueryTasksRequest&& from) noexcept
      : QueryTasksRequest(nullptr, std::move(from)) {}
  inline QueryTasksRequest& operator=(const QueryTasksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTasksRequest& operator=(QueryTasksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTasksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTasksRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTasksRequest*>(
        &_QueryTasksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(QueryTasksRequest& a, QueryTasksRequest& b) { a.Swap(&b); }
  inline void Swap(QueryTasksRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTasksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTasksRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<QueryTasksRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryTasksRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryTasksRequest& from) { QueryTasksRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryTasksRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.QueryTasksRequest"; }

 protected:
  explicit QueryTasksRequest(::google::protobuf::Arena* arena);
  QueryTasksRequest(::google::protobuf::Arena* arena, const QueryTasksRequest& from);
  QueryTasksRequest(::google::protobuf::Arena* arena, QueryTasksRequest&& from) noexcept
      : QueryTasksRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TimeRange = QueryTasksRequest_TimeRange;
  using StatusFilter = QueryTasksRequest_StatusFilter;
  using FilterType = QueryTasksRequest_FilterType;
  static constexpr FilterType FILTER_TYPE_INVALID = QueryTasksRequest_FilterType_FILTER_TYPE_INVALID;
  static constexpr FilterType FILTER_TYPE_INCLUSIVE = QueryTasksRequest_FilterType_FILTER_TYPE_INCLUSIVE;
  static constexpr FilterType FILTER_TYPE_EXCLUSIVE = QueryTasksRequest_FilterType_FILTER_TYPE_EXCLUSIVE;
  static inline bool FilterType_IsValid(int value) {
    return QueryTasksRequest_FilterType_IsValid(value);
  }
  static constexpr FilterType FilterType_MIN = QueryTasksRequest_FilterType_FilterType_MIN;
  static constexpr FilterType FilterType_MAX = QueryTasksRequest_FilterType_FilterType_MAX;
  static constexpr int FilterType_ARRAYSIZE = QueryTasksRequest_FilterType_FilterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FilterType_descriptor() {
    return QueryTasksRequest_FilterType_descriptor();
  }
  template <typename T>
  static inline const std::string& FilterType_Name(T value) {
    return QueryTasksRequest_FilterType_Name(value);
  }
  static inline bool FilterType_Parse(absl::string_view name, FilterType* value) {
    return QueryTasksRequest_FilterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kParentTaskIdFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kStatusFilterFieldNumber = 4,
    kUpdateTimeRangeFieldNumber = 5,
    kViewFieldNumber = 6,
  };
  // string parent_task_id = 1 [json_name = "parentTaskId"];
  void clear_parent_task_id() ;
  const std::string& parent_task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_parent_task_id();
  PROTOBUF_NODISCARD std::string* release_parent_task_id();
  void set_allocated_parent_task_id(std::string* value);

  private:
  const std::string& _internal_parent_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_task_id(
      const std::string& value);
  std::string* _internal_mutable_parent_task_id();

  public:
  // string page_token = 3 [json_name = "pageToken"];
  void clear_page_token() ;
  const std::string& page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* value);

  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(
      const std::string& value);
  std::string* _internal_mutable_page_token();

  public:
  // .anduril.taskmanager.v1.QueryTasksRequest.StatusFilter status_filter = 4 [json_name = "statusFilter"];
  bool has_status_filter() const;
  void clear_status_filter() ;
  const ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter& status_filter() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* release_status_filter();
  ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* mutable_status_filter();
  void set_allocated_status_filter(::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* value);
  void unsafe_arena_set_allocated_status_filter(::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* value);
  ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* unsafe_arena_release_status_filter();

  private:
  const ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter& _internal_status_filter() const;
  ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* _internal_mutable_status_filter();

  public:
  // .anduril.taskmanager.v1.QueryTasksRequest.TimeRange update_time_range = 5 [json_name = "updateTimeRange"];
  bool has_update_time_range() const;
  void clear_update_time_range() ;
  const ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange& update_time_range() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* release_update_time_range();
  ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* mutable_update_time_range();
  void set_allocated_update_time_range(::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* value);
  void unsafe_arena_set_allocated_update_time_range(::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* value);
  ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* unsafe_arena_release_update_time_range();

  private:
  const ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange& _internal_update_time_range() const;
  ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* _internal_mutable_update_time_range();

  public:
  // .anduril.taskmanager.v1.TaskView view = 6 [json_name = "view"];
  void clear_view() ;
  ::anduril::taskmanager::v1::TaskView view() const;
  void set_view(::anduril::taskmanager::v1::TaskView value);

  private:
  ::anduril::taskmanager::v1::TaskView _internal_view() const;
  void _internal_set_view(::anduril::taskmanager::v1::TaskView value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.QueryTasksRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      73, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_QueryTasksRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const QueryTasksRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr parent_task_id_;
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* status_filter_;
    ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* update_time_range_;
    int view_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class UpdateStatusRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.UpdateStatusRequest) */ {
 public:
  inline UpdateStatusRequest() : UpdateStatusRequest(nullptr) {}
  ~UpdateStatusRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateStatusRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateStatusRequest(const UpdateStatusRequest& from) : UpdateStatusRequest(nullptr, from) {}
  inline UpdateStatusRequest(UpdateStatusRequest&& from) noexcept
      : UpdateStatusRequest(nullptr, std::move(from)) {}
  inline UpdateStatusRequest& operator=(const UpdateStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStatusRequest& operator=(UpdateStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStatusRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateStatusRequest*>(
        &_UpdateStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(UpdateStatusRequest& a, UpdateStatusRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateStatusRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStatusRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<UpdateStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateStatusRequest& from) { UpdateStatusRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateStatusRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.UpdateStatusRequest"; }

 protected:
  explicit UpdateStatusRequest(::google::protobuf::Arena* arena);
  UpdateStatusRequest(::google::protobuf::Arena* arena, const UpdateStatusRequest& from);
  UpdateStatusRequest(::google::protobuf::Arena* arena, UpdateStatusRequest&& from) noexcept
      : UpdateStatusRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusUpdateFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.StatusUpdate status_update = 1 [json_name = "statusUpdate"];
  bool has_status_update() const;
  void clear_status_update() ;
  const ::anduril::taskmanager::v1::StatusUpdate& status_update() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::StatusUpdate* release_status_update();
  ::anduril::taskmanager::v1::StatusUpdate* mutable_status_update();
  void set_allocated_status_update(::anduril::taskmanager::v1::StatusUpdate* value);
  void unsafe_arena_set_allocated_status_update(::anduril::taskmanager::v1::StatusUpdate* value);
  ::anduril::taskmanager::v1::StatusUpdate* unsafe_arena_release_status_update();

  private:
  const ::anduril::taskmanager::v1::StatusUpdate& _internal_status_update() const;
  ::anduril::taskmanager::v1::StatusUpdate* _internal_mutable_status_update();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.UpdateStatusRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UpdateStatusRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateStatusRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::StatusUpdate* status_update_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class CreateTaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.CreateTaskRequest) */ {
 public:
  inline CreateTaskRequest() : CreateTaskRequest(nullptr) {}
  ~CreateTaskRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateTaskRequest(const CreateTaskRequest& from) : CreateTaskRequest(nullptr, from) {}
  inline CreateTaskRequest(CreateTaskRequest&& from) noexcept
      : CreateTaskRequest(nullptr, std::move(from)) {}
  inline CreateTaskRequest& operator=(const CreateTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTaskRequest& operator=(CreateTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTaskRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTaskRequest*>(
        &_CreateTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CreateTaskRequest& a, CreateTaskRequest& b) { a.Swap(&b); }
  inline void Swap(CreateTaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTaskRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CreateTaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateTaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateTaskRequest& from) { CreateTaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateTaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.CreateTaskRequest"; }

 protected:
  explicit CreateTaskRequest(::google::protobuf::Arena* arena);
  CreateTaskRequest(::google::protobuf::Arena* arena, const CreateTaskRequest& from);
  CreateTaskRequest(::google::protobuf::Arena* arena, CreateTaskRequest&& from) noexcept
      : CreateTaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInitialEntitiesFieldNumber = 9,
    kDisplayNameFieldNumber = 1,
    kDescriptionFieldNumber = 6,
    kTaskIdFieldNumber = 8,
    kSpecificationFieldNumber = 2,
    kAuthorFieldNumber = 3,
    kRelationsFieldNumber = 5,
    kIsExecutedElsewhereFieldNumber = 7,
  };
  // repeated .anduril.taskmanager.v1.TaskEntity initial_entities = 9 [json_name = "initialEntities"];
  int initial_entities_size() const;
  private:
  int _internal_initial_entities_size() const;

  public:
  void clear_initial_entities() ;
  ::anduril::taskmanager::v1::TaskEntity* mutable_initial_entities(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>* mutable_initial_entities();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>& _internal_initial_entities() const;
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>* _internal_mutable_initial_entities();
  public:
  const ::anduril::taskmanager::v1::TaskEntity& initial_entities(int index) const;
  ::anduril::taskmanager::v1::TaskEntity* add_initial_entities();
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>& initial_entities() const;
  // string display_name = 1 [json_name = "displayName"];
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // string description = 6 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string task_id = 8 [json_name = "taskId"];
  void clear_task_id() ;
  const std::string& task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* value);

  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(
      const std::string& value);
  std::string* _internal_mutable_task_id();

  public:
  // .google.protobuf.Any specification = 2 [json_name = "specification"];
  bool has_specification() const;
  void clear_specification() ;
  const ::google::protobuf::Any& specification() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_specification();
  ::google::protobuf::Any* mutable_specification();
  void set_allocated_specification(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_specification(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_specification();

  private:
  const ::google::protobuf::Any& _internal_specification() const;
  ::google::protobuf::Any* _internal_mutable_specification();

  public:
  // .anduril.taskmanager.v1.Principal author = 3 [json_name = "author"];
  bool has_author() const;
  void clear_author() ;
  const ::anduril::taskmanager::v1::Principal& author() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Principal* release_author();
  ::anduril::taskmanager::v1::Principal* mutable_author();
  void set_allocated_author(::anduril::taskmanager::v1::Principal* value);
  void unsafe_arena_set_allocated_author(::anduril::taskmanager::v1::Principal* value);
  ::anduril::taskmanager::v1::Principal* unsafe_arena_release_author();

  private:
  const ::anduril::taskmanager::v1::Principal& _internal_author() const;
  ::anduril::taskmanager::v1::Principal* _internal_mutable_author();

  public:
  // .anduril.taskmanager.v1.Relations relations = 5 [json_name = "relations"];
  bool has_relations() const;
  void clear_relations() ;
  const ::anduril::taskmanager::v1::Relations& relations() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Relations* release_relations();
  ::anduril::taskmanager::v1::Relations* mutable_relations();
  void set_allocated_relations(::anduril::taskmanager::v1::Relations* value);
  void unsafe_arena_set_allocated_relations(::anduril::taskmanager::v1::Relations* value);
  ::anduril::taskmanager::v1::Relations* unsafe_arena_release_relations();

  private:
  const ::anduril::taskmanager::v1::Relations& _internal_relations() const;
  ::anduril::taskmanager::v1::Relations* _internal_mutable_relations();

  public:
  // bool is_executed_elsewhere = 7 [json_name = "isExecutedElsewhere"];
  void clear_is_executed_elsewhere() ;
  bool is_executed_elsewhere() const;
  void set_is_executed_elsewhere(bool value);

  private:
  bool _internal_is_executed_elsewhere() const;
  void _internal_set_is_executed_elsewhere(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.CreateTaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 8, 4,
      87, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CreateTaskRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateTaskRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::anduril::taskmanager::v1::TaskEntity > initial_entities_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    ::google::protobuf::Any* specification_;
    ::anduril::taskmanager::v1::Principal* author_;
    ::anduril::taskmanager::v1::Relations* relations_;
    bool is_executed_elsewhere_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class UpdateStatusResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.UpdateStatusResponse) */ {
 public:
  inline UpdateStatusResponse() : UpdateStatusResponse(nullptr) {}
  ~UpdateStatusResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateStatusResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateStatusResponse(const UpdateStatusResponse& from) : UpdateStatusResponse(nullptr, from) {}
  inline UpdateStatusResponse(UpdateStatusResponse&& from) noexcept
      : UpdateStatusResponse(nullptr, std::move(from)) {}
  inline UpdateStatusResponse& operator=(const UpdateStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStatusResponse& operator=(UpdateStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStatusResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateStatusResponse*>(
        &_UpdateStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(UpdateStatusResponse& a, UpdateStatusResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateStatusResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<UpdateStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateStatusResponse& from) { UpdateStatusResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateStatusResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.UpdateStatusResponse"; }

 protected:
  explicit UpdateStatusResponse(::google::protobuf::Arena* arena);
  UpdateStatusResponse(::google::protobuf::Arena* arena, const UpdateStatusResponse& from);
  UpdateStatusResponse(::google::protobuf::Arena* arena, UpdateStatusResponse&& from) noexcept
      : UpdateStatusResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::anduril::taskmanager::v1::Task& task() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Task* release_task();
  ::anduril::taskmanager::v1::Task* mutable_task();
  void set_allocated_task(::anduril::taskmanager::v1::Task* value);
  void unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value);
  ::anduril::taskmanager::v1::Task* unsafe_arena_release_task();

  private:
  const ::anduril::taskmanager::v1::Task& _internal_task() const;
  ::anduril::taskmanager::v1::Task* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.UpdateStatusResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UpdateStatusResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateStatusResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Task* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class QueryTasksResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.QueryTasksResponse) */ {
 public:
  inline QueryTasksResponse() : QueryTasksResponse(nullptr) {}
  ~QueryTasksResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTasksResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryTasksResponse(const QueryTasksResponse& from) : QueryTasksResponse(nullptr, from) {}
  inline QueryTasksResponse(QueryTasksResponse&& from) noexcept
      : QueryTasksResponse(nullptr, std::move(from)) {}
  inline QueryTasksResponse& operator=(const QueryTasksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTasksResponse& operator=(QueryTasksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTasksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTasksResponse* internal_default_instance() {
    return reinterpret_cast<const QueryTasksResponse*>(
        &_QueryTasksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(QueryTasksResponse& a, QueryTasksResponse& b) { a.Swap(&b); }
  inline void Swap(QueryTasksResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTasksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTasksResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<QueryTasksResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryTasksResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryTasksResponse& from) { QueryTasksResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryTasksResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.QueryTasksResponse"; }

 protected:
  explicit QueryTasksResponse(::google::protobuf::Arena* arena);
  QueryTasksResponse(::google::protobuf::Arena* arena, const QueryTasksResponse& from);
  QueryTasksResponse(::google::protobuf::Arena* arena, QueryTasksResponse&& from) noexcept
      : QueryTasksResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTasksFieldNumber = 1,
    kPageTokenFieldNumber = 2,
  };
  // repeated .anduril.taskmanager.v1.Task tasks = 1 [json_name = "tasks"];
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;

  public:
  void clear_tasks() ;
  ::anduril::taskmanager::v1::Task* mutable_tasks(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Task>* mutable_tasks();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Task>& _internal_tasks() const;
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Task>* _internal_mutable_tasks();
  public:
  const ::anduril::taskmanager::v1::Task& tasks(int index) const;
  ::anduril::taskmanager::v1::Task* add_tasks();
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Task>& tasks() const;
  // string page_token = 2 [json_name = "pageToken"];
  void clear_page_token() ;
  const std::string& page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* value);

  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(
      const std::string& value);
  std::string* _internal_mutable_page_token();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.QueryTasksResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      60, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_QueryTasksResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const QueryTasksResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::taskmanager::v1::Task > tasks_;
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class GetTaskResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.GetTaskResponse) */ {
 public:
  inline GetTaskResponse() : GetTaskResponse(nullptr) {}
  ~GetTaskResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTaskResponse(const GetTaskResponse& from) : GetTaskResponse(nullptr, from) {}
  inline GetTaskResponse(GetTaskResponse&& from) noexcept
      : GetTaskResponse(nullptr, std::move(from)) {}
  inline GetTaskResponse& operator=(const GetTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTaskResponse& operator=(GetTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTaskResponse* internal_default_instance() {
    return reinterpret_cast<const GetTaskResponse*>(
        &_GetTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(GetTaskResponse& a, GetTaskResponse& b) { a.Swap(&b); }
  inline void Swap(GetTaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTaskResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetTaskResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTaskResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTaskResponse& from) { GetTaskResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTaskResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.GetTaskResponse"; }

 protected:
  explicit GetTaskResponse(::google::protobuf::Arena* arena);
  GetTaskResponse(::google::protobuf::Arena* arena, const GetTaskResponse& from);
  GetTaskResponse(::google::protobuf::Arena* arena, GetTaskResponse&& from) noexcept
      : GetTaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::anduril::taskmanager::v1::Task& task() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Task* release_task();
  ::anduril::taskmanager::v1::Task* mutable_task();
  void set_allocated_task(::anduril::taskmanager::v1::Task* value);
  void unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value);
  ::anduril::taskmanager::v1::Task* unsafe_arena_release_task();

  private:
  const ::anduril::taskmanager::v1::Task& _internal_task() const;
  ::anduril::taskmanager::v1::Task* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.GetTaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetTaskResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTaskResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Task* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class CreateTaskResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.CreateTaskResponse) */ {
 public:
  inline CreateTaskResponse() : CreateTaskResponse(nullptr) {}
  ~CreateTaskResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateTaskResponse(const CreateTaskResponse& from) : CreateTaskResponse(nullptr, from) {}
  inline CreateTaskResponse(CreateTaskResponse&& from) noexcept
      : CreateTaskResponse(nullptr, std::move(from)) {}
  inline CreateTaskResponse& operator=(const CreateTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTaskResponse& operator=(CreateTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTaskResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTaskResponse*>(
        &_CreateTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CreateTaskResponse& a, CreateTaskResponse& b) { a.Swap(&b); }
  inline void Swap(CreateTaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTaskResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CreateTaskResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateTaskResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateTaskResponse& from) { CreateTaskResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateTaskResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.CreateTaskResponse"; }

 protected:
  explicit CreateTaskResponse(::google::protobuf::Arena* arena);
  CreateTaskResponse(::google::protobuf::Arena* arena, const CreateTaskResponse& from);
  CreateTaskResponse(::google::protobuf::Arena* arena, CreateTaskResponse&& from) noexcept
      : CreateTaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::anduril::taskmanager::v1::Task& task() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Task* release_task();
  ::anduril::taskmanager::v1::Task* mutable_task();
  void set_allocated_task(::anduril::taskmanager::v1::Task* value);
  void unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value);
  ::anduril::taskmanager::v1::Task* unsafe_arena_release_task();

  private:
  const ::anduril::taskmanager::v1::Task& _internal_task() const;
  ::anduril::taskmanager::v1::Task* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.CreateTaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CreateTaskResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateTaskResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Task* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class ListenAsAgentResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.ListenAsAgentResponse) */ {
 public:
  inline ListenAsAgentResponse() : ListenAsAgentResponse(nullptr) {}
  ~ListenAsAgentResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListenAsAgentResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListenAsAgentResponse(const ListenAsAgentResponse& from) : ListenAsAgentResponse(nullptr, from) {}
  inline ListenAsAgentResponse(ListenAsAgentResponse&& from) noexcept
      : ListenAsAgentResponse(nullptr, std::move(from)) {}
  inline ListenAsAgentResponse& operator=(const ListenAsAgentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenAsAgentResponse& operator=(ListenAsAgentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenAsAgentResponse& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kExecuteRequest = 1,
    kCancelRequest = 2,
    kCompleteRequest = 3,
    REQUEST_NOT_SET = 0,
  };
  static inline const ListenAsAgentResponse* internal_default_instance() {
    return reinterpret_cast<const ListenAsAgentResponse*>(
        &_ListenAsAgentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ListenAsAgentResponse& a, ListenAsAgentResponse& b) { a.Swap(&b); }
  inline void Swap(ListenAsAgentResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenAsAgentResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenAsAgentResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ListenAsAgentResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListenAsAgentResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListenAsAgentResponse& from) { ListenAsAgentResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListenAsAgentResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.ListenAsAgentResponse"; }

 protected:
  explicit ListenAsAgentResponse(::google::protobuf::Arena* arena);
  ListenAsAgentResponse(::google::protobuf::Arena* arena, const ListenAsAgentResponse& from);
  ListenAsAgentResponse(::google::protobuf::Arena* arena, ListenAsAgentResponse&& from) noexcept
      : ListenAsAgentResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExecuteRequestFieldNumber = 1,
    kCancelRequestFieldNumber = 2,
    kCompleteRequestFieldNumber = 3,
  };
  // .anduril.taskmanager.v1.ExecuteRequest execute_request = 1 [json_name = "executeRequest"];
  bool has_execute_request() const;
  private:
  bool _internal_has_execute_request() const;

  public:
  void clear_execute_request() ;
  const ::anduril::taskmanager::v1::ExecuteRequest& execute_request() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::ExecuteRequest* release_execute_request();
  ::anduril::taskmanager::v1::ExecuteRequest* mutable_execute_request();
  void set_allocated_execute_request(::anduril::taskmanager::v1::ExecuteRequest* value);
  void unsafe_arena_set_allocated_execute_request(::anduril::taskmanager::v1::ExecuteRequest* value);
  ::anduril::taskmanager::v1::ExecuteRequest* unsafe_arena_release_execute_request();

  private:
  const ::anduril::taskmanager::v1::ExecuteRequest& _internal_execute_request() const;
  ::anduril::taskmanager::v1::ExecuteRequest* _internal_mutable_execute_request();

  public:
  // .anduril.taskmanager.v1.CancelRequest cancel_request = 2 [json_name = "cancelRequest"];
  bool has_cancel_request() const;
  private:
  bool _internal_has_cancel_request() const;

  public:
  void clear_cancel_request() ;
  const ::anduril::taskmanager::v1::CancelRequest& cancel_request() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::CancelRequest* release_cancel_request();
  ::anduril::taskmanager::v1::CancelRequest* mutable_cancel_request();
  void set_allocated_cancel_request(::anduril::taskmanager::v1::CancelRequest* value);
  void unsafe_arena_set_allocated_cancel_request(::anduril::taskmanager::v1::CancelRequest* value);
  ::anduril::taskmanager::v1::CancelRequest* unsafe_arena_release_cancel_request();

  private:
  const ::anduril::taskmanager::v1::CancelRequest& _internal_cancel_request() const;
  ::anduril::taskmanager::v1::CancelRequest* _internal_mutable_cancel_request();

  public:
  // .anduril.taskmanager.v1.CompleteRequest complete_request = 3 [json_name = "completeRequest"];
  bool has_complete_request() const;
  private:
  bool _internal_has_complete_request() const;

  public:
  void clear_complete_request() ;
  const ::anduril::taskmanager::v1::CompleteRequest& complete_request() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::CompleteRequest* release_complete_request();
  ::anduril::taskmanager::v1::CompleteRequest* mutable_complete_request();
  void set_allocated_complete_request(::anduril::taskmanager::v1::CompleteRequest* value);
  void unsafe_arena_set_allocated_complete_request(::anduril::taskmanager::v1::CompleteRequest* value);
  ::anduril::taskmanager::v1::CompleteRequest* unsafe_arena_release_complete_request();

  private:
  const ::anduril::taskmanager::v1::CompleteRequest& _internal_complete_request() const;
  ::anduril::taskmanager::v1::CompleteRequest* _internal_mutable_complete_request();

  public:
  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.ListenAsAgentResponse)
 private:
  class _Internal;
  void set_has_execute_request();
  void set_has_cancel_request();
  void set_has_complete_request();
  inline bool has_request() const;
  inline void clear_has_request();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ListenAsAgentResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListenAsAgentResponse& from_msg);
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::taskmanager::v1::ExecuteRequest* execute_request_;
      ::anduril::taskmanager::v1::CancelRequest* cancel_request_;
      ::anduril::taskmanager::v1::CompleteRequest* complete_request_;
    } request_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CreateTaskRequest

// string display_name = 1 [json_name = "displayName"];
inline void CreateTaskRequest::clear_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& CreateTaskRequest::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateTaskRequest::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.CreateTaskRequest.display_name)
}
inline std::string* CreateTaskRequest::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.display_name)
  return _s;
}
inline const std::string& CreateTaskRequest::_internal_display_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.display_name_.Get();
}
inline void CreateTaskRequest::_internal_set_display_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* CreateTaskRequest::_internal_mutable_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* CreateTaskRequest::release_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.display_name)
  return _impl_.display_name_.Release();
}
inline void CreateTaskRequest::set_allocated_display_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.display_name_.IsDefault()) {
          _impl_.display_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.display_name)
}

// .google.protobuf.Any specification = 2 [json_name = "specification"];
inline bool CreateTaskRequest::has_specification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.specification_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& CreateTaskRequest::_internal_specification() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.specification_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& CreateTaskRequest::specification() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.specification)
  return _internal_specification();
}
inline void CreateTaskRequest::unsafe_arena_set_allocated_specification(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.specification_);
  }
  _impl_.specification_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.specification)
}
inline ::google::protobuf::Any* CreateTaskRequest::release_specification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.specification_;
  _impl_.specification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* CreateTaskRequest::unsafe_arena_release_specification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.specification)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.specification_;
  _impl_.specification_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* CreateTaskRequest::_internal_mutable_specification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.specification_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.specification_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.specification_;
}
inline ::google::protobuf::Any* CreateTaskRequest::mutable_specification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Any* _msg = _internal_mutable_specification();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.specification)
  return _msg;
}
inline void CreateTaskRequest::set_allocated_specification(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.specification_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.specification_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.specification)
}

// .anduril.taskmanager.v1.Principal author = 3 [json_name = "author"];
inline bool CreateTaskRequest::has_author() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.author_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Principal& CreateTaskRequest::_internal_author() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Principal* p = _impl_.author_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Principal&>(::anduril::taskmanager::v1::_Principal_default_instance_);
}
inline const ::anduril::taskmanager::v1::Principal& CreateTaskRequest::author() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.author)
  return _internal_author();
}
inline void CreateTaskRequest::unsafe_arena_set_allocated_author(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.author_);
  }
  _impl_.author_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.author)
}
inline ::anduril::taskmanager::v1::Principal* CreateTaskRequest::release_author() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::taskmanager::v1::Principal* released = _impl_.author_;
  _impl_.author_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Principal* CreateTaskRequest::unsafe_arena_release_author() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.author)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::taskmanager::v1::Principal* temp = _impl_.author_;
  _impl_.author_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Principal* CreateTaskRequest::_internal_mutable_author() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.author_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Principal>(GetArena());
    _impl_.author_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(p);
  }
  return _impl_.author_;
}
inline ::anduril::taskmanager::v1::Principal* CreateTaskRequest::mutable_author() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::taskmanager::v1::Principal* _msg = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.author)
  return _msg;
}
inline void CreateTaskRequest::set_allocated_author(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.author_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.author_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.author)
}

// .anduril.taskmanager.v1.Relations relations = 5 [json_name = "relations"];
inline bool CreateTaskRequest::has_relations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relations_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Relations& CreateTaskRequest::_internal_relations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Relations* p = _impl_.relations_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Relations&>(::anduril::taskmanager::v1::_Relations_default_instance_);
}
inline const ::anduril::taskmanager::v1::Relations& CreateTaskRequest::relations() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.relations)
  return _internal_relations();
}
inline void CreateTaskRequest::unsafe_arena_set_allocated_relations(::anduril::taskmanager::v1::Relations* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relations_);
  }
  _impl_.relations_ = reinterpret_cast<::anduril::taskmanager::v1::Relations*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.relations)
}
inline ::anduril::taskmanager::v1::Relations* CreateTaskRequest::release_relations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::taskmanager::v1::Relations* released = _impl_.relations_;
  _impl_.relations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Relations* CreateTaskRequest::unsafe_arena_release_relations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.relations)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::taskmanager::v1::Relations* temp = _impl_.relations_;
  _impl_.relations_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Relations* CreateTaskRequest::_internal_mutable_relations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.relations_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Relations>(GetArena());
    _impl_.relations_ = reinterpret_cast<::anduril::taskmanager::v1::Relations*>(p);
  }
  return _impl_.relations_;
}
inline ::anduril::taskmanager::v1::Relations* CreateTaskRequest::mutable_relations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::anduril::taskmanager::v1::Relations* _msg = _internal_mutable_relations();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.relations)
  return _msg;
}
inline void CreateTaskRequest::set_allocated_relations(::anduril::taskmanager::v1::Relations* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relations_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.relations_ = reinterpret_cast<::anduril::taskmanager::v1::Relations*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.relations)
}

// string description = 6 [json_name = "description"];
inline void CreateTaskRequest::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CreateTaskRequest::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateTaskRequest::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.CreateTaskRequest.description)
}
inline std::string* CreateTaskRequest::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.description)
  return _s;
}
inline const std::string& CreateTaskRequest::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void CreateTaskRequest::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* CreateTaskRequest::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* CreateTaskRequest::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.description)
  return _impl_.description_.Release();
}
inline void CreateTaskRequest::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.description)
}

// bool is_executed_elsewhere = 7 [json_name = "isExecutedElsewhere"];
inline void CreateTaskRequest::clear_is_executed_elsewhere() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_executed_elsewhere_ = false;
}
inline bool CreateTaskRequest::is_executed_elsewhere() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.is_executed_elsewhere)
  return _internal_is_executed_elsewhere();
}
inline void CreateTaskRequest::set_is_executed_elsewhere(bool value) {
  _internal_set_is_executed_elsewhere(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.CreateTaskRequest.is_executed_elsewhere)
}
inline bool CreateTaskRequest::_internal_is_executed_elsewhere() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_executed_elsewhere_;
}
inline void CreateTaskRequest::_internal_set_is_executed_elsewhere(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_executed_elsewhere_ = value;
}

// string task_id = 8 [json_name = "taskId"];
inline void CreateTaskRequest::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& CreateTaskRequest::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateTaskRequest::set_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.CreateTaskRequest.task_id)
}
inline std::string* CreateTaskRequest::mutable_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.task_id)
  return _s;
}
inline const std::string& CreateTaskRequest::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_.Get();
}
inline void CreateTaskRequest::_internal_set_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(value, GetArena());
}
inline std::string* CreateTaskRequest::_internal_mutable_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_id_.Mutable( GetArena());
}
inline std::string* CreateTaskRequest::release_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.task_id)
  return _impl_.task_id_.Release();
}
inline void CreateTaskRequest::set_allocated_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.task_id_.IsDefault()) {
          _impl_.task_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.task_id)
}

// repeated .anduril.taskmanager.v1.TaskEntity initial_entities = 9 [json_name = "initialEntities"];
inline int CreateTaskRequest::_internal_initial_entities_size() const {
  return _internal_initial_entities().size();
}
inline int CreateTaskRequest::initial_entities_size() const {
  return _internal_initial_entities_size();
}
inline ::anduril::taskmanager::v1::TaskEntity* CreateTaskRequest::mutable_initial_entities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.initial_entities)
  return _internal_mutable_initial_entities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>* CreateTaskRequest::mutable_initial_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.taskmanager.v1.CreateTaskRequest.initial_entities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_initial_entities();
}
inline const ::anduril::taskmanager::v1::TaskEntity& CreateTaskRequest::initial_entities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.initial_entities)
  return _internal_initial_entities().Get(index);
}
inline ::anduril::taskmanager::v1::TaskEntity* CreateTaskRequest::add_initial_entities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::taskmanager::v1::TaskEntity* _add = _internal_mutable_initial_entities()->Add();
  // @@protoc_insertion_point(field_add:anduril.taskmanager.v1.CreateTaskRequest.initial_entities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>& CreateTaskRequest::initial_entities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.taskmanager.v1.CreateTaskRequest.initial_entities)
  return _internal_initial_entities();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>&
CreateTaskRequest::_internal_initial_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initial_entities_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>*
CreateTaskRequest::_internal_mutable_initial_entities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.initial_entities_;
}

// -------------------------------------------------------------------

// CreateTaskResponse

// .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
inline bool CreateTaskResponse::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Task& CreateTaskResponse::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Task&>(::anduril::taskmanager::v1::_Task_default_instance_);
}
inline const ::anduril::taskmanager::v1::Task& CreateTaskResponse::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskResponse.task)
  return _internal_task();
}
inline void CreateTaskResponse::unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.CreateTaskResponse.task)
}
inline ::anduril::taskmanager::v1::Task* CreateTaskResponse::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Task* CreateTaskResponse::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskResponse.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Task* CreateTaskResponse::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::anduril::taskmanager::v1::Task* CreateTaskResponse::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskResponse.task)
  return _msg;
}
inline void CreateTaskResponse::set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskResponse.task)
}

// -------------------------------------------------------------------

// GetTaskRequest

// string task_id = 1 [json_name = "taskId"];
inline void GetTaskRequest::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& GetTaskRequest::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.GetTaskRequest.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTaskRequest::set_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.GetTaskRequest.task_id)
}
inline std::string* GetTaskRequest::mutable_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.GetTaskRequest.task_id)
  return _s;
}
inline const std::string& GetTaskRequest::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_.Get();
}
inline void GetTaskRequest::_internal_set_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(value, GetArena());
}
inline std::string* GetTaskRequest::_internal_mutable_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_id_.Mutable( GetArena());
}
inline std::string* GetTaskRequest::release_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.GetTaskRequest.task_id)
  return _impl_.task_id_.Release();
}
inline void GetTaskRequest::set_allocated_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.task_id_.IsDefault()) {
          _impl_.task_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.GetTaskRequest.task_id)
}

// uint32 definition_version = 2 [json_name = "definitionVersion"];
inline void GetTaskRequest::clear_definition_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.definition_version_ = 0u;
}
inline ::uint32_t GetTaskRequest::definition_version() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.GetTaskRequest.definition_version)
  return _internal_definition_version();
}
inline void GetTaskRequest::set_definition_version(::uint32_t value) {
  _internal_set_definition_version(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.GetTaskRequest.definition_version)
}
inline ::uint32_t GetTaskRequest::_internal_definition_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.definition_version_;
}
inline void GetTaskRequest::_internal_set_definition_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.definition_version_ = value;
}

// .anduril.taskmanager.v1.TaskView task_view = 3 [json_name = "taskView"];
inline void GetTaskRequest::clear_task_view() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_view_ = 0;
}
inline ::anduril::taskmanager::v1::TaskView GetTaskRequest::task_view() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.GetTaskRequest.task_view)
  return _internal_task_view();
}
inline void GetTaskRequest::set_task_view(::anduril::taskmanager::v1::TaskView value) {
  _internal_set_task_view(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.GetTaskRequest.task_view)
}
inline ::anduril::taskmanager::v1::TaskView GetTaskRequest::_internal_task_view() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::taskmanager::v1::TaskView>(_impl_.task_view_);
}
inline void GetTaskRequest::_internal_set_task_view(::anduril::taskmanager::v1::TaskView value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_view_ = value;
}

// -------------------------------------------------------------------

// GetTaskResponse

// .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
inline bool GetTaskResponse::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Task& GetTaskResponse::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Task&>(::anduril::taskmanager::v1::_Task_default_instance_);
}
inline const ::anduril::taskmanager::v1::Task& GetTaskResponse::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.GetTaskResponse.task)
  return _internal_task();
}
inline void GetTaskResponse::unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.GetTaskResponse.task)
}
inline ::anduril::taskmanager::v1::Task* GetTaskResponse::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Task* GetTaskResponse::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.GetTaskResponse.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Task* GetTaskResponse::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::anduril::taskmanager::v1::Task* GetTaskResponse::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.GetTaskResponse.task)
  return _msg;
}
inline void GetTaskResponse::set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.GetTaskResponse.task)
}

// -------------------------------------------------------------------

// QueryTasksRequest_TimeRange

// .google.protobuf.Timestamp update_start_time = 1 [json_name = "updateStartTime"];
inline bool QueryTasksRequest_TimeRange::has_update_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_start_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& QueryTasksRequest_TimeRange::_internal_update_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.update_start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& QueryTasksRequest_TimeRange::update_start_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksRequest.TimeRange.update_start_time)
  return _internal_update_start_time();
}
inline void QueryTasksRequest_TimeRange::unsafe_arena_set_allocated_update_start_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_start_time_);
  }
  _impl_.update_start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.QueryTasksRequest.TimeRange.update_start_time)
}
inline ::google::protobuf::Timestamp* QueryTasksRequest_TimeRange::release_update_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.update_start_time_;
  _impl_.update_start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* QueryTasksRequest_TimeRange::unsafe_arena_release_update_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.QueryTasksRequest.TimeRange.update_start_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.update_start_time_;
  _impl_.update_start_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* QueryTasksRequest_TimeRange::_internal_mutable_update_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_start_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.update_start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.update_start_time_;
}
inline ::google::protobuf::Timestamp* QueryTasksRequest_TimeRange::mutable_update_start_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_update_start_time();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.QueryTasksRequest.TimeRange.update_start_time)
  return _msg;
}
inline void QueryTasksRequest_TimeRange::set_allocated_update_start_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_start_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.update_start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.QueryTasksRequest.TimeRange.update_start_time)
}

// .google.protobuf.Timestamp update_end_time = 2 [json_name = "updateEndTime"];
inline bool QueryTasksRequest_TimeRange::has_update_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_end_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& QueryTasksRequest_TimeRange::_internal_update_end_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.update_end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& QueryTasksRequest_TimeRange::update_end_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksRequest.TimeRange.update_end_time)
  return _internal_update_end_time();
}
inline void QueryTasksRequest_TimeRange::unsafe_arena_set_allocated_update_end_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_end_time_);
  }
  _impl_.update_end_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.QueryTasksRequest.TimeRange.update_end_time)
}
inline ::google::protobuf::Timestamp* QueryTasksRequest_TimeRange::release_update_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.update_end_time_;
  _impl_.update_end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* QueryTasksRequest_TimeRange::unsafe_arena_release_update_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.QueryTasksRequest.TimeRange.update_end_time)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.update_end_time_;
  _impl_.update_end_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* QueryTasksRequest_TimeRange::_internal_mutable_update_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_end_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.update_end_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.update_end_time_;
}
inline ::google::protobuf::Timestamp* QueryTasksRequest_TimeRange::mutable_update_end_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_update_end_time();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.QueryTasksRequest.TimeRange.update_end_time)
  return _msg;
}
inline void QueryTasksRequest_TimeRange::set_allocated_update_end_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_end_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.update_end_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.QueryTasksRequest.TimeRange.update_end_time)
}

// -------------------------------------------------------------------

// QueryTasksRequest_StatusFilter

// repeated .anduril.taskmanager.v1.Status status = 1 [json_name = "status"];
inline int QueryTasksRequest_StatusFilter::_internal_status_size() const {
  return _internal_status().size();
}
inline int QueryTasksRequest_StatusFilter::status_size() const {
  return _internal_status_size();
}
inline void QueryTasksRequest_StatusFilter::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Clear();
}
inline ::anduril::taskmanager::v1::Status QueryTasksRequest_StatusFilter::status(int index) const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksRequest.StatusFilter.status)
  return static_cast<::anduril::taskmanager::v1::Status>(_internal_status().Get(index));
}
inline void QueryTasksRequest_StatusFilter::set_status(int index, ::anduril::taskmanager::v1::Status value) {
  _internal_mutable_status()->Set(index, value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.QueryTasksRequest.StatusFilter.status)
}
inline void QueryTasksRequest_StatusFilter::add_status(::anduril::taskmanager::v1::Status value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_status()->Add(value);
  // @@protoc_insertion_point(field_add:anduril.taskmanager.v1.QueryTasksRequest.StatusFilter.status)
}
inline const ::google::protobuf::RepeatedField<int>& QueryTasksRequest_StatusFilter::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.taskmanager.v1.QueryTasksRequest.StatusFilter.status)
  return _internal_status();
}
inline ::google::protobuf::RepeatedField<int>* QueryTasksRequest_StatusFilter::mutable_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.taskmanager.v1.QueryTasksRequest.StatusFilter.status)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_status();
}
inline const ::google::protobuf::RepeatedField<int>& QueryTasksRequest_StatusFilter::_internal_status()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_;
}
inline ::google::protobuf::RepeatedField<int>* QueryTasksRequest_StatusFilter::_internal_mutable_status() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.status_;
}

// .anduril.taskmanager.v1.QueryTasksRequest.FilterType filter_type = 2 [json_name = "filterType"];
inline void QueryTasksRequest_StatusFilter::clear_filter_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_type_ = 0;
}
inline ::anduril::taskmanager::v1::QueryTasksRequest_FilterType QueryTasksRequest_StatusFilter::filter_type() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksRequest.StatusFilter.filter_type)
  return _internal_filter_type();
}
inline void QueryTasksRequest_StatusFilter::set_filter_type(::anduril::taskmanager::v1::QueryTasksRequest_FilterType value) {
  _internal_set_filter_type(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.QueryTasksRequest.StatusFilter.filter_type)
}
inline ::anduril::taskmanager::v1::QueryTasksRequest_FilterType QueryTasksRequest_StatusFilter::_internal_filter_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::taskmanager::v1::QueryTasksRequest_FilterType>(_impl_.filter_type_);
}
inline void QueryTasksRequest_StatusFilter::_internal_set_filter_type(::anduril::taskmanager::v1::QueryTasksRequest_FilterType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_type_ = value;
}

// -------------------------------------------------------------------

// QueryTasksRequest

// string parent_task_id = 1 [json_name = "parentTaskId"];
inline void QueryTasksRequest::clear_parent_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_task_id_.ClearToEmpty();
}
inline const std::string& QueryTasksRequest::parent_task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksRequest.parent_task_id)
  return _internal_parent_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTasksRequest::set_parent_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.QueryTasksRequest.parent_task_id)
}
inline std::string* QueryTasksRequest::mutable_parent_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_task_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.QueryTasksRequest.parent_task_id)
  return _s;
}
inline const std::string& QueryTasksRequest::_internal_parent_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_task_id_.Get();
}
inline void QueryTasksRequest::_internal_set_parent_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_task_id_.Set(value, GetArena());
}
inline std::string* QueryTasksRequest::_internal_mutable_parent_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parent_task_id_.Mutable( GetArena());
}
inline std::string* QueryTasksRequest::release_parent_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.QueryTasksRequest.parent_task_id)
  return _impl_.parent_task_id_.Release();
}
inline void QueryTasksRequest::set_allocated_parent_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_task_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_task_id_.IsDefault()) {
          _impl_.parent_task_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.QueryTasksRequest.parent_task_id)
}

// string page_token = 3 [json_name = "pageToken"];
inline void QueryTasksRequest::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& QueryTasksRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTasksRequest::set_page_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.QueryTasksRequest.page_token)
}
inline std::string* QueryTasksRequest::mutable_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.QueryTasksRequest.page_token)
  return _s;
}
inline const std::string& QueryTasksRequest::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void QueryTasksRequest::_internal_set_page_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.Set(value, GetArena());
}
inline std::string* QueryTasksRequest::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.page_token_.Mutable( GetArena());
}
inline std::string* QueryTasksRequest::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.QueryTasksRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void QueryTasksRequest::set_allocated_page_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.page_token_.IsDefault()) {
          _impl_.page_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.QueryTasksRequest.page_token)
}

// .anduril.taskmanager.v1.QueryTasksRequest.StatusFilter status_filter = 4 [json_name = "statusFilter"];
inline bool QueryTasksRequest::has_status_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_filter_ != nullptr);
  return value;
}
inline void QueryTasksRequest::clear_status_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_filter_ != nullptr) _impl_.status_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter& QueryTasksRequest::_internal_status_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* p = _impl_.status_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter&>(::anduril::taskmanager::v1::_QueryTasksRequest_StatusFilter_default_instance_);
}
inline const ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter& QueryTasksRequest::status_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksRequest.status_filter)
  return _internal_status_filter();
}
inline void QueryTasksRequest::unsafe_arena_set_allocated_status_filter(::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_filter_);
  }
  _impl_.status_filter_ = reinterpret_cast<::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.QueryTasksRequest.status_filter)
}
inline ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* QueryTasksRequest::release_status_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* released = _impl_.status_filter_;
  _impl_.status_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* QueryTasksRequest::unsafe_arena_release_status_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.QueryTasksRequest.status_filter)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* temp = _impl_.status_filter_;
  _impl_.status_filter_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* QueryTasksRequest::_internal_mutable_status_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter>(GetArena());
    _impl_.status_filter_ = reinterpret_cast<::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter*>(p);
  }
  return _impl_.status_filter_;
}
inline ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* QueryTasksRequest::mutable_status_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* _msg = _internal_mutable_status_filter();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.QueryTasksRequest.status_filter)
  return _msg;
}
inline void QueryTasksRequest::set_allocated_status_filter(::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_filter_ = reinterpret_cast<::anduril::taskmanager::v1::QueryTasksRequest_StatusFilter*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.QueryTasksRequest.status_filter)
}

// .anduril.taskmanager.v1.QueryTasksRequest.TimeRange update_time_range = 5 [json_name = "updateTimeRange"];
inline bool QueryTasksRequest::has_update_time_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_time_range_ != nullptr);
  return value;
}
inline void QueryTasksRequest::clear_update_time_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_time_range_ != nullptr) _impl_.update_time_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange& QueryTasksRequest::_internal_update_time_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* p = _impl_.update_time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange&>(::anduril::taskmanager::v1::_QueryTasksRequest_TimeRange_default_instance_);
}
inline const ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange& QueryTasksRequest::update_time_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksRequest.update_time_range)
  return _internal_update_time_range();
}
inline void QueryTasksRequest::unsafe_arena_set_allocated_update_time_range(::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_time_range_);
  }
  _impl_.update_time_range_ = reinterpret_cast<::anduril::taskmanager::v1::QueryTasksRequest_TimeRange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.QueryTasksRequest.update_time_range)
}
inline ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* QueryTasksRequest::release_update_time_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* released = _impl_.update_time_range_;
  _impl_.update_time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* QueryTasksRequest::unsafe_arena_release_update_time_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.QueryTasksRequest.update_time_range)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* temp = _impl_.update_time_range_;
  _impl_.update_time_range_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* QueryTasksRequest::_internal_mutable_update_time_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_time_range_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::QueryTasksRequest_TimeRange>(GetArena());
    _impl_.update_time_range_ = reinterpret_cast<::anduril::taskmanager::v1::QueryTasksRequest_TimeRange*>(p);
  }
  return _impl_.update_time_range_;
}
inline ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* QueryTasksRequest::mutable_update_time_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* _msg = _internal_mutable_update_time_range();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.QueryTasksRequest.update_time_range)
  return _msg;
}
inline void QueryTasksRequest::set_allocated_update_time_range(::anduril::taskmanager::v1::QueryTasksRequest_TimeRange* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.update_time_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.update_time_range_ = reinterpret_cast<::anduril::taskmanager::v1::QueryTasksRequest_TimeRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.QueryTasksRequest.update_time_range)
}

// .anduril.taskmanager.v1.TaskView view = 6 [json_name = "view"];
inline void QueryTasksRequest::clear_view() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.view_ = 0;
}
inline ::anduril::taskmanager::v1::TaskView QueryTasksRequest::view() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksRequest.view)
  return _internal_view();
}
inline void QueryTasksRequest::set_view(::anduril::taskmanager::v1::TaskView value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.QueryTasksRequest.view)
}
inline ::anduril::taskmanager::v1::TaskView QueryTasksRequest::_internal_view() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::taskmanager::v1::TaskView>(_impl_.view_);
}
inline void QueryTasksRequest::_internal_set_view(::anduril::taskmanager::v1::TaskView value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.view_ = value;
}

// -------------------------------------------------------------------

// QueryTasksResponse

// repeated .anduril.taskmanager.v1.Task tasks = 1 [json_name = "tasks"];
inline int QueryTasksResponse::_internal_tasks_size() const {
  return _internal_tasks().size();
}
inline int QueryTasksResponse::tasks_size() const {
  return _internal_tasks_size();
}
inline ::anduril::taskmanager::v1::Task* QueryTasksResponse::mutable_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.QueryTasksResponse.tasks)
  return _internal_mutable_tasks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Task>* QueryTasksResponse::mutable_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.taskmanager.v1.QueryTasksResponse.tasks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tasks();
}
inline const ::anduril::taskmanager::v1::Task& QueryTasksResponse::tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksResponse.tasks)
  return _internal_tasks().Get(index);
}
inline ::anduril::taskmanager::v1::Task* QueryTasksResponse::add_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::taskmanager::v1::Task* _add = _internal_mutable_tasks()->Add();
  // @@protoc_insertion_point(field_add:anduril.taskmanager.v1.QueryTasksResponse.tasks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Task>& QueryTasksResponse::tasks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.taskmanager.v1.QueryTasksResponse.tasks)
  return _internal_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Task>&
QueryTasksResponse::_internal_tasks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tasks_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::Task>*
QueryTasksResponse::_internal_mutable_tasks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tasks_;
}

// string page_token = 2 [json_name = "pageToken"];
inline void QueryTasksResponse::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& QueryTasksResponse::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.QueryTasksResponse.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTasksResponse::set_page_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.QueryTasksResponse.page_token)
}
inline std::string* QueryTasksResponse::mutable_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.QueryTasksResponse.page_token)
  return _s;
}
inline const std::string& QueryTasksResponse::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void QueryTasksResponse::_internal_set_page_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.Set(value, GetArena());
}
inline std::string* QueryTasksResponse::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.page_token_.Mutable( GetArena());
}
inline std::string* QueryTasksResponse::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.QueryTasksResponse.page_token)
  return _impl_.page_token_.Release();
}
inline void QueryTasksResponse::set_allocated_page_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.page_token_.IsDefault()) {
          _impl_.page_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.QueryTasksResponse.page_token)
}

// -------------------------------------------------------------------

// UpdateStatusRequest

// .anduril.taskmanager.v1.StatusUpdate status_update = 1 [json_name = "statusUpdate"];
inline bool UpdateStatusRequest::has_status_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_update_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::StatusUpdate& UpdateStatusRequest::_internal_status_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::StatusUpdate* p = _impl_.status_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::StatusUpdate&>(::anduril::taskmanager::v1::_StatusUpdate_default_instance_);
}
inline const ::anduril::taskmanager::v1::StatusUpdate& UpdateStatusRequest::status_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.UpdateStatusRequest.status_update)
  return _internal_status_update();
}
inline void UpdateStatusRequest::unsafe_arena_set_allocated_status_update(::anduril::taskmanager::v1::StatusUpdate* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_update_);
  }
  _impl_.status_update_ = reinterpret_cast<::anduril::taskmanager::v1::StatusUpdate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.UpdateStatusRequest.status_update)
}
inline ::anduril::taskmanager::v1::StatusUpdate* UpdateStatusRequest::release_status_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::StatusUpdate* released = _impl_.status_update_;
  _impl_.status_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::StatusUpdate* UpdateStatusRequest::unsafe_arena_release_status_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.UpdateStatusRequest.status_update)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::StatusUpdate* temp = _impl_.status_update_;
  _impl_.status_update_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::StatusUpdate* UpdateStatusRequest::_internal_mutable_status_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_update_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::StatusUpdate>(GetArena());
    _impl_.status_update_ = reinterpret_cast<::anduril::taskmanager::v1::StatusUpdate*>(p);
  }
  return _impl_.status_update_;
}
inline ::anduril::taskmanager::v1::StatusUpdate* UpdateStatusRequest::mutable_status_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::StatusUpdate* _msg = _internal_mutable_status_update();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.UpdateStatusRequest.status_update)
  return _msg;
}
inline void UpdateStatusRequest::set_allocated_status_update(::anduril::taskmanager::v1::StatusUpdate* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_update_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_update_ = reinterpret_cast<::anduril::taskmanager::v1::StatusUpdate*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.UpdateStatusRequest.status_update)
}

// -------------------------------------------------------------------

// UpdateStatusResponse

// .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
inline bool UpdateStatusResponse::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Task& UpdateStatusResponse::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Task&>(::anduril::taskmanager::v1::_Task_default_instance_);
}
inline const ::anduril::taskmanager::v1::Task& UpdateStatusResponse::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.UpdateStatusResponse.task)
  return _internal_task();
}
inline void UpdateStatusResponse::unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.UpdateStatusResponse.task)
}
inline ::anduril::taskmanager::v1::Task* UpdateStatusResponse::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Task* UpdateStatusResponse::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.UpdateStatusResponse.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Task* UpdateStatusResponse::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::anduril::taskmanager::v1::Task* UpdateStatusResponse::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.UpdateStatusResponse.task)
  return _msg;
}
inline void UpdateStatusResponse::set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.UpdateStatusResponse.task)
}

// -------------------------------------------------------------------

// ListenAsAgentRequest

// .anduril.taskmanager.v1.EntityIds entity_ids = 1 [json_name = "entityIds"];
inline bool ListenAsAgentRequest::has_entity_ids() const {
  return agent_selector_case() == kEntityIds;
}
inline bool ListenAsAgentRequest::_internal_has_entity_ids() const {
  return agent_selector_case() == kEntityIds;
}
inline void ListenAsAgentRequest::set_has_entity_ids() {
  _impl_._oneof_case_[0] = kEntityIds;
}
inline void ListenAsAgentRequest::clear_entity_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (agent_selector_case() == kEntityIds) {
    if (GetArena() == nullptr) {
      delete _impl_.agent_selector_.entity_ids_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.agent_selector_.entity_ids_);
    }
    clear_has_agent_selector();
  }
}
inline ::anduril::taskmanager::v1::EntityIds* ListenAsAgentRequest::release_entity_ids() {
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.ListenAsAgentRequest.entity_ids)
  if (agent_selector_case() == kEntityIds) {
    clear_has_agent_selector();
    auto* temp = _impl_.agent_selector_.entity_ids_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.agent_selector_.entity_ids_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::taskmanager::v1::EntityIds& ListenAsAgentRequest::_internal_entity_ids() const {
  return agent_selector_case() == kEntityIds ? *_impl_.agent_selector_.entity_ids_ : reinterpret_cast<::anduril::taskmanager::v1::EntityIds&>(::anduril::taskmanager::v1::_EntityIds_default_instance_);
}
inline const ::anduril::taskmanager::v1::EntityIds& ListenAsAgentRequest::entity_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.ListenAsAgentRequest.entity_ids)
  return _internal_entity_ids();
}
inline ::anduril::taskmanager::v1::EntityIds* ListenAsAgentRequest::unsafe_arena_release_entity_ids() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.taskmanager.v1.ListenAsAgentRequest.entity_ids)
  if (agent_selector_case() == kEntityIds) {
    clear_has_agent_selector();
    auto* temp = _impl_.agent_selector_.entity_ids_;
    _impl_.agent_selector_.entity_ids_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ListenAsAgentRequest::unsafe_arena_set_allocated_entity_ids(::anduril::taskmanager::v1::EntityIds* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_agent_selector();
  if (value) {
    set_has_entity_ids();
    _impl_.agent_selector_.entity_ids_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.ListenAsAgentRequest.entity_ids)
}
inline ::anduril::taskmanager::v1::EntityIds* ListenAsAgentRequest::_internal_mutable_entity_ids() {
  if (agent_selector_case() != kEntityIds) {
    clear_agent_selector();
    set_has_entity_ids();
    _impl_.agent_selector_.entity_ids_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::EntityIds>(GetArena());
  }
  return _impl_.agent_selector_.entity_ids_;
}
inline ::anduril::taskmanager::v1::EntityIds* ListenAsAgentRequest::mutable_entity_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::taskmanager::v1::EntityIds* _msg = _internal_mutable_entity_ids();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.ListenAsAgentRequest.entity_ids)
  return _msg;
}

inline bool ListenAsAgentRequest::has_agent_selector() const {
  return agent_selector_case() != AGENT_SELECTOR_NOT_SET;
}
inline void ListenAsAgentRequest::clear_has_agent_selector() {
  _impl_._oneof_case_[0] = AGENT_SELECTOR_NOT_SET;
}
inline ListenAsAgentRequest::AgentSelectorCase ListenAsAgentRequest::agent_selector_case() const {
  return ListenAsAgentRequest::AgentSelectorCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ListenAsAgentResponse

// .anduril.taskmanager.v1.ExecuteRequest execute_request = 1 [json_name = "executeRequest"];
inline bool ListenAsAgentResponse::has_execute_request() const {
  return request_case() == kExecuteRequest;
}
inline bool ListenAsAgentResponse::_internal_has_execute_request() const {
  return request_case() == kExecuteRequest;
}
inline void ListenAsAgentResponse::set_has_execute_request() {
  _impl_._oneof_case_[0] = kExecuteRequest;
}
inline ::anduril::taskmanager::v1::ExecuteRequest* ListenAsAgentResponse::release_execute_request() {
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.ListenAsAgentResponse.execute_request)
  if (request_case() == kExecuteRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.execute_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.execute_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::taskmanager::v1::ExecuteRequest& ListenAsAgentResponse::_internal_execute_request() const {
  return request_case() == kExecuteRequest ? *_impl_.request_.execute_request_ : reinterpret_cast<::anduril::taskmanager::v1::ExecuteRequest&>(::anduril::taskmanager::v1::_ExecuteRequest_default_instance_);
}
inline const ::anduril::taskmanager::v1::ExecuteRequest& ListenAsAgentResponse::execute_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.ListenAsAgentResponse.execute_request)
  return _internal_execute_request();
}
inline ::anduril::taskmanager::v1::ExecuteRequest* ListenAsAgentResponse::unsafe_arena_release_execute_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.taskmanager.v1.ListenAsAgentResponse.execute_request)
  if (request_case() == kExecuteRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.execute_request_;
    _impl_.request_.execute_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ListenAsAgentResponse::unsafe_arena_set_allocated_execute_request(::anduril::taskmanager::v1::ExecuteRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_execute_request();
    _impl_.request_.execute_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.ListenAsAgentResponse.execute_request)
}
inline ::anduril::taskmanager::v1::ExecuteRequest* ListenAsAgentResponse::_internal_mutable_execute_request() {
  if (request_case() != kExecuteRequest) {
    clear_request();
    set_has_execute_request();
    _impl_.request_.execute_request_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::ExecuteRequest>(GetArena());
  }
  return _impl_.request_.execute_request_;
}
inline ::anduril::taskmanager::v1::ExecuteRequest* ListenAsAgentResponse::mutable_execute_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::taskmanager::v1::ExecuteRequest* _msg = _internal_mutable_execute_request();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.ListenAsAgentResponse.execute_request)
  return _msg;
}

// .anduril.taskmanager.v1.CancelRequest cancel_request = 2 [json_name = "cancelRequest"];
inline bool ListenAsAgentResponse::has_cancel_request() const {
  return request_case() == kCancelRequest;
}
inline bool ListenAsAgentResponse::_internal_has_cancel_request() const {
  return request_case() == kCancelRequest;
}
inline void ListenAsAgentResponse::set_has_cancel_request() {
  _impl_._oneof_case_[0] = kCancelRequest;
}
inline ::anduril::taskmanager::v1::CancelRequest* ListenAsAgentResponse::release_cancel_request() {
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.ListenAsAgentResponse.cancel_request)
  if (request_case() == kCancelRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.cancel_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::taskmanager::v1::CancelRequest& ListenAsAgentResponse::_internal_cancel_request() const {
  return request_case() == kCancelRequest ? *_impl_.request_.cancel_request_ : reinterpret_cast<::anduril::taskmanager::v1::CancelRequest&>(::anduril::taskmanager::v1::_CancelRequest_default_instance_);
}
inline const ::anduril::taskmanager::v1::CancelRequest& ListenAsAgentResponse::cancel_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.ListenAsAgentResponse.cancel_request)
  return _internal_cancel_request();
}
inline ::anduril::taskmanager::v1::CancelRequest* ListenAsAgentResponse::unsafe_arena_release_cancel_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.taskmanager.v1.ListenAsAgentResponse.cancel_request)
  if (request_case() == kCancelRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.cancel_request_;
    _impl_.request_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ListenAsAgentResponse::unsafe_arena_set_allocated_cancel_request(::anduril::taskmanager::v1::CancelRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_cancel_request();
    _impl_.request_.cancel_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.ListenAsAgentResponse.cancel_request)
}
inline ::anduril::taskmanager::v1::CancelRequest* ListenAsAgentResponse::_internal_mutable_cancel_request() {
  if (request_case() != kCancelRequest) {
    clear_request();
    set_has_cancel_request();
    _impl_.request_.cancel_request_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::CancelRequest>(GetArena());
  }
  return _impl_.request_.cancel_request_;
}
inline ::anduril::taskmanager::v1::CancelRequest* ListenAsAgentResponse::mutable_cancel_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::taskmanager::v1::CancelRequest* _msg = _internal_mutable_cancel_request();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.ListenAsAgentResponse.cancel_request)
  return _msg;
}

// .anduril.taskmanager.v1.CompleteRequest complete_request = 3 [json_name = "completeRequest"];
inline bool ListenAsAgentResponse::has_complete_request() const {
  return request_case() == kCompleteRequest;
}
inline bool ListenAsAgentResponse::_internal_has_complete_request() const {
  return request_case() == kCompleteRequest;
}
inline void ListenAsAgentResponse::set_has_complete_request() {
  _impl_._oneof_case_[0] = kCompleteRequest;
}
inline ::anduril::taskmanager::v1::CompleteRequest* ListenAsAgentResponse::release_complete_request() {
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.ListenAsAgentResponse.complete_request)
  if (request_case() == kCompleteRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.complete_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.complete_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::taskmanager::v1::CompleteRequest& ListenAsAgentResponse::_internal_complete_request() const {
  return request_case() == kCompleteRequest ? *_impl_.request_.complete_request_ : reinterpret_cast<::anduril::taskmanager::v1::CompleteRequest&>(::anduril::taskmanager::v1::_CompleteRequest_default_instance_);
}
inline const ::anduril::taskmanager::v1::CompleteRequest& ListenAsAgentResponse::complete_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.ListenAsAgentResponse.complete_request)
  return _internal_complete_request();
}
inline ::anduril::taskmanager::v1::CompleteRequest* ListenAsAgentResponse::unsafe_arena_release_complete_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.taskmanager.v1.ListenAsAgentResponse.complete_request)
  if (request_case() == kCompleteRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.complete_request_;
    _impl_.request_.complete_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ListenAsAgentResponse::unsafe_arena_set_allocated_complete_request(::anduril::taskmanager::v1::CompleteRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_complete_request();
    _impl_.request_.complete_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.ListenAsAgentResponse.complete_request)
}
inline ::anduril::taskmanager::v1::CompleteRequest* ListenAsAgentResponse::_internal_mutable_complete_request() {
  if (request_case() != kCompleteRequest) {
    clear_request();
    set_has_complete_request();
    _impl_.request_.complete_request_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::CompleteRequest>(GetArena());
  }
  return _impl_.request_.complete_request_;
}
inline ::anduril::taskmanager::v1::CompleteRequest* ListenAsAgentResponse::mutable_complete_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::taskmanager::v1::CompleteRequest* _msg = _internal_mutable_complete_request();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.ListenAsAgentResponse.complete_request)
  return _msg;
}

inline bool ListenAsAgentResponse::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void ListenAsAgentResponse::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline ListenAsAgentResponse::RequestCase ListenAsAgentResponse::request_case() const {
  return ListenAsAgentResponse::RequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RateLimit

// uint32 update_per_task_limit_ms = 1 [json_name = "updatePerTaskLimitMs"];
inline void RateLimit::clear_update_per_task_limit_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_per_task_limit_ms_ = 0u;
}
inline ::uint32_t RateLimit::update_per_task_limit_ms() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.RateLimit.update_per_task_limit_ms)
  return _internal_update_per_task_limit_ms();
}
inline void RateLimit::set_update_per_task_limit_ms(::uint32_t value) {
  _internal_set_update_per_task_limit_ms(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.RateLimit.update_per_task_limit_ms)
}
inline ::uint32_t RateLimit::_internal_update_per_task_limit_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.update_per_task_limit_ms_;
}
inline void RateLimit::_internal_set_update_per_task_limit_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_per_task_limit_ms_ = value;
}

// -------------------------------------------------------------------

// Heartbeat

// .google.protobuf.Timestamp timestamp = 1 [json_name = "timestamp"];
inline bool Heartbeat::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Heartbeat::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Heartbeat::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Heartbeat.timestamp)
  return _internal_timestamp();
}
inline void Heartbeat::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Heartbeat.timestamp)
}
inline ::google::protobuf::Timestamp* Heartbeat::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Heartbeat::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Heartbeat.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Heartbeat::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* Heartbeat::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Heartbeat.timestamp)
  return _msg;
}
inline void Heartbeat::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Heartbeat.timestamp)
}

// -------------------------------------------------------------------

// EntityIds

// repeated string entity_ids = 1 [json_name = "entityIds"];
inline int EntityIds::_internal_entity_ids_size() const {
  return _internal_entity_ids().size();
}
inline int EntityIds::entity_ids_size() const {
  return _internal_entity_ids_size();
}
inline void EntityIds::clear_entity_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_ids_.Clear();
}
inline std::string* EntityIds::add_entity_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_entity_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:anduril.taskmanager.v1.EntityIds.entity_ids)
  return _s;
}
inline const std::string& EntityIds::entity_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.EntityIds.entity_ids)
  return _internal_entity_ids().Get(index);
}
inline std::string* EntityIds::mutable_entity_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.EntityIds.entity_ids)
  return _internal_mutable_entity_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void EntityIds::set_entity_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_entity_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.EntityIds.entity_ids)
}
template <typename Arg_, typename... Args_>
inline void EntityIds::add_entity_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_entity_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:anduril.taskmanager.v1.EntityIds.entity_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
EntityIds::entity_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.taskmanager.v1.EntityIds.entity_ids)
  return _internal_entity_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
EntityIds::mutable_entity_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.taskmanager.v1.EntityIds.entity_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entity_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
EntityIds::_internal_entity_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
EntityIds::_internal_mutable_entity_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entity_ids_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace taskmanager
}  // namespace anduril


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::anduril::taskmanager::v1::QueryTasksRequest_FilterType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::taskmanager::v1::QueryTasksRequest_FilterType>() {
  return ::anduril::taskmanager::v1::QueryTasksRequest_FilterType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto_2epb_2eh
