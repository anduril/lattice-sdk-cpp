// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/taskmanager/v1/task_manager_api.pub.proto
// Protobuf C++ Version: 5.27.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "anduril/taskmanager/v1/task.pub.pb.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
namespace anduril {
namespace taskmanager {
namespace v1 {
class CreateTaskRequest;
struct CreateTaskRequestDefaultTypeInternal;
extern CreateTaskRequestDefaultTypeInternal _CreateTaskRequest_default_instance_;
class CreateTaskResponse;
struct CreateTaskResponseDefaultTypeInternal;
extern CreateTaskResponseDefaultTypeInternal _CreateTaskResponse_default_instance_;
class GetTaskRequest;
struct GetTaskRequestDefaultTypeInternal;
extern GetTaskRequestDefaultTypeInternal _GetTaskRequest_default_instance_;
class GetTaskResponse;
struct GetTaskResponseDefaultTypeInternal;
extern GetTaskResponseDefaultTypeInternal _GetTaskResponse_default_instance_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class RateLimit;
struct RateLimitDefaultTypeInternal;
extern RateLimitDefaultTypeInternal _RateLimit_default_instance_;
class StreamTasksRequest;
struct StreamTasksRequestDefaultTypeInternal;
extern StreamTasksRequestDefaultTypeInternal _StreamTasksRequest_default_instance_;
class StreamTasksResponse;
struct StreamTasksResponseDefaultTypeInternal;
extern StreamTasksResponseDefaultTypeInternal _StreamTasksResponse_default_instance_;
class UpdateStatusRequest;
struct UpdateStatusRequestDefaultTypeInternal;
extern UpdateStatusRequestDefaultTypeInternal _UpdateStatusRequest_default_instance_;
class UpdateStatusResponse;
struct UpdateStatusResponseDefaultTypeInternal;
extern UpdateStatusResponseDefaultTypeInternal _UpdateStatusResponse_default_instance_;
class UpdateTaskRequest;
struct UpdateTaskRequestDefaultTypeInternal;
extern UpdateTaskRequestDefaultTypeInternal _UpdateTaskRequest_default_instance_;
class UpdateTaskResponse;
struct UpdateTaskResponseDefaultTypeInternal;
extern UpdateTaskResponseDefaultTypeInternal _UpdateTaskResponse_default_instance_;
}  // namespace v1
}  // namespace taskmanager
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace taskmanager {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class RateLimit final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.RateLimit) */ {
 public:
  inline RateLimit() : RateLimit(nullptr) {}
  ~RateLimit() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RateLimit(
      ::google::protobuf::internal::ConstantInitialized);

  inline RateLimit(const RateLimit& from) : RateLimit(nullptr, from) {}
  inline RateLimit(RateLimit&& from) noexcept
      : RateLimit(nullptr, std::move(from)) {}
  inline RateLimit& operator=(const RateLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline RateLimit& operator=(RateLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RateLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const RateLimit* internal_default_instance() {
    return reinterpret_cast<const RateLimit*>(
        &_RateLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(RateLimit& a, RateLimit& b) { a.Swap(&b); }
  inline void Swap(RateLimit* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RateLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RateLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RateLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RateLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RateLimit& from) { RateLimit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RateLimit* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.RateLimit"; }

 protected:
  explicit RateLimit(::google::protobuf::Arena* arena);
  RateLimit(::google::protobuf::Arena* arena, const RateLimit& from);
  RateLimit(::google::protobuf::Arena* arena, RateLimit&& from) noexcept
      : RateLimit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUpdatePerTaskLimitMsFieldNumber = 1,
  };
  // uint32 update_per_task_limit_ms = 1 [json_name = "updatePerTaskLimitMs"];
  void clear_update_per_task_limit_ms() ;
  ::uint32_t update_per_task_limit_ms() const;
  void set_update_per_task_limit_ms(::uint32_t value);

  private:
  ::uint32_t _internal_update_per_task_limit_ms() const;
  void _internal_set_update_per_task_limit_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.RateLimit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RateLimit_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RateLimit& from_msg);
    ::uint32_t update_per_task_limit_ms_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class GetTaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.GetTaskRequest) */ {
 public:
  inline GetTaskRequest() : GetTaskRequest(nullptr) {}
  ~GetTaskRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTaskRequest(const GetTaskRequest& from) : GetTaskRequest(nullptr, from) {}
  inline GetTaskRequest(GetTaskRequest&& from) noexcept
      : GetTaskRequest(nullptr, std::move(from)) {}
  inline GetTaskRequest& operator=(const GetTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTaskRequest& operator=(GetTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTaskRequest* internal_default_instance() {
    return reinterpret_cast<const GetTaskRequest*>(
        &_GetTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(GetTaskRequest& a, GetTaskRequest& b) { a.Swap(&b); }
  inline void Swap(GetTaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTaskRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetTaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTaskRequest& from) { GetTaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.GetTaskRequest"; }

 protected:
  explicit GetTaskRequest(::google::protobuf::Arena* arena);
  GetTaskRequest(::google::protobuf::Arena* arena, const GetTaskRequest& from);
  GetTaskRequest(::google::protobuf::Arena* arena, GetTaskRequest&& from) noexcept
      : GetTaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskIdFieldNumber = 1,
    kDefinitionVersionFieldNumber = 2,
    kTaskViewFieldNumber = 3,
  };
  // string task_id = 1 [json_name = "taskId"];
  void clear_task_id() ;
  const std::string& task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* value);

  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(
      const std::string& value);
  std::string* _internal_mutable_task_id();

  public:
  // uint32 definition_version = 2 [json_name = "definitionVersion"];
  void clear_definition_version() ;
  ::uint32_t definition_version() const;
  void set_definition_version(::uint32_t value);

  private:
  ::uint32_t _internal_definition_version() const;
  void _internal_set_definition_version(::uint32_t value);

  public:
  // .anduril.taskmanager.v1.TaskView task_view = 3 [json_name = "taskView"];
  void clear_task_view() ;
  ::anduril::taskmanager::v1::TaskView task_view() const;
  void set_task_view(::anduril::taskmanager::v1::TaskView value);

  private:
  ::anduril::taskmanager::v1::TaskView _internal_task_view() const;
  void _internal_set_task_view(::anduril::taskmanager::v1::TaskView value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.GetTaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      53, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetTaskRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTaskRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    ::uint32_t definition_version_;
    int task_view_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class StreamTasksRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.StreamTasksRequest) */ {
 public:
  inline StreamTasksRequest() : StreamTasksRequest(nullptr) {}
  ~StreamTasksRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StreamTasksRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline StreamTasksRequest(const StreamTasksRequest& from) : StreamTasksRequest(nullptr, from) {}
  inline StreamTasksRequest(StreamTasksRequest&& from) noexcept
      : StreamTasksRequest(nullptr, std::move(from)) {}
  inline StreamTasksRequest& operator=(const StreamTasksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamTasksRequest& operator=(StreamTasksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamTasksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamTasksRequest* internal_default_instance() {
    return reinterpret_cast<const StreamTasksRequest*>(
        &_StreamTasksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(StreamTasksRequest& a, StreamTasksRequest& b) { a.Swap(&b); }
  inline void Swap(StreamTasksRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamTasksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamTasksRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StreamTasksRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamTasksRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StreamTasksRequest& from) { StreamTasksRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamTasksRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.StreamTasksRequest"; }

 protected:
  explicit StreamTasksRequest(::google::protobuf::Arena* arena);
  StreamTasksRequest(::google::protobuf::Arena* arena, const StreamTasksRequest& from);
  StreamTasksRequest(::google::protobuf::Arena* arena, StreamTasksRequest&& from) noexcept
      : StreamTasksRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kViewsFieldNumber = 2,
    kRateLimitFieldNumber = 1,
    kHeartbeatPeriodMillisFieldNumber = 3,
  };
  // repeated .anduril.taskmanager.v1.TaskView views = 2 [json_name = "views"];
  int views_size() const;
  private:
  int _internal_views_size() const;

  public:
  void clear_views() ;
  public:
  ::anduril::taskmanager::v1::TaskView views(int index) const;
  void set_views(int index, ::anduril::taskmanager::v1::TaskView value);
  void add_views(::anduril::taskmanager::v1::TaskView value);
  const ::google::protobuf::RepeatedField<int>& views() const;
  ::google::protobuf::RepeatedField<int>* mutable_views();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_views() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_views();

  public:
  // .anduril.taskmanager.v1.RateLimit rate_limit = 1 [json_name = "rateLimit"];
  bool has_rate_limit() const;
  void clear_rate_limit() ;
  const ::anduril::taskmanager::v1::RateLimit& rate_limit() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::RateLimit* release_rate_limit();
  ::anduril::taskmanager::v1::RateLimit* mutable_rate_limit();
  void set_allocated_rate_limit(::anduril::taskmanager::v1::RateLimit* value);
  void unsafe_arena_set_allocated_rate_limit(::anduril::taskmanager::v1::RateLimit* value);
  ::anduril::taskmanager::v1::RateLimit* unsafe_arena_release_rate_limit();

  private:
  const ::anduril::taskmanager::v1::RateLimit& _internal_rate_limit() const;
  ::anduril::taskmanager::v1::RateLimit* _internal_mutable_rate_limit();

  public:
  // uint32 heartbeat_period_millis = 3 [json_name = "heartbeatPeriodMillis"];
  void clear_heartbeat_period_millis() ;
  ::uint32_t heartbeat_period_millis() const;
  void set_heartbeat_period_millis(::uint32_t value);

  private:
  ::uint32_t _internal_heartbeat_period_millis() const;
  void _internal_set_heartbeat_period_millis(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.StreamTasksRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StreamTasksRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StreamTasksRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> views_;
    mutable ::google::protobuf::internal::CachedSize _views_cached_byte_size_;
    ::anduril::taskmanager::v1::RateLimit* rate_limit_;
    ::uint32_t heartbeat_period_millis_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Heartbeat(
      ::google::protobuf::internal::ConstantInitialized);

  inline Heartbeat(const Heartbeat& from) : Heartbeat(nullptr, from) {}
  inline Heartbeat(Heartbeat&& from) noexcept
      : Heartbeat(nullptr, std::move(from)) {}
  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
        &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Heartbeat& a, Heartbeat& b) { a.Swap(&b); }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Heartbeat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Heartbeat& from) { Heartbeat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Heartbeat* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.Heartbeat"; }

 protected:
  explicit Heartbeat(::google::protobuf::Arena* arena);
  Heartbeat(::google::protobuf::Arena* arena, const Heartbeat& from);
  Heartbeat(::google::protobuf::Arena* arena, Heartbeat&& from) noexcept
      : Heartbeat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 1,
  };
  // .google.protobuf.Timestamp timestamp = 1 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.Heartbeat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Heartbeat_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Heartbeat& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class UpdateStatusRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.UpdateStatusRequest) */ {
 public:
  inline UpdateStatusRequest() : UpdateStatusRequest(nullptr) {}
  ~UpdateStatusRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateStatusRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateStatusRequest(const UpdateStatusRequest& from) : UpdateStatusRequest(nullptr, from) {}
  inline UpdateStatusRequest(UpdateStatusRequest&& from) noexcept
      : UpdateStatusRequest(nullptr, std::move(from)) {}
  inline UpdateStatusRequest& operator=(const UpdateStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStatusRequest& operator=(UpdateStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStatusRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateStatusRequest*>(
        &_UpdateStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(UpdateStatusRequest& a, UpdateStatusRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateStatusRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStatusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UpdateStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateStatusRequest& from) { UpdateStatusRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateStatusRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.UpdateStatusRequest"; }

 protected:
  explicit UpdateStatusRequest(::google::protobuf::Arena* arena);
  UpdateStatusRequest(::google::protobuf::Arena* arena, const UpdateStatusRequest& from);
  UpdateStatusRequest(::google::protobuf::Arena* arena, UpdateStatusRequest&& from) noexcept
      : UpdateStatusRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusUpdateFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.StatusUpdate status_update = 1 [json_name = "statusUpdate"];
  bool has_status_update() const;
  void clear_status_update() ;
  const ::anduril::taskmanager::v1::StatusUpdate& status_update() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::StatusUpdate* release_status_update();
  ::anduril::taskmanager::v1::StatusUpdate* mutable_status_update();
  void set_allocated_status_update(::anduril::taskmanager::v1::StatusUpdate* value);
  void unsafe_arena_set_allocated_status_update(::anduril::taskmanager::v1::StatusUpdate* value);
  ::anduril::taskmanager::v1::StatusUpdate* unsafe_arena_release_status_update();

  private:
  const ::anduril::taskmanager::v1::StatusUpdate& _internal_status_update() const;
  ::anduril::taskmanager::v1::StatusUpdate* _internal_mutable_status_update();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.UpdateStatusRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UpdateStatusRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateStatusRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::StatusUpdate* status_update_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class CreateTaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.CreateTaskRequest) */ {
 public:
  inline CreateTaskRequest() : CreateTaskRequest(nullptr) {}
  ~CreateTaskRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateTaskRequest(const CreateTaskRequest& from) : CreateTaskRequest(nullptr, from) {}
  inline CreateTaskRequest(CreateTaskRequest&& from) noexcept
      : CreateTaskRequest(nullptr, std::move(from)) {}
  inline CreateTaskRequest& operator=(const CreateTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTaskRequest& operator=(CreateTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTaskRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTaskRequest*>(
        &_CreateTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CreateTaskRequest& a, CreateTaskRequest& b) { a.Swap(&b); }
  inline void Swap(CreateTaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTaskRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CreateTaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateTaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateTaskRequest& from) { CreateTaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateTaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.CreateTaskRequest"; }

 protected:
  explicit CreateTaskRequest(::google::protobuf::Arena* arena);
  CreateTaskRequest(::google::protobuf::Arena* arena, const CreateTaskRequest& from);
  CreateTaskRequest(::google::protobuf::Arena* arena, CreateTaskRequest&& from) noexcept
      : CreateTaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInitialEntitiesFieldNumber = 9,
    kDisplayNameFieldNumber = 1,
    kDescriptionFieldNumber = 6,
    kTaskIdFieldNumber = 8,
    kSpecificationFieldNumber = 2,
    kAuthorFieldNumber = 3,
    kRelationsFieldNumber = 5,
    kIsExecutedElsewhereFieldNumber = 7,
  };
  // repeated .anduril.taskmanager.v1.TaskEntity initial_entities = 9 [json_name = "initialEntities"];
  int initial_entities_size() const;
  private:
  int _internal_initial_entities_size() const;

  public:
  void clear_initial_entities() ;
  ::anduril::taskmanager::v1::TaskEntity* mutable_initial_entities(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>* mutable_initial_entities();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>& _internal_initial_entities() const;
  ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>* _internal_mutable_initial_entities();
  public:
  const ::anduril::taskmanager::v1::TaskEntity& initial_entities(int index) const;
  ::anduril::taskmanager::v1::TaskEntity* add_initial_entities();
  const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>& initial_entities() const;
  // string display_name = 1 [json_name = "displayName"];
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // string description = 6 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string task_id = 8 [json_name = "taskId"];
  void clear_task_id() ;
  const std::string& task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* value);

  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(
      const std::string& value);
  std::string* _internal_mutable_task_id();

  public:
  // .google.protobuf.Any specification = 2 [json_name = "specification"];
  bool has_specification() const;
  void clear_specification() ;
  const ::google::protobuf::Any& specification() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_specification();
  ::google::protobuf::Any* mutable_specification();
  void set_allocated_specification(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_specification(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_specification();

  private:
  const ::google::protobuf::Any& _internal_specification() const;
  ::google::protobuf::Any* _internal_mutable_specification();

  public:
  // .anduril.taskmanager.v1.Principal author = 3 [json_name = "author"];
  bool has_author() const;
  void clear_author() ;
  const ::anduril::taskmanager::v1::Principal& author() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Principal* release_author();
  ::anduril::taskmanager::v1::Principal* mutable_author();
  void set_allocated_author(::anduril::taskmanager::v1::Principal* value);
  void unsafe_arena_set_allocated_author(::anduril::taskmanager::v1::Principal* value);
  ::anduril::taskmanager::v1::Principal* unsafe_arena_release_author();

  private:
  const ::anduril::taskmanager::v1::Principal& _internal_author() const;
  ::anduril::taskmanager::v1::Principal* _internal_mutable_author();

  public:
  // .anduril.taskmanager.v1.Relations relations = 5 [json_name = "relations"];
  bool has_relations() const;
  void clear_relations() ;
  const ::anduril::taskmanager::v1::Relations& relations() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Relations* release_relations();
  ::anduril::taskmanager::v1::Relations* mutable_relations();
  void set_allocated_relations(::anduril::taskmanager::v1::Relations* value);
  void unsafe_arena_set_allocated_relations(::anduril::taskmanager::v1::Relations* value);
  ::anduril::taskmanager::v1::Relations* unsafe_arena_release_relations();

  private:
  const ::anduril::taskmanager::v1::Relations& _internal_relations() const;
  ::anduril::taskmanager::v1::Relations* _internal_mutable_relations();

  public:
  // bool is_executed_elsewhere = 7 [json_name = "isExecutedElsewhere"];
  void clear_is_executed_elsewhere() ;
  bool is_executed_elsewhere() const;
  void set_is_executed_elsewhere(bool value);

  private:
  bool _internal_is_executed_elsewhere() const;
  void _internal_set_is_executed_elsewhere(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.CreateTaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 8, 4,
      87, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CreateTaskRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateTaskRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::anduril::taskmanager::v1::TaskEntity > initial_entities_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    ::google::protobuf::Any* specification_;
    ::anduril::taskmanager::v1::Principal* author_;
    ::anduril::taskmanager::v1::Relations* relations_;
    bool is_executed_elsewhere_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class UpdateTaskResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.UpdateTaskResponse) */ {
 public:
  inline UpdateTaskResponse() : UpdateTaskResponse(nullptr) {}
  ~UpdateTaskResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateTaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateTaskResponse(const UpdateTaskResponse& from) : UpdateTaskResponse(nullptr, from) {}
  inline UpdateTaskResponse(UpdateTaskResponse&& from) noexcept
      : UpdateTaskResponse(nullptr, std::move(from)) {}
  inline UpdateTaskResponse& operator=(const UpdateTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTaskResponse& operator=(UpdateTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTaskResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateTaskResponse*>(
        &_UpdateTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(UpdateTaskResponse& a, UpdateTaskResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateTaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTaskResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UpdateTaskResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateTaskResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateTaskResponse& from) { UpdateTaskResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateTaskResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.UpdateTaskResponse"; }

 protected:
  explicit UpdateTaskResponse(::google::protobuf::Arena* arena);
  UpdateTaskResponse(::google::protobuf::Arena* arena, const UpdateTaskResponse& from);
  UpdateTaskResponse(::google::protobuf::Arena* arena, UpdateTaskResponse&& from) noexcept
      : UpdateTaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::anduril::taskmanager::v1::Task& task() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Task* release_task();
  ::anduril::taskmanager::v1::Task* mutable_task();
  void set_allocated_task(::anduril::taskmanager::v1::Task* value);
  void unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value);
  ::anduril::taskmanager::v1::Task* unsafe_arena_release_task();

  private:
  const ::anduril::taskmanager::v1::Task& _internal_task() const;
  ::anduril::taskmanager::v1::Task* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.UpdateTaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UpdateTaskResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateTaskResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Task* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class UpdateTaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.UpdateTaskRequest) */ {
 public:
  inline UpdateTaskRequest() : UpdateTaskRequest(nullptr) {}
  ~UpdateTaskRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateTaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateTaskRequest(const UpdateTaskRequest& from) : UpdateTaskRequest(nullptr, from) {}
  inline UpdateTaskRequest(UpdateTaskRequest&& from) noexcept
      : UpdateTaskRequest(nullptr, std::move(from)) {}
  inline UpdateTaskRequest& operator=(const UpdateTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTaskRequest& operator=(UpdateTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTaskRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateTaskRequest*>(
        &_UpdateTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(UpdateTaskRequest& a, UpdateTaskRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateTaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTaskRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UpdateTaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateTaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateTaskRequest& from) { UpdateTaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateTaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.UpdateTaskRequest"; }

 protected:
  explicit UpdateTaskRequest(::google::protobuf::Arena* arena);
  UpdateTaskRequest(::google::protobuf::Arena* arena, const UpdateTaskRequest& from);
  UpdateTaskRequest(::google::protobuf::Arena* arena, UpdateTaskRequest&& from) noexcept
      : UpdateTaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 1,
    kIsExecutedElsewhereFieldNumber = 7,
  };
  // .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::anduril::taskmanager::v1::Task& task() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Task* release_task();
  ::anduril::taskmanager::v1::Task* mutable_task();
  void set_allocated_task(::anduril::taskmanager::v1::Task* value);
  void unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value);
  ::anduril::taskmanager::v1::Task* unsafe_arena_release_task();

  private:
  const ::anduril::taskmanager::v1::Task& _internal_task() const;
  ::anduril::taskmanager::v1::Task* _internal_mutable_task();

  public:
  // bool is_executed_elsewhere = 7 [json_name = "isExecutedElsewhere"];
  void clear_is_executed_elsewhere() ;
  bool is_executed_elsewhere() const;
  void set_is_executed_elsewhere(bool value);

  private:
  bool _internal_is_executed_elsewhere() const;
  void _internal_set_is_executed_elsewhere(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.UpdateTaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UpdateTaskRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateTaskRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Task* task_;
    bool is_executed_elsewhere_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class UpdateStatusResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.UpdateStatusResponse) */ {
 public:
  inline UpdateStatusResponse() : UpdateStatusResponse(nullptr) {}
  ~UpdateStatusResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateStatusResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateStatusResponse(const UpdateStatusResponse& from) : UpdateStatusResponse(nullptr, from) {}
  inline UpdateStatusResponse(UpdateStatusResponse&& from) noexcept
      : UpdateStatusResponse(nullptr, std::move(from)) {}
  inline UpdateStatusResponse& operator=(const UpdateStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStatusResponse& operator=(UpdateStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStatusResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateStatusResponse*>(
        &_UpdateStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(UpdateStatusResponse& a, UpdateStatusResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateStatusResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UpdateStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateStatusResponse& from) { UpdateStatusResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateStatusResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.UpdateStatusResponse"; }

 protected:
  explicit UpdateStatusResponse(::google::protobuf::Arena* arena);
  UpdateStatusResponse(::google::protobuf::Arena* arena, const UpdateStatusResponse& from);
  UpdateStatusResponse(::google::protobuf::Arena* arena, UpdateStatusResponse&& from) noexcept
      : UpdateStatusResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::anduril::taskmanager::v1::Task& task() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Task* release_task();
  ::anduril::taskmanager::v1::Task* mutable_task();
  void set_allocated_task(::anduril::taskmanager::v1::Task* value);
  void unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value);
  ::anduril::taskmanager::v1::Task* unsafe_arena_release_task();

  private:
  const ::anduril::taskmanager::v1::Task& _internal_task() const;
  ::anduril::taskmanager::v1::Task* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.UpdateStatusResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UpdateStatusResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateStatusResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Task* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class GetTaskResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.GetTaskResponse) */ {
 public:
  inline GetTaskResponse() : GetTaskResponse(nullptr) {}
  ~GetTaskResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTaskResponse(const GetTaskResponse& from) : GetTaskResponse(nullptr, from) {}
  inline GetTaskResponse(GetTaskResponse&& from) noexcept
      : GetTaskResponse(nullptr, std::move(from)) {}
  inline GetTaskResponse& operator=(const GetTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTaskResponse& operator=(GetTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTaskResponse* internal_default_instance() {
    return reinterpret_cast<const GetTaskResponse*>(
        &_GetTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(GetTaskResponse& a, GetTaskResponse& b) { a.Swap(&b); }
  inline void Swap(GetTaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTaskResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetTaskResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTaskResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTaskResponse& from) { GetTaskResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTaskResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.GetTaskResponse"; }

 protected:
  explicit GetTaskResponse(::google::protobuf::Arena* arena);
  GetTaskResponse(::google::protobuf::Arena* arena, const GetTaskResponse& from);
  GetTaskResponse(::google::protobuf::Arena* arena, GetTaskResponse&& from) noexcept
      : GetTaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::anduril::taskmanager::v1::Task& task() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Task* release_task();
  ::anduril::taskmanager::v1::Task* mutable_task();
  void set_allocated_task(::anduril::taskmanager::v1::Task* value);
  void unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value);
  ::anduril::taskmanager::v1::Task* unsafe_arena_release_task();

  private:
  const ::anduril::taskmanager::v1::Task& _internal_task() const;
  ::anduril::taskmanager::v1::Task* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.GetTaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetTaskResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTaskResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Task* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class CreateTaskResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.CreateTaskResponse) */ {
 public:
  inline CreateTaskResponse() : CreateTaskResponse(nullptr) {}
  ~CreateTaskResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateTaskResponse(const CreateTaskResponse& from) : CreateTaskResponse(nullptr, from) {}
  inline CreateTaskResponse(CreateTaskResponse&& from) noexcept
      : CreateTaskResponse(nullptr, std::move(from)) {}
  inline CreateTaskResponse& operator=(const CreateTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTaskResponse& operator=(CreateTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTaskResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTaskResponse*>(
        &_CreateTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CreateTaskResponse& a, CreateTaskResponse& b) { a.Swap(&b); }
  inline void Swap(CreateTaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTaskResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CreateTaskResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateTaskResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateTaskResponse& from) { CreateTaskResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateTaskResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.CreateTaskResponse"; }

 protected:
  explicit CreateTaskResponse(::google::protobuf::Arena* arena);
  CreateTaskResponse(::google::protobuf::Arena* arena, const CreateTaskResponse& from);
  CreateTaskResponse(::google::protobuf::Arena* arena, CreateTaskResponse&& from) noexcept
      : CreateTaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 1,
  };
  // .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::anduril::taskmanager::v1::Task& task() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Task* release_task();
  ::anduril::taskmanager::v1::Task* mutable_task();
  void set_allocated_task(::anduril::taskmanager::v1::Task* value);
  void unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value);
  ::anduril::taskmanager::v1::Task* unsafe_arena_release_task();

  private:
  const ::anduril::taskmanager::v1::Task& _internal_task() const;
  ::anduril::taskmanager::v1::Task* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.CreateTaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CreateTaskResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateTaskResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::Task* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};
// -------------------------------------------------------------------

class StreamTasksResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.taskmanager.v1.StreamTasksResponse) */ {
 public:
  inline StreamTasksResponse() : StreamTasksResponse(nullptr) {}
  ~StreamTasksResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StreamTasksResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline StreamTasksResponse(const StreamTasksResponse& from) : StreamTasksResponse(nullptr, from) {}
  inline StreamTasksResponse(StreamTasksResponse&& from) noexcept
      : StreamTasksResponse(nullptr, std::move(from)) {}
  inline StreamTasksResponse& operator=(const StreamTasksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamTasksResponse& operator=(StreamTasksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamTasksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamTasksResponse* internal_default_instance() {
    return reinterpret_cast<const StreamTasksResponse*>(
        &_StreamTasksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(StreamTasksResponse& a, StreamTasksResponse& b) { a.Swap(&b); }
  inline void Swap(StreamTasksResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamTasksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamTasksResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StreamTasksResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamTasksResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StreamTasksResponse& from) { StreamTasksResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamTasksResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.taskmanager.v1.StreamTasksResponse"; }

 protected:
  explicit StreamTasksResponse(::google::protobuf::Arena* arena);
  StreamTasksResponse(::google::protobuf::Arena* arena, const StreamTasksResponse& from);
  StreamTasksResponse(::google::protobuf::Arena* arena, StreamTasksResponse&& from) noexcept
      : StreamTasksResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskEventFieldNumber = 1,
    kHeartbeatFieldNumber = 2,
  };
  // .anduril.taskmanager.v1.TaskEvent task_event = 1 [json_name = "taskEvent"];
  bool has_task_event() const;
  void clear_task_event() ;
  const ::anduril::taskmanager::v1::TaskEvent& task_event() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::TaskEvent* release_task_event();
  ::anduril::taskmanager::v1::TaskEvent* mutable_task_event();
  void set_allocated_task_event(::anduril::taskmanager::v1::TaskEvent* value);
  void unsafe_arena_set_allocated_task_event(::anduril::taskmanager::v1::TaskEvent* value);
  ::anduril::taskmanager::v1::TaskEvent* unsafe_arena_release_task_event();

  private:
  const ::anduril::taskmanager::v1::TaskEvent& _internal_task_event() const;
  ::anduril::taskmanager::v1::TaskEvent* _internal_mutable_task_event();

  public:
  // .anduril.taskmanager.v1.Heartbeat heartbeat = 2 [json_name = "heartbeat"];
  bool has_heartbeat() const;
  void clear_heartbeat() ;
  const ::anduril::taskmanager::v1::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::anduril::taskmanager::v1::Heartbeat* release_heartbeat();
  ::anduril::taskmanager::v1::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::anduril::taskmanager::v1::Heartbeat* value);
  void unsafe_arena_set_allocated_heartbeat(::anduril::taskmanager::v1::Heartbeat* value);
  ::anduril::taskmanager::v1::Heartbeat* unsafe_arena_release_heartbeat();

  private:
  const ::anduril::taskmanager::v1::Heartbeat& _internal_heartbeat() const;
  ::anduril::taskmanager::v1::Heartbeat* _internal_mutable_heartbeat();

  public:
  // @@protoc_insertion_point(class_scope:anduril.taskmanager.v1.StreamTasksResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StreamTasksResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StreamTasksResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::taskmanager::v1::TaskEvent* task_event_;
    ::anduril::taskmanager::v1::Heartbeat* heartbeat_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CreateTaskRequest

// string display_name = 1 [json_name = "displayName"];
inline void CreateTaskRequest::clear_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& CreateTaskRequest::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateTaskRequest::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.CreateTaskRequest.display_name)
}
inline std::string* CreateTaskRequest::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.display_name)
  return _s;
}
inline const std::string& CreateTaskRequest::_internal_display_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.display_name_.Get();
}
inline void CreateTaskRequest::_internal_set_display_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* CreateTaskRequest::_internal_mutable_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* CreateTaskRequest::release_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.display_name)
  return _impl_.display_name_.Release();
}
inline void CreateTaskRequest::set_allocated_display_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.display_name_.IsDefault()) {
          _impl_.display_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.display_name)
}

// .google.protobuf.Any specification = 2 [json_name = "specification"];
inline bool CreateTaskRequest::has_specification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.specification_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& CreateTaskRequest::_internal_specification() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.specification_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& CreateTaskRequest::specification() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.specification)
  return _internal_specification();
}
inline void CreateTaskRequest::unsafe_arena_set_allocated_specification(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.specification_);
  }
  _impl_.specification_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.specification)
}
inline ::google::protobuf::Any* CreateTaskRequest::release_specification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.specification_;
  _impl_.specification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* CreateTaskRequest::unsafe_arena_release_specification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.specification)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.specification_;
  _impl_.specification_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* CreateTaskRequest::_internal_mutable_specification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.specification_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.specification_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.specification_;
}
inline ::google::protobuf::Any* CreateTaskRequest::mutable_specification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Any* _msg = _internal_mutable_specification();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.specification)
  return _msg;
}
inline void CreateTaskRequest::set_allocated_specification(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.specification_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.specification_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.specification)
}

// .anduril.taskmanager.v1.Principal author = 3 [json_name = "author"];
inline bool CreateTaskRequest::has_author() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.author_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Principal& CreateTaskRequest::_internal_author() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Principal* p = _impl_.author_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Principal&>(::anduril::taskmanager::v1::_Principal_default_instance_);
}
inline const ::anduril::taskmanager::v1::Principal& CreateTaskRequest::author() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.author)
  return _internal_author();
}
inline void CreateTaskRequest::unsafe_arena_set_allocated_author(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.author_);
  }
  _impl_.author_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.author)
}
inline ::anduril::taskmanager::v1::Principal* CreateTaskRequest::release_author() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::taskmanager::v1::Principal* released = _impl_.author_;
  _impl_.author_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Principal* CreateTaskRequest::unsafe_arena_release_author() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.author)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::taskmanager::v1::Principal* temp = _impl_.author_;
  _impl_.author_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Principal* CreateTaskRequest::_internal_mutable_author() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.author_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Principal>(GetArena());
    _impl_.author_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(p);
  }
  return _impl_.author_;
}
inline ::anduril::taskmanager::v1::Principal* CreateTaskRequest::mutable_author() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::taskmanager::v1::Principal* _msg = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.author)
  return _msg;
}
inline void CreateTaskRequest::set_allocated_author(::anduril::taskmanager::v1::Principal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.author_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.author_ = reinterpret_cast<::anduril::taskmanager::v1::Principal*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.author)
}

// .anduril.taskmanager.v1.Relations relations = 5 [json_name = "relations"];
inline bool CreateTaskRequest::has_relations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relations_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Relations& CreateTaskRequest::_internal_relations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Relations* p = _impl_.relations_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Relations&>(::anduril::taskmanager::v1::_Relations_default_instance_);
}
inline const ::anduril::taskmanager::v1::Relations& CreateTaskRequest::relations() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.relations)
  return _internal_relations();
}
inline void CreateTaskRequest::unsafe_arena_set_allocated_relations(::anduril::taskmanager::v1::Relations* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relations_);
  }
  _impl_.relations_ = reinterpret_cast<::anduril::taskmanager::v1::Relations*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.relations)
}
inline ::anduril::taskmanager::v1::Relations* CreateTaskRequest::release_relations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::taskmanager::v1::Relations* released = _impl_.relations_;
  _impl_.relations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Relations* CreateTaskRequest::unsafe_arena_release_relations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.relations)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::taskmanager::v1::Relations* temp = _impl_.relations_;
  _impl_.relations_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Relations* CreateTaskRequest::_internal_mutable_relations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.relations_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Relations>(GetArena());
    _impl_.relations_ = reinterpret_cast<::anduril::taskmanager::v1::Relations*>(p);
  }
  return _impl_.relations_;
}
inline ::anduril::taskmanager::v1::Relations* CreateTaskRequest::mutable_relations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::anduril::taskmanager::v1::Relations* _msg = _internal_mutable_relations();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.relations)
  return _msg;
}
inline void CreateTaskRequest::set_allocated_relations(::anduril::taskmanager::v1::Relations* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relations_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.relations_ = reinterpret_cast<::anduril::taskmanager::v1::Relations*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.relations)
}

// string description = 6 [json_name = "description"];
inline void CreateTaskRequest::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CreateTaskRequest::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateTaskRequest::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.CreateTaskRequest.description)
}
inline std::string* CreateTaskRequest::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.description)
  return _s;
}
inline const std::string& CreateTaskRequest::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void CreateTaskRequest::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* CreateTaskRequest::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* CreateTaskRequest::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.description)
  return _impl_.description_.Release();
}
inline void CreateTaskRequest::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.description)
}

// bool is_executed_elsewhere = 7 [json_name = "isExecutedElsewhere"];
inline void CreateTaskRequest::clear_is_executed_elsewhere() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_executed_elsewhere_ = false;
}
inline bool CreateTaskRequest::is_executed_elsewhere() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.is_executed_elsewhere)
  return _internal_is_executed_elsewhere();
}
inline void CreateTaskRequest::set_is_executed_elsewhere(bool value) {
  _internal_set_is_executed_elsewhere(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.CreateTaskRequest.is_executed_elsewhere)
}
inline bool CreateTaskRequest::_internal_is_executed_elsewhere() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_executed_elsewhere_;
}
inline void CreateTaskRequest::_internal_set_is_executed_elsewhere(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_executed_elsewhere_ = value;
}

// string task_id = 8 [json_name = "taskId"];
inline void CreateTaskRequest::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& CreateTaskRequest::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateTaskRequest::set_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.CreateTaskRequest.task_id)
}
inline std::string* CreateTaskRequest::mutable_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.task_id)
  return _s;
}
inline const std::string& CreateTaskRequest::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_.Get();
}
inline void CreateTaskRequest::_internal_set_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(value, GetArena());
}
inline std::string* CreateTaskRequest::_internal_mutable_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_id_.Mutable( GetArena());
}
inline std::string* CreateTaskRequest::release_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskRequest.task_id)
  return _impl_.task_id_.Release();
}
inline void CreateTaskRequest::set_allocated_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.task_id_.IsDefault()) {
          _impl_.task_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskRequest.task_id)
}

// repeated .anduril.taskmanager.v1.TaskEntity initial_entities = 9 [json_name = "initialEntities"];
inline int CreateTaskRequest::_internal_initial_entities_size() const {
  return _internal_initial_entities().size();
}
inline int CreateTaskRequest::initial_entities_size() const {
  return _internal_initial_entities_size();
}
inline ::anduril::taskmanager::v1::TaskEntity* CreateTaskRequest::mutable_initial_entities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskRequest.initial_entities)
  return _internal_mutable_initial_entities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>* CreateTaskRequest::mutable_initial_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.taskmanager.v1.CreateTaskRequest.initial_entities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_initial_entities();
}
inline const ::anduril::taskmanager::v1::TaskEntity& CreateTaskRequest::initial_entities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskRequest.initial_entities)
  return _internal_initial_entities().Get(index);
}
inline ::anduril::taskmanager::v1::TaskEntity* CreateTaskRequest::add_initial_entities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::taskmanager::v1::TaskEntity* _add = _internal_mutable_initial_entities()->Add();
  // @@protoc_insertion_point(field_add:anduril.taskmanager.v1.CreateTaskRequest.initial_entities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>& CreateTaskRequest::initial_entities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.taskmanager.v1.CreateTaskRequest.initial_entities)
  return _internal_initial_entities();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>&
CreateTaskRequest::_internal_initial_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initial_entities_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::taskmanager::v1::TaskEntity>*
CreateTaskRequest::_internal_mutable_initial_entities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.initial_entities_;
}

// -------------------------------------------------------------------

// CreateTaskResponse

// .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
inline bool CreateTaskResponse::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Task& CreateTaskResponse::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Task&>(::anduril::taskmanager::v1::_Task_default_instance_);
}
inline const ::anduril::taskmanager::v1::Task& CreateTaskResponse::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.CreateTaskResponse.task)
  return _internal_task();
}
inline void CreateTaskResponse::unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.CreateTaskResponse.task)
}
inline ::anduril::taskmanager::v1::Task* CreateTaskResponse::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Task* CreateTaskResponse::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.CreateTaskResponse.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Task* CreateTaskResponse::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::anduril::taskmanager::v1::Task* CreateTaskResponse::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.CreateTaskResponse.task)
  return _msg;
}
inline void CreateTaskResponse::set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.CreateTaskResponse.task)
}

// -------------------------------------------------------------------

// GetTaskRequest

// string task_id = 1 [json_name = "taskId"];
inline void GetTaskRequest::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& GetTaskRequest::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.GetTaskRequest.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTaskRequest::set_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.GetTaskRequest.task_id)
}
inline std::string* GetTaskRequest::mutable_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.GetTaskRequest.task_id)
  return _s;
}
inline const std::string& GetTaskRequest::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_.Get();
}
inline void GetTaskRequest::_internal_set_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(value, GetArena());
}
inline std::string* GetTaskRequest::_internal_mutable_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_id_.Mutable( GetArena());
}
inline std::string* GetTaskRequest::release_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.GetTaskRequest.task_id)
  return _impl_.task_id_.Release();
}
inline void GetTaskRequest::set_allocated_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.task_id_.IsDefault()) {
          _impl_.task_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.GetTaskRequest.task_id)
}

// uint32 definition_version = 2 [json_name = "definitionVersion"];
inline void GetTaskRequest::clear_definition_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.definition_version_ = 0u;
}
inline ::uint32_t GetTaskRequest::definition_version() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.GetTaskRequest.definition_version)
  return _internal_definition_version();
}
inline void GetTaskRequest::set_definition_version(::uint32_t value) {
  _internal_set_definition_version(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.GetTaskRequest.definition_version)
}
inline ::uint32_t GetTaskRequest::_internal_definition_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.definition_version_;
}
inline void GetTaskRequest::_internal_set_definition_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.definition_version_ = value;
}

// .anduril.taskmanager.v1.TaskView task_view = 3 [json_name = "taskView"];
inline void GetTaskRequest::clear_task_view() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_view_ = 0;
}
inline ::anduril::taskmanager::v1::TaskView GetTaskRequest::task_view() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.GetTaskRequest.task_view)
  return _internal_task_view();
}
inline void GetTaskRequest::set_task_view(::anduril::taskmanager::v1::TaskView value) {
  _internal_set_task_view(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.GetTaskRequest.task_view)
}
inline ::anduril::taskmanager::v1::TaskView GetTaskRequest::_internal_task_view() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::taskmanager::v1::TaskView>(_impl_.task_view_);
}
inline void GetTaskRequest::_internal_set_task_view(::anduril::taskmanager::v1::TaskView value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_view_ = value;
}

// -------------------------------------------------------------------

// GetTaskResponse

// .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
inline bool GetTaskResponse::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Task& GetTaskResponse::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Task&>(::anduril::taskmanager::v1::_Task_default_instance_);
}
inline const ::anduril::taskmanager::v1::Task& GetTaskResponse::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.GetTaskResponse.task)
  return _internal_task();
}
inline void GetTaskResponse::unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.GetTaskResponse.task)
}
inline ::anduril::taskmanager::v1::Task* GetTaskResponse::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Task* GetTaskResponse::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.GetTaskResponse.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Task* GetTaskResponse::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::anduril::taskmanager::v1::Task* GetTaskResponse::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.GetTaskResponse.task)
  return _msg;
}
inline void GetTaskResponse::set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.GetTaskResponse.task)
}

// -------------------------------------------------------------------

// UpdateTaskRequest

// .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
inline bool UpdateTaskRequest::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Task& UpdateTaskRequest::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Task&>(::anduril::taskmanager::v1::_Task_default_instance_);
}
inline const ::anduril::taskmanager::v1::Task& UpdateTaskRequest::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.UpdateTaskRequest.task)
  return _internal_task();
}
inline void UpdateTaskRequest::unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.UpdateTaskRequest.task)
}
inline ::anduril::taskmanager::v1::Task* UpdateTaskRequest::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Task* UpdateTaskRequest::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.UpdateTaskRequest.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Task* UpdateTaskRequest::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::anduril::taskmanager::v1::Task* UpdateTaskRequest::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.UpdateTaskRequest.task)
  return _msg;
}
inline void UpdateTaskRequest::set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.UpdateTaskRequest.task)
}

// bool is_executed_elsewhere = 7 [json_name = "isExecutedElsewhere"];
inline void UpdateTaskRequest::clear_is_executed_elsewhere() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_executed_elsewhere_ = false;
}
inline bool UpdateTaskRequest::is_executed_elsewhere() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.UpdateTaskRequest.is_executed_elsewhere)
  return _internal_is_executed_elsewhere();
}
inline void UpdateTaskRequest::set_is_executed_elsewhere(bool value) {
  _internal_set_is_executed_elsewhere(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.UpdateTaskRequest.is_executed_elsewhere)
}
inline bool UpdateTaskRequest::_internal_is_executed_elsewhere() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_executed_elsewhere_;
}
inline void UpdateTaskRequest::_internal_set_is_executed_elsewhere(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_executed_elsewhere_ = value;
}

// -------------------------------------------------------------------

// UpdateTaskResponse

// .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
inline bool UpdateTaskResponse::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Task& UpdateTaskResponse::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Task&>(::anduril::taskmanager::v1::_Task_default_instance_);
}
inline const ::anduril::taskmanager::v1::Task& UpdateTaskResponse::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.UpdateTaskResponse.task)
  return _internal_task();
}
inline void UpdateTaskResponse::unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.UpdateTaskResponse.task)
}
inline ::anduril::taskmanager::v1::Task* UpdateTaskResponse::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Task* UpdateTaskResponse::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.UpdateTaskResponse.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Task* UpdateTaskResponse::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::anduril::taskmanager::v1::Task* UpdateTaskResponse::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.UpdateTaskResponse.task)
  return _msg;
}
inline void UpdateTaskResponse::set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.UpdateTaskResponse.task)
}

// -------------------------------------------------------------------

// UpdateStatusRequest

// .anduril.taskmanager.v1.StatusUpdate status_update = 1 [json_name = "statusUpdate"];
inline bool UpdateStatusRequest::has_status_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_update_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::StatusUpdate& UpdateStatusRequest::_internal_status_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::StatusUpdate* p = _impl_.status_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::StatusUpdate&>(::anduril::taskmanager::v1::_StatusUpdate_default_instance_);
}
inline const ::anduril::taskmanager::v1::StatusUpdate& UpdateStatusRequest::status_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.UpdateStatusRequest.status_update)
  return _internal_status_update();
}
inline void UpdateStatusRequest::unsafe_arena_set_allocated_status_update(::anduril::taskmanager::v1::StatusUpdate* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_update_);
  }
  _impl_.status_update_ = reinterpret_cast<::anduril::taskmanager::v1::StatusUpdate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.UpdateStatusRequest.status_update)
}
inline ::anduril::taskmanager::v1::StatusUpdate* UpdateStatusRequest::release_status_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::StatusUpdate* released = _impl_.status_update_;
  _impl_.status_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::StatusUpdate* UpdateStatusRequest::unsafe_arena_release_status_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.UpdateStatusRequest.status_update)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::StatusUpdate* temp = _impl_.status_update_;
  _impl_.status_update_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::StatusUpdate* UpdateStatusRequest::_internal_mutable_status_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_update_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::StatusUpdate>(GetArena());
    _impl_.status_update_ = reinterpret_cast<::anduril::taskmanager::v1::StatusUpdate*>(p);
  }
  return _impl_.status_update_;
}
inline ::anduril::taskmanager::v1::StatusUpdate* UpdateStatusRequest::mutable_status_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::StatusUpdate* _msg = _internal_mutable_status_update();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.UpdateStatusRequest.status_update)
  return _msg;
}
inline void UpdateStatusRequest::set_allocated_status_update(::anduril::taskmanager::v1::StatusUpdate* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_update_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_update_ = reinterpret_cast<::anduril::taskmanager::v1::StatusUpdate*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.UpdateStatusRequest.status_update)
}

// -------------------------------------------------------------------

// UpdateStatusResponse

// .anduril.taskmanager.v1.Task task = 1 [json_name = "task"];
inline bool UpdateStatusResponse::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::Task& UpdateStatusResponse::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Task&>(::anduril::taskmanager::v1::_Task_default_instance_);
}
inline const ::anduril::taskmanager::v1::Task& UpdateStatusResponse::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.UpdateStatusResponse.task)
  return _internal_task();
}
inline void UpdateStatusResponse::unsafe_arena_set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.UpdateStatusResponse.task)
}
inline ::anduril::taskmanager::v1::Task* UpdateStatusResponse::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Task* UpdateStatusResponse::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.UpdateStatusResponse.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Task* UpdateStatusResponse::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::anduril::taskmanager::v1::Task* UpdateStatusResponse::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.UpdateStatusResponse.task)
  return _msg;
}
inline void UpdateStatusResponse::set_allocated_task(::anduril::taskmanager::v1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::anduril::taskmanager::v1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.UpdateStatusResponse.task)
}

// -------------------------------------------------------------------

// StreamTasksRequest

// .anduril.taskmanager.v1.RateLimit rate_limit = 1 [json_name = "rateLimit"];
inline bool StreamTasksRequest::has_rate_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rate_limit_ != nullptr);
  return value;
}
inline void StreamTasksRequest::clear_rate_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rate_limit_ != nullptr) _impl_.rate_limit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::taskmanager::v1::RateLimit& StreamTasksRequest::_internal_rate_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::RateLimit* p = _impl_.rate_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::RateLimit&>(::anduril::taskmanager::v1::_RateLimit_default_instance_);
}
inline const ::anduril::taskmanager::v1::RateLimit& StreamTasksRequest::rate_limit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.StreamTasksRequest.rate_limit)
  return _internal_rate_limit();
}
inline void StreamTasksRequest::unsafe_arena_set_allocated_rate_limit(::anduril::taskmanager::v1::RateLimit* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rate_limit_);
  }
  _impl_.rate_limit_ = reinterpret_cast<::anduril::taskmanager::v1::RateLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.StreamTasksRequest.rate_limit)
}
inline ::anduril::taskmanager::v1::RateLimit* StreamTasksRequest::release_rate_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::RateLimit* released = _impl_.rate_limit_;
  _impl_.rate_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::RateLimit* StreamTasksRequest::unsafe_arena_release_rate_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.StreamTasksRequest.rate_limit)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::RateLimit* temp = _impl_.rate_limit_;
  _impl_.rate_limit_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::RateLimit* StreamTasksRequest::_internal_mutable_rate_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rate_limit_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::RateLimit>(GetArena());
    _impl_.rate_limit_ = reinterpret_cast<::anduril::taskmanager::v1::RateLimit*>(p);
  }
  return _impl_.rate_limit_;
}
inline ::anduril::taskmanager::v1::RateLimit* StreamTasksRequest::mutable_rate_limit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::RateLimit* _msg = _internal_mutable_rate_limit();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.StreamTasksRequest.rate_limit)
  return _msg;
}
inline void StreamTasksRequest::set_allocated_rate_limit(::anduril::taskmanager::v1::RateLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rate_limit_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rate_limit_ = reinterpret_cast<::anduril::taskmanager::v1::RateLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.StreamTasksRequest.rate_limit)
}

// repeated .anduril.taskmanager.v1.TaskView views = 2 [json_name = "views"];
inline int StreamTasksRequest::_internal_views_size() const {
  return _internal_views().size();
}
inline int StreamTasksRequest::views_size() const {
  return _internal_views_size();
}
inline void StreamTasksRequest::clear_views() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.views_.Clear();
}
inline ::anduril::taskmanager::v1::TaskView StreamTasksRequest::views(int index) const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.StreamTasksRequest.views)
  return static_cast<::anduril::taskmanager::v1::TaskView>(_internal_views().Get(index));
}
inline void StreamTasksRequest::set_views(int index, ::anduril::taskmanager::v1::TaskView value) {
  _internal_mutable_views()->Set(index, value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.StreamTasksRequest.views)
}
inline void StreamTasksRequest::add_views(::anduril::taskmanager::v1::TaskView value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_views()->Add(value);
  // @@protoc_insertion_point(field_add:anduril.taskmanager.v1.StreamTasksRequest.views)
}
inline const ::google::protobuf::RepeatedField<int>& StreamTasksRequest::views() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.taskmanager.v1.StreamTasksRequest.views)
  return _internal_views();
}
inline ::google::protobuf::RepeatedField<int>* StreamTasksRequest::mutable_views()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.taskmanager.v1.StreamTasksRequest.views)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_views();
}
inline const ::google::protobuf::RepeatedField<int>& StreamTasksRequest::_internal_views()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.views_;
}
inline ::google::protobuf::RepeatedField<int>* StreamTasksRequest::_internal_mutable_views() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.views_;
}

// uint32 heartbeat_period_millis = 3 [json_name = "heartbeatPeriodMillis"];
inline void StreamTasksRequest::clear_heartbeat_period_millis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.heartbeat_period_millis_ = 0u;
}
inline ::uint32_t StreamTasksRequest::heartbeat_period_millis() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.StreamTasksRequest.heartbeat_period_millis)
  return _internal_heartbeat_period_millis();
}
inline void StreamTasksRequest::set_heartbeat_period_millis(::uint32_t value) {
  _internal_set_heartbeat_period_millis(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.StreamTasksRequest.heartbeat_period_millis)
}
inline ::uint32_t StreamTasksRequest::_internal_heartbeat_period_millis() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.heartbeat_period_millis_;
}
inline void StreamTasksRequest::_internal_set_heartbeat_period_millis(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.heartbeat_period_millis_ = value;
}

// -------------------------------------------------------------------

// StreamTasksResponse

// .anduril.taskmanager.v1.TaskEvent task_event = 1 [json_name = "taskEvent"];
inline bool StreamTasksResponse::has_task_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_event_ != nullptr);
  return value;
}
inline const ::anduril::taskmanager::v1::TaskEvent& StreamTasksResponse::_internal_task_event() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::TaskEvent* p = _impl_.task_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::TaskEvent&>(::anduril::taskmanager::v1::_TaskEvent_default_instance_);
}
inline const ::anduril::taskmanager::v1::TaskEvent& StreamTasksResponse::task_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.StreamTasksResponse.task_event)
  return _internal_task_event();
}
inline void StreamTasksResponse::unsafe_arena_set_allocated_task_event(::anduril::taskmanager::v1::TaskEvent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_event_);
  }
  _impl_.task_event_ = reinterpret_cast<::anduril::taskmanager::v1::TaskEvent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.StreamTasksResponse.task_event)
}
inline ::anduril::taskmanager::v1::TaskEvent* StreamTasksResponse::release_task_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::TaskEvent* released = _impl_.task_event_;
  _impl_.task_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::TaskEvent* StreamTasksResponse::unsafe_arena_release_task_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.StreamTasksResponse.task_event)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::taskmanager::v1::TaskEvent* temp = _impl_.task_event_;
  _impl_.task_event_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::TaskEvent* StreamTasksResponse::_internal_mutable_task_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_event_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::TaskEvent>(GetArena());
    _impl_.task_event_ = reinterpret_cast<::anduril::taskmanager::v1::TaskEvent*>(p);
  }
  return _impl_.task_event_;
}
inline ::anduril::taskmanager::v1::TaskEvent* StreamTasksResponse::mutable_task_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::taskmanager::v1::TaskEvent* _msg = _internal_mutable_task_event();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.StreamTasksResponse.task_event)
  return _msg;
}
inline void StreamTasksResponse::set_allocated_task_event(::anduril::taskmanager::v1::TaskEvent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_event_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_event_ = reinterpret_cast<::anduril::taskmanager::v1::TaskEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.StreamTasksResponse.task_event)
}

// .anduril.taskmanager.v1.Heartbeat heartbeat = 2 [json_name = "heartbeat"];
inline bool StreamTasksResponse::has_heartbeat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heartbeat_ != nullptr);
  return value;
}
inline void StreamTasksResponse::clear_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.heartbeat_ != nullptr) _impl_.heartbeat_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::taskmanager::v1::Heartbeat& StreamTasksResponse::_internal_heartbeat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::taskmanager::v1::Heartbeat* p = _impl_.heartbeat_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::taskmanager::v1::Heartbeat&>(::anduril::taskmanager::v1::_Heartbeat_default_instance_);
}
inline const ::anduril::taskmanager::v1::Heartbeat& StreamTasksResponse::heartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.StreamTasksResponse.heartbeat)
  return _internal_heartbeat();
}
inline void StreamTasksResponse::unsafe_arena_set_allocated_heartbeat(::anduril::taskmanager::v1::Heartbeat* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heartbeat_);
  }
  _impl_.heartbeat_ = reinterpret_cast<::anduril::taskmanager::v1::Heartbeat*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.StreamTasksResponse.heartbeat)
}
inline ::anduril::taskmanager::v1::Heartbeat* StreamTasksResponse::release_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::taskmanager::v1::Heartbeat* released = _impl_.heartbeat_;
  _impl_.heartbeat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::taskmanager::v1::Heartbeat* StreamTasksResponse::unsafe_arena_release_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.StreamTasksResponse.heartbeat)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::taskmanager::v1::Heartbeat* temp = _impl_.heartbeat_;
  _impl_.heartbeat_ = nullptr;
  return temp;
}
inline ::anduril::taskmanager::v1::Heartbeat* StreamTasksResponse::_internal_mutable_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.heartbeat_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::taskmanager::v1::Heartbeat>(GetArena());
    _impl_.heartbeat_ = reinterpret_cast<::anduril::taskmanager::v1::Heartbeat*>(p);
  }
  return _impl_.heartbeat_;
}
inline ::anduril::taskmanager::v1::Heartbeat* StreamTasksResponse::mutable_heartbeat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::taskmanager::v1::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.StreamTasksResponse.heartbeat)
  return _msg;
}
inline void StreamTasksResponse::set_allocated_heartbeat(::anduril::taskmanager::v1::Heartbeat* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.heartbeat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.heartbeat_ = reinterpret_cast<::anduril::taskmanager::v1::Heartbeat*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.StreamTasksResponse.heartbeat)
}

// -------------------------------------------------------------------

// RateLimit

// uint32 update_per_task_limit_ms = 1 [json_name = "updatePerTaskLimitMs"];
inline void RateLimit::clear_update_per_task_limit_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_per_task_limit_ms_ = 0u;
}
inline ::uint32_t RateLimit::update_per_task_limit_ms() const {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.RateLimit.update_per_task_limit_ms)
  return _internal_update_per_task_limit_ms();
}
inline void RateLimit::set_update_per_task_limit_ms(::uint32_t value) {
  _internal_set_update_per_task_limit_ms(value);
  // @@protoc_insertion_point(field_set:anduril.taskmanager.v1.RateLimit.update_per_task_limit_ms)
}
inline ::uint32_t RateLimit::_internal_update_per_task_limit_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.update_per_task_limit_ms_;
}
inline void RateLimit::_internal_set_update_per_task_limit_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_per_task_limit_ms_ = value;
}

// -------------------------------------------------------------------

// Heartbeat

// .google.protobuf.Timestamp timestamp = 1 [json_name = "timestamp"];
inline bool Heartbeat::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Heartbeat::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Heartbeat::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.taskmanager.v1.Heartbeat.timestamp)
  return _internal_timestamp();
}
inline void Heartbeat::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.taskmanager.v1.Heartbeat.timestamp)
}
inline ::google::protobuf::Timestamp* Heartbeat::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Heartbeat::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.taskmanager.v1.Heartbeat.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Heartbeat::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* Heartbeat::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:anduril.taskmanager.v1.Heartbeat.timestamp)
  return _msg;
}
inline void Heartbeat::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.taskmanager.v1.Heartbeat.timestamp)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace taskmanager
}  // namespace anduril


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2ftaskmanager_2fv1_2ftask_5fmanager_5fapi_2epub_2eproto_2epb_2eh
