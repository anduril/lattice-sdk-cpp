// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: anduril/tasks/v2/shared/strike.pub.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "anduril/tasks/v2/common.pub.pb.h"
#include "anduril/tasks/v2/objective.pub.pb.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/empty.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto;
namespace anduril {
namespace tasks {
namespace v2 {
class PayloadConfiguration;
struct PayloadConfigurationDefaultTypeInternal;
extern PayloadConfigurationDefaultTypeInternal _PayloadConfiguration_default_instance_;
class ReleasePayload;
struct ReleasePayloadDefaultTypeInternal;
extern ReleasePayloadDefaultTypeInternal _ReleasePayload_default_instance_;
class Smack;
struct SmackDefaultTypeInternal;
extern SmackDefaultTypeInternal _Smack_default_instance_;
class Strike;
struct StrikeDefaultTypeInternal;
extern StrikeDefaultTypeInternal _Strike_default_instance_;
class StrikeParameters;
struct StrikeParametersDefaultTypeInternal;
extern StrikeParametersDefaultTypeInternal _StrikeParameters_default_instance_;
class StrikeReleaseConstraint;
struct StrikeReleaseConstraintDefaultTypeInternal;
extern StrikeReleaseConstraintDefaultTypeInternal _StrikeReleaseConstraint_default_instance_;
}  // namespace v2
}  // namespace tasks
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace tasks {
namespace v2 {

// ===================================================================


// -------------------------------------------------------------------

class PayloadConfiguration final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.tasks.v2.PayloadConfiguration) */ {
 public:
  inline PayloadConfiguration() : PayloadConfiguration(nullptr) {}
  ~PayloadConfiguration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PayloadConfiguration(::google::protobuf::internal::ConstantInitialized);

  inline PayloadConfiguration(const PayloadConfiguration& from)
      : PayloadConfiguration(nullptr, from) {}
  PayloadConfiguration(PayloadConfiguration&& from) noexcept
    : PayloadConfiguration() {
    *this = ::std::move(from);
  }

  inline PayloadConfiguration& operator=(const PayloadConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadConfiguration& operator=(PayloadConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PayloadConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadConfiguration* internal_default_instance() {
    return reinterpret_cast<const PayloadConfiguration*>(
               &_PayloadConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PayloadConfiguration& a, PayloadConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadConfiguration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadConfiguration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PayloadConfiguration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PayloadConfiguration& from) {
    PayloadConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PayloadConfiguration* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.tasks.v2.PayloadConfiguration";
  }
  protected:
  explicit PayloadConfiguration(::google::protobuf::Arena* arena);
  PayloadConfiguration(::google::protobuf::Arena* arena, const PayloadConfiguration& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilityIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // string capability_id = 1 [json_name = "capabilityId"];
  void clear_capability_id() ;
  const std::string& capability_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_capability_id(Arg_&& arg, Args_... args);
  std::string* mutable_capability_id();
  PROTOBUF_NODISCARD std::string* release_capability_id();
  void set_allocated_capability_id(std::string* value);

  private:
  const std::string& _internal_capability_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_capability_id(
      const std::string& value);
  std::string* _internal_mutable_capability_id();

  public:
  // uint32 quantity = 2 [json_name = "quantity"];
  void clear_quantity() ;
  ::uint32_t quantity() const;
  void set_quantity(::uint32_t value);

  private:
  ::uint32_t _internal_quantity() const;
  void _internal_set_quantity(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.PayloadConfiguration)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr capability_id_;
    ::uint32_t quantity_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto;
};// -------------------------------------------------------------------

class StrikeParameters final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.tasks.v2.StrikeParameters) */ {
 public:
  inline StrikeParameters() : StrikeParameters(nullptr) {}
  ~StrikeParameters() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StrikeParameters(::google::protobuf::internal::ConstantInitialized);

  inline StrikeParameters(const StrikeParameters& from)
      : StrikeParameters(nullptr, from) {}
  StrikeParameters(StrikeParameters&& from) noexcept
    : StrikeParameters() {
    *this = ::std::move(from);
  }

  inline StrikeParameters& operator=(const StrikeParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrikeParameters& operator=(StrikeParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrikeParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrikeParameters* internal_default_instance() {
    return reinterpret_cast<const StrikeParameters*>(
               &_StrikeParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StrikeParameters& a, StrikeParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(StrikeParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrikeParameters* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrikeParameters* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrikeParameters>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrikeParameters& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StrikeParameters& from) {
    StrikeParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StrikeParameters* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.tasks.v2.StrikeParameters";
  }
  protected:
  explicit StrikeParameters(::google::protobuf::Arena* arena);
  StrikeParameters(::google::protobuf::Arena* arena, const StrikeParameters& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadsToEmployFieldNumber = 1,
    kDesiredImpactTimeFieldNumber = 2,
    kRunInBearingFieldNumber = 3,
    kGlideSlopeAngleFieldNumber = 4,
  };
  // repeated .anduril.tasks.v2.PayloadConfiguration payloads_to_employ = 1 [json_name = "payloadsToEmploy"];
  int payloads_to_employ_size() const;
  private:
  int _internal_payloads_to_employ_size() const;

  public:
  void clear_payloads_to_employ() ;
  ::anduril::tasks::v2::PayloadConfiguration* mutable_payloads_to_employ(int index);
  ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::PayloadConfiguration >*
      mutable_payloads_to_employ();
  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>& _internal_payloads_to_employ() const;
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>* _internal_mutable_payloads_to_employ();
  public:
  const ::anduril::tasks::v2::PayloadConfiguration& payloads_to_employ(int index) const;
  ::anduril::tasks::v2::PayloadConfiguration* add_payloads_to_employ();
  const ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::PayloadConfiguration >&
      payloads_to_employ() const;
  // .google.protobuf.Duration desired_impact_time = 2 [json_name = "desiredImpactTime"];
  bool has_desired_impact_time() const;
  void clear_desired_impact_time() ;
  const ::google::protobuf::Duration& desired_impact_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_desired_impact_time();
  ::google::protobuf::Duration* mutable_desired_impact_time();
  void set_allocated_desired_impact_time(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_desired_impact_time(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_desired_impact_time();

  private:
  const ::google::protobuf::Duration& _internal_desired_impact_time() const;
  ::google::protobuf::Duration* _internal_mutable_desired_impact_time();

  public:
  // double run_in_bearing = 3 [json_name = "runInBearing"];
  void clear_run_in_bearing() ;
  double run_in_bearing() const;
  void set_run_in_bearing(double value);

  private:
  double _internal_run_in_bearing() const;
  void _internal_set_run_in_bearing(double value);

  public:
  // double glide_slope_angle = 4 [json_name = "glideSlopeAngle"];
  void clear_glide_slope_angle() ;
  double glide_slope_angle() const;
  void set_glide_slope_angle(double value);

  private:
  double _internal_glide_slope_angle() const;
  void _internal_set_glide_slope_angle(double value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.StrikeParameters)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::PayloadConfiguration > payloads_to_employ_;
    ::google::protobuf::Duration* desired_impact_time_;
    double run_in_bearing_;
    double glide_slope_angle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto;
};// -------------------------------------------------------------------

class StrikeReleaseConstraint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.tasks.v2.StrikeReleaseConstraint) */ {
 public:
  inline StrikeReleaseConstraint() : StrikeReleaseConstraint(nullptr) {}
  ~StrikeReleaseConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StrikeReleaseConstraint(::google::protobuf::internal::ConstantInitialized);

  inline StrikeReleaseConstraint(const StrikeReleaseConstraint& from)
      : StrikeReleaseConstraint(nullptr, from) {}
  StrikeReleaseConstraint(StrikeReleaseConstraint&& from) noexcept
    : StrikeReleaseConstraint() {
    *this = ::std::move(from);
  }

  inline StrikeReleaseConstraint& operator=(const StrikeReleaseConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrikeReleaseConstraint& operator=(StrikeReleaseConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrikeReleaseConstraint& default_instance() {
    return *internal_default_instance();
  }
  enum StrikeReleaseConstraintCase {
    kReleaseArea = 1,
    STRIKE_RELEASE_CONSTRAINT_NOT_SET = 0,
  };

  static inline const StrikeReleaseConstraint* internal_default_instance() {
    return reinterpret_cast<const StrikeReleaseConstraint*>(
               &_StrikeReleaseConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StrikeReleaseConstraint& a, StrikeReleaseConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(StrikeReleaseConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrikeReleaseConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrikeReleaseConstraint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrikeReleaseConstraint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StrikeReleaseConstraint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StrikeReleaseConstraint& from) {
    StrikeReleaseConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StrikeReleaseConstraint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.tasks.v2.StrikeReleaseConstraint";
  }
  protected:
  explicit StrikeReleaseConstraint(::google::protobuf::Arena* arena);
  StrikeReleaseConstraint(::google::protobuf::Arena* arena, const StrikeReleaseConstraint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReleaseAreaFieldNumber = 1,
  };
  // .anduril.tasks.v2.AreaConstraints release_area = 1 [json_name = "releaseArea"];
  bool has_release_area() const;
  private:
  bool _internal_has_release_area() const;

  public:
  void clear_release_area() ;
  const ::anduril::tasks::v2::AreaConstraints& release_area() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::AreaConstraints* release_release_area();
  ::anduril::tasks::v2::AreaConstraints* mutable_release_area();
  void set_allocated_release_area(::anduril::tasks::v2::AreaConstraints* value);
  void unsafe_arena_set_allocated_release_area(::anduril::tasks::v2::AreaConstraints* value);
  ::anduril::tasks::v2::AreaConstraints* unsafe_arena_release_release_area();

  private:
  const ::anduril::tasks::v2::AreaConstraints& _internal_release_area() const;
  ::anduril::tasks::v2::AreaConstraints* _internal_mutable_release_area();

  public:
  void clear_strike_release_constraint();
  StrikeReleaseConstraintCase strike_release_constraint_case() const;
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.StrikeReleaseConstraint)
 private:
  class _Internal;
  void set_has_release_area();

  inline bool has_strike_release_constraint() const;
  inline void clear_has_strike_release_constraint();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union StrikeReleaseConstraintUnion {
      constexpr StrikeReleaseConstraintUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::tasks::v2::AreaConstraints* release_area_;
    } strike_release_constraint_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto;
};// -------------------------------------------------------------------

class Strike final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.tasks.v2.Strike) */ {
 public:
  inline Strike() : Strike(nullptr) {}
  ~Strike() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Strike(::google::protobuf::internal::ConstantInitialized);

  inline Strike(const Strike& from)
      : Strike(nullptr, from) {}
  Strike(Strike&& from) noexcept
    : Strike() {
    *this = ::std::move(from);
  }

  inline Strike& operator=(const Strike& from) {
    CopyFrom(from);
    return *this;
  }
  inline Strike& operator=(Strike&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Strike& default_instance() {
    return *internal_default_instance();
  }
  static inline const Strike* internal_default_instance() {
    return reinterpret_cast<const Strike*>(
               &_Strike_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Strike& a, Strike& b) {
    a.Swap(&b);
  }
  inline void Swap(Strike* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Strike* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Strike* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Strike>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Strike& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Strike& from) {
    Strike::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Strike* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.tasks.v2.Strike";
  }
  protected:
  explicit Strike(::google::protobuf::Arena* arena);
  Strike(::google::protobuf::Arena* arena, const Strike& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectiveFieldNumber = 1,
    kIngressAngleFieldNumber = 2,
    kStrikeReleaseConstraintFieldNumber = 3,
    kParametersFieldNumber = 4,
  };
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // .anduril.tasks.v2.AnglePair ingress_angle = 2 [json_name = "ingressAngle"];
  bool has_ingress_angle() const;
  void clear_ingress_angle() ;
  const ::anduril::tasks::v2::AnglePair& ingress_angle() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::AnglePair* release_ingress_angle();
  ::anduril::tasks::v2::AnglePair* mutable_ingress_angle();
  void set_allocated_ingress_angle(::anduril::tasks::v2::AnglePair* value);
  void unsafe_arena_set_allocated_ingress_angle(::anduril::tasks::v2::AnglePair* value);
  ::anduril::tasks::v2::AnglePair* unsafe_arena_release_ingress_angle();

  private:
  const ::anduril::tasks::v2::AnglePair& _internal_ingress_angle() const;
  ::anduril::tasks::v2::AnglePair* _internal_mutable_ingress_angle();

  public:
  // .anduril.tasks.v2.StrikeReleaseConstraint strike_release_constraint = 3 [json_name = "strikeReleaseConstraint"];
  bool has_strike_release_constraint() const;
  void clear_strike_release_constraint() ;
  const ::anduril::tasks::v2::StrikeReleaseConstraint& strike_release_constraint() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::StrikeReleaseConstraint* release_strike_release_constraint();
  ::anduril::tasks::v2::StrikeReleaseConstraint* mutable_strike_release_constraint();
  void set_allocated_strike_release_constraint(::anduril::tasks::v2::StrikeReleaseConstraint* value);
  void unsafe_arena_set_allocated_strike_release_constraint(::anduril::tasks::v2::StrikeReleaseConstraint* value);
  ::anduril::tasks::v2::StrikeReleaseConstraint* unsafe_arena_release_strike_release_constraint();

  private:
  const ::anduril::tasks::v2::StrikeReleaseConstraint& _internal_strike_release_constraint() const;
  ::anduril::tasks::v2::StrikeReleaseConstraint* _internal_mutable_strike_release_constraint();

  public:
  // .anduril.tasks.v2.StrikeParameters parameters = 4 [json_name = "parameters"];
  bool has_parameters() const;
  void clear_parameters() ;
  const ::anduril::tasks::v2::StrikeParameters& parameters() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::StrikeParameters* release_parameters();
  ::anduril::tasks::v2::StrikeParameters* mutable_parameters();
  void set_allocated_parameters(::anduril::tasks::v2::StrikeParameters* value);
  void unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::StrikeParameters* value);
  ::anduril::tasks::v2::StrikeParameters* unsafe_arena_release_parameters();

  private:
  const ::anduril::tasks::v2::StrikeParameters& _internal_parameters() const;
  ::anduril::tasks::v2::StrikeParameters* _internal_mutable_parameters();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.Strike)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::Objective* objective_;
    ::anduril::tasks::v2::AnglePair* ingress_angle_;
    ::anduril::tasks::v2::StrikeReleaseConstraint* strike_release_constraint_;
    ::anduril::tasks::v2::StrikeParameters* parameters_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto;
};// -------------------------------------------------------------------

class Smack final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.tasks.v2.Smack) */ {
 public:
  inline Smack() : Smack(nullptr) {}
  ~Smack() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Smack(::google::protobuf::internal::ConstantInitialized);

  inline Smack(const Smack& from)
      : Smack(nullptr, from) {}
  Smack(Smack&& from) noexcept
    : Smack() {
    *this = ::std::move(from);
  }

  inline Smack& operator=(const Smack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Smack& operator=(Smack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Smack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Smack* internal_default_instance() {
    return reinterpret_cast<const Smack*>(
               &_Smack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Smack& a, Smack& b) {
    a.Swap(&b);
  }
  inline void Swap(Smack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Smack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Smack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Smack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Smack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Smack& from) {
    Smack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Smack* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.tasks.v2.Smack";
  }
  protected:
  explicit Smack(::google::protobuf::Arena* arena);
  Smack(::google::protobuf::Arena* arena, const Smack& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectiveFieldNumber = 1,
    kParametersFieldNumber = 2,
  };
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // .anduril.tasks.v2.StrikeParameters parameters = 2 [json_name = "parameters"];
  bool has_parameters() const;
  void clear_parameters() ;
  const ::anduril::tasks::v2::StrikeParameters& parameters() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::StrikeParameters* release_parameters();
  ::anduril::tasks::v2::StrikeParameters* mutable_parameters();
  void set_allocated_parameters(::anduril::tasks::v2::StrikeParameters* value);
  void unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::StrikeParameters* value);
  ::anduril::tasks::v2::StrikeParameters* unsafe_arena_release_parameters();

  private:
  const ::anduril::tasks::v2::StrikeParameters& _internal_parameters() const;
  ::anduril::tasks::v2::StrikeParameters* _internal_mutable_parameters();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.Smack)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::Objective* objective_;
    ::anduril::tasks::v2::StrikeParameters* parameters_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto;
};// -------------------------------------------------------------------

class ReleasePayload final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.tasks.v2.ReleasePayload) */ {
 public:
  inline ReleasePayload() : ReleasePayload(nullptr) {}
  ~ReleasePayload() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReleasePayload(::google::protobuf::internal::ConstantInitialized);

  inline ReleasePayload(const ReleasePayload& from)
      : ReleasePayload(nullptr, from) {}
  ReleasePayload(ReleasePayload&& from) noexcept
    : ReleasePayload() {
    *this = ::std::move(from);
  }

  inline ReleasePayload& operator=(const ReleasePayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleasePayload& operator=(ReleasePayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleasePayload& default_instance() {
    return *internal_default_instance();
  }
  enum ReleaseMethodCase {
    kPrecisionRelease = 3,
    RELEASE_METHOD_NOT_SET = 0,
  };

  static inline const ReleasePayload* internal_default_instance() {
    return reinterpret_cast<const ReleasePayload*>(
               &_ReleasePayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReleasePayload& a, ReleasePayload& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleasePayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleasePayload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleasePayload* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReleasePayload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReleasePayload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ReleasePayload& from) {
    ReleasePayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReleasePayload* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.tasks.v2.ReleasePayload";
  }
  protected:
  explicit ReleasePayload(::google::protobuf::Arena* arena);
  ReleasePayload(::google::protobuf::Arena* arena, const ReleasePayload& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadsFieldNumber = 1,
    kObjectiveFieldNumber = 2,
    kPrecisionReleaseFieldNumber = 3,
  };
  // repeated .anduril.tasks.v2.PayloadConfiguration payloads = 1 [json_name = "payloads"];
  int payloads_size() const;
  private:
  int _internal_payloads_size() const;

  public:
  void clear_payloads() ;
  ::anduril::tasks::v2::PayloadConfiguration* mutable_payloads(int index);
  ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::PayloadConfiguration >*
      mutable_payloads();
  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>& _internal_payloads() const;
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>* _internal_mutable_payloads();
  public:
  const ::anduril::tasks::v2::PayloadConfiguration& payloads(int index) const;
  ::anduril::tasks::v2::PayloadConfiguration* add_payloads();
  const ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::PayloadConfiguration >&
      payloads() const;
  // .anduril.tasks.v2.Objective objective = 2 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // .google.protobuf.Empty precision_release = 3 [json_name = "precisionRelease"];
  bool has_precision_release() const;
  private:
  bool _internal_has_precision_release() const;

  public:
  void clear_precision_release() ;
  const ::google::protobuf::Empty& precision_release() const;
  PROTOBUF_NODISCARD ::google::protobuf::Empty* release_precision_release();
  ::google::protobuf::Empty* mutable_precision_release();
  void set_allocated_precision_release(::google::protobuf::Empty* value);
  void unsafe_arena_set_allocated_precision_release(::google::protobuf::Empty* value);
  ::google::protobuf::Empty* unsafe_arena_release_precision_release();

  private:
  const ::google::protobuf::Empty& _internal_precision_release() const;
  ::google::protobuf::Empty* _internal_mutable_precision_release();

  public:
  void clear_release_method();
  ReleaseMethodCase release_method_case() const;
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.ReleasePayload)
 private:
  class _Internal;
  void set_has_precision_release();

  inline bool has_release_method() const;
  inline void clear_has_release_method();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::PayloadConfiguration > payloads_;
    ::anduril::tasks::v2::Objective* objective_;
    union ReleaseMethodUnion {
      constexpr ReleaseMethodUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Empty* precision_release_;
    } release_method_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Smack

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool Smack::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& Smack::_internal_objective() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& Smack::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Smack.objective)
  return _internal_objective();
}
inline void Smack::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Smack.objective)
}
inline ::anduril::tasks::v2::Objective* Smack::release_objective() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* Smack::unsafe_arena_release_objective() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Smack.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* Smack::_internal_mutable_objective() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.objective_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* Smack::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Smack.objective)
  return _msg;
}
inline void Smack::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Smack.objective)
}

// .anduril.tasks.v2.StrikeParameters parameters = 2 [json_name = "parameters"];
inline bool Smack::has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline void Smack::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::tasks::v2::StrikeParameters& Smack::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::tasks::v2::StrikeParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::StrikeParameters&>(::anduril::tasks::v2::_StrikeParameters_default_instance_);
}
inline const ::anduril::tasks::v2::StrikeParameters& Smack::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Smack.parameters)
  return _internal_parameters();
}
inline void Smack::unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::StrikeParameters* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::StrikeParameters*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Smack.parameters)
}
inline ::anduril::tasks::v2::StrikeParameters* Smack::release_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::StrikeParameters* released = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::StrikeParameters* Smack::unsafe_arena_release_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Smack.parameters)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::StrikeParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::StrikeParameters* Smack::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::tasks::v2::StrikeParameters>(GetArena());
    _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::StrikeParameters*>(p);
  }
  return _impl_.parameters_;
}
inline ::anduril::tasks::v2::StrikeParameters* Smack::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::StrikeParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Smack.parameters)
  return _msg;
}
inline void Smack::set_allocated_parameters(::anduril::tasks::v2::StrikeParameters* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::tasks::v2::StrikeParameters*>(_impl_.parameters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::tasks::v2::StrikeParameters*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::StrikeParameters*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Smack.parameters)
}

// -------------------------------------------------------------------

// Strike

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool Strike::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& Strike::_internal_objective() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& Strike::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Strike.objective)
  return _internal_objective();
}
inline void Strike::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Strike.objective)
}
inline ::anduril::tasks::v2::Objective* Strike::release_objective() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* Strike::unsafe_arena_release_objective() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Strike.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* Strike::_internal_mutable_objective() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.objective_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* Strike::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Strike.objective)
  return _msg;
}
inline void Strike::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Strike.objective)
}

// .anduril.tasks.v2.AnglePair ingress_angle = 2 [json_name = "ingressAngle"];
inline bool Strike::has_ingress_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ingress_angle_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::AnglePair& Strike::_internal_ingress_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::tasks::v2::AnglePair* p = _impl_.ingress_angle_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::AnglePair&>(::anduril::tasks::v2::_AnglePair_default_instance_);
}
inline const ::anduril::tasks::v2::AnglePair& Strike::ingress_angle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Strike.ingress_angle)
  return _internal_ingress_angle();
}
inline void Strike::unsafe_arena_set_allocated_ingress_angle(::anduril::tasks::v2::AnglePair* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ingress_angle_);
  }
  _impl_.ingress_angle_ = reinterpret_cast<::anduril::tasks::v2::AnglePair*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Strike.ingress_angle)
}
inline ::anduril::tasks::v2::AnglePair* Strike::release_ingress_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::AnglePair* released = _impl_.ingress_angle_;
  _impl_.ingress_angle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::AnglePair* Strike::unsafe_arena_release_ingress_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Strike.ingress_angle)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::AnglePair* temp = _impl_.ingress_angle_;
  _impl_.ingress_angle_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::AnglePair* Strike::_internal_mutable_ingress_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ingress_angle_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::tasks::v2::AnglePair>(GetArena());
    _impl_.ingress_angle_ = reinterpret_cast<::anduril::tasks::v2::AnglePair*>(p);
  }
  return _impl_.ingress_angle_;
}
inline ::anduril::tasks::v2::AnglePair* Strike::mutable_ingress_angle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::AnglePair* _msg = _internal_mutable_ingress_angle();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Strike.ingress_angle)
  return _msg;
}
inline void Strike::set_allocated_ingress_angle(::anduril::tasks::v2::AnglePair* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ingress_angle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ingress_angle_ = reinterpret_cast<::anduril::tasks::v2::AnglePair*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Strike.ingress_angle)
}

// .anduril.tasks.v2.StrikeReleaseConstraint strike_release_constraint = 3 [json_name = "strikeReleaseConstraint"];
inline bool Strike::has_strike_release_constraint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.strike_release_constraint_ != nullptr);
  return value;
}
inline void Strike::clear_strike_release_constraint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.strike_release_constraint_ != nullptr) _impl_.strike_release_constraint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::anduril::tasks::v2::StrikeReleaseConstraint& Strike::_internal_strike_release_constraint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::tasks::v2::StrikeReleaseConstraint* p = _impl_.strike_release_constraint_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::StrikeReleaseConstraint&>(::anduril::tasks::v2::_StrikeReleaseConstraint_default_instance_);
}
inline const ::anduril::tasks::v2::StrikeReleaseConstraint& Strike::strike_release_constraint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Strike.strike_release_constraint)
  return _internal_strike_release_constraint();
}
inline void Strike::unsafe_arena_set_allocated_strike_release_constraint(::anduril::tasks::v2::StrikeReleaseConstraint* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.strike_release_constraint_);
  }
  _impl_.strike_release_constraint_ = reinterpret_cast<::anduril::tasks::v2::StrikeReleaseConstraint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Strike.strike_release_constraint)
}
inline ::anduril::tasks::v2::StrikeReleaseConstraint* Strike::release_strike_release_constraint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::tasks::v2::StrikeReleaseConstraint* released = _impl_.strike_release_constraint_;
  _impl_.strike_release_constraint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::StrikeReleaseConstraint* Strike::unsafe_arena_release_strike_release_constraint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Strike.strike_release_constraint)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::tasks::v2::StrikeReleaseConstraint* temp = _impl_.strike_release_constraint_;
  _impl_.strike_release_constraint_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::StrikeReleaseConstraint* Strike::_internal_mutable_strike_release_constraint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.strike_release_constraint_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::tasks::v2::StrikeReleaseConstraint>(GetArena());
    _impl_.strike_release_constraint_ = reinterpret_cast<::anduril::tasks::v2::StrikeReleaseConstraint*>(p);
  }
  return _impl_.strike_release_constraint_;
}
inline ::anduril::tasks::v2::StrikeReleaseConstraint* Strike::mutable_strike_release_constraint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::StrikeReleaseConstraint* _msg = _internal_mutable_strike_release_constraint();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Strike.strike_release_constraint)
  return _msg;
}
inline void Strike::set_allocated_strike_release_constraint(::anduril::tasks::v2::StrikeReleaseConstraint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::tasks::v2::StrikeReleaseConstraint*>(_impl_.strike_release_constraint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::tasks::v2::StrikeReleaseConstraint*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.strike_release_constraint_ = reinterpret_cast<::anduril::tasks::v2::StrikeReleaseConstraint*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Strike.strike_release_constraint)
}

// .anduril.tasks.v2.StrikeParameters parameters = 4 [json_name = "parameters"];
inline bool Strike::has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline void Strike::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::anduril::tasks::v2::StrikeParameters& Strike::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::tasks::v2::StrikeParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::StrikeParameters&>(::anduril::tasks::v2::_StrikeParameters_default_instance_);
}
inline const ::anduril::tasks::v2::StrikeParameters& Strike::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Strike.parameters)
  return _internal_parameters();
}
inline void Strike::unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::StrikeParameters* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::StrikeParameters*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Strike.parameters)
}
inline ::anduril::tasks::v2::StrikeParameters* Strike::release_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::tasks::v2::StrikeParameters* released = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::StrikeParameters* Strike::unsafe_arena_release_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Strike.parameters)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::anduril::tasks::v2::StrikeParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::StrikeParameters* Strike::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::tasks::v2::StrikeParameters>(GetArena());
    _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::StrikeParameters*>(p);
  }
  return _impl_.parameters_;
}
inline ::anduril::tasks::v2::StrikeParameters* Strike::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::StrikeParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Strike.parameters)
  return _msg;
}
inline void Strike::set_allocated_parameters(::anduril::tasks::v2::StrikeParameters* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::tasks::v2::StrikeParameters*>(_impl_.parameters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::tasks::v2::StrikeParameters*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::StrikeParameters*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Strike.parameters)
}

// -------------------------------------------------------------------

// StrikeReleaseConstraint

// .anduril.tasks.v2.AreaConstraints release_area = 1 [json_name = "releaseArea"];
inline bool StrikeReleaseConstraint::has_release_area() const {
  return strike_release_constraint_case() == kReleaseArea;
}
inline bool StrikeReleaseConstraint::_internal_has_release_area() const {
  return strike_release_constraint_case() == kReleaseArea;
}
inline void StrikeReleaseConstraint::set_has_release_area() {
  _impl_._oneof_case_[0] = kReleaseArea;
}
inline ::anduril::tasks::v2::AreaConstraints* StrikeReleaseConstraint::release_release_area() {
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.StrikeReleaseConstraint.release_area)
  if (strike_release_constraint_case() == kReleaseArea) {
    clear_has_strike_release_constraint();
    auto* temp = _impl_.strike_release_constraint_.release_area_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.strike_release_constraint_.release_area_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::tasks::v2::AreaConstraints& StrikeReleaseConstraint::_internal_release_area() const {
  return strike_release_constraint_case() == kReleaseArea ? *_impl_.strike_release_constraint_.release_area_ : reinterpret_cast<::anduril::tasks::v2::AreaConstraints&>(::anduril::tasks::v2::_AreaConstraints_default_instance_);
}
inline const ::anduril::tasks::v2::AreaConstraints& StrikeReleaseConstraint::release_area() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.StrikeReleaseConstraint.release_area)
  return _internal_release_area();
}
inline ::anduril::tasks::v2::AreaConstraints* StrikeReleaseConstraint::unsafe_arena_release_release_area() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.tasks.v2.StrikeReleaseConstraint.release_area)
  if (strike_release_constraint_case() == kReleaseArea) {
    clear_has_strike_release_constraint();
    auto* temp = _impl_.strike_release_constraint_.release_area_;
    _impl_.strike_release_constraint_.release_area_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StrikeReleaseConstraint::unsafe_arena_set_allocated_release_area(::anduril::tasks::v2::AreaConstraints* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_strike_release_constraint();
  if (value) {
    set_has_release_area();
    _impl_.strike_release_constraint_.release_area_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.StrikeReleaseConstraint.release_area)
}
inline ::anduril::tasks::v2::AreaConstraints* StrikeReleaseConstraint::_internal_mutable_release_area() {
  if (strike_release_constraint_case() != kReleaseArea) {
    clear_strike_release_constraint();
    set_has_release_area();
    _impl_.strike_release_constraint_.release_area_ = CreateMaybeMessage<::anduril::tasks::v2::AreaConstraints>(GetArena());
  }
  return _impl_.strike_release_constraint_.release_area_;
}
inline ::anduril::tasks::v2::AreaConstraints* StrikeReleaseConstraint::mutable_release_area() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::AreaConstraints* _msg = _internal_mutable_release_area();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.StrikeReleaseConstraint.release_area)
  return _msg;
}

inline bool StrikeReleaseConstraint::has_strike_release_constraint() const {
  return strike_release_constraint_case() != STRIKE_RELEASE_CONSTRAINT_NOT_SET;
}
inline void StrikeReleaseConstraint::clear_has_strike_release_constraint() {
  _impl_._oneof_case_[0] = STRIKE_RELEASE_CONSTRAINT_NOT_SET;
}
inline StrikeReleaseConstraint::StrikeReleaseConstraintCase StrikeReleaseConstraint::strike_release_constraint_case() const {
  return StrikeReleaseConstraint::StrikeReleaseConstraintCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StrikeParameters

// repeated .anduril.tasks.v2.PayloadConfiguration payloads_to_employ = 1 [json_name = "payloadsToEmploy"];
inline int StrikeParameters::_internal_payloads_to_employ_size() const {
  return _internal_payloads_to_employ().size();
}
inline int StrikeParameters::payloads_to_employ_size() const {
  return _internal_payloads_to_employ_size();
}
inline void StrikeParameters::clear_payloads_to_employ() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payloads_to_employ_.Clear();
}
inline ::anduril::tasks::v2::PayloadConfiguration* StrikeParameters::mutable_payloads_to_employ(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.StrikeParameters.payloads_to_employ)
  return _internal_mutable_payloads_to_employ()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>* StrikeParameters::mutable_payloads_to_employ()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.tasks.v2.StrikeParameters.payloads_to_employ)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_payloads_to_employ();
}
inline const ::anduril::tasks::v2::PayloadConfiguration& StrikeParameters::payloads_to_employ(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.StrikeParameters.payloads_to_employ)
  return _internal_payloads_to_employ().Get(index);
}
inline ::anduril::tasks::v2::PayloadConfiguration* StrikeParameters::add_payloads_to_employ() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::anduril::tasks::v2::PayloadConfiguration* _add = _internal_mutable_payloads_to_employ()->Add();
  // @@protoc_insertion_point(field_add:anduril.tasks.v2.StrikeParameters.payloads_to_employ)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>& StrikeParameters::payloads_to_employ() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.tasks.v2.StrikeParameters.payloads_to_employ)
  return _internal_payloads_to_employ();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>&
StrikeParameters::_internal_payloads_to_employ() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payloads_to_employ_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>*
StrikeParameters::_internal_mutable_payloads_to_employ() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.payloads_to_employ_;
}

// .google.protobuf.Duration desired_impact_time = 2 [json_name = "desiredImpactTime"];
inline bool StrikeParameters::has_desired_impact_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.desired_impact_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& StrikeParameters::_internal_desired_impact_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.desired_impact_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& StrikeParameters::desired_impact_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.StrikeParameters.desired_impact_time)
  return _internal_desired_impact_time();
}
inline void StrikeParameters::unsafe_arena_set_allocated_desired_impact_time(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.desired_impact_time_);
  }
  _impl_.desired_impact_time_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.StrikeParameters.desired_impact_time)
}
inline ::google::protobuf::Duration* StrikeParameters::release_desired_impact_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.desired_impact_time_;
  _impl_.desired_impact_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* StrikeParameters::unsafe_arena_release_desired_impact_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.StrikeParameters.desired_impact_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.desired_impact_time_;
  _impl_.desired_impact_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* StrikeParameters::_internal_mutable_desired_impact_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.desired_impact_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArena());
    _impl_.desired_impact_time_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.desired_impact_time_;
}
inline ::google::protobuf::Duration* StrikeParameters::mutable_desired_impact_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_desired_impact_time();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.StrikeParameters.desired_impact_time)
  return _msg;
}
inline void StrikeParameters::set_allocated_desired_impact_time(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.desired_impact_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.desired_impact_time_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.StrikeParameters.desired_impact_time)
}

// double run_in_bearing = 3 [json_name = "runInBearing"];
inline void StrikeParameters::clear_run_in_bearing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.run_in_bearing_ = 0;
}
inline double StrikeParameters::run_in_bearing() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.StrikeParameters.run_in_bearing)
  return _internal_run_in_bearing();
}
inline void StrikeParameters::set_run_in_bearing(double value) {
  _internal_set_run_in_bearing(value);
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.StrikeParameters.run_in_bearing)
}
inline double StrikeParameters::_internal_run_in_bearing() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.run_in_bearing_;
}
inline void StrikeParameters::_internal_set_run_in_bearing(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.run_in_bearing_ = value;
}

// double glide_slope_angle = 4 [json_name = "glideSlopeAngle"];
inline void StrikeParameters::clear_glide_slope_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.glide_slope_angle_ = 0;
}
inline double StrikeParameters::glide_slope_angle() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.StrikeParameters.glide_slope_angle)
  return _internal_glide_slope_angle();
}
inline void StrikeParameters::set_glide_slope_angle(double value) {
  _internal_set_glide_slope_angle(value);
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.StrikeParameters.glide_slope_angle)
}
inline double StrikeParameters::_internal_glide_slope_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.glide_slope_angle_;
}
inline void StrikeParameters::_internal_set_glide_slope_angle(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.glide_slope_angle_ = value;
}

// -------------------------------------------------------------------

// PayloadConfiguration

// string capability_id = 1 [json_name = "capabilityId"];
inline void PayloadConfiguration::clear_capability_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capability_id_.ClearToEmpty();
}
inline const std::string& PayloadConfiguration::capability_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.PayloadConfiguration.capability_id)
  return _internal_capability_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PayloadConfiguration::set_capability_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.capability_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.PayloadConfiguration.capability_id)
}
inline std::string* PayloadConfiguration::mutable_capability_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_capability_id();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.PayloadConfiguration.capability_id)
  return _s;
}
inline const std::string& PayloadConfiguration::_internal_capability_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capability_id_.Get();
}
inline void PayloadConfiguration::_internal_set_capability_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.capability_id_.Set(value, GetArena());
}
inline std::string* PayloadConfiguration::_internal_mutable_capability_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.capability_id_.Mutable( GetArena());
}
inline std::string* PayloadConfiguration::release_capability_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.PayloadConfiguration.capability_id)
  return _impl_.capability_id_.Release();
}
inline void PayloadConfiguration::set_allocated_capability_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capability_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.capability_id_.IsDefault()) {
          _impl_.capability_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.PayloadConfiguration.capability_id)
}

// uint32 quantity = 2 [json_name = "quantity"];
inline void PayloadConfiguration::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0u;
}
inline ::uint32_t PayloadConfiguration::quantity() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.PayloadConfiguration.quantity)
  return _internal_quantity();
}
inline void PayloadConfiguration::set_quantity(::uint32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.PayloadConfiguration.quantity)
}
inline ::uint32_t PayloadConfiguration::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void PayloadConfiguration::_internal_set_quantity(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// ReleasePayload

// repeated .anduril.tasks.v2.PayloadConfiguration payloads = 1 [json_name = "payloads"];
inline int ReleasePayload::_internal_payloads_size() const {
  return _internal_payloads().size();
}
inline int ReleasePayload::payloads_size() const {
  return _internal_payloads_size();
}
inline void ReleasePayload::clear_payloads() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payloads_.Clear();
}
inline ::anduril::tasks::v2::PayloadConfiguration* ReleasePayload::mutable_payloads(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.ReleasePayload.payloads)
  return _internal_mutable_payloads()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>* ReleasePayload::mutable_payloads()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.tasks.v2.ReleasePayload.payloads)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_payloads();
}
inline const ::anduril::tasks::v2::PayloadConfiguration& ReleasePayload::payloads(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ReleasePayload.payloads)
  return _internal_payloads().Get(index);
}
inline ::anduril::tasks::v2::PayloadConfiguration* ReleasePayload::add_payloads() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::anduril::tasks::v2::PayloadConfiguration* _add = _internal_mutable_payloads()->Add();
  // @@protoc_insertion_point(field_add:anduril.tasks.v2.ReleasePayload.payloads)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>& ReleasePayload::payloads() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.tasks.v2.ReleasePayload.payloads)
  return _internal_payloads();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>&
ReleasePayload::_internal_payloads() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payloads_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::PayloadConfiguration>*
ReleasePayload::_internal_mutable_payloads() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.payloads_;
}

// .anduril.tasks.v2.Objective objective = 2 [json_name = "objective"];
inline bool ReleasePayload::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& ReleasePayload::_internal_objective() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& ReleasePayload::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ReleasePayload.objective)
  return _internal_objective();
}
inline void ReleasePayload::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.ReleasePayload.objective)
}
inline ::anduril::tasks::v2::Objective* ReleasePayload::release_objective() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* ReleasePayload::unsafe_arena_release_objective() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.ReleasePayload.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* ReleasePayload::_internal_mutable_objective() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.objective_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* ReleasePayload::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.ReleasePayload.objective)
  return _msg;
}
inline void ReleasePayload::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.ReleasePayload.objective)
}

// .google.protobuf.Empty precision_release = 3 [json_name = "precisionRelease"];
inline bool ReleasePayload::has_precision_release() const {
  return release_method_case() == kPrecisionRelease;
}
inline bool ReleasePayload::_internal_has_precision_release() const {
  return release_method_case() == kPrecisionRelease;
}
inline void ReleasePayload::set_has_precision_release() {
  _impl_._oneof_case_[0] = kPrecisionRelease;
}
inline ::google::protobuf::Empty* ReleasePayload::release_precision_release() {
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.ReleasePayload.precision_release)
  if (release_method_case() == kPrecisionRelease) {
    clear_has_release_method();
    auto* temp = _impl_.release_method_.precision_release_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.release_method_.precision_release_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& ReleasePayload::_internal_precision_release() const {
  return release_method_case() == kPrecisionRelease ? *_impl_.release_method_.precision_release_ : reinterpret_cast<::google::protobuf::Empty&>(::google::protobuf::_Empty_default_instance_);
}
inline const ::google::protobuf::Empty& ReleasePayload::precision_release() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ReleasePayload.precision_release)
  return _internal_precision_release();
}
inline ::google::protobuf::Empty* ReleasePayload::unsafe_arena_release_precision_release() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.tasks.v2.ReleasePayload.precision_release)
  if (release_method_case() == kPrecisionRelease) {
    clear_has_release_method();
    auto* temp = _impl_.release_method_.precision_release_;
    _impl_.release_method_.precision_release_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReleasePayload::unsafe_arena_set_allocated_precision_release(::google::protobuf::Empty* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_release_method();
  if (value) {
    set_has_precision_release();
    _impl_.release_method_.precision_release_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.ReleasePayload.precision_release)
}
inline ::google::protobuf::Empty* ReleasePayload::_internal_mutable_precision_release() {
  if (release_method_case() != kPrecisionRelease) {
    clear_release_method();
    set_has_precision_release();
    _impl_.release_method_.precision_release_ = CreateMaybeMessage<::google::protobuf::Empty>(GetArena());
  }
  return _impl_.release_method_.precision_release_;
}
inline ::google::protobuf::Empty* ReleasePayload::mutable_precision_release() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Empty* _msg = _internal_mutable_precision_release();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.ReleasePayload.precision_release)
  return _msg;
}

inline bool ReleasePayload::has_release_method() const {
  return release_method_case() != RELEASE_METHOD_NOT_SET;
}
inline void ReleasePayload::clear_has_release_method() {
  _impl_._oneof_case_[0] = RELEASE_METHOD_NOT_SET;
}
inline ReleasePayload::ReleaseMethodCase ReleasePayload::release_method_case() const {
  return ReleasePayload::ReleaseMethodCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v2
}  // namespace tasks
}  // namespace anduril


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2ftasks_2fv2_2fshared_2fstrike_2epub_2eproto_2epb_2eh
