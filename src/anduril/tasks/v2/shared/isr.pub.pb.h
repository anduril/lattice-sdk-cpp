// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/tasks/v2/shared/isr.pub.proto
// Protobuf C++ Version: 5.27.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "anduril/tasks/v2/common.pub.pb.h"
#include "anduril/tasks/v2/objective.pub.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
namespace anduril {
namespace tasks {
namespace v2 {
class AreaSearch;
struct AreaSearchDefaultTypeInternal;
extern AreaSearchDefaultTypeInternal _AreaSearch_default_instance_;
class AzimuthElevationPoint;
struct AzimuthElevationPointDefaultTypeInternal;
extern AzimuthElevationPointDefaultTypeInternal _AzimuthElevationPoint_default_instance_;
class BattleDamageAssessment;
struct BattleDamageAssessmentDefaultTypeInternal;
extern BattleDamageAssessmentDefaultTypeInternal _BattleDamageAssessment_default_instance_;
class FramePoint;
struct FramePointDefaultTypeInternal;
extern FramePointDefaultTypeInternal _FramePoint_default_instance_;
class GimbalPoint;
struct GimbalPointDefaultTypeInternal;
extern GimbalPointDefaultTypeInternal _GimbalPoint_default_instance_;
class GimbalZoom;
struct GimbalZoomDefaultTypeInternal;
extern GimbalZoomDefaultTypeInternal _GimbalZoom_default_instance_;
class ISRParameters;
struct ISRParametersDefaultTypeInternal;
extern ISRParametersDefaultTypeInternal _ISRParameters_default_instance_;
class ImproveTrackQuality;
struct ImproveTrackQualityDefaultTypeInternal;
extern ImproveTrackQualityDefaultTypeInternal _ImproveTrackQuality_default_instance_;
class Investigate;
struct InvestigateDefaultTypeInternal;
extern InvestigateDefaultTypeInternal _Investigate_default_instance_;
class Loiter;
struct LoiterDefaultTypeInternal;
extern LoiterDefaultTypeInternal _Loiter_default_instance_;
class LoiterType;
struct LoiterTypeDefaultTypeInternal;
extern LoiterTypeDefaultTypeInternal _LoiterType_default_instance_;
class Map;
struct MapDefaultTypeInternal;
extern MapDefaultTypeInternal _Map_default_instance_;
class Monitor;
struct MonitorDefaultTypeInternal;
extern MonitorDefaultTypeInternal _Monitor_default_instance_;
class OrbitDuration;
struct OrbitDurationDefaultTypeInternal;
extern OrbitDurationDefaultTypeInternal _OrbitDuration_default_instance_;
class OrbitType;
struct OrbitTypeDefaultTypeInternal;
extern OrbitTypeDefaultTypeInternal _OrbitType_default_instance_;
class Prior;
struct PriorDefaultTypeInternal;
extern PriorDefaultTypeInternal _Prior_default_instance_;
class Scan;
struct ScanDefaultTypeInternal;
extern ScanDefaultTypeInternal _Scan_default_instance_;
class Shadow;
struct ShadowDefaultTypeInternal;
extern ShadowDefaultTypeInternal _Shadow_default_instance_;
class VisualId;
struct VisualIdDefaultTypeInternal;
extern VisualIdDefaultTypeInternal _VisualId_default_instance_;
class VolumeSearch;
struct VolumeSearchDefaultTypeInternal;
extern VolumeSearchDefaultTypeInternal _VolumeSearch_default_instance_;
}  // namespace v2
}  // namespace tasks
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace tasks {
namespace v2 {
enum OrbitDirection : int {
  ORBIT_DIRECTION_DIRECTION_INVALID = 0,
  ORBIT_DIRECTION_RIGHT = 1,
  ORBIT_DIRECTION_LEFT = 2,
  OrbitDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrbitDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrbitDirection_IsValid(int value);
extern const uint32_t OrbitDirection_internal_data_[];
constexpr OrbitDirection OrbitDirection_MIN = static_cast<OrbitDirection>(0);
constexpr OrbitDirection OrbitDirection_MAX = static_cast<OrbitDirection>(2);
constexpr int OrbitDirection_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
OrbitDirection_descriptor();
template <typename T>
const std::string& OrbitDirection_Name(T value) {
  static_assert(std::is_same<T, OrbitDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrbitDirection_Name().");
  return OrbitDirection_Name(static_cast<OrbitDirection>(value));
}
template <>
inline const std::string& OrbitDirection_Name(OrbitDirection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OrbitDirection_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool OrbitDirection_Parse(absl::string_view name, OrbitDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrbitDirection>(
      OrbitDirection_descriptor(), name, value);
}
enum OrbitPattern : int {
  ORBIT_PATTERN_INVALID = 0,
  ORBIT_PATTERN_CIRCLE = 1,
  ORBIT_PATTERN_RACETRACK = 2,
  ORBIT_PATTERN_FIGURE_EIGHT = 3,
  OrbitPattern_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrbitPattern_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrbitPattern_IsValid(int value);
extern const uint32_t OrbitPattern_internal_data_[];
constexpr OrbitPattern OrbitPattern_MIN = static_cast<OrbitPattern>(0);
constexpr OrbitPattern OrbitPattern_MAX = static_cast<OrbitPattern>(3);
constexpr int OrbitPattern_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
OrbitPattern_descriptor();
template <typename T>
const std::string& OrbitPattern_Name(T value) {
  static_assert(std::is_same<T, OrbitPattern>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrbitPattern_Name().");
  return OrbitPattern_Name(static_cast<OrbitPattern>(value));
}
template <>
inline const std::string& OrbitPattern_Name(OrbitPattern value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OrbitPattern_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool OrbitPattern_Parse(absl::string_view name, OrbitPattern* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrbitPattern>(
      OrbitPattern_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class AzimuthElevationPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.AzimuthElevationPoint) */ {
 public:
  inline AzimuthElevationPoint() : AzimuthElevationPoint(nullptr) {}
  ~AzimuthElevationPoint() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AzimuthElevationPoint(
      ::google::protobuf::internal::ConstantInitialized);

  inline AzimuthElevationPoint(const AzimuthElevationPoint& from) : AzimuthElevationPoint(nullptr, from) {}
  inline AzimuthElevationPoint(AzimuthElevationPoint&& from) noexcept
      : AzimuthElevationPoint(nullptr, std::move(from)) {}
  inline AzimuthElevationPoint& operator=(const AzimuthElevationPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline AzimuthElevationPoint& operator=(AzimuthElevationPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AzimuthElevationPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const AzimuthElevationPoint* internal_default_instance() {
    return reinterpret_cast<const AzimuthElevationPoint*>(
        &_AzimuthElevationPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(AzimuthElevationPoint& a, AzimuthElevationPoint& b) { a.Swap(&b); }
  inline void Swap(AzimuthElevationPoint* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AzimuthElevationPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AzimuthElevationPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AzimuthElevationPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AzimuthElevationPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AzimuthElevationPoint& from) { AzimuthElevationPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AzimuthElevationPoint* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.AzimuthElevationPoint"; }

 protected:
  explicit AzimuthElevationPoint(::google::protobuf::Arena* arena);
  AzimuthElevationPoint(::google::protobuf::Arena* arena, const AzimuthElevationPoint& from);
  AzimuthElevationPoint(::google::protobuf::Arena* arena, AzimuthElevationPoint&& from) noexcept
      : AzimuthElevationPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAzimuthFieldNumber = 1,
    kElevationFieldNumber = 2,
  };
  // double azimuth = 1 [json_name = "azimuth"];
  void clear_azimuth() ;
  double azimuth() const;
  void set_azimuth(double value);

  private:
  double _internal_azimuth() const;
  void _internal_set_azimuth(double value);

  public:
  // double elevation = 2 [json_name = "elevation"];
  void clear_elevation() ;
  double elevation() const;
  void set_elevation(double value);

  private:
  double _internal_elevation() const;
  void _internal_set_elevation(double value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.AzimuthElevationPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AzimuthElevationPoint_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AzimuthElevationPoint& from_msg);
    double azimuth_;
    double elevation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class ISRParameters final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.ISRParameters) */ {
 public:
  inline ISRParameters() : ISRParameters(nullptr) {}
  ~ISRParameters() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ISRParameters(
      ::google::protobuf::internal::ConstantInitialized);

  inline ISRParameters(const ISRParameters& from) : ISRParameters(nullptr, from) {}
  inline ISRParameters(ISRParameters&& from) noexcept
      : ISRParameters(nullptr, std::move(from)) {}
  inline ISRParameters& operator=(const ISRParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ISRParameters& operator=(ISRParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ISRParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ISRParameters* internal_default_instance() {
    return reinterpret_cast<const ISRParameters*>(
        &_ISRParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ISRParameters& a, ISRParameters& b) { a.Swap(&b); }
  inline void Swap(ISRParameters* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ISRParameters* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ISRParameters* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ISRParameters>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ISRParameters& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ISRParameters& from) { ISRParameters::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ISRParameters* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.ISRParameters"; }

 protected:
  explicit ISRParameters(::google::protobuf::Arena* arena);
  ISRParameters(::google::protobuf::Arena* arena, const ISRParameters& from);
  ISRParameters(::google::protobuf::Arena* arena, ISRParameters&& from) noexcept
      : ISRParameters(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpeedFieldNumber = 1,
    kSpeedMSFieldNumber = 2,
    kStandoffDistanceMFieldNumber = 3,
    kStandoffDistanceFieldNumber = 4,
    kStandoffAngleFieldNumber = 5,
    kExpirationTimeMsFieldNumber = 6,
  };
  // .google.protobuf.FloatValue speed = 1 [json_name = "speed", deprecated = true];
  [[deprecated]]  bool has_speed() const;
  [[deprecated]]  void clear_speed() ;
  [[deprecated]] const ::google::protobuf::FloatValue& speed() const;
  [[deprecated]] PROTOBUF_NODISCARD ::google::protobuf::FloatValue* release_speed();
  [[deprecated]] ::google::protobuf::FloatValue* mutable_speed();
  [[deprecated]] void set_allocated_speed(::google::protobuf::FloatValue* value);
  [[deprecated]] void unsafe_arena_set_allocated_speed(::google::protobuf::FloatValue* value);
  [[deprecated]] ::google::protobuf::FloatValue* unsafe_arena_release_speed();

  private:
  const ::google::protobuf::FloatValue& _internal_speed() const;
  ::google::protobuf::FloatValue* _internal_mutable_speed();

  public:
  // .google.protobuf.FloatValue speed_m_s = 2 [json_name = "speedMS"];
  bool has_speed_m_s() const;
  void clear_speed_m_s() ;
  const ::google::protobuf::FloatValue& speed_m_s() const;
  PROTOBUF_NODISCARD ::google::protobuf::FloatValue* release_speed_m_s();
  ::google::protobuf::FloatValue* mutable_speed_m_s();
  void set_allocated_speed_m_s(::google::protobuf::FloatValue* value);
  void unsafe_arena_set_allocated_speed_m_s(::google::protobuf::FloatValue* value);
  ::google::protobuf::FloatValue* unsafe_arena_release_speed_m_s();

  private:
  const ::google::protobuf::FloatValue& _internal_speed_m_s() const;
  ::google::protobuf::FloatValue* _internal_mutable_speed_m_s();

  public:
  // .google.protobuf.FloatValue standoff_distance_m = 3 [json_name = "standoffDistanceM"];
  bool has_standoff_distance_m() const;
  void clear_standoff_distance_m() ;
  const ::google::protobuf::FloatValue& standoff_distance_m() const;
  PROTOBUF_NODISCARD ::google::protobuf::FloatValue* release_standoff_distance_m();
  ::google::protobuf::FloatValue* mutable_standoff_distance_m();
  void set_allocated_standoff_distance_m(::google::protobuf::FloatValue* value);
  void unsafe_arena_set_allocated_standoff_distance_m(::google::protobuf::FloatValue* value);
  ::google::protobuf::FloatValue* unsafe_arena_release_standoff_distance_m();

  private:
  const ::google::protobuf::FloatValue& _internal_standoff_distance_m() const;
  ::google::protobuf::FloatValue* _internal_mutable_standoff_distance_m();

  public:
  // .google.protobuf.FloatValue standoff_distance = 4 [json_name = "standoffDistance", deprecated = true];
  [[deprecated]]  bool has_standoff_distance() const;
  [[deprecated]]  void clear_standoff_distance() ;
  [[deprecated]] const ::google::protobuf::FloatValue& standoff_distance() const;
  [[deprecated]] PROTOBUF_NODISCARD ::google::protobuf::FloatValue* release_standoff_distance();
  [[deprecated]] ::google::protobuf::FloatValue* mutable_standoff_distance();
  [[deprecated]] void set_allocated_standoff_distance(::google::protobuf::FloatValue* value);
  [[deprecated]] void unsafe_arena_set_allocated_standoff_distance(::google::protobuf::FloatValue* value);
  [[deprecated]] ::google::protobuf::FloatValue* unsafe_arena_release_standoff_distance();

  private:
  const ::google::protobuf::FloatValue& _internal_standoff_distance() const;
  ::google::protobuf::FloatValue* _internal_mutable_standoff_distance();

  public:
  // .google.protobuf.FloatValue standoff_angle = 5 [json_name = "standoffAngle"];
  bool has_standoff_angle() const;
  void clear_standoff_angle() ;
  const ::google::protobuf::FloatValue& standoff_angle() const;
  PROTOBUF_NODISCARD ::google::protobuf::FloatValue* release_standoff_angle();
  ::google::protobuf::FloatValue* mutable_standoff_angle();
  void set_allocated_standoff_angle(::google::protobuf::FloatValue* value);
  void unsafe_arena_set_allocated_standoff_angle(::google::protobuf::FloatValue* value);
  ::google::protobuf::FloatValue* unsafe_arena_release_standoff_angle();

  private:
  const ::google::protobuf::FloatValue& _internal_standoff_angle() const;
  ::google::protobuf::FloatValue* _internal_mutable_standoff_angle();

  public:
  // .google.protobuf.UInt64Value expiration_time_ms = 6 [json_name = "expirationTimeMs"];
  bool has_expiration_time_ms() const;
  void clear_expiration_time_ms() ;
  const ::google::protobuf::UInt64Value& expiration_time_ms() const;
  PROTOBUF_NODISCARD ::google::protobuf::UInt64Value* release_expiration_time_ms();
  ::google::protobuf::UInt64Value* mutable_expiration_time_ms();
  void set_allocated_expiration_time_ms(::google::protobuf::UInt64Value* value);
  void unsafe_arena_set_allocated_expiration_time_ms(::google::protobuf::UInt64Value* value);
  ::google::protobuf::UInt64Value* unsafe_arena_release_expiration_time_ms();

  private:
  const ::google::protobuf::UInt64Value& _internal_expiration_time_ms() const;
  ::google::protobuf::UInt64Value* _internal_mutable_expiration_time_ms();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.ISRParameters)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 6,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ISRParameters_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ISRParameters& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::FloatValue* speed_;
    ::google::protobuf::FloatValue* speed_m_s_;
    ::google::protobuf::FloatValue* standoff_distance_m_;
    ::google::protobuf::FloatValue* standoff_distance_;
    ::google::protobuf::FloatValue* standoff_angle_;
    ::google::protobuf::UInt64Value* expiration_time_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class GimbalZoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.GimbalZoom) */ {
 public:
  inline GimbalZoom() : GimbalZoom(nullptr) {}
  ~GimbalZoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GimbalZoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline GimbalZoom(const GimbalZoom& from) : GimbalZoom(nullptr, from) {}
  inline GimbalZoom(GimbalZoom&& from) noexcept
      : GimbalZoom(nullptr, std::move(from)) {}
  inline GimbalZoom& operator=(const GimbalZoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline GimbalZoom& operator=(GimbalZoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GimbalZoom& default_instance() {
    return *internal_default_instance();
  }
  enum ModeCase {
    kSetHorizontalFov = 1,
    kSetMagnification = 2,
    MODE_NOT_SET = 0,
  };
  static inline const GimbalZoom* internal_default_instance() {
    return reinterpret_cast<const GimbalZoom*>(
        &_GimbalZoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(GimbalZoom& a, GimbalZoom& b) { a.Swap(&b); }
  inline void Swap(GimbalZoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GimbalZoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GimbalZoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GimbalZoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GimbalZoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GimbalZoom& from) { GimbalZoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GimbalZoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.GimbalZoom"; }

 protected:
  explicit GimbalZoom(::google::protobuf::Arena* arena);
  GimbalZoom(::google::protobuf::Arena* arena, const GimbalZoom& from);
  GimbalZoom(::google::protobuf::Arena* arena, GimbalZoom&& from) noexcept
      : GimbalZoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSetHorizontalFovFieldNumber = 1,
    kSetMagnificationFieldNumber = 2,
  };
  // .google.protobuf.DoubleValue set_horizontal_fov = 1 [json_name = "setHorizontalFov"];
  bool has_set_horizontal_fov() const;
  private:
  bool _internal_has_set_horizontal_fov() const;

  public:
  void clear_set_horizontal_fov() ;
  const ::google::protobuf::DoubleValue& set_horizontal_fov() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_set_horizontal_fov();
  ::google::protobuf::DoubleValue* mutable_set_horizontal_fov();
  void set_allocated_set_horizontal_fov(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_set_horizontal_fov(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_set_horizontal_fov();

  private:
  const ::google::protobuf::DoubleValue& _internal_set_horizontal_fov() const;
  ::google::protobuf::DoubleValue* _internal_mutable_set_horizontal_fov();

  public:
  // .google.protobuf.FloatValue set_magnification = 2 [json_name = "setMagnification"];
  bool has_set_magnification() const;
  private:
  bool _internal_has_set_magnification() const;

  public:
  void clear_set_magnification() ;
  const ::google::protobuf::FloatValue& set_magnification() const;
  PROTOBUF_NODISCARD ::google::protobuf::FloatValue* release_set_magnification();
  ::google::protobuf::FloatValue* mutable_set_magnification();
  void set_allocated_set_magnification(::google::protobuf::FloatValue* value);
  void unsafe_arena_set_allocated_set_magnification(::google::protobuf::FloatValue* value);
  ::google::protobuf::FloatValue* unsafe_arena_release_set_magnification();

  private:
  const ::google::protobuf::FloatValue& _internal_set_magnification() const;
  ::google::protobuf::FloatValue* _internal_mutable_set_magnification();

  public:
  void clear_mode();
  ModeCase mode_case() const;
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.GimbalZoom)
 private:
  class _Internal;
  void set_has_set_horizontal_fov();
  void set_has_set_magnification();
  inline bool has_mode() const;
  inline void clear_has_mode();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GimbalZoom_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GimbalZoom& from_msg);
    union ModeUnion {
      constexpr ModeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::DoubleValue* set_horizontal_fov_;
      ::google::protobuf::FloatValue* set_magnification_;
    } mode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class FramePoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.FramePoint) */ {
 public:
  inline FramePoint() : FramePoint(nullptr) {}
  ~FramePoint() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FramePoint(
      ::google::protobuf::internal::ConstantInitialized);

  inline FramePoint(const FramePoint& from) : FramePoint(nullptr, from) {}
  inline FramePoint(FramePoint&& from) noexcept
      : FramePoint(nullptr, std::move(from)) {}
  inline FramePoint& operator=(const FramePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline FramePoint& operator=(FramePoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FramePoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const FramePoint* internal_default_instance() {
    return reinterpret_cast<const FramePoint*>(
        &_FramePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(FramePoint& a, FramePoint& b) { a.Swap(&b); }
  inline void Swap(FramePoint* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FramePoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FramePoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FramePoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FramePoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FramePoint& from) { FramePoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FramePoint* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.FramePoint"; }

 protected:
  explicit FramePoint(::google::protobuf::Arena* arena);
  FramePoint(::google::protobuf::Arena* arena, const FramePoint& from);
  FramePoint(::google::protobuf::Arena* arena, FramePoint&& from) noexcept
      : FramePoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 3,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // .google.protobuf.Timestamp timestamp = 3 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // float x = 1 [json_name = "x"];
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2 [json_name = "y"];
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.FramePoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FramePoint_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FramePoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* timestamp_;
    float x_;
    float y_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class Prior final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.Prior) */ {
 public:
  inline Prior() : Prior(nullptr) {}
  ~Prior() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Prior(
      ::google::protobuf::internal::ConstantInitialized);

  inline Prior(const Prior& from) : Prior(nullptr, from) {}
  inline Prior(Prior&& from) noexcept
      : Prior(nullptr, std::move(from)) {}
  inline Prior& operator=(const Prior& from) {
    CopyFrom(from);
    return *this;
  }
  inline Prior& operator=(Prior&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Prior& default_instance() {
    return *internal_default_instance();
  }
  enum PriorCase {
    kEntityId = 1,
    kPoint = 5,
    PRIOR_NOT_SET = 0,
  };
  static inline const Prior* internal_default_instance() {
    return reinterpret_cast<const Prior*>(
        &_Prior_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Prior& a, Prior& b) { a.Swap(&b); }
  inline void Swap(Prior* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Prior* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Prior* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Prior>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Prior& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Prior& from) { Prior::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Prior* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.Prior"; }

 protected:
  explicit Prior(::google::protobuf::Arena* arena);
  Prior(::google::protobuf::Arena* arena, const Prior& from);
  Prior(::google::protobuf::Arena* arena, Prior&& from) noexcept
      : Prior(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kPointFieldNumber = 5,
  };
  // string entity_id = 1 [json_name = "entityId"];
  bool has_entity_id() const;
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // .anduril.tasks.v2.Point point = 5 [json_name = "point"];
  bool has_point() const;
  private:
  bool _internal_has_point() const;

  public:
  void clear_point() ;
  const ::anduril::tasks::v2::Point& point() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Point* release_point();
  ::anduril::tasks::v2::Point* mutable_point();
  void set_allocated_point(::anduril::tasks::v2::Point* value);
  void unsafe_arena_set_allocated_point(::anduril::tasks::v2::Point* value);
  ::anduril::tasks::v2::Point* unsafe_arena_release_point();

  private:
  const ::anduril::tasks::v2::Point& _internal_point() const;
  ::anduril::tasks::v2::Point* _internal_mutable_point();

  public:
  void clear_prior();
  PriorCase prior_case() const;
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.Prior)
 private:
  class _Internal;
  void set_has_entity_id();
  void set_has_point();
  inline bool has_prior() const;
  inline void clear_has_prior();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      40, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Prior_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Prior& from_msg);
    union PriorUnion {
      constexpr PriorUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr entity_id_;
      ::anduril::tasks::v2::Point* point_;
    } prior_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class OrbitDuration final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.OrbitDuration) */ {
 public:
  inline OrbitDuration() : OrbitDuration(nullptr) {}
  ~OrbitDuration() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrbitDuration(
      ::google::protobuf::internal::ConstantInitialized);

  inline OrbitDuration(const OrbitDuration& from) : OrbitDuration(nullptr, from) {}
  inline OrbitDuration(OrbitDuration&& from) noexcept
      : OrbitDuration(nullptr, std::move(from)) {}
  inline OrbitDuration& operator=(const OrbitDuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrbitDuration& operator=(OrbitDuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrbitDuration& default_instance() {
    return *internal_default_instance();
  }
  enum DurationCase {
    kDurationRange = 1,
    kNumOfOrbits = 2,
    DURATION_NOT_SET = 0,
  };
  static inline const OrbitDuration* internal_default_instance() {
    return reinterpret_cast<const OrbitDuration*>(
        &_OrbitDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(OrbitDuration& a, OrbitDuration& b) { a.Swap(&b); }
  inline void Swap(OrbitDuration* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrbitDuration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrbitDuration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<OrbitDuration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrbitDuration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OrbitDuration& from) { OrbitDuration::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OrbitDuration* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.OrbitDuration"; }

 protected:
  explicit OrbitDuration(::google::protobuf::Arena* arena);
  OrbitDuration(::google::protobuf::Arena* arena, const OrbitDuration& from);
  OrbitDuration(::google::protobuf::Arena* arena, OrbitDuration&& from) noexcept
      : OrbitDuration(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDurationRangeFieldNumber = 1,
    kNumOfOrbitsFieldNumber = 2,
  };
  // .anduril.tasks.v2.DurationRange duration_range = 1 [json_name = "durationRange"];
  bool has_duration_range() const;
  private:
  bool _internal_has_duration_range() const;

  public:
  void clear_duration_range() ;
  const ::anduril::tasks::v2::DurationRange& duration_range() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::DurationRange* release_duration_range();
  ::anduril::tasks::v2::DurationRange* mutable_duration_range();
  void set_allocated_duration_range(::anduril::tasks::v2::DurationRange* value);
  void unsafe_arena_set_allocated_duration_range(::anduril::tasks::v2::DurationRange* value);
  ::anduril::tasks::v2::DurationRange* unsafe_arena_release_duration_range();

  private:
  const ::anduril::tasks::v2::DurationRange& _internal_duration_range() const;
  ::anduril::tasks::v2::DurationRange* _internal_mutable_duration_range();

  public:
  // uint64 num_of_orbits = 2 [json_name = "numOfOrbits"];
  bool has_num_of_orbits() const;
  void clear_num_of_orbits() ;
  ::uint64_t num_of_orbits() const;
  void set_num_of_orbits(::uint64_t value);

  private:
  ::uint64_t _internal_num_of_orbits() const;
  void _internal_set_num_of_orbits(::uint64_t value);

  public:
  void clear_duration();
  DurationCase duration_case() const;
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.OrbitDuration)
 private:
  class _Internal;
  void set_has_duration_range();
  void set_has_num_of_orbits();
  inline bool has_duration() const;
  inline void clear_has_duration();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_OrbitDuration_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OrbitDuration& from_msg);
    union DurationUnion {
      constexpr DurationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::tasks::v2::DurationRange* duration_range_;
      ::uint64_t num_of_orbits_;
    } duration_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class VolumeSearch final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.VolumeSearch) */ {
 public:
  inline VolumeSearch() : VolumeSearch(nullptr) {}
  ~VolumeSearch() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeSearch(
      ::google::protobuf::internal::ConstantInitialized);

  inline VolumeSearch(const VolumeSearch& from) : VolumeSearch(nullptr, from) {}
  inline VolumeSearch(VolumeSearch&& from) noexcept
      : VolumeSearch(nullptr, std::move(from)) {}
  inline VolumeSearch& operator=(const VolumeSearch& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeSearch& operator=(VolumeSearch&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeSearch& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeSearch* internal_default_instance() {
    return reinterpret_cast<const VolumeSearch*>(
        &_VolumeSearch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(VolumeSearch& a, VolumeSearch& b) { a.Swap(&b); }
  inline void Swap(VolumeSearch* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeSearch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeSearch* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<VolumeSearch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VolumeSearch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VolumeSearch& from) { VolumeSearch::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeSearch* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.VolumeSearch"; }

 protected:
  explicit VolumeSearch(::google::protobuf::Arena* arena);
  VolumeSearch(::google::protobuf::Arena* arena, const VolumeSearch& from);
  VolumeSearch(::google::protobuf::Arena* arena, VolumeSearch&& from) noexcept
      : VolumeSearch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPriorsFieldNumber = 2,
    kParticipantsFieldNumber = 3,
    kControlAreasFieldNumber = 4,
    kObjectiveFieldNumber = 1,
  };
  // repeated .anduril.tasks.v2.Prior priors = 2 [json_name = "priors"];
  int priors_size() const;
  private:
  int _internal_priors_size() const;

  public:
  void clear_priors() ;
  ::anduril::tasks::v2::Prior* mutable_priors(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>* mutable_priors();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>& _internal_priors() const;
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>* _internal_mutable_priors();
  public:
  const ::anduril::tasks::v2::Prior& priors(int index) const;
  ::anduril::tasks::v2::Prior* add_priors();
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>& priors() const;
  // repeated .anduril.tasks.v2.Agent participants = 3 [json_name = "participants"];
  int participants_size() const;
  private:
  int _internal_participants_size() const;

  public:
  void clear_participants() ;
  ::anduril::tasks::v2::Agent* mutable_participants(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>* mutable_participants();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>& _internal_participants() const;
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>* _internal_mutable_participants();
  public:
  const ::anduril::tasks::v2::Agent& participants(int index) const;
  ::anduril::tasks::v2::Agent* add_participants();
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>& participants() const;
  // repeated .anduril.tasks.v2.ControlArea control_areas = 4 [json_name = "controlAreas"];
  int control_areas_size() const;
  private:
  int _internal_control_areas_size() const;

  public:
  void clear_control_areas() ;
  ::anduril::tasks::v2::ControlArea* mutable_control_areas(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>* mutable_control_areas();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>& _internal_control_areas() const;
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>* _internal_mutable_control_areas();
  public:
  const ::anduril::tasks::v2::ControlArea& control_areas(int index) const;
  ::anduril::tasks::v2::ControlArea* add_control_areas();
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>& control_areas() const;
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.VolumeSearch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_VolumeSearch_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VolumeSearch& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::Prior > priors_;
    ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::Agent > participants_;
    ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::ControlArea > control_areas_;
    ::anduril::tasks::v2::Objective* objective_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class VisualId final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.VisualId) */ {
 public:
  inline VisualId() : VisualId(nullptr) {}
  ~VisualId() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VisualId(
      ::google::protobuf::internal::ConstantInitialized);

  inline VisualId(const VisualId& from) : VisualId(nullptr, from) {}
  inline VisualId(VisualId&& from) noexcept
      : VisualId(nullptr, std::move(from)) {}
  inline VisualId& operator=(const VisualId& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisualId& operator=(VisualId&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisualId& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisualId* internal_default_instance() {
    return reinterpret_cast<const VisualId*>(
        &_VisualId_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(VisualId& a, VisualId& b) { a.Swap(&b); }
  inline void Swap(VisualId* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisualId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisualId* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<VisualId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisualId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VisualId& from) { VisualId::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisualId* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.VisualId"; }

 protected:
  explicit VisualId(::google::protobuf::Arena* arena);
  VisualId(::google::protobuf::Arena* arena, const VisualId& from);
  VisualId(::google::protobuf::Arena* arena, VisualId&& from) noexcept
      : VisualId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectiveFieldNumber = 1,
    kParametersFieldNumber = 2,
  };
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
  bool has_parameters() const;
  void clear_parameters() ;
  const ::anduril::tasks::v2::ISRParameters& parameters() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::ISRParameters* release_parameters();
  ::anduril::tasks::v2::ISRParameters* mutable_parameters();
  void set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  void unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  ::anduril::tasks::v2::ISRParameters* unsafe_arena_release_parameters();

  private:
  const ::anduril::tasks::v2::ISRParameters& _internal_parameters() const;
  ::anduril::tasks::v2::ISRParameters* _internal_mutable_parameters();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.VisualId)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_VisualId_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VisualId& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::Objective* objective_;
    ::anduril::tasks::v2::ISRParameters* parameters_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class Shadow final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.Shadow) */ {
 public:
  inline Shadow() : Shadow(nullptr) {}
  ~Shadow() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Shadow(
      ::google::protobuf::internal::ConstantInitialized);

  inline Shadow(const Shadow& from) : Shadow(nullptr, from) {}
  inline Shadow(Shadow&& from) noexcept
      : Shadow(nullptr, std::move(from)) {}
  inline Shadow& operator=(const Shadow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shadow& operator=(Shadow&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shadow& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shadow* internal_default_instance() {
    return reinterpret_cast<const Shadow*>(
        &_Shadow_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Shadow& a, Shadow& b) { a.Swap(&b); }
  inline void Swap(Shadow* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shadow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shadow* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Shadow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Shadow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Shadow& from) { Shadow::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Shadow* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.Shadow"; }

 protected:
  explicit Shadow(::google::protobuf::Arena* arena);
  Shadow(::google::protobuf::Arena* arena, const Shadow& from);
  Shadow(::google::protobuf::Arena* arena, Shadow&& from) noexcept
      : Shadow(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectiveFieldNumber = 1,
    kParametersFieldNumber = 2,
  };
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
  bool has_parameters() const;
  void clear_parameters() ;
  const ::anduril::tasks::v2::ISRParameters& parameters() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::ISRParameters* release_parameters();
  ::anduril::tasks::v2::ISRParameters* mutable_parameters();
  void set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  void unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  ::anduril::tasks::v2::ISRParameters* unsafe_arena_release_parameters();

  private:
  const ::anduril::tasks::v2::ISRParameters& _internal_parameters() const;
  ::anduril::tasks::v2::ISRParameters* _internal_mutable_parameters();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.Shadow)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Shadow_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Shadow& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::Objective* objective_;
    ::anduril::tasks::v2::ISRParameters* parameters_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class Scan final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.Scan) */ {
 public:
  inline Scan() : Scan(nullptr) {}
  ~Scan() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Scan(
      ::google::protobuf::internal::ConstantInitialized);

  inline Scan(const Scan& from) : Scan(nullptr, from) {}
  inline Scan(Scan&& from) noexcept
      : Scan(nullptr, std::move(from)) {}
  inline Scan& operator=(const Scan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scan& operator=(Scan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Scan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Scan* internal_default_instance() {
    return reinterpret_cast<const Scan*>(
        &_Scan_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(Scan& a, Scan& b) { a.Swap(&b); }
  inline void Swap(Scan* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Scan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Scan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Scan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Scan& from) { Scan::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Scan* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.Scan"; }

 protected:
  explicit Scan(::google::protobuf::Arena* arena);
  Scan(::google::protobuf::Arena* arena, const Scan& from);
  Scan(::google::protobuf::Arena* arena, Scan&& from) noexcept
      : Scan(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectiveFieldNumber = 1,
    kParametersFieldNumber = 2,
  };
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
  bool has_parameters() const;
  void clear_parameters() ;
  const ::anduril::tasks::v2::ISRParameters& parameters() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::ISRParameters* release_parameters();
  ::anduril::tasks::v2::ISRParameters* mutable_parameters();
  void set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  void unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  ::anduril::tasks::v2::ISRParameters* unsafe_arena_release_parameters();

  private:
  const ::anduril::tasks::v2::ISRParameters& _internal_parameters() const;
  ::anduril::tasks::v2::ISRParameters* _internal_mutable_parameters();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.Scan)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Scan_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Scan& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::Objective* objective_;
    ::anduril::tasks::v2::ISRParameters* parameters_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class OrbitType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.OrbitType) */ {
 public:
  inline OrbitType() : OrbitType(nullptr) {}
  ~OrbitType() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrbitType(
      ::google::protobuf::internal::ConstantInitialized);

  inline OrbitType(const OrbitType& from) : OrbitType(nullptr, from) {}
  inline OrbitType(OrbitType&& from) noexcept
      : OrbitType(nullptr, std::move(from)) {}
  inline OrbitType& operator=(const OrbitType& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrbitType& operator=(OrbitType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrbitType& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrbitType* internal_default_instance() {
    return reinterpret_cast<const OrbitType*>(
        &_OrbitType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(OrbitType& a, OrbitType& b) { a.Swap(&b); }
  inline void Swap(OrbitType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrbitType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrbitType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<OrbitType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrbitType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OrbitType& from) { OrbitType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OrbitType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.OrbitType"; }

 protected:
  explicit OrbitType(::google::protobuf::Arena* arena);
  OrbitType(::google::protobuf::Arena* arena, const OrbitType& from);
  OrbitType(::google::protobuf::Arena* arena, OrbitType&& from) noexcept
      : OrbitType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDurationFieldNumber = 3,
    kDirectionFieldNumber = 1,
    kPatternFieldNumber = 2,
  };
  // .anduril.tasks.v2.OrbitDuration duration = 3 [json_name = "duration"];
  bool has_duration() const;
  void clear_duration() ;
  const ::anduril::tasks::v2::OrbitDuration& duration() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::OrbitDuration* release_duration();
  ::anduril::tasks::v2::OrbitDuration* mutable_duration();
  void set_allocated_duration(::anduril::tasks::v2::OrbitDuration* value);
  void unsafe_arena_set_allocated_duration(::anduril::tasks::v2::OrbitDuration* value);
  ::anduril::tasks::v2::OrbitDuration* unsafe_arena_release_duration();

  private:
  const ::anduril::tasks::v2::OrbitDuration& _internal_duration() const;
  ::anduril::tasks::v2::OrbitDuration* _internal_mutable_duration();

  public:
  // .anduril.tasks.v2.OrbitDirection direction = 1 [json_name = "direction"];
  void clear_direction() ;
  ::anduril::tasks::v2::OrbitDirection direction() const;
  void set_direction(::anduril::tasks::v2::OrbitDirection value);

  private:
  ::anduril::tasks::v2::OrbitDirection _internal_direction() const;
  void _internal_set_direction(::anduril::tasks::v2::OrbitDirection value);

  public:
  // .anduril.tasks.v2.OrbitPattern pattern = 2 [json_name = "pattern"];
  void clear_pattern() ;
  ::anduril::tasks::v2::OrbitPattern pattern() const;
  void set_pattern(::anduril::tasks::v2::OrbitPattern value);

  private:
  ::anduril::tasks::v2::OrbitPattern _internal_pattern() const;
  void _internal_set_pattern(::anduril::tasks::v2::OrbitPattern value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.OrbitType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_OrbitType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OrbitType& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::OrbitDuration* duration_;
    int direction_;
    int pattern_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class Monitor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.Monitor) */ {
 public:
  inline Monitor() : Monitor(nullptr) {}
  ~Monitor() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Monitor(
      ::google::protobuf::internal::ConstantInitialized);

  inline Monitor(const Monitor& from) : Monitor(nullptr, from) {}
  inline Monitor(Monitor&& from) noexcept
      : Monitor(nullptr, std::move(from)) {}
  inline Monitor& operator=(const Monitor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Monitor& operator=(Monitor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Monitor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Monitor* internal_default_instance() {
    return reinterpret_cast<const Monitor*>(
        &_Monitor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(Monitor& a, Monitor& b) { a.Swap(&b); }
  inline void Swap(Monitor* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Monitor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Monitor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Monitor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Monitor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Monitor& from) { Monitor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Monitor* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.Monitor"; }

 protected:
  explicit Monitor(::google::protobuf::Arena* arena);
  Monitor(::google::protobuf::Arena* arena, const Monitor& from);
  Monitor(::google::protobuf::Arena* arena, Monitor&& from) noexcept
      : Monitor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackIdFieldNumber = 2,
    kTrackProducerFieldNumber = 3,
    kObjectiveFieldNumber = 1,
  };
  // string track_id = 2 [json_name = "trackId"];
  void clear_track_id() ;
  const std::string& track_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_id(Arg_&& arg, Args_... args);
  std::string* mutable_track_id();
  PROTOBUF_NODISCARD std::string* release_track_id();
  void set_allocated_track_id(std::string* value);

  private:
  const std::string& _internal_track_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_id(
      const std::string& value);
  std::string* _internal_mutable_track_id();

  public:
  // string track_producer = 3 [json_name = "trackProducer"];
  void clear_track_producer() ;
  const std::string& track_producer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_producer(Arg_&& arg, Args_... args);
  std::string* mutable_track_producer();
  PROTOBUF_NODISCARD std::string* release_track_producer();
  void set_allocated_track_producer(std::string* value);

  private:
  const std::string& _internal_track_producer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_producer(
      const std::string& value);
  std::string* _internal_mutable_track_producer();

  public:
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.Monitor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      55, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Monitor_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Monitor& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr track_id_;
    ::google::protobuf::internal::ArenaStringPtr track_producer_;
    ::anduril::tasks::v2::Objective* objective_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class Map final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.Map) */ {
 public:
  inline Map() : Map(nullptr) {}
  ~Map() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Map(
      ::google::protobuf::internal::ConstantInitialized);

  inline Map(const Map& from) : Map(nullptr, from) {}
  inline Map(Map&& from) noexcept
      : Map(nullptr, std::move(from)) {}
  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map& operator=(Map&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map* internal_default_instance() {
    return reinterpret_cast<const Map*>(
        &_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Map& a, Map& b) { a.Swap(&b); }
  inline void Swap(Map* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Map>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Map& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Map& from) { Map::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Map* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.Map"; }

 protected:
  explicit Map(::google::protobuf::Arena* arena);
  Map(::google::protobuf::Arena* arena, const Map& from);
  Map(::google::protobuf::Arena* arena, Map&& from) noexcept
      : Map(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectiveFieldNumber = 1,
    kParametersFieldNumber = 2,
    kMinNiirsFieldNumber = 3,
  };
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
  bool has_parameters() const;
  void clear_parameters() ;
  const ::anduril::tasks::v2::ISRParameters& parameters() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::ISRParameters* release_parameters();
  ::anduril::tasks::v2::ISRParameters* mutable_parameters();
  void set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  void unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  ::anduril::tasks::v2::ISRParameters* unsafe_arena_release_parameters();

  private:
  const ::anduril::tasks::v2::ISRParameters& _internal_parameters() const;
  ::anduril::tasks::v2::ISRParameters* _internal_mutable_parameters();

  public:
  // .google.protobuf.UInt32Value min_niirs = 3 [json_name = "minNiirs"];
  bool has_min_niirs() const;
  void clear_min_niirs() ;
  const ::google::protobuf::UInt32Value& min_niirs() const;
  PROTOBUF_NODISCARD ::google::protobuf::UInt32Value* release_min_niirs();
  ::google::protobuf::UInt32Value* mutable_min_niirs();
  void set_allocated_min_niirs(::google::protobuf::UInt32Value* value);
  void unsafe_arena_set_allocated_min_niirs(::google::protobuf::UInt32Value* value);
  ::google::protobuf::UInt32Value* unsafe_arena_release_min_niirs();

  private:
  const ::google::protobuf::UInt32Value& _internal_min_niirs() const;
  ::google::protobuf::UInt32Value* _internal_mutable_min_niirs();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.Map)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Map_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Map& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::Objective* objective_;
    ::anduril::tasks::v2::ISRParameters* parameters_;
    ::google::protobuf::UInt32Value* min_niirs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class Investigate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.Investigate) */ {
 public:
  inline Investigate() : Investigate(nullptr) {}
  ~Investigate() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Investigate(
      ::google::protobuf::internal::ConstantInitialized);

  inline Investigate(const Investigate& from) : Investigate(nullptr, from) {}
  inline Investigate(Investigate&& from) noexcept
      : Investigate(nullptr, std::move(from)) {}
  inline Investigate& operator=(const Investigate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Investigate& operator=(Investigate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Investigate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Investigate* internal_default_instance() {
    return reinterpret_cast<const Investigate*>(
        &_Investigate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Investigate& a, Investigate& b) { a.Swap(&b); }
  inline void Swap(Investigate* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Investigate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Investigate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Investigate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Investigate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Investigate& from) { Investigate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Investigate* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.Investigate"; }

 protected:
  explicit Investigate(::google::protobuf::Arena* arena);
  Investigate(::google::protobuf::Arena* arena, const Investigate& from);
  Investigate(::google::protobuf::Arena* arena, Investigate&& from) noexcept
      : Investigate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectiveFieldNumber = 1,
    kParametersFieldNumber = 2,
  };
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
  bool has_parameters() const;
  void clear_parameters() ;
  const ::anduril::tasks::v2::ISRParameters& parameters() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::ISRParameters* release_parameters();
  ::anduril::tasks::v2::ISRParameters* mutable_parameters();
  void set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  void unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  ::anduril::tasks::v2::ISRParameters* unsafe_arena_release_parameters();

  private:
  const ::anduril::tasks::v2::ISRParameters& _internal_parameters() const;
  ::anduril::tasks::v2::ISRParameters* _internal_mutable_parameters();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.Investigate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Investigate_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Investigate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::Objective* objective_;
    ::anduril::tasks::v2::ISRParameters* parameters_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class ImproveTrackQuality final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.ImproveTrackQuality) */ {
 public:
  inline ImproveTrackQuality() : ImproveTrackQuality(nullptr) {}
  ~ImproveTrackQuality() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ImproveTrackQuality(
      ::google::protobuf::internal::ConstantInitialized);

  inline ImproveTrackQuality(const ImproveTrackQuality& from) : ImproveTrackQuality(nullptr, from) {}
  inline ImproveTrackQuality(ImproveTrackQuality&& from) noexcept
      : ImproveTrackQuality(nullptr, std::move(from)) {}
  inline ImproveTrackQuality& operator=(const ImproveTrackQuality& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImproveTrackQuality& operator=(ImproveTrackQuality&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImproveTrackQuality& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImproveTrackQuality* internal_default_instance() {
    return reinterpret_cast<const ImproveTrackQuality*>(
        &_ImproveTrackQuality_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ImproveTrackQuality& a, ImproveTrackQuality& b) { a.Swap(&b); }
  inline void Swap(ImproveTrackQuality* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImproveTrackQuality* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImproveTrackQuality* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ImproveTrackQuality>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ImproveTrackQuality& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ImproveTrackQuality& from) { ImproveTrackQuality::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ImproveTrackQuality* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.ImproveTrackQuality"; }

 protected:
  explicit ImproveTrackQuality(::google::protobuf::Arena* arena);
  ImproveTrackQuality(::google::protobuf::Arena* arena, const ImproveTrackQuality& from);
  ImproveTrackQuality(::google::protobuf::Arena* arena, ImproveTrackQuality&& from) noexcept
      : ImproveTrackQuality(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectiveFieldNumber = 1,
    kTerminationTrackQualityFieldNumber = 2,
  };
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // uint32 termination_track_quality = 2 [json_name = "terminationTrackQuality"];
  void clear_termination_track_quality() ;
  ::uint32_t termination_track_quality() const;
  void set_termination_track_quality(::uint32_t value);

  private:
  ::uint32_t _internal_termination_track_quality() const;
  void _internal_set_termination_track_quality(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.ImproveTrackQuality)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ImproveTrackQuality_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ImproveTrackQuality& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::Objective* objective_;
    ::uint32_t termination_track_quality_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class GimbalPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.GimbalPoint) */ {
 public:
  inline GimbalPoint() : GimbalPoint(nullptr) {}
  ~GimbalPoint() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GimbalPoint(
      ::google::protobuf::internal::ConstantInitialized);

  inline GimbalPoint(const GimbalPoint& from) : GimbalPoint(nullptr, from) {}
  inline GimbalPoint(GimbalPoint&& from) noexcept
      : GimbalPoint(nullptr, std::move(from)) {}
  inline GimbalPoint& operator=(const GimbalPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline GimbalPoint& operator=(GimbalPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GimbalPoint& default_instance() {
    return *internal_default_instance();
  }
  enum PointTypeCase {
    kLookAt = 1,
    kCelestialLocation = 2,
    kFrameLocation = 4,
    POINT_TYPE_NOT_SET = 0,
  };
  static inline const GimbalPoint* internal_default_instance() {
    return reinterpret_cast<const GimbalPoint*>(
        &_GimbalPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(GimbalPoint& a, GimbalPoint& b) { a.Swap(&b); }
  inline void Swap(GimbalPoint* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GimbalPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GimbalPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GimbalPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GimbalPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GimbalPoint& from) { GimbalPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GimbalPoint* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.GimbalPoint"; }

 protected:
  explicit GimbalPoint(::google::protobuf::Arena* arena);
  GimbalPoint(::google::protobuf::Arena* arena, const GimbalPoint& from);
  GimbalPoint(::google::protobuf::Arena* arena, GimbalPoint&& from) noexcept
      : GimbalPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParametersFieldNumber = 3,
    kLookAtFieldNumber = 1,
    kCelestialLocationFieldNumber = 2,
    kFrameLocationFieldNumber = 4,
  };
  // .anduril.tasks.v2.ISRParameters parameters = 3 [json_name = "parameters"];
  bool has_parameters() const;
  void clear_parameters() ;
  const ::anduril::tasks::v2::ISRParameters& parameters() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::ISRParameters* release_parameters();
  ::anduril::tasks::v2::ISRParameters* mutable_parameters();
  void set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  void unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  ::anduril::tasks::v2::ISRParameters* unsafe_arena_release_parameters();

  private:
  const ::anduril::tasks::v2::ISRParameters& _internal_parameters() const;
  ::anduril::tasks::v2::ISRParameters* _internal_mutable_parameters();

  public:
  // .anduril.tasks.v2.Objective look_at = 1 [json_name = "lookAt"];
  bool has_look_at() const;
  private:
  bool _internal_has_look_at() const;

  public:
  void clear_look_at() ;
  const ::anduril::tasks::v2::Objective& look_at() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_look_at();
  ::anduril::tasks::v2::Objective* mutable_look_at();
  void set_allocated_look_at(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_look_at(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_look_at();

  private:
  const ::anduril::tasks::v2::Objective& _internal_look_at() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_look_at();

  public:
  // .anduril.tasks.v2.AzimuthElevationPoint celestial_location = 2 [json_name = "celestialLocation"];
  bool has_celestial_location() const;
  private:
  bool _internal_has_celestial_location() const;

  public:
  void clear_celestial_location() ;
  const ::anduril::tasks::v2::AzimuthElevationPoint& celestial_location() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::AzimuthElevationPoint* release_celestial_location();
  ::anduril::tasks::v2::AzimuthElevationPoint* mutable_celestial_location();
  void set_allocated_celestial_location(::anduril::tasks::v2::AzimuthElevationPoint* value);
  void unsafe_arena_set_allocated_celestial_location(::anduril::tasks::v2::AzimuthElevationPoint* value);
  ::anduril::tasks::v2::AzimuthElevationPoint* unsafe_arena_release_celestial_location();

  private:
  const ::anduril::tasks::v2::AzimuthElevationPoint& _internal_celestial_location() const;
  ::anduril::tasks::v2::AzimuthElevationPoint* _internal_mutable_celestial_location();

  public:
  // .anduril.tasks.v2.FramePoint frame_location = 4 [json_name = "frameLocation"];
  bool has_frame_location() const;
  private:
  bool _internal_has_frame_location() const;

  public:
  void clear_frame_location() ;
  const ::anduril::tasks::v2::FramePoint& frame_location() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::FramePoint* release_frame_location();
  ::anduril::tasks::v2::FramePoint* mutable_frame_location();
  void set_allocated_frame_location(::anduril::tasks::v2::FramePoint* value);
  void unsafe_arena_set_allocated_frame_location(::anduril::tasks::v2::FramePoint* value);
  ::anduril::tasks::v2::FramePoint* unsafe_arena_release_frame_location();

  private:
  const ::anduril::tasks::v2::FramePoint& _internal_frame_location() const;
  ::anduril::tasks::v2::FramePoint* _internal_mutable_frame_location();

  public:
  void clear_point_type();
  PointTypeCase point_type_case() const;
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.GimbalPoint)
 private:
  class _Internal;
  void set_has_look_at();
  void set_has_celestial_location();
  void set_has_frame_location();
  inline bool has_point_type() const;
  inline void clear_has_point_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GimbalPoint_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GimbalPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::ISRParameters* parameters_;
    union PointTypeUnion {
      constexpr PointTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::tasks::v2::Objective* look_at_;
      ::anduril::tasks::v2::AzimuthElevationPoint* celestial_location_;
      ::anduril::tasks::v2::FramePoint* frame_location_;
    } point_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class BattleDamageAssessment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.BattleDamageAssessment) */ {
 public:
  inline BattleDamageAssessment() : BattleDamageAssessment(nullptr) {}
  ~BattleDamageAssessment() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleDamageAssessment(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleDamageAssessment(const BattleDamageAssessment& from) : BattleDamageAssessment(nullptr, from) {}
  inline BattleDamageAssessment(BattleDamageAssessment&& from) noexcept
      : BattleDamageAssessment(nullptr, std::move(from)) {}
  inline BattleDamageAssessment& operator=(const BattleDamageAssessment& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleDamageAssessment& operator=(BattleDamageAssessment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleDamageAssessment& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleDamageAssessment* internal_default_instance() {
    return reinterpret_cast<const BattleDamageAssessment*>(
        &_BattleDamageAssessment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(BattleDamageAssessment& a, BattleDamageAssessment& b) { a.Swap(&b); }
  inline void Swap(BattleDamageAssessment* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleDamageAssessment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleDamageAssessment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleDamageAssessment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleDamageAssessment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleDamageAssessment& from) { BattleDamageAssessment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleDamageAssessment* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.BattleDamageAssessment"; }

 protected:
  explicit BattleDamageAssessment(::google::protobuf::Arena* arena);
  BattleDamageAssessment(::google::protobuf::Arena* arena, const BattleDamageAssessment& from);
  BattleDamageAssessment(::google::protobuf::Arena* arena, BattleDamageAssessment&& from) noexcept
      : BattleDamageAssessment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectiveFieldNumber = 1,
    kParametersFieldNumber = 2,
  };
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
  bool has_parameters() const;
  void clear_parameters() ;
  const ::anduril::tasks::v2::ISRParameters& parameters() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::ISRParameters* release_parameters();
  ::anduril::tasks::v2::ISRParameters* mutable_parameters();
  void set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  void unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  ::anduril::tasks::v2::ISRParameters* unsafe_arena_release_parameters();

  private:
  const ::anduril::tasks::v2::ISRParameters& _internal_parameters() const;
  ::anduril::tasks::v2::ISRParameters* _internal_mutable_parameters();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.BattleDamageAssessment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_BattleDamageAssessment_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BattleDamageAssessment& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::Objective* objective_;
    ::anduril::tasks::v2::ISRParameters* parameters_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class AreaSearch final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.AreaSearch) */ {
 public:
  inline AreaSearch() : AreaSearch(nullptr) {}
  ~AreaSearch() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AreaSearch(
      ::google::protobuf::internal::ConstantInitialized);

  inline AreaSearch(const AreaSearch& from) : AreaSearch(nullptr, from) {}
  inline AreaSearch(AreaSearch&& from) noexcept
      : AreaSearch(nullptr, std::move(from)) {}
  inline AreaSearch& operator=(const AreaSearch& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaSearch& operator=(AreaSearch&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AreaSearch& default_instance() {
    return *internal_default_instance();
  }
  static inline const AreaSearch* internal_default_instance() {
    return reinterpret_cast<const AreaSearch*>(
        &_AreaSearch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AreaSearch& a, AreaSearch& b) { a.Swap(&b); }
  inline void Swap(AreaSearch* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaSearch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaSearch* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AreaSearch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AreaSearch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AreaSearch& from) { AreaSearch::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AreaSearch* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.AreaSearch"; }

 protected:
  explicit AreaSearch(::google::protobuf::Arena* arena);
  AreaSearch(::google::protobuf::Arena* arena, const AreaSearch& from);
  AreaSearch(::google::protobuf::Arena* arena, AreaSearch&& from) noexcept
      : AreaSearch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPriorsFieldNumber = 2,
    kParticipantsFieldNumber = 3,
    kControlAreasFieldNumber = 4,
    kObjectiveFieldNumber = 1,
  };
  // repeated .anduril.tasks.v2.Prior priors = 2 [json_name = "priors"];
  int priors_size() const;
  private:
  int _internal_priors_size() const;

  public:
  void clear_priors() ;
  ::anduril::tasks::v2::Prior* mutable_priors(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>* mutable_priors();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>& _internal_priors() const;
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>* _internal_mutable_priors();
  public:
  const ::anduril::tasks::v2::Prior& priors(int index) const;
  ::anduril::tasks::v2::Prior* add_priors();
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>& priors() const;
  // repeated .anduril.tasks.v2.Agent participants = 3 [json_name = "participants"];
  int participants_size() const;
  private:
  int _internal_participants_size() const;

  public:
  void clear_participants() ;
  ::anduril::tasks::v2::Agent* mutable_participants(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>* mutable_participants();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>& _internal_participants() const;
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>* _internal_mutable_participants();
  public:
  const ::anduril::tasks::v2::Agent& participants(int index) const;
  ::anduril::tasks::v2::Agent* add_participants();
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>& participants() const;
  // repeated .anduril.tasks.v2.ControlArea control_areas = 4 [json_name = "controlAreas"];
  int control_areas_size() const;
  private:
  int _internal_control_areas_size() const;

  public:
  void clear_control_areas() ;
  ::anduril::tasks::v2::ControlArea* mutable_control_areas(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>* mutable_control_areas();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>& _internal_control_areas() const;
  ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>* _internal_mutable_control_areas();
  public:
  const ::anduril::tasks::v2::ControlArea& control_areas(int index) const;
  ::anduril::tasks::v2::ControlArea* add_control_areas();
  const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>& control_areas() const;
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.AreaSearch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AreaSearch_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AreaSearch& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::Prior > priors_;
    ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::Agent > participants_;
    ::google::protobuf::RepeatedPtrField< ::anduril::tasks::v2::ControlArea > control_areas_;
    ::anduril::tasks::v2::Objective* objective_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class LoiterType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.LoiterType) */ {
 public:
  inline LoiterType() : LoiterType(nullptr) {}
  ~LoiterType() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoiterType(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoiterType(const LoiterType& from) : LoiterType(nullptr, from) {}
  inline LoiterType(LoiterType&& from) noexcept
      : LoiterType(nullptr, std::move(from)) {}
  inline LoiterType& operator=(const LoiterType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoiterType& operator=(LoiterType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoiterType& default_instance() {
    return *internal_default_instance();
  }
  enum LoiterTypeCase {
    kOrbitType = 1,
    LOITER_TYPE_NOT_SET = 0,
  };
  static inline const LoiterType* internal_default_instance() {
    return reinterpret_cast<const LoiterType*>(
        &_LoiterType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(LoiterType& a, LoiterType& b) { a.Swap(&b); }
  inline void Swap(LoiterType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoiterType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoiterType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LoiterType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoiterType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoiterType& from) { LoiterType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoiterType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.LoiterType"; }

 protected:
  explicit LoiterType(::google::protobuf::Arena* arena);
  LoiterType(::google::protobuf::Arena* arena, const LoiterType& from);
  LoiterType(::google::protobuf::Arena* arena, LoiterType&& from) noexcept
      : LoiterType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrbitTypeFieldNumber = 1,
  };
  // .anduril.tasks.v2.OrbitType orbit_type = 1 [json_name = "orbitType"];
  bool has_orbit_type() const;
  private:
  bool _internal_has_orbit_type() const;

  public:
  void clear_orbit_type() ;
  const ::anduril::tasks::v2::OrbitType& orbit_type() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::OrbitType* release_orbit_type();
  ::anduril::tasks::v2::OrbitType* mutable_orbit_type();
  void set_allocated_orbit_type(::anduril::tasks::v2::OrbitType* value);
  void unsafe_arena_set_allocated_orbit_type(::anduril::tasks::v2::OrbitType* value);
  ::anduril::tasks::v2::OrbitType* unsafe_arena_release_orbit_type();

  private:
  const ::anduril::tasks::v2::OrbitType& _internal_orbit_type() const;
  ::anduril::tasks::v2::OrbitType* _internal_mutable_orbit_type();

  public:
  void clear_loiter_type();
  LoiterTypeCase loiter_type_case() const;
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.LoiterType)
 private:
  class _Internal;
  void set_has_orbit_type();
  inline bool has_loiter_type() const;
  inline void clear_has_loiter_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LoiterType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoiterType& from_msg);
    union LoiterTypeUnion {
      constexpr LoiterTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::tasks::v2::OrbitType* orbit_type_;
    } loiter_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};
// -------------------------------------------------------------------

class Loiter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.tasks.v2.Loiter) */ {
 public:
  inline Loiter() : Loiter(nullptr) {}
  ~Loiter() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Loiter(
      ::google::protobuf::internal::ConstantInitialized);

  inline Loiter(const Loiter& from) : Loiter(nullptr, from) {}
  inline Loiter(Loiter&& from) noexcept
      : Loiter(nullptr, std::move(from)) {}
  inline Loiter& operator=(const Loiter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Loiter& operator=(Loiter&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Loiter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Loiter* internal_default_instance() {
    return reinterpret_cast<const Loiter*>(
        &_Loiter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Loiter& a, Loiter& b) { a.Swap(&b); }
  inline void Swap(Loiter* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Loiter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Loiter* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Loiter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Loiter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Loiter& from) { Loiter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Loiter* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.tasks.v2.Loiter"; }

 protected:
  explicit Loiter(::google::protobuf::Arena* arena);
  Loiter(::google::protobuf::Arena* arena, const Loiter& from);
  Loiter(::google::protobuf::Arena* arena, Loiter&& from) noexcept
      : Loiter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectiveFieldNumber = 1,
    kLoiterTypeFieldNumber = 2,
    kParametersFieldNumber = 3,
  };
  // .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
  bool has_objective() const;
  void clear_objective() ;
  const ::anduril::tasks::v2::Objective& objective() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::Objective* release_objective();
  ::anduril::tasks::v2::Objective* mutable_objective();
  void set_allocated_objective(::anduril::tasks::v2::Objective* value);
  void unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value);
  ::anduril::tasks::v2::Objective* unsafe_arena_release_objective();

  private:
  const ::anduril::tasks::v2::Objective& _internal_objective() const;
  ::anduril::tasks::v2::Objective* _internal_mutable_objective();

  public:
  // .anduril.tasks.v2.LoiterType loiter_type = 2 [json_name = "loiterType"];
  bool has_loiter_type() const;
  void clear_loiter_type() ;
  const ::anduril::tasks::v2::LoiterType& loiter_type() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::LoiterType* release_loiter_type();
  ::anduril::tasks::v2::LoiterType* mutable_loiter_type();
  void set_allocated_loiter_type(::anduril::tasks::v2::LoiterType* value);
  void unsafe_arena_set_allocated_loiter_type(::anduril::tasks::v2::LoiterType* value);
  ::anduril::tasks::v2::LoiterType* unsafe_arena_release_loiter_type();

  private:
  const ::anduril::tasks::v2::LoiterType& _internal_loiter_type() const;
  ::anduril::tasks::v2::LoiterType* _internal_mutable_loiter_type();

  public:
  // .anduril.tasks.v2.ISRParameters parameters = 3 [json_name = "parameters"];
  bool has_parameters() const;
  void clear_parameters() ;
  const ::anduril::tasks::v2::ISRParameters& parameters() const;
  PROTOBUF_NODISCARD ::anduril::tasks::v2::ISRParameters* release_parameters();
  ::anduril::tasks::v2::ISRParameters* mutable_parameters();
  void set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  void unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value);
  ::anduril::tasks::v2::ISRParameters* unsafe_arena_release_parameters();

  private:
  const ::anduril::tasks::v2::ISRParameters& _internal_parameters() const;
  ::anduril::tasks::v2::ISRParameters* _internal_mutable_parameters();

  public:
  // @@protoc_insertion_point(class_scope:anduril.tasks.v2.Loiter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Loiter_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Loiter& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::anduril::tasks::v2::Objective* objective_;
    ::anduril::tasks::v2::LoiterType* loiter_type_;
    ::anduril::tasks::v2::ISRParameters* parameters_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Investigate

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool Investigate::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& Investigate::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& Investigate::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Investigate.objective)
  return _internal_objective();
}
inline void Investigate::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Investigate.objective)
}
inline ::anduril::tasks::v2::Objective* Investigate::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* Investigate::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Investigate.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* Investigate::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* Investigate::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Investigate.objective)
  return _msg;
}
inline void Investigate::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Investigate.objective)
}

// .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
inline bool Investigate::has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline void Investigate::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::tasks::v2::ISRParameters& Investigate::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::ISRParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::ISRParameters&>(::anduril::tasks::v2::_ISRParameters_default_instance_);
}
inline const ::anduril::tasks::v2::ISRParameters& Investigate::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Investigate.parameters)
  return _internal_parameters();
}
inline void Investigate::unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Investigate.parameters)
}
inline ::anduril::tasks::v2::ISRParameters* Investigate::release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* released = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::ISRParameters* Investigate::unsafe_arena_release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Investigate.parameters)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::ISRParameters* Investigate::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::ISRParameters>(GetArena());
    _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(p);
  }
  return _impl_.parameters_;
}
inline ::anduril::tasks::v2::ISRParameters* Investigate::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::tasks::v2::ISRParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Investigate.parameters)
  return _msg;
}
inline void Investigate::set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.parameters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Investigate.parameters)
}

// -------------------------------------------------------------------

// VisualId

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool VisualId::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& VisualId::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& VisualId::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.VisualId.objective)
  return _internal_objective();
}
inline void VisualId::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.VisualId.objective)
}
inline ::anduril::tasks::v2::Objective* VisualId::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* VisualId::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.VisualId.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* VisualId::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* VisualId::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.VisualId.objective)
  return _msg;
}
inline void VisualId::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.VisualId.objective)
}

// .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
inline bool VisualId::has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline void VisualId::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::tasks::v2::ISRParameters& VisualId::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::ISRParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::ISRParameters&>(::anduril::tasks::v2::_ISRParameters_default_instance_);
}
inline const ::anduril::tasks::v2::ISRParameters& VisualId::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.VisualId.parameters)
  return _internal_parameters();
}
inline void VisualId::unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.VisualId.parameters)
}
inline ::anduril::tasks::v2::ISRParameters* VisualId::release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* released = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::ISRParameters* VisualId::unsafe_arena_release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.VisualId.parameters)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::ISRParameters* VisualId::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::ISRParameters>(GetArena());
    _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(p);
  }
  return _impl_.parameters_;
}
inline ::anduril::tasks::v2::ISRParameters* VisualId::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::tasks::v2::ISRParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.VisualId.parameters)
  return _msg;
}
inline void VisualId::set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.parameters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.VisualId.parameters)
}

// -------------------------------------------------------------------

// Map

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool Map::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& Map::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& Map::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Map.objective)
  return _internal_objective();
}
inline void Map::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Map.objective)
}
inline ::anduril::tasks::v2::Objective* Map::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* Map::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Map.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* Map::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* Map::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Map.objective)
  return _msg;
}
inline void Map::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Map.objective)
}

// .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
inline bool Map::has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline void Map::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::tasks::v2::ISRParameters& Map::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::ISRParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::ISRParameters&>(::anduril::tasks::v2::_ISRParameters_default_instance_);
}
inline const ::anduril::tasks::v2::ISRParameters& Map::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Map.parameters)
  return _internal_parameters();
}
inline void Map::unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Map.parameters)
}
inline ::anduril::tasks::v2::ISRParameters* Map::release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* released = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::ISRParameters* Map::unsafe_arena_release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Map.parameters)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::ISRParameters* Map::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::ISRParameters>(GetArena());
    _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(p);
  }
  return _impl_.parameters_;
}
inline ::anduril::tasks::v2::ISRParameters* Map::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::tasks::v2::ISRParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Map.parameters)
  return _msg;
}
inline void Map::set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.parameters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Map.parameters)
}

// .google.protobuf.UInt32Value min_niirs = 3 [json_name = "minNiirs"];
inline bool Map::has_min_niirs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_niirs_ != nullptr);
  return value;
}
inline const ::google::protobuf::UInt32Value& Map::_internal_min_niirs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::UInt32Value* p = _impl_.min_niirs_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::UInt32Value&>(::google::protobuf::_UInt32Value_default_instance_);
}
inline const ::google::protobuf::UInt32Value& Map::min_niirs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Map.min_niirs)
  return _internal_min_niirs();
}
inline void Map::unsafe_arena_set_allocated_min_niirs(::google::protobuf::UInt32Value* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_niirs_);
  }
  _impl_.min_niirs_ = reinterpret_cast<::google::protobuf::UInt32Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Map.min_niirs)
}
inline ::google::protobuf::UInt32Value* Map::release_min_niirs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::UInt32Value* released = _impl_.min_niirs_;
  _impl_.min_niirs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::UInt32Value* Map::unsafe_arena_release_min_niirs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Map.min_niirs)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::UInt32Value* temp = _impl_.min_niirs_;
  _impl_.min_niirs_ = nullptr;
  return temp;
}
inline ::google::protobuf::UInt32Value* Map::_internal_mutable_min_niirs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.min_niirs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::UInt32Value>(GetArena());
    _impl_.min_niirs_ = reinterpret_cast<::google::protobuf::UInt32Value*>(p);
  }
  return _impl_.min_niirs_;
}
inline ::google::protobuf::UInt32Value* Map::mutable_min_niirs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::UInt32Value* _msg = _internal_mutable_min_niirs();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Map.min_niirs)
  return _msg;
}
inline void Map::set_allocated_min_niirs(::google::protobuf::UInt32Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_niirs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.min_niirs_ = reinterpret_cast<::google::protobuf::UInt32Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Map.min_niirs)
}

// -------------------------------------------------------------------

// Loiter

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool Loiter::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& Loiter::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& Loiter::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Loiter.objective)
  return _internal_objective();
}
inline void Loiter::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Loiter.objective)
}
inline ::anduril::tasks::v2::Objective* Loiter::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* Loiter::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Loiter.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* Loiter::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* Loiter::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Loiter.objective)
  return _msg;
}
inline void Loiter::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Loiter.objective)
}

// .anduril.tasks.v2.LoiterType loiter_type = 2 [json_name = "loiterType"];
inline bool Loiter::has_loiter_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.loiter_type_ != nullptr);
  return value;
}
inline void Loiter::clear_loiter_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.loiter_type_ != nullptr) _impl_.loiter_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::tasks::v2::LoiterType& Loiter::_internal_loiter_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::LoiterType* p = _impl_.loiter_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::LoiterType&>(::anduril::tasks::v2::_LoiterType_default_instance_);
}
inline const ::anduril::tasks::v2::LoiterType& Loiter::loiter_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Loiter.loiter_type)
  return _internal_loiter_type();
}
inline void Loiter::unsafe_arena_set_allocated_loiter_type(::anduril::tasks::v2::LoiterType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.loiter_type_);
  }
  _impl_.loiter_type_ = reinterpret_cast<::anduril::tasks::v2::LoiterType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Loiter.loiter_type)
}
inline ::anduril::tasks::v2::LoiterType* Loiter::release_loiter_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::LoiterType* released = _impl_.loiter_type_;
  _impl_.loiter_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::LoiterType* Loiter::unsafe_arena_release_loiter_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Loiter.loiter_type)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::LoiterType* temp = _impl_.loiter_type_;
  _impl_.loiter_type_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::LoiterType* Loiter::_internal_mutable_loiter_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.loiter_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::LoiterType>(GetArena());
    _impl_.loiter_type_ = reinterpret_cast<::anduril::tasks::v2::LoiterType*>(p);
  }
  return _impl_.loiter_type_;
}
inline ::anduril::tasks::v2::LoiterType* Loiter::mutable_loiter_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::tasks::v2::LoiterType* _msg = _internal_mutable_loiter_type();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Loiter.loiter_type)
  return _msg;
}
inline void Loiter::set_allocated_loiter_type(::anduril::tasks::v2::LoiterType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.loiter_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.loiter_type_ = reinterpret_cast<::anduril::tasks::v2::LoiterType*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Loiter.loiter_type)
}

// .anduril.tasks.v2.ISRParameters parameters = 3 [json_name = "parameters"];
inline bool Loiter::has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline void Loiter::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::anduril::tasks::v2::ISRParameters& Loiter::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::ISRParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::ISRParameters&>(::anduril::tasks::v2::_ISRParameters_default_instance_);
}
inline const ::anduril::tasks::v2::ISRParameters& Loiter::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Loiter.parameters)
  return _internal_parameters();
}
inline void Loiter::unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Loiter.parameters)
}
inline ::anduril::tasks::v2::ISRParameters* Loiter::release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::tasks::v2::ISRParameters* released = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::ISRParameters* Loiter::unsafe_arena_release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Loiter.parameters)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::tasks::v2::ISRParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::ISRParameters* Loiter::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::ISRParameters>(GetArena());
    _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(p);
  }
  return _impl_.parameters_;
}
inline ::anduril::tasks::v2::ISRParameters* Loiter::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::anduril::tasks::v2::ISRParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Loiter.parameters)
  return _msg;
}
inline void Loiter::set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.parameters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Loiter.parameters)
}

// -------------------------------------------------------------------

// AreaSearch

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool AreaSearch::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& AreaSearch::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& AreaSearch::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.AreaSearch.objective)
  return _internal_objective();
}
inline void AreaSearch::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.AreaSearch.objective)
}
inline ::anduril::tasks::v2::Objective* AreaSearch::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* AreaSearch::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.AreaSearch.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* AreaSearch::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* AreaSearch::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.AreaSearch.objective)
  return _msg;
}
inline void AreaSearch::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.AreaSearch.objective)
}

// repeated .anduril.tasks.v2.Prior priors = 2 [json_name = "priors"];
inline int AreaSearch::_internal_priors_size() const {
  return _internal_priors().size();
}
inline int AreaSearch::priors_size() const {
  return _internal_priors_size();
}
inline void AreaSearch::clear_priors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priors_.Clear();
}
inline ::anduril::tasks::v2::Prior* AreaSearch::mutable_priors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.AreaSearch.priors)
  return _internal_mutable_priors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>* AreaSearch::mutable_priors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.tasks.v2.AreaSearch.priors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_priors();
}
inline const ::anduril::tasks::v2::Prior& AreaSearch::priors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.AreaSearch.priors)
  return _internal_priors().Get(index);
}
inline ::anduril::tasks::v2::Prior* AreaSearch::add_priors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::tasks::v2::Prior* _add = _internal_mutable_priors()->Add();
  // @@protoc_insertion_point(field_add:anduril.tasks.v2.AreaSearch.priors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>& AreaSearch::priors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.tasks.v2.AreaSearch.priors)
  return _internal_priors();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>&
AreaSearch::_internal_priors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priors_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>*
AreaSearch::_internal_mutable_priors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.priors_;
}

// repeated .anduril.tasks.v2.Agent participants = 3 [json_name = "participants"];
inline int AreaSearch::_internal_participants_size() const {
  return _internal_participants().size();
}
inline int AreaSearch::participants_size() const {
  return _internal_participants_size();
}
inline ::anduril::tasks::v2::Agent* AreaSearch::mutable_participants(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.AreaSearch.participants)
  return _internal_mutable_participants()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>* AreaSearch::mutable_participants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.tasks.v2.AreaSearch.participants)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_participants();
}
inline const ::anduril::tasks::v2::Agent& AreaSearch::participants(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.AreaSearch.participants)
  return _internal_participants().Get(index);
}
inline ::anduril::tasks::v2::Agent* AreaSearch::add_participants() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::tasks::v2::Agent* _add = _internal_mutable_participants()->Add();
  // @@protoc_insertion_point(field_add:anduril.tasks.v2.AreaSearch.participants)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>& AreaSearch::participants() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.tasks.v2.AreaSearch.participants)
  return _internal_participants();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>&
AreaSearch::_internal_participants() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participants_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>*
AreaSearch::_internal_mutable_participants() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.participants_;
}

// repeated .anduril.tasks.v2.ControlArea control_areas = 4 [json_name = "controlAreas"];
inline int AreaSearch::_internal_control_areas_size() const {
  return _internal_control_areas().size();
}
inline int AreaSearch::control_areas_size() const {
  return _internal_control_areas_size();
}
inline ::anduril::tasks::v2::ControlArea* AreaSearch::mutable_control_areas(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.AreaSearch.control_areas)
  return _internal_mutable_control_areas()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>* AreaSearch::mutable_control_areas()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.tasks.v2.AreaSearch.control_areas)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_control_areas();
}
inline const ::anduril::tasks::v2::ControlArea& AreaSearch::control_areas(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.AreaSearch.control_areas)
  return _internal_control_areas().Get(index);
}
inline ::anduril::tasks::v2::ControlArea* AreaSearch::add_control_areas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::tasks::v2::ControlArea* _add = _internal_mutable_control_areas()->Add();
  // @@protoc_insertion_point(field_add:anduril.tasks.v2.AreaSearch.control_areas)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>& AreaSearch::control_areas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.tasks.v2.AreaSearch.control_areas)
  return _internal_control_areas();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>&
AreaSearch::_internal_control_areas() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.control_areas_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>*
AreaSearch::_internal_mutable_control_areas() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.control_areas_;
}

// -------------------------------------------------------------------

// VolumeSearch

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool VolumeSearch::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& VolumeSearch::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& VolumeSearch::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.VolumeSearch.objective)
  return _internal_objective();
}
inline void VolumeSearch::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.VolumeSearch.objective)
}
inline ::anduril::tasks::v2::Objective* VolumeSearch::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* VolumeSearch::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.VolumeSearch.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* VolumeSearch::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* VolumeSearch::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.VolumeSearch.objective)
  return _msg;
}
inline void VolumeSearch::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.VolumeSearch.objective)
}

// repeated .anduril.tasks.v2.Prior priors = 2 [json_name = "priors"];
inline int VolumeSearch::_internal_priors_size() const {
  return _internal_priors().size();
}
inline int VolumeSearch::priors_size() const {
  return _internal_priors_size();
}
inline void VolumeSearch::clear_priors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priors_.Clear();
}
inline ::anduril::tasks::v2::Prior* VolumeSearch::mutable_priors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.VolumeSearch.priors)
  return _internal_mutable_priors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>* VolumeSearch::mutable_priors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.tasks.v2.VolumeSearch.priors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_priors();
}
inline const ::anduril::tasks::v2::Prior& VolumeSearch::priors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.VolumeSearch.priors)
  return _internal_priors().Get(index);
}
inline ::anduril::tasks::v2::Prior* VolumeSearch::add_priors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::tasks::v2::Prior* _add = _internal_mutable_priors()->Add();
  // @@protoc_insertion_point(field_add:anduril.tasks.v2.VolumeSearch.priors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>& VolumeSearch::priors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.tasks.v2.VolumeSearch.priors)
  return _internal_priors();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>&
VolumeSearch::_internal_priors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priors_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Prior>*
VolumeSearch::_internal_mutable_priors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.priors_;
}

// repeated .anduril.tasks.v2.Agent participants = 3 [json_name = "participants"];
inline int VolumeSearch::_internal_participants_size() const {
  return _internal_participants().size();
}
inline int VolumeSearch::participants_size() const {
  return _internal_participants_size();
}
inline ::anduril::tasks::v2::Agent* VolumeSearch::mutable_participants(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.VolumeSearch.participants)
  return _internal_mutable_participants()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>* VolumeSearch::mutable_participants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.tasks.v2.VolumeSearch.participants)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_participants();
}
inline const ::anduril::tasks::v2::Agent& VolumeSearch::participants(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.VolumeSearch.participants)
  return _internal_participants().Get(index);
}
inline ::anduril::tasks::v2::Agent* VolumeSearch::add_participants() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::tasks::v2::Agent* _add = _internal_mutable_participants()->Add();
  // @@protoc_insertion_point(field_add:anduril.tasks.v2.VolumeSearch.participants)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>& VolumeSearch::participants() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.tasks.v2.VolumeSearch.participants)
  return _internal_participants();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>&
VolumeSearch::_internal_participants() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participants_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::Agent>*
VolumeSearch::_internal_mutable_participants() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.participants_;
}

// repeated .anduril.tasks.v2.ControlArea control_areas = 4 [json_name = "controlAreas"];
inline int VolumeSearch::_internal_control_areas_size() const {
  return _internal_control_areas().size();
}
inline int VolumeSearch::control_areas_size() const {
  return _internal_control_areas_size();
}
inline ::anduril::tasks::v2::ControlArea* VolumeSearch::mutable_control_areas(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.VolumeSearch.control_areas)
  return _internal_mutable_control_areas()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>* VolumeSearch::mutable_control_areas()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.tasks.v2.VolumeSearch.control_areas)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_control_areas();
}
inline const ::anduril::tasks::v2::ControlArea& VolumeSearch::control_areas(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.VolumeSearch.control_areas)
  return _internal_control_areas().Get(index);
}
inline ::anduril::tasks::v2::ControlArea* VolumeSearch::add_control_areas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::tasks::v2::ControlArea* _add = _internal_mutable_control_areas()->Add();
  // @@protoc_insertion_point(field_add:anduril.tasks.v2.VolumeSearch.control_areas)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>& VolumeSearch::control_areas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.tasks.v2.VolumeSearch.control_areas)
  return _internal_control_areas();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>&
VolumeSearch::_internal_control_areas() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.control_areas_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::tasks::v2::ControlArea>*
VolumeSearch::_internal_mutable_control_areas() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.control_areas_;
}

// -------------------------------------------------------------------

// ImproveTrackQuality

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool ImproveTrackQuality::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& ImproveTrackQuality::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& ImproveTrackQuality::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ImproveTrackQuality.objective)
  return _internal_objective();
}
inline void ImproveTrackQuality::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.ImproveTrackQuality.objective)
}
inline ::anduril::tasks::v2::Objective* ImproveTrackQuality::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* ImproveTrackQuality::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.ImproveTrackQuality.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* ImproveTrackQuality::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* ImproveTrackQuality::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.ImproveTrackQuality.objective)
  return _msg;
}
inline void ImproveTrackQuality::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.ImproveTrackQuality.objective)
}

// uint32 termination_track_quality = 2 [json_name = "terminationTrackQuality"];
inline void ImproveTrackQuality::clear_termination_track_quality() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.termination_track_quality_ = 0u;
}
inline ::uint32_t ImproveTrackQuality::termination_track_quality() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ImproveTrackQuality.termination_track_quality)
  return _internal_termination_track_quality();
}
inline void ImproveTrackQuality::set_termination_track_quality(::uint32_t value) {
  _internal_set_termination_track_quality(value);
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.ImproveTrackQuality.termination_track_quality)
}
inline ::uint32_t ImproveTrackQuality::_internal_termination_track_quality() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.termination_track_quality_;
}
inline void ImproveTrackQuality::_internal_set_termination_track_quality(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.termination_track_quality_ = value;
}

// -------------------------------------------------------------------

// Shadow

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool Shadow::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& Shadow::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& Shadow::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Shadow.objective)
  return _internal_objective();
}
inline void Shadow::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Shadow.objective)
}
inline ::anduril::tasks::v2::Objective* Shadow::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* Shadow::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Shadow.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* Shadow::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* Shadow::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Shadow.objective)
  return _msg;
}
inline void Shadow::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Shadow.objective)
}

// .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
inline bool Shadow::has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline void Shadow::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::tasks::v2::ISRParameters& Shadow::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::ISRParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::ISRParameters&>(::anduril::tasks::v2::_ISRParameters_default_instance_);
}
inline const ::anduril::tasks::v2::ISRParameters& Shadow::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Shadow.parameters)
  return _internal_parameters();
}
inline void Shadow::unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Shadow.parameters)
}
inline ::anduril::tasks::v2::ISRParameters* Shadow::release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* released = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::ISRParameters* Shadow::unsafe_arena_release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Shadow.parameters)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::ISRParameters* Shadow::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::ISRParameters>(GetArena());
    _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(p);
  }
  return _impl_.parameters_;
}
inline ::anduril::tasks::v2::ISRParameters* Shadow::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::tasks::v2::ISRParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Shadow.parameters)
  return _msg;
}
inline void Shadow::set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.parameters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Shadow.parameters)
}

// -------------------------------------------------------------------

// LoiterType

// .anduril.tasks.v2.OrbitType orbit_type = 1 [json_name = "orbitType"];
inline bool LoiterType::has_orbit_type() const {
  return loiter_type_case() == kOrbitType;
}
inline bool LoiterType::_internal_has_orbit_type() const {
  return loiter_type_case() == kOrbitType;
}
inline void LoiterType::set_has_orbit_type() {
  _impl_._oneof_case_[0] = kOrbitType;
}
inline void LoiterType::clear_orbit_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (loiter_type_case() == kOrbitType) {
    if (GetArena() == nullptr) {
      delete _impl_.loiter_type_.orbit_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.loiter_type_.orbit_type_);
    }
    clear_has_loiter_type();
  }
}
inline ::anduril::tasks::v2::OrbitType* LoiterType::release_orbit_type() {
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.LoiterType.orbit_type)
  if (loiter_type_case() == kOrbitType) {
    clear_has_loiter_type();
    auto* temp = _impl_.loiter_type_.orbit_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.loiter_type_.orbit_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::tasks::v2::OrbitType& LoiterType::_internal_orbit_type() const {
  return loiter_type_case() == kOrbitType ? *_impl_.loiter_type_.orbit_type_ : reinterpret_cast<::anduril::tasks::v2::OrbitType&>(::anduril::tasks::v2::_OrbitType_default_instance_);
}
inline const ::anduril::tasks::v2::OrbitType& LoiterType::orbit_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.LoiterType.orbit_type)
  return _internal_orbit_type();
}
inline ::anduril::tasks::v2::OrbitType* LoiterType::unsafe_arena_release_orbit_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.tasks.v2.LoiterType.orbit_type)
  if (loiter_type_case() == kOrbitType) {
    clear_has_loiter_type();
    auto* temp = _impl_.loiter_type_.orbit_type_;
    _impl_.loiter_type_.orbit_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoiterType::unsafe_arena_set_allocated_orbit_type(::anduril::tasks::v2::OrbitType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_loiter_type();
  if (value) {
    set_has_orbit_type();
    _impl_.loiter_type_.orbit_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.LoiterType.orbit_type)
}
inline ::anduril::tasks::v2::OrbitType* LoiterType::_internal_mutable_orbit_type() {
  if (loiter_type_case() != kOrbitType) {
    clear_loiter_type();
    set_has_orbit_type();
    _impl_.loiter_type_.orbit_type_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::OrbitType>(GetArena());
  }
  return _impl_.loiter_type_.orbit_type_;
}
inline ::anduril::tasks::v2::OrbitType* LoiterType::mutable_orbit_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::OrbitType* _msg = _internal_mutable_orbit_type();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.LoiterType.orbit_type)
  return _msg;
}

inline bool LoiterType::has_loiter_type() const {
  return loiter_type_case() != LOITER_TYPE_NOT_SET;
}
inline void LoiterType::clear_has_loiter_type() {
  _impl_._oneof_case_[0] = LOITER_TYPE_NOT_SET;
}
inline LoiterType::LoiterTypeCase LoiterType::loiter_type_case() const {
  return LoiterType::LoiterTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OrbitType

// .anduril.tasks.v2.OrbitDirection direction = 1 [json_name = "direction"];
inline void OrbitType::clear_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_ = 0;
}
inline ::anduril::tasks::v2::OrbitDirection OrbitType::direction() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.OrbitType.direction)
  return _internal_direction();
}
inline void OrbitType::set_direction(::anduril::tasks::v2::OrbitDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.OrbitType.direction)
}
inline ::anduril::tasks::v2::OrbitDirection OrbitType::_internal_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::tasks::v2::OrbitDirection>(_impl_.direction_);
}
inline void OrbitType::_internal_set_direction(::anduril::tasks::v2::OrbitDirection value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_ = value;
}

// .anduril.tasks.v2.OrbitPattern pattern = 2 [json_name = "pattern"];
inline void OrbitType::clear_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pattern_ = 0;
}
inline ::anduril::tasks::v2::OrbitPattern OrbitType::pattern() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.OrbitType.pattern)
  return _internal_pattern();
}
inline void OrbitType::set_pattern(::anduril::tasks::v2::OrbitPattern value) {
  _internal_set_pattern(value);
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.OrbitType.pattern)
}
inline ::anduril::tasks::v2::OrbitPattern OrbitType::_internal_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::anduril::tasks::v2::OrbitPattern>(_impl_.pattern_);
}
inline void OrbitType::_internal_set_pattern(::anduril::tasks::v2::OrbitPattern value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pattern_ = value;
}

// .anduril.tasks.v2.OrbitDuration duration = 3 [json_name = "duration"];
inline bool OrbitType::has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.duration_ != nullptr);
  return value;
}
inline void OrbitType::clear_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.duration_ != nullptr) _impl_.duration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::tasks::v2::OrbitDuration& OrbitType::_internal_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::OrbitDuration* p = _impl_.duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::OrbitDuration&>(::anduril::tasks::v2::_OrbitDuration_default_instance_);
}
inline const ::anduril::tasks::v2::OrbitDuration& OrbitType::duration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.OrbitType.duration)
  return _internal_duration();
}
inline void OrbitType::unsafe_arena_set_allocated_duration(::anduril::tasks::v2::OrbitDuration* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.duration_);
  }
  _impl_.duration_ = reinterpret_cast<::anduril::tasks::v2::OrbitDuration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.OrbitType.duration)
}
inline ::anduril::tasks::v2::OrbitDuration* OrbitType::release_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::OrbitDuration* released = _impl_.duration_;
  _impl_.duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::OrbitDuration* OrbitType::unsafe_arena_release_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.OrbitType.duration)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::OrbitDuration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::OrbitDuration* OrbitType::_internal_mutable_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.duration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::OrbitDuration>(GetArena());
    _impl_.duration_ = reinterpret_cast<::anduril::tasks::v2::OrbitDuration*>(p);
  }
  return _impl_.duration_;
}
inline ::anduril::tasks::v2::OrbitDuration* OrbitType::mutable_duration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::OrbitDuration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.OrbitType.duration)
  return _msg;
}
inline void OrbitType::set_allocated_duration(::anduril::tasks::v2::OrbitDuration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.duration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.duration_ = reinterpret_cast<::anduril::tasks::v2::OrbitDuration*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.OrbitType.duration)
}

// -------------------------------------------------------------------

// OrbitDuration

// .anduril.tasks.v2.DurationRange duration_range = 1 [json_name = "durationRange"];
inline bool OrbitDuration::has_duration_range() const {
  return duration_case() == kDurationRange;
}
inline bool OrbitDuration::_internal_has_duration_range() const {
  return duration_case() == kDurationRange;
}
inline void OrbitDuration::set_has_duration_range() {
  _impl_._oneof_case_[0] = kDurationRange;
}
inline ::anduril::tasks::v2::DurationRange* OrbitDuration::release_duration_range() {
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.OrbitDuration.duration_range)
  if (duration_case() == kDurationRange) {
    clear_has_duration();
    auto* temp = _impl_.duration_.duration_range_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.duration_.duration_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::tasks::v2::DurationRange& OrbitDuration::_internal_duration_range() const {
  return duration_case() == kDurationRange ? *_impl_.duration_.duration_range_ : reinterpret_cast<::anduril::tasks::v2::DurationRange&>(::anduril::tasks::v2::_DurationRange_default_instance_);
}
inline const ::anduril::tasks::v2::DurationRange& OrbitDuration::duration_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.OrbitDuration.duration_range)
  return _internal_duration_range();
}
inline ::anduril::tasks::v2::DurationRange* OrbitDuration::unsafe_arena_release_duration_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.tasks.v2.OrbitDuration.duration_range)
  if (duration_case() == kDurationRange) {
    clear_has_duration();
    auto* temp = _impl_.duration_.duration_range_;
    _impl_.duration_.duration_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OrbitDuration::unsafe_arena_set_allocated_duration_range(::anduril::tasks::v2::DurationRange* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_duration();
  if (value) {
    set_has_duration_range();
    _impl_.duration_.duration_range_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.OrbitDuration.duration_range)
}
inline ::anduril::tasks::v2::DurationRange* OrbitDuration::_internal_mutable_duration_range() {
  if (duration_case() != kDurationRange) {
    clear_duration();
    set_has_duration_range();
    _impl_.duration_.duration_range_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::DurationRange>(GetArena());
  }
  return _impl_.duration_.duration_range_;
}
inline ::anduril::tasks::v2::DurationRange* OrbitDuration::mutable_duration_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::DurationRange* _msg = _internal_mutable_duration_range();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.OrbitDuration.duration_range)
  return _msg;
}

// uint64 num_of_orbits = 2 [json_name = "numOfOrbits"];
inline bool OrbitDuration::has_num_of_orbits() const {
  return duration_case() == kNumOfOrbits;
}
inline void OrbitDuration::set_has_num_of_orbits() {
  _impl_._oneof_case_[0] = kNumOfOrbits;
}
inline void OrbitDuration::clear_num_of_orbits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (duration_case() == kNumOfOrbits) {
    _impl_.duration_.num_of_orbits_ = ::uint64_t{0u};
    clear_has_duration();
  }
}
inline ::uint64_t OrbitDuration::num_of_orbits() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.OrbitDuration.num_of_orbits)
  return _internal_num_of_orbits();
}
inline void OrbitDuration::set_num_of_orbits(::uint64_t value) {
  if (duration_case() != kNumOfOrbits) {
    clear_duration();
    set_has_num_of_orbits();
  }
  _impl_.duration_.num_of_orbits_ = value;
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.OrbitDuration.num_of_orbits)
}
inline ::uint64_t OrbitDuration::_internal_num_of_orbits() const {
  if (duration_case() == kNumOfOrbits) {
    return _impl_.duration_.num_of_orbits_;
  }
  return ::uint64_t{0u};
}

inline bool OrbitDuration::has_duration() const {
  return duration_case() != DURATION_NOT_SET;
}
inline void OrbitDuration::clear_has_duration() {
  _impl_._oneof_case_[0] = DURATION_NOT_SET;
}
inline OrbitDuration::DurationCase OrbitDuration::duration_case() const {
  return OrbitDuration::DurationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Prior

// string entity_id = 1 [json_name = "entityId"];
inline bool Prior::has_entity_id() const {
  return prior_case() == kEntityId;
}
inline void Prior::set_has_entity_id() {
  _impl_._oneof_case_[0] = kEntityId;
}
inline void Prior::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (prior_case() == kEntityId) {
    _impl_.prior_.entity_id_.Destroy();
    clear_has_prior();
  }
}
inline const std::string& Prior::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Prior.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Prior::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (prior_case() != kEntityId) {
    clear_prior();

    set_has_entity_id();
    _impl_.prior_.entity_id_.InitDefault();
  }
  _impl_.prior_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.Prior.entity_id)
}
inline std::string* Prior::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Prior.entity_id)
  return _s;
}
inline const std::string& Prior::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (prior_case() != kEntityId) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.prior_.entity_id_.Get();
}
inline void Prior::_internal_set_entity_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (prior_case() != kEntityId) {
    clear_prior();

    set_has_entity_id();
    _impl_.prior_.entity_id_.InitDefault();
  }
  _impl_.prior_.entity_id_.Set(value, GetArena());
}
inline std::string* Prior::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (prior_case() != kEntityId) {
    clear_prior();

    set_has_entity_id();
    _impl_.prior_.entity_id_.InitDefault();
  }
  return _impl_.prior_.entity_id_.Mutable( GetArena());
}
inline std::string* Prior::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Prior.entity_id)
  if (prior_case() != kEntityId) {
    return nullptr;
  }
  clear_has_prior();
  return _impl_.prior_.entity_id_.Release();
}
inline void Prior::set_allocated_entity_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_prior()) {
    clear_prior();
  }
  if (value != nullptr) {
    set_has_entity_id();
    _impl_.prior_.entity_id_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Prior.entity_id)
}

// .anduril.tasks.v2.Point point = 5 [json_name = "point"];
inline bool Prior::has_point() const {
  return prior_case() == kPoint;
}
inline bool Prior::_internal_has_point() const {
  return prior_case() == kPoint;
}
inline void Prior::set_has_point() {
  _impl_._oneof_case_[0] = kPoint;
}
inline ::anduril::tasks::v2::Point* Prior::release_point() {
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Prior.point)
  if (prior_case() == kPoint) {
    clear_has_prior();
    auto* temp = _impl_.prior_.point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.prior_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::tasks::v2::Point& Prior::_internal_point() const {
  return prior_case() == kPoint ? *_impl_.prior_.point_ : reinterpret_cast<::anduril::tasks::v2::Point&>(::anduril::tasks::v2::_Point_default_instance_);
}
inline const ::anduril::tasks::v2::Point& Prior::point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Prior.point)
  return _internal_point();
}
inline ::anduril::tasks::v2::Point* Prior::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.tasks.v2.Prior.point)
  if (prior_case() == kPoint) {
    clear_has_prior();
    auto* temp = _impl_.prior_.point_;
    _impl_.prior_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Prior::unsafe_arena_set_allocated_point(::anduril::tasks::v2::Point* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_prior();
  if (value) {
    set_has_point();
    _impl_.prior_.point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Prior.point)
}
inline ::anduril::tasks::v2::Point* Prior::_internal_mutable_point() {
  if (prior_case() != kPoint) {
    clear_prior();
    set_has_point();
    _impl_.prior_.point_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Point>(GetArena());
  }
  return _impl_.prior_.point_;
}
inline ::anduril::tasks::v2::Point* Prior::mutable_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::Point* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Prior.point)
  return _msg;
}

inline bool Prior::has_prior() const {
  return prior_case() != PRIOR_NOT_SET;
}
inline void Prior::clear_has_prior() {
  _impl_._oneof_case_[0] = PRIOR_NOT_SET;
}
inline Prior::PriorCase Prior::prior_case() const {
  return Prior::PriorCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ISRParameters

// .google.protobuf.FloatValue speed = 1 [json_name = "speed", deprecated = true];
inline bool ISRParameters::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_ != nullptr);
  return value;
}
inline const ::google::protobuf::FloatValue& ISRParameters::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FloatValue* p = _impl_.speed_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FloatValue&>(::google::protobuf::_FloatValue_default_instance_);
}
inline const ::google::protobuf::FloatValue& ISRParameters::speed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ISRParameters.speed)
  return _internal_speed();
}
inline void ISRParameters::unsafe_arena_set_allocated_speed(::google::protobuf::FloatValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_);
  }
  _impl_.speed_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.ISRParameters.speed)
}
inline ::google::protobuf::FloatValue* ISRParameters::release_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::FloatValue* released = _impl_.speed_;
  _impl_.speed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FloatValue* ISRParameters::unsafe_arena_release_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.ISRParameters.speed)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::FloatValue* temp = _impl_.speed_;
  _impl_.speed_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* ISRParameters::_internal_mutable_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.speed_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FloatValue>(GetArena());
    _impl_.speed_ = reinterpret_cast<::google::protobuf::FloatValue*>(p);
  }
  return _impl_.speed_;
}
inline ::google::protobuf::FloatValue* ISRParameters::mutable_speed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::FloatValue* _msg = _internal_mutable_speed();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.ISRParameters.speed)
  return _msg;
}
inline void ISRParameters::set_allocated_speed(::google::protobuf::FloatValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.speed_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.ISRParameters.speed)
}

// .google.protobuf.FloatValue speed_m_s = 2 [json_name = "speedMS"];
inline bool ISRParameters::has_speed_m_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_m_s_ != nullptr);
  return value;
}
inline const ::google::protobuf::FloatValue& ISRParameters::_internal_speed_m_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FloatValue* p = _impl_.speed_m_s_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FloatValue&>(::google::protobuf::_FloatValue_default_instance_);
}
inline const ::google::protobuf::FloatValue& ISRParameters::speed_m_s() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ISRParameters.speed_m_s)
  return _internal_speed_m_s();
}
inline void ISRParameters::unsafe_arena_set_allocated_speed_m_s(::google::protobuf::FloatValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_m_s_);
  }
  _impl_.speed_m_s_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.ISRParameters.speed_m_s)
}
inline ::google::protobuf::FloatValue* ISRParameters::release_speed_m_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FloatValue* released = _impl_.speed_m_s_;
  _impl_.speed_m_s_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FloatValue* ISRParameters::unsafe_arena_release_speed_m_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.ISRParameters.speed_m_s)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FloatValue* temp = _impl_.speed_m_s_;
  _impl_.speed_m_s_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* ISRParameters::_internal_mutable_speed_m_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.speed_m_s_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FloatValue>(GetArena());
    _impl_.speed_m_s_ = reinterpret_cast<::google::protobuf::FloatValue*>(p);
  }
  return _impl_.speed_m_s_;
}
inline ::google::protobuf::FloatValue* ISRParameters::mutable_speed_m_s() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::FloatValue* _msg = _internal_mutable_speed_m_s();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.ISRParameters.speed_m_s)
  return _msg;
}
inline void ISRParameters::set_allocated_speed_m_s(::google::protobuf::FloatValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_m_s_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.speed_m_s_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.ISRParameters.speed_m_s)
}

// .google.protobuf.FloatValue standoff_distance_m = 3 [json_name = "standoffDistanceM"];
inline bool ISRParameters::has_standoff_distance_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.standoff_distance_m_ != nullptr);
  return value;
}
inline const ::google::protobuf::FloatValue& ISRParameters::_internal_standoff_distance_m() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FloatValue* p = _impl_.standoff_distance_m_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FloatValue&>(::google::protobuf::_FloatValue_default_instance_);
}
inline const ::google::protobuf::FloatValue& ISRParameters::standoff_distance_m() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ISRParameters.standoff_distance_m)
  return _internal_standoff_distance_m();
}
inline void ISRParameters::unsafe_arena_set_allocated_standoff_distance_m(::google::protobuf::FloatValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.standoff_distance_m_);
  }
  _impl_.standoff_distance_m_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.ISRParameters.standoff_distance_m)
}
inline ::google::protobuf::FloatValue* ISRParameters::release_standoff_distance_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::FloatValue* released = _impl_.standoff_distance_m_;
  _impl_.standoff_distance_m_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FloatValue* ISRParameters::unsafe_arena_release_standoff_distance_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.ISRParameters.standoff_distance_m)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::FloatValue* temp = _impl_.standoff_distance_m_;
  _impl_.standoff_distance_m_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* ISRParameters::_internal_mutable_standoff_distance_m() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.standoff_distance_m_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FloatValue>(GetArena());
    _impl_.standoff_distance_m_ = reinterpret_cast<::google::protobuf::FloatValue*>(p);
  }
  return _impl_.standoff_distance_m_;
}
inline ::google::protobuf::FloatValue* ISRParameters::mutable_standoff_distance_m() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::FloatValue* _msg = _internal_mutable_standoff_distance_m();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.ISRParameters.standoff_distance_m)
  return _msg;
}
inline void ISRParameters::set_allocated_standoff_distance_m(::google::protobuf::FloatValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.standoff_distance_m_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.standoff_distance_m_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.ISRParameters.standoff_distance_m)
}

// .google.protobuf.FloatValue standoff_distance = 4 [json_name = "standoffDistance", deprecated = true];
inline bool ISRParameters::has_standoff_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.standoff_distance_ != nullptr);
  return value;
}
inline const ::google::protobuf::FloatValue& ISRParameters::_internal_standoff_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FloatValue* p = _impl_.standoff_distance_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FloatValue&>(::google::protobuf::_FloatValue_default_instance_);
}
inline const ::google::protobuf::FloatValue& ISRParameters::standoff_distance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ISRParameters.standoff_distance)
  return _internal_standoff_distance();
}
inline void ISRParameters::unsafe_arena_set_allocated_standoff_distance(::google::protobuf::FloatValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.standoff_distance_);
  }
  _impl_.standoff_distance_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.ISRParameters.standoff_distance)
}
inline ::google::protobuf::FloatValue* ISRParameters::release_standoff_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::FloatValue* released = _impl_.standoff_distance_;
  _impl_.standoff_distance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FloatValue* ISRParameters::unsafe_arena_release_standoff_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.ISRParameters.standoff_distance)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::FloatValue* temp = _impl_.standoff_distance_;
  _impl_.standoff_distance_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* ISRParameters::_internal_mutable_standoff_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.standoff_distance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FloatValue>(GetArena());
    _impl_.standoff_distance_ = reinterpret_cast<::google::protobuf::FloatValue*>(p);
  }
  return _impl_.standoff_distance_;
}
inline ::google::protobuf::FloatValue* ISRParameters::mutable_standoff_distance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::FloatValue* _msg = _internal_mutable_standoff_distance();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.ISRParameters.standoff_distance)
  return _msg;
}
inline void ISRParameters::set_allocated_standoff_distance(::google::protobuf::FloatValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.standoff_distance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.standoff_distance_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.ISRParameters.standoff_distance)
}

// .google.protobuf.FloatValue standoff_angle = 5 [json_name = "standoffAngle"];
inline bool ISRParameters::has_standoff_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.standoff_angle_ != nullptr);
  return value;
}
inline const ::google::protobuf::FloatValue& ISRParameters::_internal_standoff_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FloatValue* p = _impl_.standoff_angle_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FloatValue&>(::google::protobuf::_FloatValue_default_instance_);
}
inline const ::google::protobuf::FloatValue& ISRParameters::standoff_angle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ISRParameters.standoff_angle)
  return _internal_standoff_angle();
}
inline void ISRParameters::unsafe_arena_set_allocated_standoff_angle(::google::protobuf::FloatValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.standoff_angle_);
  }
  _impl_.standoff_angle_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.ISRParameters.standoff_angle)
}
inline ::google::protobuf::FloatValue* ISRParameters::release_standoff_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::FloatValue* released = _impl_.standoff_angle_;
  _impl_.standoff_angle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FloatValue* ISRParameters::unsafe_arena_release_standoff_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.ISRParameters.standoff_angle)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::FloatValue* temp = _impl_.standoff_angle_;
  _impl_.standoff_angle_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* ISRParameters::_internal_mutable_standoff_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.standoff_angle_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FloatValue>(GetArena());
    _impl_.standoff_angle_ = reinterpret_cast<::google::protobuf::FloatValue*>(p);
  }
  return _impl_.standoff_angle_;
}
inline ::google::protobuf::FloatValue* ISRParameters::mutable_standoff_angle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::google::protobuf::FloatValue* _msg = _internal_mutable_standoff_angle();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.ISRParameters.standoff_angle)
  return _msg;
}
inline void ISRParameters::set_allocated_standoff_angle(::google::protobuf::FloatValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.standoff_angle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.standoff_angle_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.ISRParameters.standoff_angle)
}

// .google.protobuf.UInt64Value expiration_time_ms = 6 [json_name = "expirationTimeMs"];
inline bool ISRParameters::has_expiration_time_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expiration_time_ms_ != nullptr);
  return value;
}
inline const ::google::protobuf::UInt64Value& ISRParameters::_internal_expiration_time_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::UInt64Value* p = _impl_.expiration_time_ms_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::UInt64Value&>(::google::protobuf::_UInt64Value_default_instance_);
}
inline const ::google::protobuf::UInt64Value& ISRParameters::expiration_time_ms() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.ISRParameters.expiration_time_ms)
  return _internal_expiration_time_ms();
}
inline void ISRParameters::unsafe_arena_set_allocated_expiration_time_ms(::google::protobuf::UInt64Value* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiration_time_ms_);
  }
  _impl_.expiration_time_ms_ = reinterpret_cast<::google::protobuf::UInt64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.ISRParameters.expiration_time_ms)
}
inline ::google::protobuf::UInt64Value* ISRParameters::release_expiration_time_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::UInt64Value* released = _impl_.expiration_time_ms_;
  _impl_.expiration_time_ms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::UInt64Value* ISRParameters::unsafe_arena_release_expiration_time_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.ISRParameters.expiration_time_ms)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::UInt64Value* temp = _impl_.expiration_time_ms_;
  _impl_.expiration_time_ms_ = nullptr;
  return temp;
}
inline ::google::protobuf::UInt64Value* ISRParameters::_internal_mutable_expiration_time_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expiration_time_ms_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::UInt64Value>(GetArena());
    _impl_.expiration_time_ms_ = reinterpret_cast<::google::protobuf::UInt64Value*>(p);
  }
  return _impl_.expiration_time_ms_;
}
inline ::google::protobuf::UInt64Value* ISRParameters::mutable_expiration_time_ms() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::google::protobuf::UInt64Value* _msg = _internal_mutable_expiration_time_ms();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.ISRParameters.expiration_time_ms)
  return _msg;
}
inline void ISRParameters::set_allocated_expiration_time_ms(::google::protobuf::UInt64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiration_time_ms_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.expiration_time_ms_ = reinterpret_cast<::google::protobuf::UInt64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.ISRParameters.expiration_time_ms)
}

// -------------------------------------------------------------------

// GimbalPoint

// .anduril.tasks.v2.Objective look_at = 1 [json_name = "lookAt"];
inline bool GimbalPoint::has_look_at() const {
  return point_type_case() == kLookAt;
}
inline bool GimbalPoint::_internal_has_look_at() const {
  return point_type_case() == kLookAt;
}
inline void GimbalPoint::set_has_look_at() {
  _impl_._oneof_case_[0] = kLookAt;
}
inline ::anduril::tasks::v2::Objective* GimbalPoint::release_look_at() {
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.GimbalPoint.look_at)
  if (point_type_case() == kLookAt) {
    clear_has_point_type();
    auto* temp = _impl_.point_type_.look_at_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.point_type_.look_at_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::tasks::v2::Objective& GimbalPoint::_internal_look_at() const {
  return point_type_case() == kLookAt ? *_impl_.point_type_.look_at_ : reinterpret_cast<::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& GimbalPoint::look_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.GimbalPoint.look_at)
  return _internal_look_at();
}
inline ::anduril::tasks::v2::Objective* GimbalPoint::unsafe_arena_release_look_at() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.tasks.v2.GimbalPoint.look_at)
  if (point_type_case() == kLookAt) {
    clear_has_point_type();
    auto* temp = _impl_.point_type_.look_at_;
    _impl_.point_type_.look_at_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GimbalPoint::unsafe_arena_set_allocated_look_at(::anduril::tasks::v2::Objective* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_point_type();
  if (value) {
    set_has_look_at();
    _impl_.point_type_.look_at_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.GimbalPoint.look_at)
}
inline ::anduril::tasks::v2::Objective* GimbalPoint::_internal_mutable_look_at() {
  if (point_type_case() != kLookAt) {
    clear_point_type();
    set_has_look_at();
    _impl_.point_type_.look_at_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
  }
  return _impl_.point_type_.look_at_;
}
inline ::anduril::tasks::v2::Objective* GimbalPoint::mutable_look_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_look_at();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.GimbalPoint.look_at)
  return _msg;
}

// .anduril.tasks.v2.AzimuthElevationPoint celestial_location = 2 [json_name = "celestialLocation"];
inline bool GimbalPoint::has_celestial_location() const {
  return point_type_case() == kCelestialLocation;
}
inline bool GimbalPoint::_internal_has_celestial_location() const {
  return point_type_case() == kCelestialLocation;
}
inline void GimbalPoint::set_has_celestial_location() {
  _impl_._oneof_case_[0] = kCelestialLocation;
}
inline void GimbalPoint::clear_celestial_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (point_type_case() == kCelestialLocation) {
    if (GetArena() == nullptr) {
      delete _impl_.point_type_.celestial_location_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.point_type_.celestial_location_);
    }
    clear_has_point_type();
  }
}
inline ::anduril::tasks::v2::AzimuthElevationPoint* GimbalPoint::release_celestial_location() {
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.GimbalPoint.celestial_location)
  if (point_type_case() == kCelestialLocation) {
    clear_has_point_type();
    auto* temp = _impl_.point_type_.celestial_location_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.point_type_.celestial_location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::tasks::v2::AzimuthElevationPoint& GimbalPoint::_internal_celestial_location() const {
  return point_type_case() == kCelestialLocation ? *_impl_.point_type_.celestial_location_ : reinterpret_cast<::anduril::tasks::v2::AzimuthElevationPoint&>(::anduril::tasks::v2::_AzimuthElevationPoint_default_instance_);
}
inline const ::anduril::tasks::v2::AzimuthElevationPoint& GimbalPoint::celestial_location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.GimbalPoint.celestial_location)
  return _internal_celestial_location();
}
inline ::anduril::tasks::v2::AzimuthElevationPoint* GimbalPoint::unsafe_arena_release_celestial_location() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.tasks.v2.GimbalPoint.celestial_location)
  if (point_type_case() == kCelestialLocation) {
    clear_has_point_type();
    auto* temp = _impl_.point_type_.celestial_location_;
    _impl_.point_type_.celestial_location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GimbalPoint::unsafe_arena_set_allocated_celestial_location(::anduril::tasks::v2::AzimuthElevationPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_point_type();
  if (value) {
    set_has_celestial_location();
    _impl_.point_type_.celestial_location_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.GimbalPoint.celestial_location)
}
inline ::anduril::tasks::v2::AzimuthElevationPoint* GimbalPoint::_internal_mutable_celestial_location() {
  if (point_type_case() != kCelestialLocation) {
    clear_point_type();
    set_has_celestial_location();
    _impl_.point_type_.celestial_location_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::AzimuthElevationPoint>(GetArena());
  }
  return _impl_.point_type_.celestial_location_;
}
inline ::anduril::tasks::v2::AzimuthElevationPoint* GimbalPoint::mutable_celestial_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::AzimuthElevationPoint* _msg = _internal_mutable_celestial_location();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.GimbalPoint.celestial_location)
  return _msg;
}

// .anduril.tasks.v2.FramePoint frame_location = 4 [json_name = "frameLocation"];
inline bool GimbalPoint::has_frame_location() const {
  return point_type_case() == kFrameLocation;
}
inline bool GimbalPoint::_internal_has_frame_location() const {
  return point_type_case() == kFrameLocation;
}
inline void GimbalPoint::set_has_frame_location() {
  _impl_._oneof_case_[0] = kFrameLocation;
}
inline void GimbalPoint::clear_frame_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (point_type_case() == kFrameLocation) {
    if (GetArena() == nullptr) {
      delete _impl_.point_type_.frame_location_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.point_type_.frame_location_);
    }
    clear_has_point_type();
  }
}
inline ::anduril::tasks::v2::FramePoint* GimbalPoint::release_frame_location() {
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.GimbalPoint.frame_location)
  if (point_type_case() == kFrameLocation) {
    clear_has_point_type();
    auto* temp = _impl_.point_type_.frame_location_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.point_type_.frame_location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::tasks::v2::FramePoint& GimbalPoint::_internal_frame_location() const {
  return point_type_case() == kFrameLocation ? *_impl_.point_type_.frame_location_ : reinterpret_cast<::anduril::tasks::v2::FramePoint&>(::anduril::tasks::v2::_FramePoint_default_instance_);
}
inline const ::anduril::tasks::v2::FramePoint& GimbalPoint::frame_location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.GimbalPoint.frame_location)
  return _internal_frame_location();
}
inline ::anduril::tasks::v2::FramePoint* GimbalPoint::unsafe_arena_release_frame_location() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.tasks.v2.GimbalPoint.frame_location)
  if (point_type_case() == kFrameLocation) {
    clear_has_point_type();
    auto* temp = _impl_.point_type_.frame_location_;
    _impl_.point_type_.frame_location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GimbalPoint::unsafe_arena_set_allocated_frame_location(::anduril::tasks::v2::FramePoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_point_type();
  if (value) {
    set_has_frame_location();
    _impl_.point_type_.frame_location_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.GimbalPoint.frame_location)
}
inline ::anduril::tasks::v2::FramePoint* GimbalPoint::_internal_mutable_frame_location() {
  if (point_type_case() != kFrameLocation) {
    clear_point_type();
    set_has_frame_location();
    _impl_.point_type_.frame_location_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::FramePoint>(GetArena());
  }
  return _impl_.point_type_.frame_location_;
}
inline ::anduril::tasks::v2::FramePoint* GimbalPoint::mutable_frame_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::tasks::v2::FramePoint* _msg = _internal_mutable_frame_location();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.GimbalPoint.frame_location)
  return _msg;
}

// .anduril.tasks.v2.ISRParameters parameters = 3 [json_name = "parameters"];
inline bool GimbalPoint::has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline void GimbalPoint::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::tasks::v2::ISRParameters& GimbalPoint::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::ISRParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::ISRParameters&>(::anduril::tasks::v2::_ISRParameters_default_instance_);
}
inline const ::anduril::tasks::v2::ISRParameters& GimbalPoint::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.GimbalPoint.parameters)
  return _internal_parameters();
}
inline void GimbalPoint::unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.GimbalPoint.parameters)
}
inline ::anduril::tasks::v2::ISRParameters* GimbalPoint::release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::ISRParameters* released = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::ISRParameters* GimbalPoint::unsafe_arena_release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.GimbalPoint.parameters)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::ISRParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::ISRParameters* GimbalPoint::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::ISRParameters>(GetArena());
    _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(p);
  }
  return _impl_.parameters_;
}
inline ::anduril::tasks::v2::ISRParameters* GimbalPoint::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::ISRParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.GimbalPoint.parameters)
  return _msg;
}
inline void GimbalPoint::set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.parameters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.GimbalPoint.parameters)
}

inline bool GimbalPoint::has_point_type() const {
  return point_type_case() != POINT_TYPE_NOT_SET;
}
inline void GimbalPoint::clear_has_point_type() {
  _impl_._oneof_case_[0] = POINT_TYPE_NOT_SET;
}
inline GimbalPoint::PointTypeCase GimbalPoint::point_type_case() const {
  return GimbalPoint::PointTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AzimuthElevationPoint

// double azimuth = 1 [json_name = "azimuth"];
inline void AzimuthElevationPoint::clear_azimuth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.azimuth_ = 0;
}
inline double AzimuthElevationPoint::azimuth() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.AzimuthElevationPoint.azimuth)
  return _internal_azimuth();
}
inline void AzimuthElevationPoint::set_azimuth(double value) {
  _internal_set_azimuth(value);
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.AzimuthElevationPoint.azimuth)
}
inline double AzimuthElevationPoint::_internal_azimuth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.azimuth_;
}
inline void AzimuthElevationPoint::_internal_set_azimuth(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.azimuth_ = value;
}

// double elevation = 2 [json_name = "elevation"];
inline void AzimuthElevationPoint::clear_elevation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elevation_ = 0;
}
inline double AzimuthElevationPoint::elevation() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.AzimuthElevationPoint.elevation)
  return _internal_elevation();
}
inline void AzimuthElevationPoint::set_elevation(double value) {
  _internal_set_elevation(value);
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.AzimuthElevationPoint.elevation)
}
inline double AzimuthElevationPoint::_internal_elevation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.elevation_;
}
inline void AzimuthElevationPoint::_internal_set_elevation(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elevation_ = value;
}

// -------------------------------------------------------------------

// FramePoint

// float x = 1 [json_name = "x"];
inline void FramePoint::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float FramePoint::x() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.FramePoint.x)
  return _internal_x();
}
inline void FramePoint::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.FramePoint.x)
}
inline float FramePoint::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void FramePoint::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2 [json_name = "y"];
inline void FramePoint::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float FramePoint::y() const {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.FramePoint.y)
  return _internal_y();
}
inline void FramePoint::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.FramePoint.y)
}
inline float FramePoint::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void FramePoint::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// .google.protobuf.Timestamp timestamp = 3 [json_name = "timestamp"];
inline bool FramePoint::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& FramePoint::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& FramePoint::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.FramePoint.timestamp)
  return _internal_timestamp();
}
inline void FramePoint::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.FramePoint.timestamp)
}
inline ::google::protobuf::Timestamp* FramePoint::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* FramePoint::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.FramePoint.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* FramePoint::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* FramePoint::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.FramePoint.timestamp)
  return _msg;
}
inline void FramePoint::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.FramePoint.timestamp)
}

// -------------------------------------------------------------------

// GimbalZoom

// .google.protobuf.DoubleValue set_horizontal_fov = 1 [json_name = "setHorizontalFov"];
inline bool GimbalZoom::has_set_horizontal_fov() const {
  return mode_case() == kSetHorizontalFov;
}
inline bool GimbalZoom::_internal_has_set_horizontal_fov() const {
  return mode_case() == kSetHorizontalFov;
}
inline void GimbalZoom::set_has_set_horizontal_fov() {
  _impl_._oneof_case_[0] = kSetHorizontalFov;
}
inline ::google::protobuf::DoubleValue* GimbalZoom::release_set_horizontal_fov() {
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.GimbalZoom.set_horizontal_fov)
  if (mode_case() == kSetHorizontalFov) {
    clear_has_mode();
    auto* temp = _impl_.mode_.set_horizontal_fov_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mode_.set_horizontal_fov_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::DoubleValue& GimbalZoom::_internal_set_horizontal_fov() const {
  return mode_case() == kSetHorizontalFov ? *_impl_.mode_.set_horizontal_fov_ : reinterpret_cast<::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& GimbalZoom::set_horizontal_fov() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.GimbalZoom.set_horizontal_fov)
  return _internal_set_horizontal_fov();
}
inline ::google::protobuf::DoubleValue* GimbalZoom::unsafe_arena_release_set_horizontal_fov() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.tasks.v2.GimbalZoom.set_horizontal_fov)
  if (mode_case() == kSetHorizontalFov) {
    clear_has_mode();
    auto* temp = _impl_.mode_.set_horizontal_fov_;
    _impl_.mode_.set_horizontal_fov_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GimbalZoom::unsafe_arena_set_allocated_set_horizontal_fov(::google::protobuf::DoubleValue* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mode();
  if (value) {
    set_has_set_horizontal_fov();
    _impl_.mode_.set_horizontal_fov_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.GimbalZoom.set_horizontal_fov)
}
inline ::google::protobuf::DoubleValue* GimbalZoom::_internal_mutable_set_horizontal_fov() {
  if (mode_case() != kSetHorizontalFov) {
    clear_mode();
    set_has_set_horizontal_fov();
    _impl_.mode_.set_horizontal_fov_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
  }
  return _impl_.mode_.set_horizontal_fov_;
}
inline ::google::protobuf::DoubleValue* GimbalZoom::mutable_set_horizontal_fov() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_set_horizontal_fov();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.GimbalZoom.set_horizontal_fov)
  return _msg;
}

// .google.protobuf.FloatValue set_magnification = 2 [json_name = "setMagnification"];
inline bool GimbalZoom::has_set_magnification() const {
  return mode_case() == kSetMagnification;
}
inline bool GimbalZoom::_internal_has_set_magnification() const {
  return mode_case() == kSetMagnification;
}
inline void GimbalZoom::set_has_set_magnification() {
  _impl_._oneof_case_[0] = kSetMagnification;
}
inline ::google::protobuf::FloatValue* GimbalZoom::release_set_magnification() {
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.GimbalZoom.set_magnification)
  if (mode_case() == kSetMagnification) {
    clear_has_mode();
    auto* temp = _impl_.mode_.set_magnification_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mode_.set_magnification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::FloatValue& GimbalZoom::_internal_set_magnification() const {
  return mode_case() == kSetMagnification ? *_impl_.mode_.set_magnification_ : reinterpret_cast<::google::protobuf::FloatValue&>(::google::protobuf::_FloatValue_default_instance_);
}
inline const ::google::protobuf::FloatValue& GimbalZoom::set_magnification() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.GimbalZoom.set_magnification)
  return _internal_set_magnification();
}
inline ::google::protobuf::FloatValue* GimbalZoom::unsafe_arena_release_set_magnification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.tasks.v2.GimbalZoom.set_magnification)
  if (mode_case() == kSetMagnification) {
    clear_has_mode();
    auto* temp = _impl_.mode_.set_magnification_;
    _impl_.mode_.set_magnification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GimbalZoom::unsafe_arena_set_allocated_set_magnification(::google::protobuf::FloatValue* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mode();
  if (value) {
    set_has_set_magnification();
    _impl_.mode_.set_magnification_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.GimbalZoom.set_magnification)
}
inline ::google::protobuf::FloatValue* GimbalZoom::_internal_mutable_set_magnification() {
  if (mode_case() != kSetMagnification) {
    clear_mode();
    set_has_set_magnification();
    _impl_.mode_.set_magnification_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FloatValue>(GetArena());
  }
  return _impl_.mode_.set_magnification_;
}
inline ::google::protobuf::FloatValue* GimbalZoom::mutable_set_magnification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::FloatValue* _msg = _internal_mutable_set_magnification();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.GimbalZoom.set_magnification)
  return _msg;
}

inline bool GimbalZoom::has_mode() const {
  return mode_case() != MODE_NOT_SET;
}
inline void GimbalZoom::clear_has_mode() {
  _impl_._oneof_case_[0] = MODE_NOT_SET;
}
inline GimbalZoom::ModeCase GimbalZoom::mode_case() const {
  return GimbalZoom::ModeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Monitor

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool Monitor::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& Monitor::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& Monitor::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Monitor.objective)
  return _internal_objective();
}
inline void Monitor::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Monitor.objective)
}
inline ::anduril::tasks::v2::Objective* Monitor::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* Monitor::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Monitor.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* Monitor::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* Monitor::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Monitor.objective)
  return _msg;
}
inline void Monitor::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Monitor.objective)
}

// string track_id = 2 [json_name = "trackId"];
inline void Monitor::clear_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_id_.ClearToEmpty();
}
inline const std::string& Monitor::track_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Monitor.track_id)
  return _internal_track_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Monitor::set_track_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.Monitor.track_id)
}
inline std::string* Monitor::mutable_track_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_id();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Monitor.track_id)
  return _s;
}
inline const std::string& Monitor::_internal_track_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_id_.Get();
}
inline void Monitor::_internal_set_track_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_id_.Set(value, GetArena());
}
inline std::string* Monitor::_internal_mutable_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.track_id_.Mutable( GetArena());
}
inline std::string* Monitor::release_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Monitor.track_id)
  return _impl_.track_id_.Release();
}
inline void Monitor::set_allocated_track_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.track_id_.IsDefault()) {
          _impl_.track_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Monitor.track_id)
}

// string track_producer = 3 [json_name = "trackProducer"];
inline void Monitor::clear_track_producer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_producer_.ClearToEmpty();
}
inline const std::string& Monitor::track_producer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Monitor.track_producer)
  return _internal_track_producer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Monitor::set_track_producer(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_producer_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.tasks.v2.Monitor.track_producer)
}
inline std::string* Monitor::mutable_track_producer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_producer();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Monitor.track_producer)
  return _s;
}
inline const std::string& Monitor::_internal_track_producer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_producer_.Get();
}
inline void Monitor::_internal_set_track_producer(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_producer_.Set(value, GetArena());
}
inline std::string* Monitor::_internal_mutable_track_producer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.track_producer_.Mutable( GetArena());
}
inline std::string* Monitor::release_track_producer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Monitor.track_producer)
  return _impl_.track_producer_.Release();
}
inline void Monitor::set_allocated_track_producer(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_producer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.track_producer_.IsDefault()) {
          _impl_.track_producer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Monitor.track_producer)
}

// -------------------------------------------------------------------

// Scan

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool Scan::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& Scan::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& Scan::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Scan.objective)
  return _internal_objective();
}
inline void Scan::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Scan.objective)
}
inline ::anduril::tasks::v2::Objective* Scan::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* Scan::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Scan.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* Scan::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* Scan::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Scan.objective)
  return _msg;
}
inline void Scan::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Scan.objective)
}

// .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
inline bool Scan::has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline void Scan::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::tasks::v2::ISRParameters& Scan::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::ISRParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::ISRParameters&>(::anduril::tasks::v2::_ISRParameters_default_instance_);
}
inline const ::anduril::tasks::v2::ISRParameters& Scan::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.Scan.parameters)
  return _internal_parameters();
}
inline void Scan::unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.Scan.parameters)
}
inline ::anduril::tasks::v2::ISRParameters* Scan::release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* released = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::ISRParameters* Scan::unsafe_arena_release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.Scan.parameters)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::ISRParameters* Scan::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::ISRParameters>(GetArena());
    _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(p);
  }
  return _impl_.parameters_;
}
inline ::anduril::tasks::v2::ISRParameters* Scan::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::tasks::v2::ISRParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.Scan.parameters)
  return _msg;
}
inline void Scan::set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.parameters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.Scan.parameters)
}

// -------------------------------------------------------------------

// BattleDamageAssessment

// .anduril.tasks.v2.Objective objective = 1 [json_name = "objective"];
inline bool BattleDamageAssessment::has_objective() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline const ::anduril::tasks::v2::Objective& BattleDamageAssessment::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::Objective* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::Objective&>(::anduril::tasks::v2::_Objective_default_instance_);
}
inline const ::anduril::tasks::v2::Objective& BattleDamageAssessment::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.BattleDamageAssessment.objective)
  return _internal_objective();
}
inline void BattleDamageAssessment::unsafe_arena_set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.BattleDamageAssessment.objective)
}
inline ::anduril::tasks::v2::Objective* BattleDamageAssessment::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::Objective* BattleDamageAssessment::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.BattleDamageAssessment.objective)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::tasks::v2::Objective* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::Objective* BattleDamageAssessment::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::Objective>(GetArena());
    _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(p);
  }
  return _impl_.objective_;
}
inline ::anduril::tasks::v2::Objective* BattleDamageAssessment::mutable_objective() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::anduril::tasks::v2::Objective* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.BattleDamageAssessment.objective)
  return _msg;
}
inline void BattleDamageAssessment::set_allocated_objective(::anduril::tasks::v2::Objective* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.objective_ = reinterpret_cast<::anduril::tasks::v2::Objective*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.BattleDamageAssessment.objective)
}

// .anduril.tasks.v2.ISRParameters parameters = 2 [json_name = "parameters"];
inline bool BattleDamageAssessment::has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline void BattleDamageAssessment::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::tasks::v2::ISRParameters& BattleDamageAssessment::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::anduril::tasks::v2::ISRParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::tasks::v2::ISRParameters&>(::anduril::tasks::v2::_ISRParameters_default_instance_);
}
inline const ::anduril::tasks::v2::ISRParameters& BattleDamageAssessment::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.tasks.v2.BattleDamageAssessment.parameters)
  return _internal_parameters();
}
inline void BattleDamageAssessment::unsafe_arena_set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.tasks.v2.BattleDamageAssessment.parameters)
}
inline ::anduril::tasks::v2::ISRParameters* BattleDamageAssessment::release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* released = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::tasks::v2::ISRParameters* BattleDamageAssessment::unsafe_arena_release_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.tasks.v2.BattleDamageAssessment.parameters)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::tasks::v2::ISRParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::anduril::tasks::v2::ISRParameters* BattleDamageAssessment::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parameters_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::anduril::tasks::v2::ISRParameters>(GetArena());
    _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(p);
  }
  return _impl_.parameters_;
}
inline ::anduril::tasks::v2::ISRParameters* BattleDamageAssessment::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::anduril::tasks::v2::ISRParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:anduril.tasks.v2.BattleDamageAssessment.parameters)
  return _msg;
}
inline void BattleDamageAssessment::set_allocated_parameters(::anduril::tasks::v2::ISRParameters* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.parameters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.parameters_ = reinterpret_cast<::anduril::tasks::v2::ISRParameters*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.tasks.v2.BattleDamageAssessment.parameters)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v2
}  // namespace tasks
}  // namespace anduril


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::anduril::tasks::v2::OrbitDirection> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::tasks::v2::OrbitDirection>() {
  return ::anduril::tasks::v2::OrbitDirection_descriptor();
}
template <>
struct is_proto_enum<::anduril::tasks::v2::OrbitPattern> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::anduril::tasks::v2::OrbitPattern>() {
  return ::anduril::tasks::v2::OrbitPattern_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2ftasks_2fv2_2fshared_2fisr_2epub_2eproto_2epb_2eh
