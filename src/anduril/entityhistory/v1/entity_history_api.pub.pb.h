// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: anduril/entityhistory/v1/entity_history_api.pub.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "anduril/entityhistory/v1/history.pub.pb.h"
#include "anduril/entitymanager/v1/filter.pub.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto;
namespace anduril {
namespace entityhistory {
namespace v1 {
class BackfillUpdate;
struct BackfillUpdateDefaultTypeInternal;
extern BackfillUpdateDefaultTypeInternal _BackfillUpdate_default_instance_;
class Downsample;
struct DownsampleDefaultTypeInternal;
extern DownsampleDefaultTypeInternal _Downsample_default_instance_;
class DownsampleDuration;
struct DownsampleDurationDefaultTypeInternal;
extern DownsampleDurationDefaultTypeInternal _DownsampleDuration_default_instance_;
class HistoryQuery;
struct HistoryQueryDefaultTypeInternal;
extern HistoryQueryDefaultTypeInternal _HistoryQuery_default_instance_;
class ListHistoryRequest;
struct ListHistoryRequestDefaultTypeInternal;
extern ListHistoryRequestDefaultTypeInternal _ListHistoryRequest_default_instance_;
class ListHistoryResponse;
struct ListHistoryResponseDefaultTypeInternal;
extern ListHistoryResponseDefaultTypeInternal _ListHistoryResponse_default_instance_;
class StreamBackfillUpdatesRequest;
struct StreamBackfillUpdatesRequestDefaultTypeInternal;
extern StreamBackfillUpdatesRequestDefaultTypeInternal _StreamBackfillUpdatesRequest_default_instance_;
class StreamBackfillUpdatesResponse;
struct StreamBackfillUpdatesResponseDefaultTypeInternal;
extern StreamBackfillUpdatesResponseDefaultTypeInternal _StreamBackfillUpdatesResponse_default_instance_;
class TimeRange;
struct TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
}  // namespace v1
}  // namespace entityhistory
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace entityhistory {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class StreamBackfillUpdatesRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:anduril.entityhistory.v1.StreamBackfillUpdatesRequest) */ {
 public:
  inline StreamBackfillUpdatesRequest() : StreamBackfillUpdatesRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamBackfillUpdatesRequest(::google::protobuf::internal::ConstantInitialized);

  inline StreamBackfillUpdatesRequest(const StreamBackfillUpdatesRequest& from)
      : StreamBackfillUpdatesRequest(nullptr, from) {}
  StreamBackfillUpdatesRequest(StreamBackfillUpdatesRequest&& from) noexcept
    : StreamBackfillUpdatesRequest() {
    *this = ::std::move(from);
  }

  inline StreamBackfillUpdatesRequest& operator=(const StreamBackfillUpdatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamBackfillUpdatesRequest& operator=(StreamBackfillUpdatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamBackfillUpdatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamBackfillUpdatesRequest* internal_default_instance() {
    return reinterpret_cast<const StreamBackfillUpdatesRequest*>(
               &_StreamBackfillUpdatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StreamBackfillUpdatesRequest& a, StreamBackfillUpdatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamBackfillUpdatesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamBackfillUpdatesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamBackfillUpdatesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamBackfillUpdatesRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StreamBackfillUpdatesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StreamBackfillUpdatesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entityhistory.v1.StreamBackfillUpdatesRequest";
  }
  protected:
  explicit StreamBackfillUpdatesRequest(::google::protobuf::Arena* arena);
  StreamBackfillUpdatesRequest(::google::protobuf::Arena* arena, const StreamBackfillUpdatesRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:anduril.entityhistory.v1.StreamBackfillUpdatesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class DownsampleDuration final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entityhistory.v1.DownsampleDuration) */ {
 public:
  inline DownsampleDuration() : DownsampleDuration(nullptr) {}
  ~DownsampleDuration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownsampleDuration(::google::protobuf::internal::ConstantInitialized);

  inline DownsampleDuration(const DownsampleDuration& from)
      : DownsampleDuration(nullptr, from) {}
  DownsampleDuration(DownsampleDuration&& from) noexcept
    : DownsampleDuration() {
    *this = ::std::move(from);
  }

  inline DownsampleDuration& operator=(const DownsampleDuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownsampleDuration& operator=(DownsampleDuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownsampleDuration& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownsampleDuration* internal_default_instance() {
    return reinterpret_cast<const DownsampleDuration*>(
               &_DownsampleDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DownsampleDuration& a, DownsampleDuration& b) {
    a.Swap(&b);
  }
  inline void Swap(DownsampleDuration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownsampleDuration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownsampleDuration* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownsampleDuration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownsampleDuration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownsampleDuration& from) {
    DownsampleDuration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DownsampleDuration* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entityhistory.v1.DownsampleDuration";
  }
  protected:
  explicit DownsampleDuration(::google::protobuf::Arena* arena);
  DownsampleDuration(::google::protobuf::Arena* arena, const DownsampleDuration& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationMsFieldNumber = 1,
  };
  // uint32 duration_ms = 1 [json_name = "durationMs"];
  void clear_duration_ms() ;
  ::uint32_t duration_ms() const;
  void set_duration_ms(::uint32_t value);

  private:
  ::uint32_t _internal_duration_ms() const;
  void _internal_set_duration_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entityhistory.v1.DownsampleDuration)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t duration_ms_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class TimeRange final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entityhistory.v1.TimeRange) */ {
 public:
  inline TimeRange() : TimeRange(nullptr) {}
  ~TimeRange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimeRange(::google::protobuf::internal::ConstantInitialized);

  inline TimeRange(const TimeRange& from)
      : TimeRange(nullptr, from) {}
  TimeRange(TimeRange&& from) noexcept
    : TimeRange() {
    *this = ::std::move(from);
  }

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
               &_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TimeRange& a, TimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeRange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimeRange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TimeRange& from) {
    TimeRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TimeRange* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entityhistory.v1.TimeRange";
  }
  protected:
  explicit TimeRange(::google::protobuf::Arena* arena);
  TimeRange(::google::protobuf::Arena* arena, const TimeRange& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowerBoundIncFieldNumber = 1,
    kUpperBoundExcFieldNumber = 2,
  };
  // .google.protobuf.Timestamp lower_bound_inc = 1 [json_name = "lowerBoundInc"];
  bool has_lower_bound_inc() const;
  void clear_lower_bound_inc() ;
  const ::google::protobuf::Timestamp& lower_bound_inc() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_lower_bound_inc();
  ::google::protobuf::Timestamp* mutable_lower_bound_inc();
  void set_allocated_lower_bound_inc(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_lower_bound_inc(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_lower_bound_inc();

  private:
  const ::google::protobuf::Timestamp& _internal_lower_bound_inc() const;
  ::google::protobuf::Timestamp* _internal_mutable_lower_bound_inc();

  public:
  // .google.protobuf.Timestamp upper_bound_exc = 2 [json_name = "upperBoundExc"];
  bool has_upper_bound_exc() const;
  void clear_upper_bound_exc() ;
  const ::google::protobuf::Timestamp& upper_bound_exc() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_upper_bound_exc();
  ::google::protobuf::Timestamp* mutable_upper_bound_exc();
  void set_allocated_upper_bound_exc(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_upper_bound_exc(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_upper_bound_exc();

  private:
  const ::google::protobuf::Timestamp& _internal_upper_bound_exc() const;
  ::google::protobuf::Timestamp* _internal_mutable_upper_bound_exc();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entityhistory.v1.TimeRange)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* lower_bound_inc_;
    ::google::protobuf::Timestamp* upper_bound_exc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class Downsample final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entityhistory.v1.Downsample) */ {
 public:
  inline Downsample() : Downsample(nullptr) {}
  ~Downsample() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Downsample(::google::protobuf::internal::ConstantInitialized);

  inline Downsample(const Downsample& from)
      : Downsample(nullptr, from) {}
  Downsample(Downsample&& from) noexcept
    : Downsample() {
    *this = ::std::move(from);
  }

  inline Downsample& operator=(const Downsample& from) {
    CopyFrom(from);
    return *this;
  }
  inline Downsample& operator=(Downsample&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Downsample& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kDownsampleDuration = 1,
    TYPE_NOT_SET = 0,
  };

  static inline const Downsample* internal_default_instance() {
    return reinterpret_cast<const Downsample*>(
               &_Downsample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Downsample& a, Downsample& b) {
    a.Swap(&b);
  }
  inline void Swap(Downsample* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Downsample* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Downsample* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Downsample>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Downsample& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Downsample& from) {
    Downsample::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Downsample* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entityhistory.v1.Downsample";
  }
  protected:
  explicit Downsample(::google::protobuf::Arena* arena);
  Downsample(::google::protobuf::Arena* arena, const Downsample& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDownsampleDurationFieldNumber = 1,
  };
  // .anduril.entityhistory.v1.DownsampleDuration downsample_duration = 1 [json_name = "downsampleDuration"];
  bool has_downsample_duration() const;
  private:
  bool _internal_has_downsample_duration() const;

  public:
  void clear_downsample_duration() ;
  const ::anduril::entityhistory::v1::DownsampleDuration& downsample_duration() const;
  PROTOBUF_NODISCARD ::anduril::entityhistory::v1::DownsampleDuration* release_downsample_duration();
  ::anduril::entityhistory::v1::DownsampleDuration* mutable_downsample_duration();
  void set_allocated_downsample_duration(::anduril::entityhistory::v1::DownsampleDuration* value);
  void unsafe_arena_set_allocated_downsample_duration(::anduril::entityhistory::v1::DownsampleDuration* value);
  ::anduril::entityhistory::v1::DownsampleDuration* unsafe_arena_release_downsample_duration();

  private:
  const ::anduril::entityhistory::v1::DownsampleDuration& _internal_downsample_duration() const;
  ::anduril::entityhistory::v1::DownsampleDuration* _internal_mutable_downsample_duration();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:anduril.entityhistory.v1.Downsample)
 private:
  class _Internal;
  void set_has_downsample_duration();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::entityhistory::v1::DownsampleDuration* downsample_duration_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class BackfillUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entityhistory.v1.BackfillUpdate) */ {
 public:
  inline BackfillUpdate() : BackfillUpdate(nullptr) {}
  ~BackfillUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BackfillUpdate(::google::protobuf::internal::ConstantInitialized);

  inline BackfillUpdate(const BackfillUpdate& from)
      : BackfillUpdate(nullptr, from) {}
  BackfillUpdate(BackfillUpdate&& from) noexcept
    : BackfillUpdate() {
    *this = ::std::move(from);
  }

  inline BackfillUpdate& operator=(const BackfillUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackfillUpdate& operator=(BackfillUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackfillUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackfillUpdate* internal_default_instance() {
    return reinterpret_cast<const BackfillUpdate*>(
               &_BackfillUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BackfillUpdate& a, BackfillUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(BackfillUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackfillUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackfillUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BackfillUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BackfillUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BackfillUpdate& from) {
    BackfillUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BackfillUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entityhistory.v1.BackfillUpdate";
  }
  protected:
  explicit BackfillUpdate(::google::protobuf::Arena* arena);
  BackfillUpdate(::google::protobuf::Arena* arena, const BackfillUpdate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdFieldNumber = 1,
    kTimeRangeFieldNumber = 2,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // .anduril.entityhistory.v1.TimeRange time_range = 2 [json_name = "timeRange"];
  bool has_time_range() const;
  void clear_time_range() ;
  const ::anduril::entityhistory::v1::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::anduril::entityhistory::v1::TimeRange* release_time_range();
  ::anduril::entityhistory::v1::TimeRange* mutable_time_range();
  void set_allocated_time_range(::anduril::entityhistory::v1::TimeRange* value);
  void unsafe_arena_set_allocated_time_range(::anduril::entityhistory::v1::TimeRange* value);
  ::anduril::entityhistory::v1::TimeRange* unsafe_arena_release_time_range();

  private:
  const ::anduril::entityhistory::v1::TimeRange& _internal_time_range() const;
  ::anduril::entityhistory::v1::TimeRange* _internal_mutable_time_range();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entityhistory.v1.BackfillUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::anduril::entityhistory::v1::TimeRange* time_range_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class StreamBackfillUpdatesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entityhistory.v1.StreamBackfillUpdatesResponse) */ {
 public:
  inline StreamBackfillUpdatesResponse() : StreamBackfillUpdatesResponse(nullptr) {}
  ~StreamBackfillUpdatesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamBackfillUpdatesResponse(::google::protobuf::internal::ConstantInitialized);

  inline StreamBackfillUpdatesResponse(const StreamBackfillUpdatesResponse& from)
      : StreamBackfillUpdatesResponse(nullptr, from) {}
  StreamBackfillUpdatesResponse(StreamBackfillUpdatesResponse&& from) noexcept
    : StreamBackfillUpdatesResponse() {
    *this = ::std::move(from);
  }

  inline StreamBackfillUpdatesResponse& operator=(const StreamBackfillUpdatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamBackfillUpdatesResponse& operator=(StreamBackfillUpdatesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamBackfillUpdatesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamBackfillUpdatesResponse* internal_default_instance() {
    return reinterpret_cast<const StreamBackfillUpdatesResponse*>(
               &_StreamBackfillUpdatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StreamBackfillUpdatesResponse& a, StreamBackfillUpdatesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamBackfillUpdatesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamBackfillUpdatesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamBackfillUpdatesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamBackfillUpdatesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamBackfillUpdatesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StreamBackfillUpdatesResponse& from) {
    StreamBackfillUpdatesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamBackfillUpdatesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entityhistory.v1.StreamBackfillUpdatesResponse";
  }
  protected:
  explicit StreamBackfillUpdatesResponse(::google::protobuf::Arena* arena);
  StreamBackfillUpdatesResponse(::google::protobuf::Arena* arena, const StreamBackfillUpdatesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackfillUpdatesFieldNumber = 1,
  };
  // repeated .anduril.entityhistory.v1.BackfillUpdate backfill_updates = 1 [json_name = "backfillUpdates"];
  int backfill_updates_size() const;
  private:
  int _internal_backfill_updates_size() const;

  public:
  void clear_backfill_updates() ;
  ::anduril::entityhistory::v1::BackfillUpdate* mutable_backfill_updates(int index);
  ::google::protobuf::RepeatedPtrField< ::anduril::entityhistory::v1::BackfillUpdate >*
      mutable_backfill_updates();
  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::entityhistory::v1::BackfillUpdate>& _internal_backfill_updates() const;
  ::google::protobuf::RepeatedPtrField<::anduril::entityhistory::v1::BackfillUpdate>* _internal_mutable_backfill_updates();
  public:
  const ::anduril::entityhistory::v1::BackfillUpdate& backfill_updates(int index) const;
  ::anduril::entityhistory::v1::BackfillUpdate* add_backfill_updates();
  const ::google::protobuf::RepeatedPtrField< ::anduril::entityhistory::v1::BackfillUpdate >&
      backfill_updates() const;
  // @@protoc_insertion_point(class_scope:anduril.entityhistory.v1.StreamBackfillUpdatesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::anduril::entityhistory::v1::BackfillUpdate > backfill_updates_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class HistoryQuery final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entityhistory.v1.HistoryQuery) */ {
 public:
  inline HistoryQuery() : HistoryQuery(nullptr) {}
  ~HistoryQuery() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HistoryQuery(::google::protobuf::internal::ConstantInitialized);

  inline HistoryQuery(const HistoryQuery& from)
      : HistoryQuery(nullptr, from) {}
  HistoryQuery(HistoryQuery&& from) noexcept
    : HistoryQuery() {
    *this = ::std::move(from);
  }

  inline HistoryQuery& operator=(const HistoryQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoryQuery& operator=(HistoryQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistoryQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistoryQuery* internal_default_instance() {
    return reinterpret_cast<const HistoryQuery*>(
               &_HistoryQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HistoryQuery& a, HistoryQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(HistoryQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoryQuery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistoryQuery* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistoryQuery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HistoryQuery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HistoryQuery& from) {
    HistoryQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HistoryQuery* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entityhistory.v1.HistoryQuery";
  }
  protected:
  explicit HistoryQuery(::google::protobuf::Arena* arena);
  HistoryQuery(::google::protobuf::Arena* arena, const HistoryQuery& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdsFieldNumber = 5,
    kTimeRangeFieldNumber = 2,
    kDownsampleFieldNumber = 3,
    kStatementFieldNumber = 4,
    kHistoryTypeFieldNumber = 1,
  };
  // repeated string entity_ids = 5 [json_name = "entityIds"];
  int entity_ids_size() const;
  private:
  int _internal_entity_ids_size() const;

  public:
  void clear_entity_ids() ;
  const std::string& entity_ids(int index) const;
  std::string* mutable_entity_ids(int index);
  void set_entity_ids(int index, const std::string& value);
  void set_entity_ids(int index, std::string&& value);
  void set_entity_ids(int index, const char* value);
  void set_entity_ids(int index, const char* value, std::size_t size);
  void set_entity_ids(int index, absl::string_view value);
  std::string* add_entity_ids();
  void add_entity_ids(const std::string& value);
  void add_entity_ids(std::string&& value);
  void add_entity_ids(const char* value);
  void add_entity_ids(const char* value, std::size_t size);
  void add_entity_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& entity_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_entity_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_entity_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_entity_ids();

  public:
  // .anduril.entityhistory.v1.TimeRange time_range = 2 [json_name = "timeRange"];
  bool has_time_range() const;
  void clear_time_range() ;
  const ::anduril::entityhistory::v1::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::anduril::entityhistory::v1::TimeRange* release_time_range();
  ::anduril::entityhistory::v1::TimeRange* mutable_time_range();
  void set_allocated_time_range(::anduril::entityhistory::v1::TimeRange* value);
  void unsafe_arena_set_allocated_time_range(::anduril::entityhistory::v1::TimeRange* value);
  ::anduril::entityhistory::v1::TimeRange* unsafe_arena_release_time_range();

  private:
  const ::anduril::entityhistory::v1::TimeRange& _internal_time_range() const;
  ::anduril::entityhistory::v1::TimeRange* _internal_mutable_time_range();

  public:
  // .anduril.entityhistory.v1.Downsample downsample = 3 [json_name = "downsample"];
  bool has_downsample() const;
  void clear_downsample() ;
  const ::anduril::entityhistory::v1::Downsample& downsample() const;
  PROTOBUF_NODISCARD ::anduril::entityhistory::v1::Downsample* release_downsample();
  ::anduril::entityhistory::v1::Downsample* mutable_downsample();
  void set_allocated_downsample(::anduril::entityhistory::v1::Downsample* value);
  void unsafe_arena_set_allocated_downsample(::anduril::entityhistory::v1::Downsample* value);
  ::anduril::entityhistory::v1::Downsample* unsafe_arena_release_downsample();

  private:
  const ::anduril::entityhistory::v1::Downsample& _internal_downsample() const;
  ::anduril::entityhistory::v1::Downsample* _internal_mutable_downsample();

  public:
  // .anduril.entitymanager.v1.Statement statement = 4 [json_name = "statement"];
  bool has_statement() const;
  void clear_statement() ;
  const ::anduril::entitymanager::v1::Statement& statement() const;
  PROTOBUF_NODISCARD ::anduril::entitymanager::v1::Statement* release_statement();
  ::anduril::entitymanager::v1::Statement* mutable_statement();
  void set_allocated_statement(::anduril::entitymanager::v1::Statement* value);
  void unsafe_arena_set_allocated_statement(::anduril::entitymanager::v1::Statement* value);
  ::anduril::entitymanager::v1::Statement* unsafe_arena_release_statement();

  private:
  const ::anduril::entitymanager::v1::Statement& _internal_statement() const;
  ::anduril::entitymanager::v1::Statement* _internal_mutable_statement();

  public:
  // .anduril.entityhistory.v1.HistoryType history_type = 1 [json_name = "historyType"];
  void clear_history_type() ;
  ::anduril::entityhistory::v1::HistoryType history_type() const;
  void set_history_type(::anduril::entityhistory::v1::HistoryType value);

  private:
  ::anduril::entityhistory::v1::HistoryType _internal_history_type() const;
  void _internal_set_history_type(::anduril::entityhistory::v1::HistoryType value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.entityhistory.v1.HistoryQuery)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> entity_ids_;
    ::anduril::entityhistory::v1::TimeRange* time_range_;
    ::anduril::entityhistory::v1::Downsample* downsample_;
    ::anduril::entitymanager::v1::Statement* statement_;
    int history_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class ListHistoryRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entityhistory.v1.ListHistoryRequest) */ {
 public:
  inline ListHistoryRequest() : ListHistoryRequest(nullptr) {}
  ~ListHistoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListHistoryRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListHistoryRequest(const ListHistoryRequest& from)
      : ListHistoryRequest(nullptr, from) {}
  ListHistoryRequest(ListHistoryRequest&& from) noexcept
    : ListHistoryRequest() {
    *this = ::std::move(from);
  }

  inline ListHistoryRequest& operator=(const ListHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListHistoryRequest& operator=(ListHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const ListHistoryRequest*>(
               &_ListHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ListHistoryRequest& a, ListHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListHistoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListHistoryRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListHistoryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListHistoryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListHistoryRequest& from) {
    ListHistoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListHistoryRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entityhistory.v1.ListHistoryRequest";
  }
  protected:
  explicit ListHistoryRequest(::google::protobuf::Arena* arena);
  ListHistoryRequest(::google::protobuf::Arena* arena, const ListHistoryRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 2,
    kHistoryQueryFieldNumber = 1,
    kHistoryPageTokenFieldNumber = 3,
  };
  // string page_token = 2 [json_name = "pageToken"];
  void clear_page_token() ;
  const std::string& page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* value);

  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(
      const std::string& value);
  std::string* _internal_mutable_page_token();

  public:
  // .anduril.entityhistory.v1.HistoryQuery history_query = 1 [json_name = "historyQuery"];
  bool has_history_query() const;
  void clear_history_query() ;
  const ::anduril::entityhistory::v1::HistoryQuery& history_query() const;
  PROTOBUF_NODISCARD ::anduril::entityhistory::v1::HistoryQuery* release_history_query();
  ::anduril::entityhistory::v1::HistoryQuery* mutable_history_query();
  void set_allocated_history_query(::anduril::entityhistory::v1::HistoryQuery* value);
  void unsafe_arena_set_allocated_history_query(::anduril::entityhistory::v1::HistoryQuery* value);
  ::anduril::entityhistory::v1::HistoryQuery* unsafe_arena_release_history_query();

  private:
  const ::anduril::entityhistory::v1::HistoryQuery& _internal_history_query() const;
  ::anduril::entityhistory::v1::HistoryQuery* _internal_mutable_history_query();

  public:
  // .anduril.entityhistory.v1.HistoryPageToken history_page_token = 3 [json_name = "historyPageToken"];
  bool has_history_page_token() const;
  void clear_history_page_token() ;
  const ::anduril::entityhistory::v1::HistoryPageToken& history_page_token() const;
  PROTOBUF_NODISCARD ::anduril::entityhistory::v1::HistoryPageToken* release_history_page_token();
  ::anduril::entityhistory::v1::HistoryPageToken* mutable_history_page_token();
  void set_allocated_history_page_token(::anduril::entityhistory::v1::HistoryPageToken* value);
  void unsafe_arena_set_allocated_history_page_token(::anduril::entityhistory::v1::HistoryPageToken* value);
  ::anduril::entityhistory::v1::HistoryPageToken* unsafe_arena_release_history_page_token();

  private:
  const ::anduril::entityhistory::v1::HistoryPageToken& _internal_history_page_token() const;
  ::anduril::entityhistory::v1::HistoryPageToken* _internal_mutable_history_page_token();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entityhistory.v1.ListHistoryRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::anduril::entityhistory::v1::HistoryQuery* history_query_;
    ::anduril::entityhistory::v1::HistoryPageToken* history_page_token_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class ListHistoryResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.entityhistory.v1.ListHistoryResponse) */ {
 public:
  inline ListHistoryResponse() : ListHistoryResponse(nullptr) {}
  ~ListHistoryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListHistoryResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListHistoryResponse(const ListHistoryResponse& from)
      : ListHistoryResponse(nullptr, from) {}
  ListHistoryResponse(ListHistoryResponse&& from) noexcept
    : ListHistoryResponse() {
    *this = ::std::move(from);
  }

  inline ListHistoryResponse& operator=(const ListHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListHistoryResponse& operator=(ListHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const ListHistoryResponse*>(
               &_ListHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListHistoryResponse& a, ListHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListHistoryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListHistoryResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListHistoryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListHistoryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListHistoryResponse& from) {
    ListHistoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListHistoryResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.entityhistory.v1.ListHistoryResponse";
  }
  protected:
  explicit ListHistoryResponse(::google::protobuf::Arena* arena);
  ListHistoryResponse(::google::protobuf::Arena* arena, const ListHistoryResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextPageTokenFieldNumber = 2,
    kHistoryPageFieldNumber = 1,
    kNextHistoryPageTokenFieldNumber = 3,
  };
  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token() ;
  const std::string& next_page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* value);

  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(
      const std::string& value);
  std::string* _internal_mutable_next_page_token();

  public:
  // .anduril.entityhistory.v1.HistoryPage history_page = 1 [json_name = "historyPage"];
  bool has_history_page() const;
  void clear_history_page() ;
  const ::anduril::entityhistory::v1::HistoryPage& history_page() const;
  PROTOBUF_NODISCARD ::anduril::entityhistory::v1::HistoryPage* release_history_page();
  ::anduril::entityhistory::v1::HistoryPage* mutable_history_page();
  void set_allocated_history_page(::anduril::entityhistory::v1::HistoryPage* value);
  void unsafe_arena_set_allocated_history_page(::anduril::entityhistory::v1::HistoryPage* value);
  ::anduril::entityhistory::v1::HistoryPage* unsafe_arena_release_history_page();

  private:
  const ::anduril::entityhistory::v1::HistoryPage& _internal_history_page() const;
  ::anduril::entityhistory::v1::HistoryPage* _internal_mutable_history_page();

  public:
  // .anduril.entityhistory.v1.HistoryPageToken next_history_page_token = 3 [json_name = "nextHistoryPageToken"];
  bool has_next_history_page_token() const;
  void clear_next_history_page_token() ;
  const ::anduril::entityhistory::v1::HistoryPageToken& next_history_page_token() const;
  PROTOBUF_NODISCARD ::anduril::entityhistory::v1::HistoryPageToken* release_next_history_page_token();
  ::anduril::entityhistory::v1::HistoryPageToken* mutable_next_history_page_token();
  void set_allocated_next_history_page_token(::anduril::entityhistory::v1::HistoryPageToken* value);
  void unsafe_arena_set_allocated_next_history_page_token(::anduril::entityhistory::v1::HistoryPageToken* value);
  ::anduril::entityhistory::v1::HistoryPageToken* unsafe_arena_release_next_history_page_token();

  private:
  const ::anduril::entityhistory::v1::HistoryPageToken& _internal_next_history_page_token() const;
  ::anduril::entityhistory::v1::HistoryPageToken* _internal_mutable_next_history_page_token();

  public:
  // @@protoc_insertion_point(class_scope:anduril.entityhistory.v1.ListHistoryResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::anduril::entityhistory::v1::HistoryPage* history_page_;
    ::anduril::entityhistory::v1::HistoryPageToken* next_history_page_token_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ListHistoryRequest

// .anduril.entityhistory.v1.HistoryQuery history_query = 1 [json_name = "historyQuery"];
inline bool ListHistoryRequest::has_history_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.history_query_ != nullptr);
  return value;
}
inline void ListHistoryRequest::clear_history_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.history_query_ != nullptr) _impl_.history_query_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entityhistory::v1::HistoryQuery& ListHistoryRequest::_internal_history_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entityhistory::v1::HistoryQuery* p = _impl_.history_query_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entityhistory::v1::HistoryQuery&>(::anduril::entityhistory::v1::_HistoryQuery_default_instance_);
}
inline const ::anduril::entityhistory::v1::HistoryQuery& ListHistoryRequest::history_query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.ListHistoryRequest.history_query)
  return _internal_history_query();
}
inline void ListHistoryRequest::unsafe_arena_set_allocated_history_query(::anduril::entityhistory::v1::HistoryQuery* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.history_query_);
  }
  _impl_.history_query_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryQuery*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.ListHistoryRequest.history_query)
}
inline ::anduril::entityhistory::v1::HistoryQuery* ListHistoryRequest::release_history_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entityhistory::v1::HistoryQuery* released = _impl_.history_query_;
  _impl_.history_query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entityhistory::v1::HistoryQuery* ListHistoryRequest::unsafe_arena_release_history_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.ListHistoryRequest.history_query)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entityhistory::v1::HistoryQuery* temp = _impl_.history_query_;
  _impl_.history_query_ = nullptr;
  return temp;
}
inline ::anduril::entityhistory::v1::HistoryQuery* ListHistoryRequest::_internal_mutable_history_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.history_query_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entityhistory::v1::HistoryQuery>(GetArena());
    _impl_.history_query_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryQuery*>(p);
  }
  return _impl_.history_query_;
}
inline ::anduril::entityhistory::v1::HistoryQuery* ListHistoryRequest::mutable_history_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entityhistory::v1::HistoryQuery* _msg = _internal_mutable_history_query();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.ListHistoryRequest.history_query)
  return _msg;
}
inline void ListHistoryRequest::set_allocated_history_query(::anduril::entityhistory::v1::HistoryQuery* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entityhistory::v1::HistoryQuery*>(_impl_.history_query_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entityhistory::v1::HistoryQuery*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.history_query_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryQuery*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.ListHistoryRequest.history_query)
}

// string page_token = 2 [json_name = "pageToken"];
inline void ListHistoryRequest::clear_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListHistoryRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.ListHistoryRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListHistoryRequest::set_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entityhistory.v1.ListHistoryRequest.page_token)
}
inline std::string* ListHistoryRequest::mutable_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.ListHistoryRequest.page_token)
  return _s;
}
inline const std::string& ListHistoryRequest::_internal_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_token_.Get();
}
inline void ListHistoryRequest::_internal_set_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(value, GetArena());
}
inline std::string* ListHistoryRequest::_internal_mutable_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.page_token_.Mutable( GetArena());
}
inline std::string* ListHistoryRequest::release_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.ListHistoryRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListHistoryRequest::set_allocated_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.page_token_.IsDefault()) {
          _impl_.page_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.ListHistoryRequest.page_token)
}

// .anduril.entityhistory.v1.HistoryPageToken history_page_token = 3 [json_name = "historyPageToken"];
inline bool ListHistoryRequest::has_history_page_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.history_page_token_ != nullptr);
  return value;
}
inline const ::anduril::entityhistory::v1::HistoryPageToken& ListHistoryRequest::_internal_history_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entityhistory::v1::HistoryPageToken* p = _impl_.history_page_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entityhistory::v1::HistoryPageToken&>(::anduril::entityhistory::v1::_HistoryPageToken_default_instance_);
}
inline const ::anduril::entityhistory::v1::HistoryPageToken& ListHistoryRequest::history_page_token() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.ListHistoryRequest.history_page_token)
  return _internal_history_page_token();
}
inline void ListHistoryRequest::unsafe_arena_set_allocated_history_page_token(::anduril::entityhistory::v1::HistoryPageToken* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.history_page_token_);
  }
  _impl_.history_page_token_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryPageToken*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.ListHistoryRequest.history_page_token)
}
inline ::anduril::entityhistory::v1::HistoryPageToken* ListHistoryRequest::release_history_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entityhistory::v1::HistoryPageToken* released = _impl_.history_page_token_;
  _impl_.history_page_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entityhistory::v1::HistoryPageToken* ListHistoryRequest::unsafe_arena_release_history_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.ListHistoryRequest.history_page_token)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entityhistory::v1::HistoryPageToken* temp = _impl_.history_page_token_;
  _impl_.history_page_token_ = nullptr;
  return temp;
}
inline ::anduril::entityhistory::v1::HistoryPageToken* ListHistoryRequest::_internal_mutable_history_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.history_page_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entityhistory::v1::HistoryPageToken>(GetArena());
    _impl_.history_page_token_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryPageToken*>(p);
  }
  return _impl_.history_page_token_;
}
inline ::anduril::entityhistory::v1::HistoryPageToken* ListHistoryRequest::mutable_history_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entityhistory::v1::HistoryPageToken* _msg = _internal_mutable_history_page_token();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.ListHistoryRequest.history_page_token)
  return _msg;
}
inline void ListHistoryRequest::set_allocated_history_page_token(::anduril::entityhistory::v1::HistoryPageToken* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.history_page_token_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.history_page_token_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryPageToken*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.ListHistoryRequest.history_page_token)
}

// -------------------------------------------------------------------

// ListHistoryResponse

// .anduril.entityhistory.v1.HistoryPage history_page = 1 [json_name = "historyPage"];
inline bool ListHistoryResponse::has_history_page() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.history_page_ != nullptr);
  return value;
}
inline const ::anduril::entityhistory::v1::HistoryPage& ListHistoryResponse::_internal_history_page() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entityhistory::v1::HistoryPage* p = _impl_.history_page_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entityhistory::v1::HistoryPage&>(::anduril::entityhistory::v1::_HistoryPage_default_instance_);
}
inline const ::anduril::entityhistory::v1::HistoryPage& ListHistoryResponse::history_page() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.ListHistoryResponse.history_page)
  return _internal_history_page();
}
inline void ListHistoryResponse::unsafe_arena_set_allocated_history_page(::anduril::entityhistory::v1::HistoryPage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.history_page_);
  }
  _impl_.history_page_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryPage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.ListHistoryResponse.history_page)
}
inline ::anduril::entityhistory::v1::HistoryPage* ListHistoryResponse::release_history_page() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entityhistory::v1::HistoryPage* released = _impl_.history_page_;
  _impl_.history_page_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entityhistory::v1::HistoryPage* ListHistoryResponse::unsafe_arena_release_history_page() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.ListHistoryResponse.history_page)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entityhistory::v1::HistoryPage* temp = _impl_.history_page_;
  _impl_.history_page_ = nullptr;
  return temp;
}
inline ::anduril::entityhistory::v1::HistoryPage* ListHistoryResponse::_internal_mutable_history_page() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.history_page_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entityhistory::v1::HistoryPage>(GetArena());
    _impl_.history_page_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryPage*>(p);
  }
  return _impl_.history_page_;
}
inline ::anduril::entityhistory::v1::HistoryPage* ListHistoryResponse::mutable_history_page() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entityhistory::v1::HistoryPage* _msg = _internal_mutable_history_page();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.ListHistoryResponse.history_page)
  return _msg;
}
inline void ListHistoryResponse::set_allocated_history_page(::anduril::entityhistory::v1::HistoryPage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.history_page_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.history_page_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryPage*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.ListHistoryResponse.history_page)
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void ListHistoryResponse::clear_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListHistoryResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.ListHistoryResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListHistoryResponse::set_next_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entityhistory.v1.ListHistoryResponse.next_page_token)
}
inline std::string* ListHistoryResponse::mutable_next_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.ListHistoryResponse.next_page_token)
  return _s;
}
inline const std::string& ListHistoryResponse::_internal_next_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_page_token_.Get();
}
inline void ListHistoryResponse::_internal_set_next_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(value, GetArena());
}
inline std::string* ListHistoryResponse::_internal_mutable_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline std::string* ListHistoryResponse::release_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.ListHistoryResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListHistoryResponse::set_allocated_next_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_page_token_.IsDefault()) {
          _impl_.next_page_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.ListHistoryResponse.next_page_token)
}

// .anduril.entityhistory.v1.HistoryPageToken next_history_page_token = 3 [json_name = "nextHistoryPageToken"];
inline bool ListHistoryResponse::has_next_history_page_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.next_history_page_token_ != nullptr);
  return value;
}
inline const ::anduril::entityhistory::v1::HistoryPageToken& ListHistoryResponse::_internal_next_history_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entityhistory::v1::HistoryPageToken* p = _impl_.next_history_page_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entityhistory::v1::HistoryPageToken&>(::anduril::entityhistory::v1::_HistoryPageToken_default_instance_);
}
inline const ::anduril::entityhistory::v1::HistoryPageToken& ListHistoryResponse::next_history_page_token() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.ListHistoryResponse.next_history_page_token)
  return _internal_next_history_page_token();
}
inline void ListHistoryResponse::unsafe_arena_set_allocated_next_history_page_token(::anduril::entityhistory::v1::HistoryPageToken* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.next_history_page_token_);
  }
  _impl_.next_history_page_token_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryPageToken*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.ListHistoryResponse.next_history_page_token)
}
inline ::anduril::entityhistory::v1::HistoryPageToken* ListHistoryResponse::release_next_history_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entityhistory::v1::HistoryPageToken* released = _impl_.next_history_page_token_;
  _impl_.next_history_page_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entityhistory::v1::HistoryPageToken* ListHistoryResponse::unsafe_arena_release_next_history_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.ListHistoryResponse.next_history_page_token)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entityhistory::v1::HistoryPageToken* temp = _impl_.next_history_page_token_;
  _impl_.next_history_page_token_ = nullptr;
  return temp;
}
inline ::anduril::entityhistory::v1::HistoryPageToken* ListHistoryResponse::_internal_mutable_next_history_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.next_history_page_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entityhistory::v1::HistoryPageToken>(GetArena());
    _impl_.next_history_page_token_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryPageToken*>(p);
  }
  return _impl_.next_history_page_token_;
}
inline ::anduril::entityhistory::v1::HistoryPageToken* ListHistoryResponse::mutable_next_history_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entityhistory::v1::HistoryPageToken* _msg = _internal_mutable_next_history_page_token();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.ListHistoryResponse.next_history_page_token)
  return _msg;
}
inline void ListHistoryResponse::set_allocated_next_history_page_token(::anduril::entityhistory::v1::HistoryPageToken* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.next_history_page_token_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.next_history_page_token_ = reinterpret_cast<::anduril::entityhistory::v1::HistoryPageToken*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.ListHistoryResponse.next_history_page_token)
}

// -------------------------------------------------------------------

// HistoryQuery

// .anduril.entityhistory.v1.HistoryType history_type = 1 [json_name = "historyType"];
inline void HistoryQuery::clear_history_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.history_type_ = 0;
}
inline ::anduril::entityhistory::v1::HistoryType HistoryQuery::history_type() const {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.HistoryQuery.history_type)
  return _internal_history_type();
}
inline void HistoryQuery::set_history_type(::anduril::entityhistory::v1::HistoryType value) {
  _internal_set_history_type(value);
  // @@protoc_insertion_point(field_set:anduril.entityhistory.v1.HistoryQuery.history_type)
}
inline ::anduril::entityhistory::v1::HistoryType HistoryQuery::_internal_history_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::anduril::entityhistory::v1::HistoryType>(_impl_.history_type_);
}
inline void HistoryQuery::_internal_set_history_type(::anduril::entityhistory::v1::HistoryType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.history_type_ = value;
}

// .anduril.entityhistory.v1.TimeRange time_range = 2 [json_name = "timeRange"];
inline bool HistoryQuery::has_time_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_range_ != nullptr);
  return value;
}
inline void HistoryQuery::clear_time_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.time_range_ != nullptr) _impl_.time_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entityhistory::v1::TimeRange& HistoryQuery::_internal_time_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entityhistory::v1::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entityhistory::v1::TimeRange&>(::anduril::entityhistory::v1::_TimeRange_default_instance_);
}
inline const ::anduril::entityhistory::v1::TimeRange& HistoryQuery::time_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.HistoryQuery.time_range)
  return _internal_time_range();
}
inline void HistoryQuery::unsafe_arena_set_allocated_time_range(::anduril::entityhistory::v1::TimeRange* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = reinterpret_cast<::anduril::entityhistory::v1::TimeRange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.HistoryQuery.time_range)
}
inline ::anduril::entityhistory::v1::TimeRange* HistoryQuery::release_time_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entityhistory::v1::TimeRange* released = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entityhistory::v1::TimeRange* HistoryQuery::unsafe_arena_release_time_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.HistoryQuery.time_range)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entityhistory::v1::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::anduril::entityhistory::v1::TimeRange* HistoryQuery::_internal_mutable_time_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entityhistory::v1::TimeRange>(GetArena());
    _impl_.time_range_ = reinterpret_cast<::anduril::entityhistory::v1::TimeRange*>(p);
  }
  return _impl_.time_range_;
}
inline ::anduril::entityhistory::v1::TimeRange* HistoryQuery::mutable_time_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entityhistory::v1::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.HistoryQuery.time_range)
  return _msg;
}
inline void HistoryQuery::set_allocated_time_range(::anduril::entityhistory::v1::TimeRange* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entityhistory::v1::TimeRange*>(_impl_.time_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entityhistory::v1::TimeRange*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_range_ = reinterpret_cast<::anduril::entityhistory::v1::TimeRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.HistoryQuery.time_range)
}

// .anduril.entityhistory.v1.Downsample downsample = 3 [json_name = "downsample"];
inline bool HistoryQuery::has_downsample() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.downsample_ != nullptr);
  return value;
}
inline void HistoryQuery::clear_downsample() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.downsample_ != nullptr) _impl_.downsample_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::anduril::entityhistory::v1::Downsample& HistoryQuery::_internal_downsample() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entityhistory::v1::Downsample* p = _impl_.downsample_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entityhistory::v1::Downsample&>(::anduril::entityhistory::v1::_Downsample_default_instance_);
}
inline const ::anduril::entityhistory::v1::Downsample& HistoryQuery::downsample() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.HistoryQuery.downsample)
  return _internal_downsample();
}
inline void HistoryQuery::unsafe_arena_set_allocated_downsample(::anduril::entityhistory::v1::Downsample* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.downsample_);
  }
  _impl_.downsample_ = reinterpret_cast<::anduril::entityhistory::v1::Downsample*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.HistoryQuery.downsample)
}
inline ::anduril::entityhistory::v1::Downsample* HistoryQuery::release_downsample() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entityhistory::v1::Downsample* released = _impl_.downsample_;
  _impl_.downsample_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entityhistory::v1::Downsample* HistoryQuery::unsafe_arena_release_downsample() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.HistoryQuery.downsample)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::entityhistory::v1::Downsample* temp = _impl_.downsample_;
  _impl_.downsample_ = nullptr;
  return temp;
}
inline ::anduril::entityhistory::v1::Downsample* HistoryQuery::_internal_mutable_downsample() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.downsample_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entityhistory::v1::Downsample>(GetArena());
    _impl_.downsample_ = reinterpret_cast<::anduril::entityhistory::v1::Downsample*>(p);
  }
  return _impl_.downsample_;
}
inline ::anduril::entityhistory::v1::Downsample* HistoryQuery::mutable_downsample() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entityhistory::v1::Downsample* _msg = _internal_mutable_downsample();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.HistoryQuery.downsample)
  return _msg;
}
inline void HistoryQuery::set_allocated_downsample(::anduril::entityhistory::v1::Downsample* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entityhistory::v1::Downsample*>(_impl_.downsample_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entityhistory::v1::Downsample*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.downsample_ = reinterpret_cast<::anduril::entityhistory::v1::Downsample*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.HistoryQuery.downsample)
}

// .anduril.entitymanager.v1.Statement statement = 4 [json_name = "statement"];
inline bool HistoryQuery::has_statement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.statement_ != nullptr);
  return value;
}
inline const ::anduril::entitymanager::v1::Statement& HistoryQuery::_internal_statement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entitymanager::v1::Statement* p = _impl_.statement_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entitymanager::v1::Statement&>(::anduril::entitymanager::v1::_Statement_default_instance_);
}
inline const ::anduril::entitymanager::v1::Statement& HistoryQuery::statement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.HistoryQuery.statement)
  return _internal_statement();
}
inline void HistoryQuery::unsafe_arena_set_allocated_statement(::anduril::entitymanager::v1::Statement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statement_);
  }
  _impl_.statement_ = reinterpret_cast<::anduril::entitymanager::v1::Statement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.HistoryQuery.statement)
}
inline ::anduril::entitymanager::v1::Statement* HistoryQuery::release_statement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::entitymanager::v1::Statement* released = _impl_.statement_;
  _impl_.statement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entitymanager::v1::Statement* HistoryQuery::unsafe_arena_release_statement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.HistoryQuery.statement)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::anduril::entitymanager::v1::Statement* temp = _impl_.statement_;
  _impl_.statement_ = nullptr;
  return temp;
}
inline ::anduril::entitymanager::v1::Statement* HistoryQuery::_internal_mutable_statement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.statement_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entitymanager::v1::Statement>(GetArena());
    _impl_.statement_ = reinterpret_cast<::anduril::entitymanager::v1::Statement*>(p);
  }
  return _impl_.statement_;
}
inline ::anduril::entitymanager::v1::Statement* HistoryQuery::mutable_statement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entitymanager::v1::Statement* _msg = _internal_mutable_statement();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.HistoryQuery.statement)
  return _msg;
}
inline void HistoryQuery::set_allocated_statement(::anduril::entitymanager::v1::Statement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.statement_ = reinterpret_cast<::anduril::entitymanager::v1::Statement*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.HistoryQuery.statement)
}

// repeated string entity_ids = 5 [json_name = "entityIds"];
inline int HistoryQuery::_internal_entity_ids_size() const {
  return _internal_entity_ids().size();
}
inline int HistoryQuery::entity_ids_size() const {
  return _internal_entity_ids_size();
}
inline void HistoryQuery::clear_entity_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_ids_.Clear();
}
inline std::string* HistoryQuery::add_entity_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_entity_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:anduril.entityhistory.v1.HistoryQuery.entity_ids)
  return _s;
}
inline const std::string& HistoryQuery::entity_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.HistoryQuery.entity_ids)
  return _internal_entity_ids().Get(index);
}
inline std::string* HistoryQuery::mutable_entity_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.HistoryQuery.entity_ids)
  return _internal_mutable_entity_ids()->Mutable(index);
}
inline void HistoryQuery::set_entity_ids(int index, const std::string& value) {
  _internal_mutable_entity_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:anduril.entityhistory.v1.HistoryQuery.entity_ids)
}
inline void HistoryQuery::set_entity_ids(int index, std::string&& value) {
  _internal_mutable_entity_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:anduril.entityhistory.v1.HistoryQuery.entity_ids)
}
inline void HistoryQuery::set_entity_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_entity_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:anduril.entityhistory.v1.HistoryQuery.entity_ids)
}
inline void HistoryQuery::set_entity_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_entity_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:anduril.entityhistory.v1.HistoryQuery.entity_ids)
}
inline void HistoryQuery::set_entity_ids(int index, absl::string_view value) {
  _internal_mutable_entity_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:anduril.entityhistory.v1.HistoryQuery.entity_ids)
}
inline void HistoryQuery::add_entity_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_entity_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:anduril.entityhistory.v1.HistoryQuery.entity_ids)
}
inline void HistoryQuery::add_entity_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_entity_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:anduril.entityhistory.v1.HistoryQuery.entity_ids)
}
inline void HistoryQuery::add_entity_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_entity_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:anduril.entityhistory.v1.HistoryQuery.entity_ids)
}
inline void HistoryQuery::add_entity_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_entity_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:anduril.entityhistory.v1.HistoryQuery.entity_ids)
}
inline void HistoryQuery::add_entity_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_entity_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:anduril.entityhistory.v1.HistoryQuery.entity_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HistoryQuery::entity_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entityhistory.v1.HistoryQuery.entity_ids)
  return _internal_entity_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HistoryQuery::mutable_entity_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entityhistory.v1.HistoryQuery.entity_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_entity_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HistoryQuery::_internal_entity_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entity_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HistoryQuery::_internal_mutable_entity_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.entity_ids_;
}

// -------------------------------------------------------------------

// TimeRange

// .google.protobuf.Timestamp lower_bound_inc = 1 [json_name = "lowerBoundInc"];
inline bool TimeRange::has_lower_bound_inc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lower_bound_inc_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TimeRange::_internal_lower_bound_inc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.lower_bound_inc_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimeRange::lower_bound_inc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.TimeRange.lower_bound_inc)
  return _internal_lower_bound_inc();
}
inline void TimeRange::unsafe_arena_set_allocated_lower_bound_inc(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lower_bound_inc_);
  }
  _impl_.lower_bound_inc_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.TimeRange.lower_bound_inc)
}
inline ::google::protobuf::Timestamp* TimeRange::release_lower_bound_inc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.lower_bound_inc_;
  _impl_.lower_bound_inc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* TimeRange::unsafe_arena_release_lower_bound_inc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.TimeRange.lower_bound_inc)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.lower_bound_inc_;
  _impl_.lower_bound_inc_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TimeRange::_internal_mutable_lower_bound_inc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lower_bound_inc_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.lower_bound_inc_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.lower_bound_inc_;
}
inline ::google::protobuf::Timestamp* TimeRange::mutable_lower_bound_inc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_lower_bound_inc();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.TimeRange.lower_bound_inc)
  return _msg;
}
inline void TimeRange::set_allocated_lower_bound_inc(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lower_bound_inc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lower_bound_inc_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.TimeRange.lower_bound_inc)
}

// .google.protobuf.Timestamp upper_bound_exc = 2 [json_name = "upperBoundExc"];
inline bool TimeRange::has_upper_bound_exc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.upper_bound_exc_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TimeRange::_internal_upper_bound_exc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.upper_bound_exc_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimeRange::upper_bound_exc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.TimeRange.upper_bound_exc)
  return _internal_upper_bound_exc();
}
inline void TimeRange::unsafe_arena_set_allocated_upper_bound_exc(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.upper_bound_exc_);
  }
  _impl_.upper_bound_exc_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.TimeRange.upper_bound_exc)
}
inline ::google::protobuf::Timestamp* TimeRange::release_upper_bound_exc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.upper_bound_exc_;
  _impl_.upper_bound_exc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* TimeRange::unsafe_arena_release_upper_bound_exc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.TimeRange.upper_bound_exc)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.upper_bound_exc_;
  _impl_.upper_bound_exc_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TimeRange::_internal_mutable_upper_bound_exc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.upper_bound_exc_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.upper_bound_exc_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.upper_bound_exc_;
}
inline ::google::protobuf::Timestamp* TimeRange::mutable_upper_bound_exc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_upper_bound_exc();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.TimeRange.upper_bound_exc)
  return _msg;
}
inline void TimeRange::set_allocated_upper_bound_exc(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.upper_bound_exc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.upper_bound_exc_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.TimeRange.upper_bound_exc)
}

// -------------------------------------------------------------------

// Downsample

// .anduril.entityhistory.v1.DownsampleDuration downsample_duration = 1 [json_name = "downsampleDuration"];
inline bool Downsample::has_downsample_duration() const {
  return type_case() == kDownsampleDuration;
}
inline bool Downsample::_internal_has_downsample_duration() const {
  return type_case() == kDownsampleDuration;
}
inline void Downsample::set_has_downsample_duration() {
  _impl_._oneof_case_[0] = kDownsampleDuration;
}
inline void Downsample::clear_downsample_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kDownsampleDuration) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.downsample_duration_;
    }
    clear_has_type();
  }
}
inline ::anduril::entityhistory::v1::DownsampleDuration* Downsample::release_downsample_duration() {
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.Downsample.downsample_duration)
  if (type_case() == kDownsampleDuration) {
    clear_has_type();
    auto* temp = _impl_.type_.downsample_duration_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.downsample_duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::entityhistory::v1::DownsampleDuration& Downsample::_internal_downsample_duration() const {
  return type_case() == kDownsampleDuration ? *_impl_.type_.downsample_duration_ : reinterpret_cast<::anduril::entityhistory::v1::DownsampleDuration&>(::anduril::entityhistory::v1::_DownsampleDuration_default_instance_);
}
inline const ::anduril::entityhistory::v1::DownsampleDuration& Downsample::downsample_duration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.Downsample.downsample_duration)
  return _internal_downsample_duration();
}
inline ::anduril::entityhistory::v1::DownsampleDuration* Downsample::unsafe_arena_release_downsample_duration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.entityhistory.v1.Downsample.downsample_duration)
  if (type_case() == kDownsampleDuration) {
    clear_has_type();
    auto* temp = _impl_.type_.downsample_duration_;
    _impl_.type_.downsample_duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Downsample::unsafe_arena_set_allocated_downsample_duration(::anduril::entityhistory::v1::DownsampleDuration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_downsample_duration();
    _impl_.type_.downsample_duration_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.Downsample.downsample_duration)
}
inline ::anduril::entityhistory::v1::DownsampleDuration* Downsample::_internal_mutable_downsample_duration() {
  if (type_case() != kDownsampleDuration) {
    clear_type();
    set_has_downsample_duration();
    _impl_.type_.downsample_duration_ = CreateMaybeMessage<::anduril::entityhistory::v1::DownsampleDuration>(GetArena());
  }
  return _impl_.type_.downsample_duration_;
}
inline ::anduril::entityhistory::v1::DownsampleDuration* Downsample::mutable_downsample_duration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entityhistory::v1::DownsampleDuration* _msg = _internal_mutable_downsample_duration();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.Downsample.downsample_duration)
  return _msg;
}

inline bool Downsample::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Downsample::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Downsample::TypeCase Downsample::type_case() const {
  return Downsample::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DownsampleDuration

// uint32 duration_ms = 1 [json_name = "durationMs"];
inline void DownsampleDuration::clear_duration_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_ms_ = 0u;
}
inline ::uint32_t DownsampleDuration::duration_ms() const {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.DownsampleDuration.duration_ms)
  return _internal_duration_ms();
}
inline void DownsampleDuration::set_duration_ms(::uint32_t value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:anduril.entityhistory.v1.DownsampleDuration.duration_ms)
}
inline ::uint32_t DownsampleDuration::_internal_duration_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_ms_;
}
inline void DownsampleDuration::_internal_set_duration_ms(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_ms_ = value;
}

// -------------------------------------------------------------------

// StreamBackfillUpdatesRequest

// -------------------------------------------------------------------

// StreamBackfillUpdatesResponse

// repeated .anduril.entityhistory.v1.BackfillUpdate backfill_updates = 1 [json_name = "backfillUpdates"];
inline int StreamBackfillUpdatesResponse::_internal_backfill_updates_size() const {
  return _internal_backfill_updates().size();
}
inline int StreamBackfillUpdatesResponse::backfill_updates_size() const {
  return _internal_backfill_updates_size();
}
inline void StreamBackfillUpdatesResponse::clear_backfill_updates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.backfill_updates_.Clear();
}
inline ::anduril::entityhistory::v1::BackfillUpdate* StreamBackfillUpdatesResponse::mutable_backfill_updates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.StreamBackfillUpdatesResponse.backfill_updates)
  return _internal_mutable_backfill_updates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entityhistory::v1::BackfillUpdate>* StreamBackfillUpdatesResponse::mutable_backfill_updates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.entityhistory.v1.StreamBackfillUpdatesResponse.backfill_updates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_backfill_updates();
}
inline const ::anduril::entityhistory::v1::BackfillUpdate& StreamBackfillUpdatesResponse::backfill_updates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.StreamBackfillUpdatesResponse.backfill_updates)
  return _internal_backfill_updates().Get(index);
}
inline ::anduril::entityhistory::v1::BackfillUpdate* StreamBackfillUpdatesResponse::add_backfill_updates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::anduril::entityhistory::v1::BackfillUpdate* _add = _internal_mutable_backfill_updates()->Add();
  // @@protoc_insertion_point(field_add:anduril.entityhistory.v1.StreamBackfillUpdatesResponse.backfill_updates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entityhistory::v1::BackfillUpdate>& StreamBackfillUpdatesResponse::backfill_updates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.entityhistory.v1.StreamBackfillUpdatesResponse.backfill_updates)
  return _internal_backfill_updates();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::entityhistory::v1::BackfillUpdate>&
StreamBackfillUpdatesResponse::_internal_backfill_updates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.backfill_updates_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::entityhistory::v1::BackfillUpdate>*
StreamBackfillUpdatesResponse::_internal_mutable_backfill_updates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.backfill_updates_;
}

// -------------------------------------------------------------------

// BackfillUpdate

// string entity_id = 1 [json_name = "entityId"];
inline void BackfillUpdate::clear_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& BackfillUpdate::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.BackfillUpdate.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BackfillUpdate::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.entityhistory.v1.BackfillUpdate.entity_id)
}
inline std::string* BackfillUpdate::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.BackfillUpdate.entity_id)
  return _s;
}
inline const std::string& BackfillUpdate::_internal_entity_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entity_id_.Get();
}
inline void BackfillUpdate::_internal_set_entity_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* BackfillUpdate::_internal_mutable_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* BackfillUpdate::release_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.BackfillUpdate.entity_id)
  return _impl_.entity_id_.Release();
}
inline void BackfillUpdate::set_allocated_entity_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entity_id_.IsDefault()) {
          _impl_.entity_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.BackfillUpdate.entity_id)
}

// .anduril.entityhistory.v1.TimeRange time_range = 2 [json_name = "timeRange"];
inline bool BackfillUpdate::has_time_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_range_ != nullptr);
  return value;
}
inline void BackfillUpdate::clear_time_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.time_range_ != nullptr) _impl_.time_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::anduril::entityhistory::v1::TimeRange& BackfillUpdate::_internal_time_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::entityhistory::v1::TimeRange* p = _impl_.time_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::entityhistory::v1::TimeRange&>(::anduril::entityhistory::v1::_TimeRange_default_instance_);
}
inline const ::anduril::entityhistory::v1::TimeRange& BackfillUpdate::time_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.entityhistory.v1.BackfillUpdate.time_range)
  return _internal_time_range();
}
inline void BackfillUpdate::unsafe_arena_set_allocated_time_range(::anduril::entityhistory::v1::TimeRange* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_range_);
  }
  _impl_.time_range_ = reinterpret_cast<::anduril::entityhistory::v1::TimeRange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.entityhistory.v1.BackfillUpdate.time_range)
}
inline ::anduril::entityhistory::v1::TimeRange* BackfillUpdate::release_time_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entityhistory::v1::TimeRange* released = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::entityhistory::v1::TimeRange* BackfillUpdate::unsafe_arena_release_time_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.entityhistory.v1.BackfillUpdate.time_range)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::entityhistory::v1::TimeRange* temp = _impl_.time_range_;
  _impl_.time_range_ = nullptr;
  return temp;
}
inline ::anduril::entityhistory::v1::TimeRange* BackfillUpdate::_internal_mutable_time_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::entityhistory::v1::TimeRange>(GetArena());
    _impl_.time_range_ = reinterpret_cast<::anduril::entityhistory::v1::TimeRange*>(p);
  }
  return _impl_.time_range_;
}
inline ::anduril::entityhistory::v1::TimeRange* BackfillUpdate::mutable_time_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::entityhistory::v1::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:anduril.entityhistory.v1.BackfillUpdate.time_range)
  return _msg;
}
inline void BackfillUpdate::set_allocated_time_range(::anduril::entityhistory::v1::TimeRange* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::anduril::entityhistory::v1::TimeRange*>(_impl_.time_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::anduril::entityhistory::v1::TimeRange*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_range_ = reinterpret_cast<::anduril::entityhistory::v1::TimeRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.entityhistory.v1.BackfillUpdate.time_range)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace entityhistory
}  // namespace anduril


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2fentityhistory_2fv1_2fentity_5fhistory_5fapi_2epub_2eproto_2epb_2eh
