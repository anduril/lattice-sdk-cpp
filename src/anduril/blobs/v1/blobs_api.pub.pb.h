// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: anduril/blobs/v1/blobs_api.pub.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "anduril/blobs/v1/common.pub.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
namespace anduril {
namespace blobs {
namespace v1 {
class BlobAnnouncement;
struct BlobAnnouncementDefaultTypeInternal;
extern BlobAnnouncementDefaultTypeInternal _BlobAnnouncement_default_instance_;
class CreateBlobChunkedRequest;
struct CreateBlobChunkedRequestDefaultTypeInternal;
extern CreateBlobChunkedRequestDefaultTypeInternal _CreateBlobChunkedRequest_default_instance_;
class CreateBlobChunkedResponse;
struct CreateBlobChunkedResponseDefaultTypeInternal;
extern CreateBlobChunkedResponseDefaultTypeInternal _CreateBlobChunkedResponse_default_instance_;
class CreateBlobRequest;
struct CreateBlobRequestDefaultTypeInternal;
extern CreateBlobRequestDefaultTypeInternal _CreateBlobRequest_default_instance_;
class CreateBlobResponse;
struct CreateBlobResponseDefaultTypeInternal;
extern CreateBlobResponseDefaultTypeInternal _CreateBlobResponse_default_instance_;
class GetBlobRequest;
struct GetBlobRequestDefaultTypeInternal;
extern GetBlobRequestDefaultTypeInternal _GetBlobRequest_default_instance_;
class GetBlobResponse;
struct GetBlobResponseDefaultTypeInternal;
extern GetBlobResponseDefaultTypeInternal _GetBlobResponse_default_instance_;
class HeadBlobRequest;
struct HeadBlobRequestDefaultTypeInternal;
extern HeadBlobRequestDefaultTypeInternal _HeadBlobRequest_default_instance_;
class HeadBlobResponse;
struct HeadBlobResponseDefaultTypeInternal;
extern HeadBlobResponseDefaultTypeInternal _HeadBlobResponse_default_instance_;
class StreamBlobMetadataRequest;
struct StreamBlobMetadataRequestDefaultTypeInternal;
extern StreamBlobMetadataRequestDefaultTypeInternal _StreamBlobMetadataRequest_default_instance_;
class StreamBlobMetadataResponse;
struct StreamBlobMetadataResponseDefaultTypeInternal;
extern StreamBlobMetadataResponseDefaultTypeInternal _StreamBlobMetadataResponse_default_instance_;
}  // namespace v1
}  // namespace blobs
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace blobs {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class StreamBlobMetadataRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.StreamBlobMetadataRequest) */ {
 public:
  inline StreamBlobMetadataRequest() : StreamBlobMetadataRequest(nullptr) {}
  ~StreamBlobMetadataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamBlobMetadataRequest(::google::protobuf::internal::ConstantInitialized);

  inline StreamBlobMetadataRequest(const StreamBlobMetadataRequest& from)
      : StreamBlobMetadataRequest(nullptr, from) {}
  StreamBlobMetadataRequest(StreamBlobMetadataRequest&& from) noexcept
    : StreamBlobMetadataRequest() {
    *this = ::std::move(from);
  }

  inline StreamBlobMetadataRequest& operator=(const StreamBlobMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamBlobMetadataRequest& operator=(StreamBlobMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamBlobMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamBlobMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const StreamBlobMetadataRequest*>(
               &_StreamBlobMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StreamBlobMetadataRequest& a, StreamBlobMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamBlobMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamBlobMetadataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamBlobMetadataRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamBlobMetadataRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamBlobMetadataRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StreamBlobMetadataRequest& from) {
    StreamBlobMetadataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamBlobMetadataRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.StreamBlobMetadataRequest";
  }
  protected:
  explicit StreamBlobMetadataRequest(::google::protobuf::Arena* arena);
  StreamBlobMetadataRequest(::google::protobuf::Arena* arena, const StreamBlobMetadataRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string client_id = 1 [json_name = "clientId"];
  void clear_client_id() ;
  const std::string& client_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* value);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.StreamBlobMetadataRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr client_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class HeadBlobRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.HeadBlobRequest) */ {
 public:
  inline HeadBlobRequest() : HeadBlobRequest(nullptr) {}
  ~HeadBlobRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeadBlobRequest(::google::protobuf::internal::ConstantInitialized);

  inline HeadBlobRequest(const HeadBlobRequest& from)
      : HeadBlobRequest(nullptr, from) {}
  HeadBlobRequest(HeadBlobRequest&& from) noexcept
    : HeadBlobRequest() {
    *this = ::std::move(from);
  }

  inline HeadBlobRequest& operator=(const HeadBlobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadBlobRequest& operator=(HeadBlobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadBlobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadBlobRequest* internal_default_instance() {
    return reinterpret_cast<const HeadBlobRequest*>(
               &_HeadBlobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HeadBlobRequest& a, HeadBlobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadBlobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadBlobRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeadBlobRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeadBlobRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeadBlobRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HeadBlobRequest& from) {
    HeadBlobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeadBlobRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.HeadBlobRequest";
  }
  protected:
  explicit HeadBlobRequest(::google::protobuf::Arena* arena);
  HeadBlobRequest(::google::protobuf::Arena* arena, const HeadBlobRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // string client_id = 1 [json_name = "clientId"];
  void clear_client_id() ;
  const std::string& client_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* value);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // string key = 2 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.HeadBlobRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr client_id_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class GetBlobRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.GetBlobRequest) */ {
 public:
  inline GetBlobRequest() : GetBlobRequest(nullptr) {}
  ~GetBlobRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetBlobRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetBlobRequest(const GetBlobRequest& from)
      : GetBlobRequest(nullptr, from) {}
  GetBlobRequest(GetBlobRequest&& from) noexcept
    : GetBlobRequest() {
    *this = ::std::move(from);
  }

  inline GetBlobRequest& operator=(const GetBlobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlobRequest& operator=(GetBlobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlobRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlobRequest*>(
               &_GetBlobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetBlobRequest& a, GetBlobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlobRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlobRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlobRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBlobRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetBlobRequest& from) {
    GetBlobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetBlobRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.GetBlobRequest";
  }
  protected:
  explicit GetBlobRequest(::google::protobuf::Arena* arena);
  GetBlobRequest(::google::protobuf::Arena* arena, const GetBlobRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // string client_id = 1 [json_name = "clientId"];
  void clear_client_id() ;
  const std::string& client_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* value);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // string key = 2 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.GetBlobRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr client_id_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class CreateBlobRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.CreateBlobRequest) */ {
 public:
  inline CreateBlobRequest() : CreateBlobRequest(nullptr) {}
  ~CreateBlobRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateBlobRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateBlobRequest(const CreateBlobRequest& from)
      : CreateBlobRequest(nullptr, from) {}
  CreateBlobRequest(CreateBlobRequest&& from) noexcept
    : CreateBlobRequest() {
    *this = ::std::move(from);
  }

  inline CreateBlobRequest& operator=(const CreateBlobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBlobRequest& operator=(CreateBlobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBlobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBlobRequest* internal_default_instance() {
    return reinterpret_cast<const CreateBlobRequest*>(
               &_CreateBlobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateBlobRequest& a, CreateBlobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateBlobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBlobRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBlobRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateBlobRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateBlobRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateBlobRequest& from) {
    CreateBlobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateBlobRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.CreateBlobRequest";
  }
  protected:
  explicit CreateBlobRequest(::google::protobuf::Arena* arena);
  CreateBlobRequest(::google::protobuf::Arena* arena, const CreateBlobRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kMd5FieldNumber = 4,
    kContentsFieldNumber = 5,
    kRetentionTimeFieldNumber = 3,
    kProvenanceFieldNumber = 6,
  };
  // string client_id = 1 [json_name = "clientId"];
  void clear_client_id() ;
  const std::string& client_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* value);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // string key = 2 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes md5 = 4 [json_name = "md5"];
  void clear_md5() ;
  const std::string& md5() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_md5(Arg_&& arg, Args_... args);
  std::string* mutable_md5();
  PROTOBUF_NODISCARD std::string* release_md5();
  void set_allocated_md5(std::string* value);

  private:
  const std::string& _internal_md5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_md5(
      const std::string& value);
  std::string* _internal_mutable_md5();

  public:
  // bytes contents = 5 [json_name = "contents"];
  void clear_contents() ;
  const std::string& contents() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contents(Arg_&& arg, Args_... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* value);

  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(
      const std::string& value);
  std::string* _internal_mutable_contents();

  public:
  // .google.protobuf.Timestamp retention_time = 3 [json_name = "retentionTime"];
  bool has_retention_time() const;
  void clear_retention_time() ;
  const ::google::protobuf::Timestamp& retention_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_retention_time();
  ::google::protobuf::Timestamp* mutable_retention_time();
  void set_allocated_retention_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_retention_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_retention_time();

  private:
  const ::google::protobuf::Timestamp& _internal_retention_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_retention_time();

  public:
  // .anduril.blobs.v1.BlobProvenance provenance = 6 [json_name = "provenance"];
  bool has_provenance() const;
  void clear_provenance() ;
  const ::anduril::blobs::v1::BlobProvenance& provenance() const;
  PROTOBUF_NODISCARD ::anduril::blobs::v1::BlobProvenance* release_provenance();
  ::anduril::blobs::v1::BlobProvenance* mutable_provenance();
  void set_allocated_provenance(::anduril::blobs::v1::BlobProvenance* value);
  void unsafe_arena_set_allocated_provenance(::anduril::blobs::v1::BlobProvenance* value);
  ::anduril::blobs::v1::BlobProvenance* unsafe_arena_release_provenance();

  private:
  const ::anduril::blobs::v1::BlobProvenance& _internal_provenance() const;
  ::anduril::blobs::v1::BlobProvenance* _internal_mutable_provenance();

  public:
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.CreateBlobRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr client_id_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr md5_;
    ::google::protobuf::internal::ArenaStringPtr contents_;
    ::google::protobuf::Timestamp* retention_time_;
    ::anduril::blobs::v1::BlobProvenance* provenance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class CreateBlobChunkedRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.CreateBlobChunkedRequest) */ {
 public:
  inline CreateBlobChunkedRequest() : CreateBlobChunkedRequest(nullptr) {}
  ~CreateBlobChunkedRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateBlobChunkedRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateBlobChunkedRequest(const CreateBlobChunkedRequest& from)
      : CreateBlobChunkedRequest(nullptr, from) {}
  CreateBlobChunkedRequest(CreateBlobChunkedRequest&& from) noexcept
    : CreateBlobChunkedRequest() {
    *this = ::std::move(from);
  }

  inline CreateBlobChunkedRequest& operator=(const CreateBlobChunkedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBlobChunkedRequest& operator=(CreateBlobChunkedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBlobChunkedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBlobChunkedRequest* internal_default_instance() {
    return reinterpret_cast<const CreateBlobChunkedRequest*>(
               &_CreateBlobChunkedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateBlobChunkedRequest& a, CreateBlobChunkedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateBlobChunkedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBlobChunkedRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBlobChunkedRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateBlobChunkedRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateBlobChunkedRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateBlobChunkedRequest& from) {
    CreateBlobChunkedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateBlobChunkedRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.CreateBlobChunkedRequest";
  }
  protected:
  explicit CreateBlobChunkedRequest(::google::protobuf::Arena* arena);
  CreateBlobChunkedRequest(::google::protobuf::Arena* arena, const CreateBlobChunkedRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kMd5FieldNumber = 4,
    kChunkContentsFieldNumber = 5,
    kRetentionTimeFieldNumber = 3,
    kProvenanceFieldNumber = 6,
  };
  // string client_id = 1 [json_name = "clientId"];
  void clear_client_id() ;
  const std::string& client_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* value);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // string key = 2 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes md5 = 4 [json_name = "md5"];
  void clear_md5() ;
  const std::string& md5() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_md5(Arg_&& arg, Args_... args);
  std::string* mutable_md5();
  PROTOBUF_NODISCARD std::string* release_md5();
  void set_allocated_md5(std::string* value);

  private:
  const std::string& _internal_md5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_md5(
      const std::string& value);
  std::string* _internal_mutable_md5();

  public:
  // bytes chunk_contents = 5 [json_name = "chunkContents"];
  void clear_chunk_contents() ;
  const std::string& chunk_contents() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chunk_contents(Arg_&& arg, Args_... args);
  std::string* mutable_chunk_contents();
  PROTOBUF_NODISCARD std::string* release_chunk_contents();
  void set_allocated_chunk_contents(std::string* value);

  private:
  const std::string& _internal_chunk_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk_contents(
      const std::string& value);
  std::string* _internal_mutable_chunk_contents();

  public:
  // .google.protobuf.Timestamp retention_time = 3 [json_name = "retentionTime"];
  bool has_retention_time() const;
  void clear_retention_time() ;
  const ::google::protobuf::Timestamp& retention_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_retention_time();
  ::google::protobuf::Timestamp* mutable_retention_time();
  void set_allocated_retention_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_retention_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_retention_time();

  private:
  const ::google::protobuf::Timestamp& _internal_retention_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_retention_time();

  public:
  // .anduril.blobs.v1.BlobProvenance provenance = 6 [json_name = "provenance"];
  bool has_provenance() const;
  void clear_provenance() ;
  const ::anduril::blobs::v1::BlobProvenance& provenance() const;
  PROTOBUF_NODISCARD ::anduril::blobs::v1::BlobProvenance* release_provenance();
  ::anduril::blobs::v1::BlobProvenance* mutable_provenance();
  void set_allocated_provenance(::anduril::blobs::v1::BlobProvenance* value);
  void unsafe_arena_set_allocated_provenance(::anduril::blobs::v1::BlobProvenance* value);
  ::anduril::blobs::v1::BlobProvenance* unsafe_arena_release_provenance();

  private:
  const ::anduril::blobs::v1::BlobProvenance& _internal_provenance() const;
  ::anduril::blobs::v1::BlobProvenance* _internal_mutable_provenance();

  public:
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.CreateBlobChunkedRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr client_id_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr md5_;
    ::google::protobuf::internal::ArenaStringPtr chunk_contents_;
    ::google::protobuf::Timestamp* retention_time_;
    ::anduril::blobs::v1::BlobProvenance* provenance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class HeadBlobResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.HeadBlobResponse) */ {
 public:
  inline HeadBlobResponse() : HeadBlobResponse(nullptr) {}
  ~HeadBlobResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeadBlobResponse(::google::protobuf::internal::ConstantInitialized);

  inline HeadBlobResponse(const HeadBlobResponse& from)
      : HeadBlobResponse(nullptr, from) {}
  HeadBlobResponse(HeadBlobResponse&& from) noexcept
    : HeadBlobResponse() {
    *this = ::std::move(from);
  }

  inline HeadBlobResponse& operator=(const HeadBlobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadBlobResponse& operator=(HeadBlobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadBlobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadBlobResponse* internal_default_instance() {
    return reinterpret_cast<const HeadBlobResponse*>(
               &_HeadBlobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HeadBlobResponse& a, HeadBlobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadBlobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadBlobResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeadBlobResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeadBlobResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeadBlobResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HeadBlobResponse& from) {
    HeadBlobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeadBlobResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.HeadBlobResponse";
  }
  protected:
  explicit HeadBlobResponse(::google::protobuf::Arena* arena);
  HeadBlobResponse(::google::protobuf::Arena* arena, const HeadBlobResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // string url = 2 [json_name = "url"];
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* value);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // .anduril.blobs.v1.BlobMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::anduril::blobs::v1::BlobMetadata& metadata() const;
  PROTOBUF_NODISCARD ::anduril::blobs::v1::BlobMetadata* release_metadata();
  ::anduril::blobs::v1::BlobMetadata* mutable_metadata();
  void set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value);
  void unsafe_arena_set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value);
  ::anduril::blobs::v1::BlobMetadata* unsafe_arena_release_metadata();

  private:
  const ::anduril::blobs::v1::BlobMetadata& _internal_metadata() const;
  ::anduril::blobs::v1::BlobMetadata* _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.HeadBlobResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::anduril::blobs::v1::BlobMetadata* metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class GetBlobResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.GetBlobResponse) */ {
 public:
  inline GetBlobResponse() : GetBlobResponse(nullptr) {}
  ~GetBlobResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetBlobResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetBlobResponse(const GetBlobResponse& from)
      : GetBlobResponse(nullptr, from) {}
  GetBlobResponse(GetBlobResponse&& from) noexcept
    : GetBlobResponse() {
    *this = ::std::move(from);
  }

  inline GetBlobResponse& operator=(const GetBlobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlobResponse& operator=(GetBlobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlobResponse* internal_default_instance() {
    return reinterpret_cast<const GetBlobResponse*>(
               &_GetBlobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetBlobResponse& a, GetBlobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlobResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlobResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlobResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBlobResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetBlobResponse& from) {
    GetBlobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetBlobResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.GetBlobResponse";
  }
  protected:
  explicit GetBlobResponse(::google::protobuf::Arena* arena);
  GetBlobResponse(::google::protobuf::Arena* arena, const GetBlobResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // bytes contents = 1 [json_name = "contents"];
  void clear_contents() ;
  const std::string& contents() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contents(Arg_&& arg, Args_... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* value);

  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(
      const std::string& value);
  std::string* _internal_mutable_contents();

  public:
  // .anduril.blobs.v1.BlobMetadata metadata = 2 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::anduril::blobs::v1::BlobMetadata& metadata() const;
  PROTOBUF_NODISCARD ::anduril::blobs::v1::BlobMetadata* release_metadata();
  ::anduril::blobs::v1::BlobMetadata* mutable_metadata();
  void set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value);
  void unsafe_arena_set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value);
  ::anduril::blobs::v1::BlobMetadata* unsafe_arena_release_metadata();

  private:
  const ::anduril::blobs::v1::BlobMetadata& _internal_metadata() const;
  ::anduril::blobs::v1::BlobMetadata* _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.GetBlobResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr contents_;
    ::anduril::blobs::v1::BlobMetadata* metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class CreateBlobResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.CreateBlobResponse) */ {
 public:
  inline CreateBlobResponse() : CreateBlobResponse(nullptr) {}
  ~CreateBlobResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateBlobResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateBlobResponse(const CreateBlobResponse& from)
      : CreateBlobResponse(nullptr, from) {}
  CreateBlobResponse(CreateBlobResponse&& from) noexcept
    : CreateBlobResponse() {
    *this = ::std::move(from);
  }

  inline CreateBlobResponse& operator=(const CreateBlobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBlobResponse& operator=(CreateBlobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBlobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBlobResponse* internal_default_instance() {
    return reinterpret_cast<const CreateBlobResponse*>(
               &_CreateBlobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateBlobResponse& a, CreateBlobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateBlobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBlobResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBlobResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateBlobResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateBlobResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateBlobResponse& from) {
    CreateBlobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateBlobResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.CreateBlobResponse";
  }
  protected:
  explicit CreateBlobResponse(::google::protobuf::Arena* arena);
  CreateBlobResponse(::google::protobuf::Arena* arena, const CreateBlobResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // string url = 2 [json_name = "url"];
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* value);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // .anduril.blobs.v1.BlobMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::anduril::blobs::v1::BlobMetadata& metadata() const;
  PROTOBUF_NODISCARD ::anduril::blobs::v1::BlobMetadata* release_metadata();
  ::anduril::blobs::v1::BlobMetadata* mutable_metadata();
  void set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value);
  void unsafe_arena_set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value);
  ::anduril::blobs::v1::BlobMetadata* unsafe_arena_release_metadata();

  private:
  const ::anduril::blobs::v1::BlobMetadata& _internal_metadata() const;
  ::anduril::blobs::v1::BlobMetadata* _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.CreateBlobResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::anduril::blobs::v1::BlobMetadata* metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class CreateBlobChunkedResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.CreateBlobChunkedResponse) */ {
 public:
  inline CreateBlobChunkedResponse() : CreateBlobChunkedResponse(nullptr) {}
  ~CreateBlobChunkedResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateBlobChunkedResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateBlobChunkedResponse(const CreateBlobChunkedResponse& from)
      : CreateBlobChunkedResponse(nullptr, from) {}
  CreateBlobChunkedResponse(CreateBlobChunkedResponse&& from) noexcept
    : CreateBlobChunkedResponse() {
    *this = ::std::move(from);
  }

  inline CreateBlobChunkedResponse& operator=(const CreateBlobChunkedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBlobChunkedResponse& operator=(CreateBlobChunkedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBlobChunkedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBlobChunkedResponse* internal_default_instance() {
    return reinterpret_cast<const CreateBlobChunkedResponse*>(
               &_CreateBlobChunkedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateBlobChunkedResponse& a, CreateBlobChunkedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateBlobChunkedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBlobChunkedResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBlobChunkedResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateBlobChunkedResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateBlobChunkedResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateBlobChunkedResponse& from) {
    CreateBlobChunkedResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateBlobChunkedResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.CreateBlobChunkedResponse";
  }
  protected:
  explicit CreateBlobChunkedResponse(::google::protobuf::Arena* arena);
  CreateBlobChunkedResponse(::google::protobuf::Arena* arena, const CreateBlobChunkedResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // string url = 2 [json_name = "url"];
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* value);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // .anduril.blobs.v1.BlobMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::anduril::blobs::v1::BlobMetadata& metadata() const;
  PROTOBUF_NODISCARD ::anduril::blobs::v1::BlobMetadata* release_metadata();
  ::anduril::blobs::v1::BlobMetadata* mutable_metadata();
  void set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value);
  void unsafe_arena_set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value);
  ::anduril::blobs::v1::BlobMetadata* unsafe_arena_release_metadata();

  private:
  const ::anduril::blobs::v1::BlobMetadata& _internal_metadata() const;
  ::anduril::blobs::v1::BlobMetadata* _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.CreateBlobChunkedResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::anduril::blobs::v1::BlobMetadata* metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class BlobAnnouncement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.BlobAnnouncement) */ {
 public:
  inline BlobAnnouncement() : BlobAnnouncement(nullptr) {}
  ~BlobAnnouncement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlobAnnouncement(::google::protobuf::internal::ConstantInitialized);

  inline BlobAnnouncement(const BlobAnnouncement& from)
      : BlobAnnouncement(nullptr, from) {}
  BlobAnnouncement(BlobAnnouncement&& from) noexcept
    : BlobAnnouncement() {
    *this = ::std::move(from);
  }

  inline BlobAnnouncement& operator=(const BlobAnnouncement& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobAnnouncement& operator=(BlobAnnouncement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobAnnouncement& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobAnnouncement* internal_default_instance() {
    return reinterpret_cast<const BlobAnnouncement*>(
               &_BlobAnnouncement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BlobAnnouncement& a, BlobAnnouncement& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobAnnouncement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobAnnouncement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlobAnnouncement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlobAnnouncement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlobAnnouncement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BlobAnnouncement& from) {
    BlobAnnouncement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BlobAnnouncement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.BlobAnnouncement";
  }
  protected:
  explicit BlobAnnouncement(::google::protobuf::Arena* arena);
  BlobAnnouncement(::google::protobuf::Arena* arena, const BlobAnnouncement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kMetadataFieldNumber = 3,
  };
  // string client_id = 1 [json_name = "clientId"];
  void clear_client_id() ;
  const std::string& client_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* value);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // string key = 2 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .anduril.blobs.v1.BlobMetadata metadata = 3 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::anduril::blobs::v1::BlobMetadata& metadata() const;
  PROTOBUF_NODISCARD ::anduril::blobs::v1::BlobMetadata* release_metadata();
  ::anduril::blobs::v1::BlobMetadata* mutable_metadata();
  void set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value);
  void unsafe_arena_set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value);
  ::anduril::blobs::v1::BlobMetadata* unsafe_arena_release_metadata();

  private:
  const ::anduril::blobs::v1::BlobMetadata& _internal_metadata() const;
  ::anduril::blobs::v1::BlobMetadata* _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.BlobAnnouncement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr client_id_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::anduril::blobs::v1::BlobMetadata* metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};// -------------------------------------------------------------------

class StreamBlobMetadataResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:anduril.blobs.v1.StreamBlobMetadataResponse) */ {
 public:
  inline StreamBlobMetadataResponse() : StreamBlobMetadataResponse(nullptr) {}
  ~StreamBlobMetadataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamBlobMetadataResponse(::google::protobuf::internal::ConstantInitialized);

  inline StreamBlobMetadataResponse(const StreamBlobMetadataResponse& from)
      : StreamBlobMetadataResponse(nullptr, from) {}
  StreamBlobMetadataResponse(StreamBlobMetadataResponse&& from) noexcept
    : StreamBlobMetadataResponse() {
    *this = ::std::move(from);
  }

  inline StreamBlobMetadataResponse& operator=(const StreamBlobMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamBlobMetadataResponse& operator=(StreamBlobMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamBlobMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamBlobMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const StreamBlobMetadataResponse*>(
               &_StreamBlobMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StreamBlobMetadataResponse& a, StreamBlobMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamBlobMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamBlobMetadataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamBlobMetadataResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamBlobMetadataResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamBlobMetadataResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StreamBlobMetadataResponse& from) {
    StreamBlobMetadataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamBlobMetadataResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "anduril.blobs.v1.StreamBlobMetadataResponse";
  }
  protected:
  explicit StreamBlobMetadataResponse(::google::protobuf::Arena* arena);
  StreamBlobMetadataResponse(::google::protobuf::Arena* arena, const StreamBlobMetadataResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnnouncementsFieldNumber = 1,
  };
  // repeated .anduril.blobs.v1.BlobAnnouncement announcements = 1 [json_name = "announcements"];
  int announcements_size() const;
  private:
  int _internal_announcements_size() const;

  public:
  void clear_announcements() ;
  ::anduril::blobs::v1::BlobAnnouncement* mutable_announcements(int index);
  ::google::protobuf::RepeatedPtrField< ::anduril::blobs::v1::BlobAnnouncement >*
      mutable_announcements();
  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::blobs::v1::BlobAnnouncement>& _internal_announcements() const;
  ::google::protobuf::RepeatedPtrField<::anduril::blobs::v1::BlobAnnouncement>* _internal_mutable_announcements();
  public:
  const ::anduril::blobs::v1::BlobAnnouncement& announcements(int index) const;
  ::anduril::blobs::v1::BlobAnnouncement* add_announcements();
  const ::google::protobuf::RepeatedPtrField< ::anduril::blobs::v1::BlobAnnouncement >&
      announcements() const;
  // @@protoc_insertion_point(class_scope:anduril.blobs.v1.StreamBlobMetadataResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::anduril::blobs::v1::BlobAnnouncement > announcements_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CreateBlobRequest

// string client_id = 1 [json_name = "clientId"];
inline void CreateBlobRequest::clear_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& CreateBlobRequest::client_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobRequest.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBlobRequest::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.CreateBlobRequest.client_id)
}
inline std::string* CreateBlobRequest::mutable_client_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobRequest.client_id)
  return _s;
}
inline const std::string& CreateBlobRequest::_internal_client_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_id_.Get();
}
inline void CreateBlobRequest::_internal_set_client_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(value, GetArena());
}
inline std::string* CreateBlobRequest::_internal_mutable_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.client_id_.Mutable( GetArena());
}
inline std::string* CreateBlobRequest::release_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobRequest.client_id)
  return _impl_.client_id_.Release();
}
inline void CreateBlobRequest::set_allocated_client_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobRequest.client_id)
}

// string key = 2 [json_name = "key"];
inline void CreateBlobRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CreateBlobRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBlobRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.CreateBlobRequest.key)
}
inline std::string* CreateBlobRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobRequest.key)
  return _s;
}
inline const std::string& CreateBlobRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void CreateBlobRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* CreateBlobRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* CreateBlobRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobRequest.key)
  return _impl_.key_.Release();
}
inline void CreateBlobRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobRequest.key)
}

// .google.protobuf.Timestamp retention_time = 3 [json_name = "retentionTime"];
inline bool CreateBlobRequest::has_retention_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.retention_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& CreateBlobRequest::_internal_retention_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.retention_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& CreateBlobRequest::retention_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobRequest.retention_time)
  return _internal_retention_time();
}
inline void CreateBlobRequest::unsafe_arena_set_allocated_retention_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.retention_time_);
  }
  _impl_.retention_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.blobs.v1.CreateBlobRequest.retention_time)
}
inline ::google::protobuf::Timestamp* CreateBlobRequest::release_retention_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.retention_time_;
  _impl_.retention_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* CreateBlobRequest::unsafe_arena_release_retention_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobRequest.retention_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.retention_time_;
  _impl_.retention_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* CreateBlobRequest::_internal_mutable_retention_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.retention_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.retention_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.retention_time_;
}
inline ::google::protobuf::Timestamp* CreateBlobRequest::mutable_retention_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_retention_time();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobRequest.retention_time)
  return _msg;
}
inline void CreateBlobRequest::set_allocated_retention_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.retention_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.retention_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobRequest.retention_time)
}

// bytes md5 = 4 [json_name = "md5"];
inline void CreateBlobRequest::clear_md5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.md5_.ClearToEmpty();
}
inline const std::string& CreateBlobRequest::md5() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobRequest.md5)
  return _internal_md5();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBlobRequest::set_md5(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.md5_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.CreateBlobRequest.md5)
}
inline std::string* CreateBlobRequest::mutable_md5() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_md5();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobRequest.md5)
  return _s;
}
inline const std::string& CreateBlobRequest::_internal_md5() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.md5_.Get();
}
inline void CreateBlobRequest::_internal_set_md5(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.md5_.Set(value, GetArena());
}
inline std::string* CreateBlobRequest::_internal_mutable_md5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.md5_.Mutable( GetArena());
}
inline std::string* CreateBlobRequest::release_md5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobRequest.md5)
  return _impl_.md5_.Release();
}
inline void CreateBlobRequest::set_allocated_md5(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.md5_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.md5_.IsDefault()) {
          _impl_.md5_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobRequest.md5)
}

// bytes contents = 5 [json_name = "contents"];
inline void CreateBlobRequest::clear_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contents_.ClearToEmpty();
}
inline const std::string& CreateBlobRequest::contents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobRequest.contents)
  return _internal_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBlobRequest::set_contents(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.contents_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.CreateBlobRequest.contents)
}
inline std::string* CreateBlobRequest::mutable_contents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobRequest.contents)
  return _s;
}
inline const std::string& CreateBlobRequest::_internal_contents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contents_.Get();
}
inline void CreateBlobRequest::_internal_set_contents(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.contents_.Set(value, GetArena());
}
inline std::string* CreateBlobRequest::_internal_mutable_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.contents_.Mutable( GetArena());
}
inline std::string* CreateBlobRequest::release_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobRequest.contents)
  return _impl_.contents_.Release();
}
inline void CreateBlobRequest::set_allocated_contents(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contents_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contents_.IsDefault()) {
          _impl_.contents_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobRequest.contents)
}

// .anduril.blobs.v1.BlobProvenance provenance = 6 [json_name = "provenance"];
inline bool CreateBlobRequest::has_provenance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.provenance_ != nullptr);
  return value;
}
inline const ::anduril::blobs::v1::BlobProvenance& CreateBlobRequest::_internal_provenance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::blobs::v1::BlobProvenance* p = _impl_.provenance_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::blobs::v1::BlobProvenance&>(::anduril::blobs::v1::_BlobProvenance_default_instance_);
}
inline const ::anduril::blobs::v1::BlobProvenance& CreateBlobRequest::provenance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobRequest.provenance)
  return _internal_provenance();
}
inline void CreateBlobRequest::unsafe_arena_set_allocated_provenance(::anduril::blobs::v1::BlobProvenance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.provenance_);
  }
  _impl_.provenance_ = reinterpret_cast<::anduril::blobs::v1::BlobProvenance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.blobs.v1.CreateBlobRequest.provenance)
}
inline ::anduril::blobs::v1::BlobProvenance* CreateBlobRequest::release_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::blobs::v1::BlobProvenance* released = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::blobs::v1::BlobProvenance* CreateBlobRequest::unsafe_arena_release_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobRequest.provenance)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::blobs::v1::BlobProvenance* temp = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  return temp;
}
inline ::anduril::blobs::v1::BlobProvenance* CreateBlobRequest::_internal_mutable_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.provenance_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::blobs::v1::BlobProvenance>(GetArena());
    _impl_.provenance_ = reinterpret_cast<::anduril::blobs::v1::BlobProvenance*>(p);
  }
  return _impl_.provenance_;
}
inline ::anduril::blobs::v1::BlobProvenance* CreateBlobRequest::mutable_provenance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::blobs::v1::BlobProvenance* _msg = _internal_mutable_provenance();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobRequest.provenance)
  return _msg;
}
inline void CreateBlobRequest::set_allocated_provenance(::anduril::blobs::v1::BlobProvenance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.provenance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.provenance_ = reinterpret_cast<::anduril::blobs::v1::BlobProvenance*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobRequest.provenance)
}

// -------------------------------------------------------------------

// CreateBlobResponse

// .anduril.blobs.v1.BlobMetadata metadata = 1 [json_name = "metadata"];
inline bool CreateBlobResponse::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline const ::anduril::blobs::v1::BlobMetadata& CreateBlobResponse::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::blobs::v1::BlobMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::blobs::v1::BlobMetadata&>(::anduril::blobs::v1::_BlobMetadata_default_instance_);
}
inline const ::anduril::blobs::v1::BlobMetadata& CreateBlobResponse::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobResponse.metadata)
  return _internal_metadata();
}
inline void CreateBlobResponse::unsafe_arena_set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.blobs.v1.CreateBlobResponse.metadata)
}
inline ::anduril::blobs::v1::BlobMetadata* CreateBlobResponse::release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::blobs::v1::BlobMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::blobs::v1::BlobMetadata* CreateBlobResponse::unsafe_arena_release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobResponse.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::blobs::v1::BlobMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::anduril::blobs::v1::BlobMetadata* CreateBlobResponse::_internal_mutable_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::blobs::v1::BlobMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::anduril::blobs::v1::BlobMetadata* CreateBlobResponse::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::blobs::v1::BlobMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobResponse.metadata)
  return _msg;
}
inline void CreateBlobResponse::set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobResponse.metadata)
}

// string url = 2 [json_name = "url"];
inline void CreateBlobResponse::clear_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.url_.ClearToEmpty();
}
inline const std::string& CreateBlobResponse::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobResponse.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBlobResponse::set_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.CreateBlobResponse.url)
}
inline std::string* CreateBlobResponse::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobResponse.url)
  return _s;
}
inline const std::string& CreateBlobResponse::_internal_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.url_.Get();
}
inline void CreateBlobResponse::_internal_set_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* CreateBlobResponse::_internal_mutable_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* CreateBlobResponse::release_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobResponse.url)
  return _impl_.url_.Release();
}
inline void CreateBlobResponse::set_allocated_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.url_.IsDefault()) {
          _impl_.url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobResponse.url)
}

// -------------------------------------------------------------------

// CreateBlobChunkedRequest

// string client_id = 1 [json_name = "clientId"];
inline void CreateBlobChunkedRequest::clear_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& CreateBlobChunkedRequest::client_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobChunkedRequest.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBlobChunkedRequest::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.CreateBlobChunkedRequest.client_id)
}
inline std::string* CreateBlobChunkedRequest::mutable_client_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobChunkedRequest.client_id)
  return _s;
}
inline const std::string& CreateBlobChunkedRequest::_internal_client_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_id_.Get();
}
inline void CreateBlobChunkedRequest::_internal_set_client_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(value, GetArena());
}
inline std::string* CreateBlobChunkedRequest::_internal_mutable_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.client_id_.Mutable( GetArena());
}
inline std::string* CreateBlobChunkedRequest::release_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobChunkedRequest.client_id)
  return _impl_.client_id_.Release();
}
inline void CreateBlobChunkedRequest::set_allocated_client_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobChunkedRequest.client_id)
}

// string key = 2 [json_name = "key"];
inline void CreateBlobChunkedRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CreateBlobChunkedRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobChunkedRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBlobChunkedRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.CreateBlobChunkedRequest.key)
}
inline std::string* CreateBlobChunkedRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobChunkedRequest.key)
  return _s;
}
inline const std::string& CreateBlobChunkedRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void CreateBlobChunkedRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* CreateBlobChunkedRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* CreateBlobChunkedRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobChunkedRequest.key)
  return _impl_.key_.Release();
}
inline void CreateBlobChunkedRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobChunkedRequest.key)
}

// .google.protobuf.Timestamp retention_time = 3 [json_name = "retentionTime"];
inline bool CreateBlobChunkedRequest::has_retention_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.retention_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& CreateBlobChunkedRequest::_internal_retention_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.retention_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& CreateBlobChunkedRequest::retention_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobChunkedRequest.retention_time)
  return _internal_retention_time();
}
inline void CreateBlobChunkedRequest::unsafe_arena_set_allocated_retention_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.retention_time_);
  }
  _impl_.retention_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.blobs.v1.CreateBlobChunkedRequest.retention_time)
}
inline ::google::protobuf::Timestamp* CreateBlobChunkedRequest::release_retention_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.retention_time_;
  _impl_.retention_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* CreateBlobChunkedRequest::unsafe_arena_release_retention_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobChunkedRequest.retention_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.retention_time_;
  _impl_.retention_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* CreateBlobChunkedRequest::_internal_mutable_retention_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.retention_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.retention_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.retention_time_;
}
inline ::google::protobuf::Timestamp* CreateBlobChunkedRequest::mutable_retention_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_retention_time();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobChunkedRequest.retention_time)
  return _msg;
}
inline void CreateBlobChunkedRequest::set_allocated_retention_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.retention_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.retention_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobChunkedRequest.retention_time)
}

// bytes md5 = 4 [json_name = "md5"];
inline void CreateBlobChunkedRequest::clear_md5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.md5_.ClearToEmpty();
}
inline const std::string& CreateBlobChunkedRequest::md5() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobChunkedRequest.md5)
  return _internal_md5();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBlobChunkedRequest::set_md5(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.md5_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.CreateBlobChunkedRequest.md5)
}
inline std::string* CreateBlobChunkedRequest::mutable_md5() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_md5();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobChunkedRequest.md5)
  return _s;
}
inline const std::string& CreateBlobChunkedRequest::_internal_md5() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.md5_.Get();
}
inline void CreateBlobChunkedRequest::_internal_set_md5(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.md5_.Set(value, GetArena());
}
inline std::string* CreateBlobChunkedRequest::_internal_mutable_md5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.md5_.Mutable( GetArena());
}
inline std::string* CreateBlobChunkedRequest::release_md5() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobChunkedRequest.md5)
  return _impl_.md5_.Release();
}
inline void CreateBlobChunkedRequest::set_allocated_md5(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.md5_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.md5_.IsDefault()) {
          _impl_.md5_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobChunkedRequest.md5)
}

// bytes chunk_contents = 5 [json_name = "chunkContents"];
inline void CreateBlobChunkedRequest::clear_chunk_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chunk_contents_.ClearToEmpty();
}
inline const std::string& CreateBlobChunkedRequest::chunk_contents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobChunkedRequest.chunk_contents)
  return _internal_chunk_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBlobChunkedRequest::set_chunk_contents(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.chunk_contents_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.CreateBlobChunkedRequest.chunk_contents)
}
inline std::string* CreateBlobChunkedRequest::mutable_chunk_contents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_chunk_contents();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobChunkedRequest.chunk_contents)
  return _s;
}
inline const std::string& CreateBlobChunkedRequest::_internal_chunk_contents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.chunk_contents_.Get();
}
inline void CreateBlobChunkedRequest::_internal_set_chunk_contents(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.chunk_contents_.Set(value, GetArena());
}
inline std::string* CreateBlobChunkedRequest::_internal_mutable_chunk_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.chunk_contents_.Mutable( GetArena());
}
inline std::string* CreateBlobChunkedRequest::release_chunk_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobChunkedRequest.chunk_contents)
  return _impl_.chunk_contents_.Release();
}
inline void CreateBlobChunkedRequest::set_allocated_chunk_contents(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chunk_contents_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chunk_contents_.IsDefault()) {
          _impl_.chunk_contents_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobChunkedRequest.chunk_contents)
}

// .anduril.blobs.v1.BlobProvenance provenance = 6 [json_name = "provenance"];
inline bool CreateBlobChunkedRequest::has_provenance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.provenance_ != nullptr);
  return value;
}
inline const ::anduril::blobs::v1::BlobProvenance& CreateBlobChunkedRequest::_internal_provenance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::blobs::v1::BlobProvenance* p = _impl_.provenance_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::blobs::v1::BlobProvenance&>(::anduril::blobs::v1::_BlobProvenance_default_instance_);
}
inline const ::anduril::blobs::v1::BlobProvenance& CreateBlobChunkedRequest::provenance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobChunkedRequest.provenance)
  return _internal_provenance();
}
inline void CreateBlobChunkedRequest::unsafe_arena_set_allocated_provenance(::anduril::blobs::v1::BlobProvenance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.provenance_);
  }
  _impl_.provenance_ = reinterpret_cast<::anduril::blobs::v1::BlobProvenance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.blobs.v1.CreateBlobChunkedRequest.provenance)
}
inline ::anduril::blobs::v1::BlobProvenance* CreateBlobChunkedRequest::release_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::blobs::v1::BlobProvenance* released = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::blobs::v1::BlobProvenance* CreateBlobChunkedRequest::unsafe_arena_release_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobChunkedRequest.provenance)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::anduril::blobs::v1::BlobProvenance* temp = _impl_.provenance_;
  _impl_.provenance_ = nullptr;
  return temp;
}
inline ::anduril::blobs::v1::BlobProvenance* CreateBlobChunkedRequest::_internal_mutable_provenance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.provenance_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::blobs::v1::BlobProvenance>(GetArena());
    _impl_.provenance_ = reinterpret_cast<::anduril::blobs::v1::BlobProvenance*>(p);
  }
  return _impl_.provenance_;
}
inline ::anduril::blobs::v1::BlobProvenance* CreateBlobChunkedRequest::mutable_provenance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::blobs::v1::BlobProvenance* _msg = _internal_mutable_provenance();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobChunkedRequest.provenance)
  return _msg;
}
inline void CreateBlobChunkedRequest::set_allocated_provenance(::anduril::blobs::v1::BlobProvenance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.provenance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.provenance_ = reinterpret_cast<::anduril::blobs::v1::BlobProvenance*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobChunkedRequest.provenance)
}

// -------------------------------------------------------------------

// CreateBlobChunkedResponse

// .anduril.blobs.v1.BlobMetadata metadata = 1 [json_name = "metadata"];
inline bool CreateBlobChunkedResponse::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline const ::anduril::blobs::v1::BlobMetadata& CreateBlobChunkedResponse::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::blobs::v1::BlobMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::blobs::v1::BlobMetadata&>(::anduril::blobs::v1::_BlobMetadata_default_instance_);
}
inline const ::anduril::blobs::v1::BlobMetadata& CreateBlobChunkedResponse::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobChunkedResponse.metadata)
  return _internal_metadata();
}
inline void CreateBlobChunkedResponse::unsafe_arena_set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.blobs.v1.CreateBlobChunkedResponse.metadata)
}
inline ::anduril::blobs::v1::BlobMetadata* CreateBlobChunkedResponse::release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::blobs::v1::BlobMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::blobs::v1::BlobMetadata* CreateBlobChunkedResponse::unsafe_arena_release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobChunkedResponse.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::blobs::v1::BlobMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::anduril::blobs::v1::BlobMetadata* CreateBlobChunkedResponse::_internal_mutable_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::blobs::v1::BlobMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::anduril::blobs::v1::BlobMetadata* CreateBlobChunkedResponse::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::blobs::v1::BlobMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobChunkedResponse.metadata)
  return _msg;
}
inline void CreateBlobChunkedResponse::set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobChunkedResponse.metadata)
}

// string url = 2 [json_name = "url"];
inline void CreateBlobChunkedResponse::clear_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.url_.ClearToEmpty();
}
inline const std::string& CreateBlobChunkedResponse::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.CreateBlobChunkedResponse.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateBlobChunkedResponse::set_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.CreateBlobChunkedResponse.url)
}
inline std::string* CreateBlobChunkedResponse::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.CreateBlobChunkedResponse.url)
  return _s;
}
inline const std::string& CreateBlobChunkedResponse::_internal_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.url_.Get();
}
inline void CreateBlobChunkedResponse::_internal_set_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* CreateBlobChunkedResponse::_internal_mutable_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* CreateBlobChunkedResponse::release_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.CreateBlobChunkedResponse.url)
  return _impl_.url_.Release();
}
inline void CreateBlobChunkedResponse::set_allocated_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.url_.IsDefault()) {
          _impl_.url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.CreateBlobChunkedResponse.url)
}

// -------------------------------------------------------------------

// GetBlobRequest

// string client_id = 1 [json_name = "clientId"];
inline void GetBlobRequest::clear_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& GetBlobRequest::client_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.GetBlobRequest.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetBlobRequest::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.GetBlobRequest.client_id)
}
inline std::string* GetBlobRequest::mutable_client_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.GetBlobRequest.client_id)
  return _s;
}
inline const std::string& GetBlobRequest::_internal_client_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_id_.Get();
}
inline void GetBlobRequest::_internal_set_client_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(value, GetArena());
}
inline std::string* GetBlobRequest::_internal_mutable_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.client_id_.Mutable( GetArena());
}
inline std::string* GetBlobRequest::release_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.GetBlobRequest.client_id)
  return _impl_.client_id_.Release();
}
inline void GetBlobRequest::set_allocated_client_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.GetBlobRequest.client_id)
}

// string key = 2 [json_name = "key"];
inline void GetBlobRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& GetBlobRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.GetBlobRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetBlobRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.GetBlobRequest.key)
}
inline std::string* GetBlobRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.GetBlobRequest.key)
  return _s;
}
inline const std::string& GetBlobRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void GetBlobRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* GetBlobRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* GetBlobRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.GetBlobRequest.key)
  return _impl_.key_.Release();
}
inline void GetBlobRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.GetBlobRequest.key)
}

// -------------------------------------------------------------------

// GetBlobResponse

// bytes contents = 1 [json_name = "contents"];
inline void GetBlobResponse::clear_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contents_.ClearToEmpty();
}
inline const std::string& GetBlobResponse::contents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.GetBlobResponse.contents)
  return _internal_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetBlobResponse::set_contents(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.contents_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.GetBlobResponse.contents)
}
inline std::string* GetBlobResponse::mutable_contents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.GetBlobResponse.contents)
  return _s;
}
inline const std::string& GetBlobResponse::_internal_contents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contents_.Get();
}
inline void GetBlobResponse::_internal_set_contents(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.contents_.Set(value, GetArena());
}
inline std::string* GetBlobResponse::_internal_mutable_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.contents_.Mutable( GetArena());
}
inline std::string* GetBlobResponse::release_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.GetBlobResponse.contents)
  return _impl_.contents_.Release();
}
inline void GetBlobResponse::set_allocated_contents(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contents_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contents_.IsDefault()) {
          _impl_.contents_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.GetBlobResponse.contents)
}

// .anduril.blobs.v1.BlobMetadata metadata = 2 [json_name = "metadata"];
inline bool GetBlobResponse::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline const ::anduril::blobs::v1::BlobMetadata& GetBlobResponse::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::blobs::v1::BlobMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::blobs::v1::BlobMetadata&>(::anduril::blobs::v1::_BlobMetadata_default_instance_);
}
inline const ::anduril::blobs::v1::BlobMetadata& GetBlobResponse::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.GetBlobResponse.metadata)
  return _internal_metadata();
}
inline void GetBlobResponse::unsafe_arena_set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.blobs.v1.GetBlobResponse.metadata)
}
inline ::anduril::blobs::v1::BlobMetadata* GetBlobResponse::release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::blobs::v1::BlobMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::blobs::v1::BlobMetadata* GetBlobResponse::unsafe_arena_release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.GetBlobResponse.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::blobs::v1::BlobMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::anduril::blobs::v1::BlobMetadata* GetBlobResponse::_internal_mutable_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::blobs::v1::BlobMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::anduril::blobs::v1::BlobMetadata* GetBlobResponse::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::blobs::v1::BlobMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.GetBlobResponse.metadata)
  return _msg;
}
inline void GetBlobResponse::set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.GetBlobResponse.metadata)
}

// -------------------------------------------------------------------

// HeadBlobRequest

// string client_id = 1 [json_name = "clientId"];
inline void HeadBlobRequest::clear_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& HeadBlobRequest::client_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.HeadBlobRequest.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HeadBlobRequest::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.HeadBlobRequest.client_id)
}
inline std::string* HeadBlobRequest::mutable_client_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.HeadBlobRequest.client_id)
  return _s;
}
inline const std::string& HeadBlobRequest::_internal_client_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_id_.Get();
}
inline void HeadBlobRequest::_internal_set_client_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(value, GetArena());
}
inline std::string* HeadBlobRequest::_internal_mutable_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.client_id_.Mutable( GetArena());
}
inline std::string* HeadBlobRequest::release_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.HeadBlobRequest.client_id)
  return _impl_.client_id_.Release();
}
inline void HeadBlobRequest::set_allocated_client_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.HeadBlobRequest.client_id)
}

// string key = 2 [json_name = "key"];
inline void HeadBlobRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& HeadBlobRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.HeadBlobRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HeadBlobRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.HeadBlobRequest.key)
}
inline std::string* HeadBlobRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.HeadBlobRequest.key)
  return _s;
}
inline const std::string& HeadBlobRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void HeadBlobRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* HeadBlobRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* HeadBlobRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.HeadBlobRequest.key)
  return _impl_.key_.Release();
}
inline void HeadBlobRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.HeadBlobRequest.key)
}

// -------------------------------------------------------------------

// HeadBlobResponse

// .anduril.blobs.v1.BlobMetadata metadata = 1 [json_name = "metadata"];
inline bool HeadBlobResponse::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline const ::anduril::blobs::v1::BlobMetadata& HeadBlobResponse::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::blobs::v1::BlobMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::blobs::v1::BlobMetadata&>(::anduril::blobs::v1::_BlobMetadata_default_instance_);
}
inline const ::anduril::blobs::v1::BlobMetadata& HeadBlobResponse::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.HeadBlobResponse.metadata)
  return _internal_metadata();
}
inline void HeadBlobResponse::unsafe_arena_set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.blobs.v1.HeadBlobResponse.metadata)
}
inline ::anduril::blobs::v1::BlobMetadata* HeadBlobResponse::release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::blobs::v1::BlobMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::blobs::v1::BlobMetadata* HeadBlobResponse::unsafe_arena_release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.HeadBlobResponse.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::blobs::v1::BlobMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::anduril::blobs::v1::BlobMetadata* HeadBlobResponse::_internal_mutable_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::blobs::v1::BlobMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::anduril::blobs::v1::BlobMetadata* HeadBlobResponse::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::blobs::v1::BlobMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.HeadBlobResponse.metadata)
  return _msg;
}
inline void HeadBlobResponse::set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.HeadBlobResponse.metadata)
}

// string url = 2 [json_name = "url"];
inline void HeadBlobResponse::clear_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.url_.ClearToEmpty();
}
inline const std::string& HeadBlobResponse::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.HeadBlobResponse.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HeadBlobResponse::set_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.HeadBlobResponse.url)
}
inline std::string* HeadBlobResponse::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.HeadBlobResponse.url)
  return _s;
}
inline const std::string& HeadBlobResponse::_internal_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.url_.Get();
}
inline void HeadBlobResponse::_internal_set_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* HeadBlobResponse::_internal_mutable_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* HeadBlobResponse::release_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.HeadBlobResponse.url)
  return _impl_.url_.Release();
}
inline void HeadBlobResponse::set_allocated_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.url_.IsDefault()) {
          _impl_.url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.HeadBlobResponse.url)
}

// -------------------------------------------------------------------

// StreamBlobMetadataRequest

// string client_id = 1 [json_name = "clientId"];
inline void StreamBlobMetadataRequest::clear_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& StreamBlobMetadataRequest::client_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.StreamBlobMetadataRequest.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamBlobMetadataRequest::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.StreamBlobMetadataRequest.client_id)
}
inline std::string* StreamBlobMetadataRequest::mutable_client_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.StreamBlobMetadataRequest.client_id)
  return _s;
}
inline const std::string& StreamBlobMetadataRequest::_internal_client_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_id_.Get();
}
inline void StreamBlobMetadataRequest::_internal_set_client_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(value, GetArena());
}
inline std::string* StreamBlobMetadataRequest::_internal_mutable_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.client_id_.Mutable( GetArena());
}
inline std::string* StreamBlobMetadataRequest::release_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.StreamBlobMetadataRequest.client_id)
  return _impl_.client_id_.Release();
}
inline void StreamBlobMetadataRequest::set_allocated_client_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.StreamBlobMetadataRequest.client_id)
}

// -------------------------------------------------------------------

// StreamBlobMetadataResponse

// repeated .anduril.blobs.v1.BlobAnnouncement announcements = 1 [json_name = "announcements"];
inline int StreamBlobMetadataResponse::_internal_announcements_size() const {
  return _internal_announcements().size();
}
inline int StreamBlobMetadataResponse::announcements_size() const {
  return _internal_announcements_size();
}
inline void StreamBlobMetadataResponse::clear_announcements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.announcements_.Clear();
}
inline ::anduril::blobs::v1::BlobAnnouncement* StreamBlobMetadataResponse::mutable_announcements(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.StreamBlobMetadataResponse.announcements)
  return _internal_mutable_announcements()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::blobs::v1::BlobAnnouncement>* StreamBlobMetadataResponse::mutable_announcements()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.blobs.v1.StreamBlobMetadataResponse.announcements)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_announcements();
}
inline const ::anduril::blobs::v1::BlobAnnouncement& StreamBlobMetadataResponse::announcements(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.StreamBlobMetadataResponse.announcements)
  return _internal_announcements().Get(index);
}
inline ::anduril::blobs::v1::BlobAnnouncement* StreamBlobMetadataResponse::add_announcements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::anduril::blobs::v1::BlobAnnouncement* _add = _internal_mutable_announcements()->Add();
  // @@protoc_insertion_point(field_add:anduril.blobs.v1.StreamBlobMetadataResponse.announcements)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::blobs::v1::BlobAnnouncement>& StreamBlobMetadataResponse::announcements() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.blobs.v1.StreamBlobMetadataResponse.announcements)
  return _internal_announcements();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::blobs::v1::BlobAnnouncement>&
StreamBlobMetadataResponse::_internal_announcements() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.announcements_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::blobs::v1::BlobAnnouncement>*
StreamBlobMetadataResponse::_internal_mutable_announcements() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.announcements_;
}

// -------------------------------------------------------------------

// BlobAnnouncement

// string client_id = 1 [json_name = "clientId"];
inline void BlobAnnouncement::clear_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& BlobAnnouncement::client_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.BlobAnnouncement.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlobAnnouncement::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.BlobAnnouncement.client_id)
}
inline std::string* BlobAnnouncement::mutable_client_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.BlobAnnouncement.client_id)
  return _s;
}
inline const std::string& BlobAnnouncement::_internal_client_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_id_.Get();
}
inline void BlobAnnouncement::_internal_set_client_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_id_.Set(value, GetArena());
}
inline std::string* BlobAnnouncement::_internal_mutable_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.client_id_.Mutable( GetArena());
}
inline std::string* BlobAnnouncement::release_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.BlobAnnouncement.client_id)
  return _impl_.client_id_.Release();
}
inline void BlobAnnouncement::set_allocated_client_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.BlobAnnouncement.client_id)
}

// string key = 2 [json_name = "key"];
inline void BlobAnnouncement::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& BlobAnnouncement::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.BlobAnnouncement.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlobAnnouncement::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.blobs.v1.BlobAnnouncement.key)
}
inline std::string* BlobAnnouncement::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.BlobAnnouncement.key)
  return _s;
}
inline const std::string& BlobAnnouncement::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void BlobAnnouncement::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* BlobAnnouncement::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* BlobAnnouncement::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.BlobAnnouncement.key)
  return _impl_.key_.Release();
}
inline void BlobAnnouncement::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.BlobAnnouncement.key)
}

// .anduril.blobs.v1.BlobMetadata metadata = 3 [json_name = "metadata"];
inline bool BlobAnnouncement::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline const ::anduril::blobs::v1::BlobMetadata& BlobAnnouncement::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::anduril::blobs::v1::BlobMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::anduril::blobs::v1::BlobMetadata&>(::anduril::blobs::v1::_BlobMetadata_default_instance_);
}
inline const ::anduril::blobs::v1::BlobMetadata& BlobAnnouncement::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.blobs.v1.BlobAnnouncement.metadata)
  return _internal_metadata();
}
inline void BlobAnnouncement::unsafe_arena_set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.blobs.v1.BlobAnnouncement.metadata)
}
inline ::anduril::blobs::v1::BlobMetadata* BlobAnnouncement::release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::blobs::v1::BlobMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::anduril::blobs::v1::BlobMetadata* BlobAnnouncement::unsafe_arena_release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:anduril.blobs.v1.BlobAnnouncement.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::anduril::blobs::v1::BlobMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::anduril::blobs::v1::BlobMetadata* BlobAnnouncement::_internal_mutable_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::anduril::blobs::v1::BlobMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::anduril::blobs::v1::BlobMetadata* BlobAnnouncement::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::blobs::v1::BlobMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:anduril.blobs.v1.BlobAnnouncement.metadata)
  return _msg;
}
inline void BlobAnnouncement::set_allocated_metadata(::anduril::blobs::v1::BlobMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::anduril::blobs::v1::BlobMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:anduril.blobs.v1.BlobAnnouncement.metadata)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace blobs
}  // namespace anduril


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2fblobs_2fv1_2fblobs_5fapi_2epub_2eproto_2epb_2eh
