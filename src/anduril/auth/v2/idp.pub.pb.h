// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: anduril/auth/v2/idp.pub.proto
// Protobuf C++ Version: 5.27.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_anduril_2fauth_2fv2_2fidp_2epub_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_anduril_2fauth_2fv2_2fidp_2epub_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_anduril_2fauth_2fv2_2fidp_2epub_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_anduril_2fauth_2fv2_2fidp_2epub_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_anduril_2fauth_2fv2_2fidp_2epub_2eproto;
namespace anduril {
namespace auth {
namespace v2 {
class ExternalIDP;
struct ExternalIDPDefaultTypeInternal;
extern ExternalIDPDefaultTypeInternal _ExternalIDP_default_instance_;
class GetSSOURLRequest;
struct GetSSOURLRequestDefaultTypeInternal;
extern GetSSOURLRequestDefaultTypeInternal _GetSSOURLRequest_default_instance_;
class GetSSOURLResponse;
struct GetSSOURLResponseDefaultTypeInternal;
extern GetSSOURLResponseDefaultTypeInternal _GetSSOURLResponse_default_instance_;
class GetSSOURLResponse_InvalidEmail;
struct GetSSOURLResponse_InvalidEmailDefaultTypeInternal;
extern GetSSOURLResponse_InvalidEmailDefaultTypeInternal _GetSSOURLResponse_InvalidEmail_default_instance_;
class GetSSOURLResponse_ValidDomain;
struct GetSSOURLResponse_ValidDomainDefaultTypeInternal;
extern GetSSOURLResponse_ValidDomainDefaultTypeInternal _GetSSOURLResponse_ValidDomain_default_instance_;
class Idp;
struct IdpDefaultTypeInternal;
extern IdpDefaultTypeInternal _Idp_default_instance_;
class InternalIDP;
struct InternalIDPDefaultTypeInternal;
extern InternalIDPDefaultTypeInternal _InternalIDP_default_instance_;
class PIV;
struct PIVDefaultTypeInternal;
extern PIVDefaultTypeInternal _PIV_default_instance_;
}  // namespace v2
}  // namespace auth
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace anduril {
namespace auth {
namespace v2 {

// ===================================================================


// -------------------------------------------------------------------

class PIV final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:anduril.auth.v2.PIV) */ {
 public:
  inline PIV() : PIV(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PIV(
      ::google::protobuf::internal::ConstantInitialized);

  inline PIV(const PIV& from) : PIV(nullptr, from) {}
  inline PIV(PIV&& from) noexcept
      : PIV(nullptr, std::move(from)) {}
  inline PIV& operator=(const PIV& from) {
    CopyFrom(from);
    return *this;
  }
  inline PIV& operator=(PIV&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PIV& default_instance() {
    return *internal_default_instance();
  }
  static inline const PIV* internal_default_instance() {
    return reinterpret_cast<const PIV*>(
        &_PIV_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PIV& a, PIV& b) { a.Swap(&b); }
  inline void Swap(PIV* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PIV* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PIV* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<PIV>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PIV& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PIV& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.auth.v2.PIV"; }

 protected:
  explicit PIV(::google::protobuf::Arena* arena);
  PIV(::google::protobuf::Arena* arena, const PIV& from);
  PIV(::google::protobuf::Arena* arena, PIV&& from) noexcept
      : PIV(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:anduril.auth.v2.PIV)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PIV_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PIV& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_anduril_2fauth_2fv2_2fidp_2epub_2eproto;
};
// -------------------------------------------------------------------

class InternalIDP final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:anduril.auth.v2.InternalIDP) */ {
 public:
  inline InternalIDP() : InternalIDP(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InternalIDP(
      ::google::protobuf::internal::ConstantInitialized);

  inline InternalIDP(const InternalIDP& from) : InternalIDP(nullptr, from) {}
  inline InternalIDP(InternalIDP&& from) noexcept
      : InternalIDP(nullptr, std::move(from)) {}
  inline InternalIDP& operator=(const InternalIDP& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalIDP& operator=(InternalIDP&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalIDP& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternalIDP* internal_default_instance() {
    return reinterpret_cast<const InternalIDP*>(
        &_InternalIDP_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(InternalIDP& a, InternalIDP& b) { a.Swap(&b); }
  inline void Swap(InternalIDP* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalIDP* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalIDP* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InternalIDP>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InternalIDP& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InternalIDP& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.auth.v2.InternalIDP"; }

 protected:
  explicit InternalIDP(::google::protobuf::Arena* arena);
  InternalIDP(::google::protobuf::Arena* arena, const InternalIDP& from);
  InternalIDP(::google::protobuf::Arena* arena, InternalIDP&& from) noexcept
      : InternalIDP(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:anduril.auth.v2.InternalIDP)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InternalIDP_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InternalIDP& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_anduril_2fauth_2fv2_2fidp_2epub_2eproto;
};
// -------------------------------------------------------------------

class GetSSOURLResponse_InvalidEmail final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.auth.v2.GetSSOURLResponse.InvalidEmail) */ {
 public:
  inline GetSSOURLResponse_InvalidEmail() : GetSSOURLResponse_InvalidEmail(nullptr) {}
  ~GetSSOURLResponse_InvalidEmail() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetSSOURLResponse_InvalidEmail(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetSSOURLResponse_InvalidEmail(const GetSSOURLResponse_InvalidEmail& from) : GetSSOURLResponse_InvalidEmail(nullptr, from) {}
  inline GetSSOURLResponse_InvalidEmail(GetSSOURLResponse_InvalidEmail&& from) noexcept
      : GetSSOURLResponse_InvalidEmail(nullptr, std::move(from)) {}
  inline GetSSOURLResponse_InvalidEmail& operator=(const GetSSOURLResponse_InvalidEmail& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSSOURLResponse_InvalidEmail& operator=(GetSSOURLResponse_InvalidEmail&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSSOURLResponse_InvalidEmail& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSSOURLResponse_InvalidEmail* internal_default_instance() {
    return reinterpret_cast<const GetSSOURLResponse_InvalidEmail*>(
        &_GetSSOURLResponse_InvalidEmail_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(GetSSOURLResponse_InvalidEmail& a, GetSSOURLResponse_InvalidEmail& b) { a.Swap(&b); }
  inline void Swap(GetSSOURLResponse_InvalidEmail* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSSOURLResponse_InvalidEmail* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSSOURLResponse_InvalidEmail* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetSSOURLResponse_InvalidEmail>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSSOURLResponse_InvalidEmail& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetSSOURLResponse_InvalidEmail& from) { GetSSOURLResponse_InvalidEmail::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetSSOURLResponse_InvalidEmail* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.auth.v2.GetSSOURLResponse.InvalidEmail"; }

 protected:
  explicit GetSSOURLResponse_InvalidEmail(::google::protobuf::Arena* arena);
  GetSSOURLResponse_InvalidEmail(::google::protobuf::Arena* arena, const GetSSOURLResponse_InvalidEmail& from);
  GetSSOURLResponse_InvalidEmail(::google::protobuf::Arena* arena, GetSSOURLResponse_InvalidEmail&& from) noexcept
      : GetSSOURLResponse_InvalidEmail(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 1,
  };
  // string reason = 1 [json_name = "reason"];
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // @@protoc_insertion_point(class_scope:anduril.auth.v2.GetSSOURLResponse.InvalidEmail)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      61, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetSSOURLResponse_InvalidEmail_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetSSOURLResponse_InvalidEmail& from_msg);
    ::google::protobuf::internal::ArenaStringPtr reason_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fauth_2fv2_2fidp_2epub_2eproto;
};
// -------------------------------------------------------------------

class GetSSOURLRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.auth.v2.GetSSOURLRequest) */ {
 public:
  inline GetSSOURLRequest() : GetSSOURLRequest(nullptr) {}
  ~GetSSOURLRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetSSOURLRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetSSOURLRequest(const GetSSOURLRequest& from) : GetSSOURLRequest(nullptr, from) {}
  inline GetSSOURLRequest(GetSSOURLRequest&& from) noexcept
      : GetSSOURLRequest(nullptr, std::move(from)) {}
  inline GetSSOURLRequest& operator=(const GetSSOURLRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSSOURLRequest& operator=(GetSSOURLRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSSOURLRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSSOURLRequest* internal_default_instance() {
    return reinterpret_cast<const GetSSOURLRequest*>(
        &_GetSSOURLRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(GetSSOURLRequest& a, GetSSOURLRequest& b) { a.Swap(&b); }
  inline void Swap(GetSSOURLRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSSOURLRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSSOURLRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetSSOURLRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSSOURLRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetSSOURLRequest& from) { GetSSOURLRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetSSOURLRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.auth.v2.GetSSOURLRequest"; }

 protected:
  explicit GetSSOURLRequest(::google::protobuf::Arena* arena);
  GetSSOURLRequest(::google::protobuf::Arena* arena, const GetSSOURLRequest& from);
  GetSSOURLRequest(::google::protobuf::Arena* arena, GetSSOURLRequest&& from) noexcept
      : GetSSOURLRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEmailFieldNumber = 1,
    kRedirectUrlFieldNumber = 2,
    kAppendTokenFieldNumber = 3,
  };
  // string email = 1 [json_name = "email"];
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string redirect_url = 2 [json_name = "redirectUrl"];
  void clear_redirect_url() ;
  const std::string& redirect_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_redirect_url(Arg_&& arg, Args_... args);
  std::string* mutable_redirect_url();
  PROTOBUF_NODISCARD std::string* release_redirect_url();
  void set_allocated_redirect_url(std::string* value);

  private:
  const std::string& _internal_redirect_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redirect_url(
      const std::string& value);
  std::string* _internal_mutable_redirect_url();

  public:
  // bool append_token = 3 [json_name = "appendToken"];
  void clear_append_token() ;
  bool append_token() const;
  void set_append_token(bool value);

  private:
  bool _internal_append_token() const;
  void _internal_set_append_token(bool value);

  public:
  // @@protoc_insertion_point(class_scope:anduril.auth.v2.GetSSOURLRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      58, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetSSOURLRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetSSOURLRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr redirect_url_;
    bool append_token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fauth_2fv2_2fidp_2epub_2eproto;
};
// -------------------------------------------------------------------

class ExternalIDP final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.auth.v2.ExternalIDP) */ {
 public:
  inline ExternalIDP() : ExternalIDP(nullptr) {}
  ~ExternalIDP() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExternalIDP(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExternalIDP(const ExternalIDP& from) : ExternalIDP(nullptr, from) {}
  inline ExternalIDP(ExternalIDP&& from) noexcept
      : ExternalIDP(nullptr, std::move(from)) {}
  inline ExternalIDP& operator=(const ExternalIDP& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalIDP& operator=(ExternalIDP&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalIDP& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalIDP* internal_default_instance() {
    return reinterpret_cast<const ExternalIDP*>(
        &_ExternalIDP_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ExternalIDP& a, ExternalIDP& b) { a.Swap(&b); }
  inline void Swap(ExternalIDP* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalIDP* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalIDP* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExternalIDP>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExternalIDP& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExternalIDP& from) { ExternalIDP::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExternalIDP* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.auth.v2.ExternalIDP"; }

 protected:
  explicit ExternalIDP(::google::protobuf::Arena* arena);
  ExternalIDP(::google::protobuf::Arena* arena, const ExternalIDP& from);
  ExternalIDP(::google::protobuf::Arena* arena, ExternalIDP&& from) noexcept
      : ExternalIDP(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kSsoUrlFieldNumber = 2,
    kUniqueIdFieldNumber = 3,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string sso_url = 2 [json_name = "ssoUrl"];
  void clear_sso_url() ;
  const std::string& sso_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sso_url(Arg_&& arg, Args_... args);
  std::string* mutable_sso_url();
  PROTOBUF_NODISCARD std::string* release_sso_url();
  void set_allocated_sso_url(std::string* value);

  private:
  const std::string& _internal_sso_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sso_url(
      const std::string& value);
  std::string* _internal_mutable_sso_url();

  public:
  // string unique_id = 3 [json_name = "uniqueId"];
  void clear_unique_id() ;
  const std::string& unique_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_unique_id(Arg_&& arg, Args_... args);
  std::string* mutable_unique_id();
  PROTOBUF_NODISCARD std::string* release_unique_id();
  void set_allocated_unique_id(std::string* value);

  private:
  const std::string& _internal_unique_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_id(
      const std::string& value);
  std::string* _internal_mutable_unique_id();

  public:
  // @@protoc_insertion_point(class_scope:anduril.auth.v2.ExternalIDP)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      56, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ExternalIDP_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExternalIDP& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr sso_url_;
    ::google::protobuf::internal::ArenaStringPtr unique_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fauth_2fv2_2fidp_2epub_2eproto;
};
// -------------------------------------------------------------------

class Idp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.auth.v2.Idp) */ {
 public:
  inline Idp() : Idp(nullptr) {}
  ~Idp() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Idp(
      ::google::protobuf::internal::ConstantInitialized);

  inline Idp(const Idp& from) : Idp(nullptr, from) {}
  inline Idp(Idp&& from) noexcept
      : Idp(nullptr, std::move(from)) {}
  inline Idp& operator=(const Idp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Idp& operator=(Idp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Idp& default_instance() {
    return *internal_default_instance();
  }
  enum IdpCase {
    kInternal = 1,
    kExternal = 2,
    kPiv = 3,
    IDP_NOT_SET = 0,
  };
  static inline const Idp* internal_default_instance() {
    return reinterpret_cast<const Idp*>(
        &_Idp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Idp& a, Idp& b) { a.Swap(&b); }
  inline void Swap(Idp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Idp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Idp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Idp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Idp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Idp& from) { Idp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Idp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.auth.v2.Idp"; }

 protected:
  explicit Idp(::google::protobuf::Arena* arena);
  Idp(::google::protobuf::Arena* arena, const Idp& from);
  Idp(::google::protobuf::Arena* arena, Idp&& from) noexcept
      : Idp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInternalFieldNumber = 1,
    kExternalFieldNumber = 2,
    kPivFieldNumber = 3,
  };
  // .anduril.auth.v2.InternalIDP internal = 1 [json_name = "internal"];
  bool has_internal() const;
  private:
  bool _internal_has_internal() const;

  public:
  void clear_internal() ;
  const ::anduril::auth::v2::InternalIDP& internal() const;
  PROTOBUF_NODISCARD ::anduril::auth::v2::InternalIDP* release_internal();
  ::anduril::auth::v2::InternalIDP* mutable_internal();
  void set_allocated_internal(::anduril::auth::v2::InternalIDP* value);
  void unsafe_arena_set_allocated_internal(::anduril::auth::v2::InternalIDP* value);
  ::anduril::auth::v2::InternalIDP* unsafe_arena_release_internal();

  private:
  const ::anduril::auth::v2::InternalIDP& _internal_internal() const;
  ::anduril::auth::v2::InternalIDP* _internal_mutable_internal();

  public:
  // .anduril.auth.v2.ExternalIDP external = 2 [json_name = "external"];
  bool has_external() const;
  private:
  bool _internal_has_external() const;

  public:
  void clear_external() ;
  const ::anduril::auth::v2::ExternalIDP& external() const;
  PROTOBUF_NODISCARD ::anduril::auth::v2::ExternalIDP* release_external();
  ::anduril::auth::v2::ExternalIDP* mutable_external();
  void set_allocated_external(::anduril::auth::v2::ExternalIDP* value);
  void unsafe_arena_set_allocated_external(::anduril::auth::v2::ExternalIDP* value);
  ::anduril::auth::v2::ExternalIDP* unsafe_arena_release_external();

  private:
  const ::anduril::auth::v2::ExternalIDP& _internal_external() const;
  ::anduril::auth::v2::ExternalIDP* _internal_mutable_external();

  public:
  // .anduril.auth.v2.PIV piv = 3 [json_name = "piv"];
  bool has_piv() const;
  private:
  bool _internal_has_piv() const;

  public:
  void clear_piv() ;
  const ::anduril::auth::v2::PIV& piv() const;
  PROTOBUF_NODISCARD ::anduril::auth::v2::PIV* release_piv();
  ::anduril::auth::v2::PIV* mutable_piv();
  void set_allocated_piv(::anduril::auth::v2::PIV* value);
  void unsafe_arena_set_allocated_piv(::anduril::auth::v2::PIV* value);
  ::anduril::auth::v2::PIV* unsafe_arena_release_piv();

  private:
  const ::anduril::auth::v2::PIV& _internal_piv() const;
  ::anduril::auth::v2::PIV* _internal_mutable_piv();

  public:
  void clear_idp();
  IdpCase idp_case() const;
  // @@protoc_insertion_point(class_scope:anduril.auth.v2.Idp)
 private:
  class _Internal;
  void set_has_internal();
  void set_has_external();
  void set_has_piv();
  inline bool has_idp() const;
  inline void clear_has_idp();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Idp_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Idp& from_msg);
    union IdpUnion {
      constexpr IdpUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::auth::v2::InternalIDP* internal_;
      ::anduril::auth::v2::ExternalIDP* external_;
      ::anduril::auth::v2::PIV* piv_;
    } idp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fauth_2fv2_2fidp_2epub_2eproto;
};
// -------------------------------------------------------------------

class GetSSOURLResponse_ValidDomain final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.auth.v2.GetSSOURLResponse.ValidDomain) */ {
 public:
  inline GetSSOURLResponse_ValidDomain() : GetSSOURLResponse_ValidDomain(nullptr) {}
  ~GetSSOURLResponse_ValidDomain() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetSSOURLResponse_ValidDomain(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetSSOURLResponse_ValidDomain(const GetSSOURLResponse_ValidDomain& from) : GetSSOURLResponse_ValidDomain(nullptr, from) {}
  inline GetSSOURLResponse_ValidDomain(GetSSOURLResponse_ValidDomain&& from) noexcept
      : GetSSOURLResponse_ValidDomain(nullptr, std::move(from)) {}
  inline GetSSOURLResponse_ValidDomain& operator=(const GetSSOURLResponse_ValidDomain& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSSOURLResponse_ValidDomain& operator=(GetSSOURLResponse_ValidDomain&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSSOURLResponse_ValidDomain& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSSOURLResponse_ValidDomain* internal_default_instance() {
    return reinterpret_cast<const GetSSOURLResponse_ValidDomain*>(
        &_GetSSOURLResponse_ValidDomain_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(GetSSOURLResponse_ValidDomain& a, GetSSOURLResponse_ValidDomain& b) { a.Swap(&b); }
  inline void Swap(GetSSOURLResponse_ValidDomain* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSSOURLResponse_ValidDomain* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSSOURLResponse_ValidDomain* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetSSOURLResponse_ValidDomain>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSSOURLResponse_ValidDomain& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetSSOURLResponse_ValidDomain& from) { GetSSOURLResponse_ValidDomain::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetSSOURLResponse_ValidDomain* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.auth.v2.GetSSOURLResponse.ValidDomain"; }

 protected:
  explicit GetSSOURLResponse_ValidDomain(::google::protobuf::Arena* arena);
  GetSSOURLResponse_ValidDomain(::google::protobuf::Arena* arena, const GetSSOURLResponse_ValidDomain& from);
  GetSSOURLResponse_ValidDomain(::google::protobuf::Arena* arena, GetSSOURLResponse_ValidDomain&& from) noexcept
      : GetSSOURLResponse_ValidDomain(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdpsFieldNumber = 1,
  };
  // repeated .anduril.auth.v2.Idp idps = 1 [json_name = "idps"];
  int idps_size() const;
  private:
  int _internal_idps_size() const;

  public:
  void clear_idps() ;
  ::anduril::auth::v2::Idp* mutable_idps(int index);
  ::google::protobuf::RepeatedPtrField<::anduril::auth::v2::Idp>* mutable_idps();

  private:
  const ::google::protobuf::RepeatedPtrField<::anduril::auth::v2::Idp>& _internal_idps() const;
  ::google::protobuf::RepeatedPtrField<::anduril::auth::v2::Idp>* _internal_mutable_idps();
  public:
  const ::anduril::auth::v2::Idp& idps(int index) const;
  ::anduril::auth::v2::Idp* add_idps();
  const ::google::protobuf::RepeatedPtrField<::anduril::auth::v2::Idp>& idps() const;
  // @@protoc_insertion_point(class_scope:anduril.auth.v2.GetSSOURLResponse.ValidDomain)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetSSOURLResponse_ValidDomain_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetSSOURLResponse_ValidDomain& from_msg);
    ::google::protobuf::RepeatedPtrField< ::anduril::auth::v2::Idp > idps_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fauth_2fv2_2fidp_2epub_2eproto;
};
// -------------------------------------------------------------------

class GetSSOURLResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:anduril.auth.v2.GetSSOURLResponse) */ {
 public:
  inline GetSSOURLResponse() : GetSSOURLResponse(nullptr) {}
  ~GetSSOURLResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetSSOURLResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetSSOURLResponse(const GetSSOURLResponse& from) : GetSSOURLResponse(nullptr, from) {}
  inline GetSSOURLResponse(GetSSOURLResponse&& from) noexcept
      : GetSSOURLResponse(nullptr, std::move(from)) {}
  inline GetSSOURLResponse& operator=(const GetSSOURLResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSSOURLResponse& operator=(GetSSOURLResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSSOURLResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kInvalidEmail = 1,
    kValidDomain = 2,
    RESPONSE_NOT_SET = 0,
  };
  static inline const GetSSOURLResponse* internal_default_instance() {
    return reinterpret_cast<const GetSSOURLResponse*>(
        &_GetSSOURLResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(GetSSOURLResponse& a, GetSSOURLResponse& b) { a.Swap(&b); }
  inline void Swap(GetSSOURLResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSSOURLResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSSOURLResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetSSOURLResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSSOURLResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetSSOURLResponse& from) { GetSSOURLResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetSSOURLResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "anduril.auth.v2.GetSSOURLResponse"; }

 protected:
  explicit GetSSOURLResponse(::google::protobuf::Arena* arena);
  GetSSOURLResponse(::google::protobuf::Arena* arena, const GetSSOURLResponse& from);
  GetSSOURLResponse(::google::protobuf::Arena* arena, GetSSOURLResponse&& from) noexcept
      : GetSSOURLResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using InvalidEmail = GetSSOURLResponse_InvalidEmail;
  using ValidDomain = GetSSOURLResponse_ValidDomain;

  // accessors -------------------------------------------------------
  enum : int {
    kInvalidEmailFieldNumber = 1,
    kValidDomainFieldNumber = 2,
  };
  // .anduril.auth.v2.GetSSOURLResponse.InvalidEmail invalid_email = 1 [json_name = "invalidEmail"];
  bool has_invalid_email() const;
  private:
  bool _internal_has_invalid_email() const;

  public:
  void clear_invalid_email() ;
  const ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail& invalid_email() const;
  PROTOBUF_NODISCARD ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* release_invalid_email();
  ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* mutable_invalid_email();
  void set_allocated_invalid_email(::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* value);
  void unsafe_arena_set_allocated_invalid_email(::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* value);
  ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* unsafe_arena_release_invalid_email();

  private:
  const ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail& _internal_invalid_email() const;
  ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* _internal_mutable_invalid_email();

  public:
  // .anduril.auth.v2.GetSSOURLResponse.ValidDomain valid_domain = 2 [json_name = "validDomain"];
  bool has_valid_domain() const;
  private:
  bool _internal_has_valid_domain() const;

  public:
  void clear_valid_domain() ;
  const ::anduril::auth::v2::GetSSOURLResponse_ValidDomain& valid_domain() const;
  PROTOBUF_NODISCARD ::anduril::auth::v2::GetSSOURLResponse_ValidDomain* release_valid_domain();
  ::anduril::auth::v2::GetSSOURLResponse_ValidDomain* mutable_valid_domain();
  void set_allocated_valid_domain(::anduril::auth::v2::GetSSOURLResponse_ValidDomain* value);
  void unsafe_arena_set_allocated_valid_domain(::anduril::auth::v2::GetSSOURLResponse_ValidDomain* value);
  ::anduril::auth::v2::GetSSOURLResponse_ValidDomain* unsafe_arena_release_valid_domain();

  private:
  const ::anduril::auth::v2::GetSSOURLResponse_ValidDomain& _internal_valid_domain() const;
  ::anduril::auth::v2::GetSSOURLResponse_ValidDomain* _internal_mutable_valid_domain();

  public:
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:anduril.auth.v2.GetSSOURLResponse)
 private:
  class _Internal;
  void set_has_invalid_email();
  void set_has_valid_domain();
  inline bool has_response() const;
  inline void clear_has_response();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetSSOURLResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetSSOURLResponse& from_msg);
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* invalid_email_;
      ::anduril::auth::v2::GetSSOURLResponse_ValidDomain* valid_domain_;
    } response_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_anduril_2fauth_2fv2_2fidp_2epub_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetSSOURLRequest

// string email = 1 [json_name = "email"];
inline void GetSSOURLRequest::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& GetSSOURLRequest::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.GetSSOURLRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetSSOURLRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.auth.v2.GetSSOURLRequest.email)
}
inline std::string* GetSSOURLRequest::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.GetSSOURLRequest.email)
  return _s;
}
inline const std::string& GetSSOURLRequest::_internal_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_.Get();
}
inline void GetSSOURLRequest::_internal_set_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(value, GetArena());
}
inline std::string* GetSSOURLRequest::_internal_mutable_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* GetSSOURLRequest::release_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.auth.v2.GetSSOURLRequest.email)
  return _impl_.email_.Release();
}
inline void GetSSOURLRequest::set_allocated_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.auth.v2.GetSSOURLRequest.email)
}

// string redirect_url = 2 [json_name = "redirectUrl"];
inline void GetSSOURLRequest::clear_redirect_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redirect_url_.ClearToEmpty();
}
inline const std::string& GetSSOURLRequest::redirect_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.GetSSOURLRequest.redirect_url)
  return _internal_redirect_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetSSOURLRequest::set_redirect_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redirect_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.auth.v2.GetSSOURLRequest.redirect_url)
}
inline std::string* GetSSOURLRequest::mutable_redirect_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_redirect_url();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.GetSSOURLRequest.redirect_url)
  return _s;
}
inline const std::string& GetSSOURLRequest::_internal_redirect_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.redirect_url_.Get();
}
inline void GetSSOURLRequest::_internal_set_redirect_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redirect_url_.Set(value, GetArena());
}
inline std::string* GetSSOURLRequest::_internal_mutable_redirect_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.redirect_url_.Mutable( GetArena());
}
inline std::string* GetSSOURLRequest::release_redirect_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.auth.v2.GetSSOURLRequest.redirect_url)
  return _impl_.redirect_url_.Release();
}
inline void GetSSOURLRequest::set_allocated_redirect_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redirect_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.redirect_url_.IsDefault()) {
          _impl_.redirect_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.auth.v2.GetSSOURLRequest.redirect_url)
}

// bool append_token = 3 [json_name = "appendToken"];
inline void GetSSOURLRequest::clear_append_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.append_token_ = false;
}
inline bool GetSSOURLRequest::append_token() const {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.GetSSOURLRequest.append_token)
  return _internal_append_token();
}
inline void GetSSOURLRequest::set_append_token(bool value) {
  _internal_set_append_token(value);
  // @@protoc_insertion_point(field_set:anduril.auth.v2.GetSSOURLRequest.append_token)
}
inline bool GetSSOURLRequest::_internal_append_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.append_token_;
}
inline void GetSSOURLRequest::_internal_set_append_token(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.append_token_ = value;
}

// -------------------------------------------------------------------

// GetSSOURLResponse_InvalidEmail

// string reason = 1 [json_name = "reason"];
inline void GetSSOURLResponse_InvalidEmail::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& GetSSOURLResponse_InvalidEmail::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.GetSSOURLResponse.InvalidEmail.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetSSOURLResponse_InvalidEmail::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.auth.v2.GetSSOURLResponse.InvalidEmail.reason)
}
inline std::string* GetSSOURLResponse_InvalidEmail::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.GetSSOURLResponse.InvalidEmail.reason)
  return _s;
}
inline const std::string& GetSSOURLResponse_InvalidEmail::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void GetSSOURLResponse_InvalidEmail::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* GetSSOURLResponse_InvalidEmail::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* GetSSOURLResponse_InvalidEmail::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.auth.v2.GetSSOURLResponse.InvalidEmail.reason)
  return _impl_.reason_.Release();
}
inline void GetSSOURLResponse_InvalidEmail::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.auth.v2.GetSSOURLResponse.InvalidEmail.reason)
}

// -------------------------------------------------------------------

// GetSSOURLResponse_ValidDomain

// repeated .anduril.auth.v2.Idp idps = 1 [json_name = "idps"];
inline int GetSSOURLResponse_ValidDomain::_internal_idps_size() const {
  return _internal_idps().size();
}
inline int GetSSOURLResponse_ValidDomain::idps_size() const {
  return _internal_idps_size();
}
inline void GetSSOURLResponse_ValidDomain::clear_idps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idps_.Clear();
}
inline ::anduril::auth::v2::Idp* GetSSOURLResponse_ValidDomain::mutable_idps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.GetSSOURLResponse.ValidDomain.idps)
  return _internal_mutable_idps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::anduril::auth::v2::Idp>* GetSSOURLResponse_ValidDomain::mutable_idps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:anduril.auth.v2.GetSSOURLResponse.ValidDomain.idps)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_idps();
}
inline const ::anduril::auth::v2::Idp& GetSSOURLResponse_ValidDomain::idps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.GetSSOURLResponse.ValidDomain.idps)
  return _internal_idps().Get(index);
}
inline ::anduril::auth::v2::Idp* GetSSOURLResponse_ValidDomain::add_idps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::anduril::auth::v2::Idp* _add = _internal_mutable_idps()->Add();
  // @@protoc_insertion_point(field_add:anduril.auth.v2.GetSSOURLResponse.ValidDomain.idps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::auth::v2::Idp>& GetSSOURLResponse_ValidDomain::idps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:anduril.auth.v2.GetSSOURLResponse.ValidDomain.idps)
  return _internal_idps();
}
inline const ::google::protobuf::RepeatedPtrField<::anduril::auth::v2::Idp>&
GetSSOURLResponse_ValidDomain::_internal_idps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.idps_;
}
inline ::google::protobuf::RepeatedPtrField<::anduril::auth::v2::Idp>*
GetSSOURLResponse_ValidDomain::_internal_mutable_idps() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.idps_;
}

// -------------------------------------------------------------------

// GetSSOURLResponse

// .anduril.auth.v2.GetSSOURLResponse.InvalidEmail invalid_email = 1 [json_name = "invalidEmail"];
inline bool GetSSOURLResponse::has_invalid_email() const {
  return response_case() == kInvalidEmail;
}
inline bool GetSSOURLResponse::_internal_has_invalid_email() const {
  return response_case() == kInvalidEmail;
}
inline void GetSSOURLResponse::set_has_invalid_email() {
  _impl_._oneof_case_[0] = kInvalidEmail;
}
inline void GetSSOURLResponse::clear_invalid_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_case() == kInvalidEmail) {
    if (GetArena() == nullptr) {
      delete _impl_.response_.invalid_email_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_.invalid_email_);
    }
    clear_has_response();
  }
}
inline ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* GetSSOURLResponse::release_invalid_email() {
  // @@protoc_insertion_point(field_release:anduril.auth.v2.GetSSOURLResponse.invalid_email)
  if (response_case() == kInvalidEmail) {
    clear_has_response();
    auto* temp = _impl_.response_.invalid_email_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.invalid_email_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail& GetSSOURLResponse::_internal_invalid_email() const {
  return response_case() == kInvalidEmail ? *_impl_.response_.invalid_email_ : reinterpret_cast<::anduril::auth::v2::GetSSOURLResponse_InvalidEmail&>(::anduril::auth::v2::_GetSSOURLResponse_InvalidEmail_default_instance_);
}
inline const ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail& GetSSOURLResponse::invalid_email() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.GetSSOURLResponse.invalid_email)
  return _internal_invalid_email();
}
inline ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* GetSSOURLResponse::unsafe_arena_release_invalid_email() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.auth.v2.GetSSOURLResponse.invalid_email)
  if (response_case() == kInvalidEmail) {
    clear_has_response();
    auto* temp = _impl_.response_.invalid_email_;
    _impl_.response_.invalid_email_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetSSOURLResponse::unsafe_arena_set_allocated_invalid_email(::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response();
  if (value) {
    set_has_invalid_email();
    _impl_.response_.invalid_email_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.auth.v2.GetSSOURLResponse.invalid_email)
}
inline ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* GetSSOURLResponse::_internal_mutable_invalid_email() {
  if (response_case() != kInvalidEmail) {
    clear_response();
    set_has_invalid_email();
    _impl_.response_.invalid_email_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::auth::v2::GetSSOURLResponse_InvalidEmail>(GetArena());
  }
  return _impl_.response_.invalid_email_;
}
inline ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* GetSSOURLResponse::mutable_invalid_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::auth::v2::GetSSOURLResponse_InvalidEmail* _msg = _internal_mutable_invalid_email();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.GetSSOURLResponse.invalid_email)
  return _msg;
}

// .anduril.auth.v2.GetSSOURLResponse.ValidDomain valid_domain = 2 [json_name = "validDomain"];
inline bool GetSSOURLResponse::has_valid_domain() const {
  return response_case() == kValidDomain;
}
inline bool GetSSOURLResponse::_internal_has_valid_domain() const {
  return response_case() == kValidDomain;
}
inline void GetSSOURLResponse::set_has_valid_domain() {
  _impl_._oneof_case_[0] = kValidDomain;
}
inline void GetSSOURLResponse::clear_valid_domain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_case() == kValidDomain) {
    if (GetArena() == nullptr) {
      delete _impl_.response_.valid_domain_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_.valid_domain_);
    }
    clear_has_response();
  }
}
inline ::anduril::auth::v2::GetSSOURLResponse_ValidDomain* GetSSOURLResponse::release_valid_domain() {
  // @@protoc_insertion_point(field_release:anduril.auth.v2.GetSSOURLResponse.valid_domain)
  if (response_case() == kValidDomain) {
    clear_has_response();
    auto* temp = _impl_.response_.valid_domain_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.valid_domain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::auth::v2::GetSSOURLResponse_ValidDomain& GetSSOURLResponse::_internal_valid_domain() const {
  return response_case() == kValidDomain ? *_impl_.response_.valid_domain_ : reinterpret_cast<::anduril::auth::v2::GetSSOURLResponse_ValidDomain&>(::anduril::auth::v2::_GetSSOURLResponse_ValidDomain_default_instance_);
}
inline const ::anduril::auth::v2::GetSSOURLResponse_ValidDomain& GetSSOURLResponse::valid_domain() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.GetSSOURLResponse.valid_domain)
  return _internal_valid_domain();
}
inline ::anduril::auth::v2::GetSSOURLResponse_ValidDomain* GetSSOURLResponse::unsafe_arena_release_valid_domain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.auth.v2.GetSSOURLResponse.valid_domain)
  if (response_case() == kValidDomain) {
    clear_has_response();
    auto* temp = _impl_.response_.valid_domain_;
    _impl_.response_.valid_domain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetSSOURLResponse::unsafe_arena_set_allocated_valid_domain(::anduril::auth::v2::GetSSOURLResponse_ValidDomain* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response();
  if (value) {
    set_has_valid_domain();
    _impl_.response_.valid_domain_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.auth.v2.GetSSOURLResponse.valid_domain)
}
inline ::anduril::auth::v2::GetSSOURLResponse_ValidDomain* GetSSOURLResponse::_internal_mutable_valid_domain() {
  if (response_case() != kValidDomain) {
    clear_response();
    set_has_valid_domain();
    _impl_.response_.valid_domain_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::auth::v2::GetSSOURLResponse_ValidDomain>(GetArena());
  }
  return _impl_.response_.valid_domain_;
}
inline ::anduril::auth::v2::GetSSOURLResponse_ValidDomain* GetSSOURLResponse::mutable_valid_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::auth::v2::GetSSOURLResponse_ValidDomain* _msg = _internal_mutable_valid_domain();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.GetSSOURLResponse.valid_domain)
  return _msg;
}

inline bool GetSSOURLResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void GetSSOURLResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline GetSSOURLResponse::ResponseCase GetSSOURLResponse::response_case() const {
  return GetSSOURLResponse::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Idp

// .anduril.auth.v2.InternalIDP internal = 1 [json_name = "internal"];
inline bool Idp::has_internal() const {
  return idp_case() == kInternal;
}
inline bool Idp::_internal_has_internal() const {
  return idp_case() == kInternal;
}
inline void Idp::set_has_internal() {
  _impl_._oneof_case_[0] = kInternal;
}
inline void Idp::clear_internal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (idp_case() == kInternal) {
    if (GetArena() == nullptr) {
      delete _impl_.idp_.internal_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.idp_.internal_);
    }
    clear_has_idp();
  }
}
inline ::anduril::auth::v2::InternalIDP* Idp::release_internal() {
  // @@protoc_insertion_point(field_release:anduril.auth.v2.Idp.internal)
  if (idp_case() == kInternal) {
    clear_has_idp();
    auto* temp = _impl_.idp_.internal_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.idp_.internal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::auth::v2::InternalIDP& Idp::_internal_internal() const {
  return idp_case() == kInternal ? *_impl_.idp_.internal_ : reinterpret_cast<::anduril::auth::v2::InternalIDP&>(::anduril::auth::v2::_InternalIDP_default_instance_);
}
inline const ::anduril::auth::v2::InternalIDP& Idp::internal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.Idp.internal)
  return _internal_internal();
}
inline ::anduril::auth::v2::InternalIDP* Idp::unsafe_arena_release_internal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.auth.v2.Idp.internal)
  if (idp_case() == kInternal) {
    clear_has_idp();
    auto* temp = _impl_.idp_.internal_;
    _impl_.idp_.internal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Idp::unsafe_arena_set_allocated_internal(::anduril::auth::v2::InternalIDP* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_idp();
  if (value) {
    set_has_internal();
    _impl_.idp_.internal_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.auth.v2.Idp.internal)
}
inline ::anduril::auth::v2::InternalIDP* Idp::_internal_mutable_internal() {
  if (idp_case() != kInternal) {
    clear_idp();
    set_has_internal();
    _impl_.idp_.internal_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::auth::v2::InternalIDP>(GetArena());
  }
  return _impl_.idp_.internal_;
}
inline ::anduril::auth::v2::InternalIDP* Idp::mutable_internal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::auth::v2::InternalIDP* _msg = _internal_mutable_internal();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.Idp.internal)
  return _msg;
}

// .anduril.auth.v2.ExternalIDP external = 2 [json_name = "external"];
inline bool Idp::has_external() const {
  return idp_case() == kExternal;
}
inline bool Idp::_internal_has_external() const {
  return idp_case() == kExternal;
}
inline void Idp::set_has_external() {
  _impl_._oneof_case_[0] = kExternal;
}
inline void Idp::clear_external() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (idp_case() == kExternal) {
    if (GetArena() == nullptr) {
      delete _impl_.idp_.external_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.idp_.external_);
    }
    clear_has_idp();
  }
}
inline ::anduril::auth::v2::ExternalIDP* Idp::release_external() {
  // @@protoc_insertion_point(field_release:anduril.auth.v2.Idp.external)
  if (idp_case() == kExternal) {
    clear_has_idp();
    auto* temp = _impl_.idp_.external_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.idp_.external_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::auth::v2::ExternalIDP& Idp::_internal_external() const {
  return idp_case() == kExternal ? *_impl_.idp_.external_ : reinterpret_cast<::anduril::auth::v2::ExternalIDP&>(::anduril::auth::v2::_ExternalIDP_default_instance_);
}
inline const ::anduril::auth::v2::ExternalIDP& Idp::external() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.Idp.external)
  return _internal_external();
}
inline ::anduril::auth::v2::ExternalIDP* Idp::unsafe_arena_release_external() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.auth.v2.Idp.external)
  if (idp_case() == kExternal) {
    clear_has_idp();
    auto* temp = _impl_.idp_.external_;
    _impl_.idp_.external_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Idp::unsafe_arena_set_allocated_external(::anduril::auth::v2::ExternalIDP* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_idp();
  if (value) {
    set_has_external();
    _impl_.idp_.external_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.auth.v2.Idp.external)
}
inline ::anduril::auth::v2::ExternalIDP* Idp::_internal_mutable_external() {
  if (idp_case() != kExternal) {
    clear_idp();
    set_has_external();
    _impl_.idp_.external_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::auth::v2::ExternalIDP>(GetArena());
  }
  return _impl_.idp_.external_;
}
inline ::anduril::auth::v2::ExternalIDP* Idp::mutable_external() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::auth::v2::ExternalIDP* _msg = _internal_mutable_external();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.Idp.external)
  return _msg;
}

// .anduril.auth.v2.PIV piv = 3 [json_name = "piv"];
inline bool Idp::has_piv() const {
  return idp_case() == kPiv;
}
inline bool Idp::_internal_has_piv() const {
  return idp_case() == kPiv;
}
inline void Idp::set_has_piv() {
  _impl_._oneof_case_[0] = kPiv;
}
inline void Idp::clear_piv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (idp_case() == kPiv) {
    if (GetArena() == nullptr) {
      delete _impl_.idp_.piv_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.idp_.piv_);
    }
    clear_has_idp();
  }
}
inline ::anduril::auth::v2::PIV* Idp::release_piv() {
  // @@protoc_insertion_point(field_release:anduril.auth.v2.Idp.piv)
  if (idp_case() == kPiv) {
    clear_has_idp();
    auto* temp = _impl_.idp_.piv_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.idp_.piv_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::anduril::auth::v2::PIV& Idp::_internal_piv() const {
  return idp_case() == kPiv ? *_impl_.idp_.piv_ : reinterpret_cast<::anduril::auth::v2::PIV&>(::anduril::auth::v2::_PIV_default_instance_);
}
inline const ::anduril::auth::v2::PIV& Idp::piv() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.Idp.piv)
  return _internal_piv();
}
inline ::anduril::auth::v2::PIV* Idp::unsafe_arena_release_piv() {
  // @@protoc_insertion_point(field_unsafe_arena_release:anduril.auth.v2.Idp.piv)
  if (idp_case() == kPiv) {
    clear_has_idp();
    auto* temp = _impl_.idp_.piv_;
    _impl_.idp_.piv_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Idp::unsafe_arena_set_allocated_piv(::anduril::auth::v2::PIV* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_idp();
  if (value) {
    set_has_piv();
    _impl_.idp_.piv_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:anduril.auth.v2.Idp.piv)
}
inline ::anduril::auth::v2::PIV* Idp::_internal_mutable_piv() {
  if (idp_case() != kPiv) {
    clear_idp();
    set_has_piv();
    _impl_.idp_.piv_ =
        ::google::protobuf::Message::DefaultConstruct<::anduril::auth::v2::PIV>(GetArena());
  }
  return _impl_.idp_.piv_;
}
inline ::anduril::auth::v2::PIV* Idp::mutable_piv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::anduril::auth::v2::PIV* _msg = _internal_mutable_piv();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.Idp.piv)
  return _msg;
}

inline bool Idp::has_idp() const {
  return idp_case() != IDP_NOT_SET;
}
inline void Idp::clear_has_idp() {
  _impl_._oneof_case_[0] = IDP_NOT_SET;
}
inline Idp::IdpCase Idp::idp_case() const {
  return Idp::IdpCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternalIDP

// -------------------------------------------------------------------

// ExternalIDP

// string name = 1 [json_name = "name"];
inline void ExternalIDP::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ExternalIDP::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.ExternalIDP.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExternalIDP::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.auth.v2.ExternalIDP.name)
}
inline std::string* ExternalIDP::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.ExternalIDP.name)
  return _s;
}
inline const std::string& ExternalIDP::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ExternalIDP::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ExternalIDP::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ExternalIDP::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.auth.v2.ExternalIDP.name)
  return _impl_.name_.Release();
}
inline void ExternalIDP::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.auth.v2.ExternalIDP.name)
}

// string sso_url = 2 [json_name = "ssoUrl"];
inline void ExternalIDP::clear_sso_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sso_url_.ClearToEmpty();
}
inline const std::string& ExternalIDP::sso_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.ExternalIDP.sso_url)
  return _internal_sso_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExternalIDP::set_sso_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sso_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.auth.v2.ExternalIDP.sso_url)
}
inline std::string* ExternalIDP::mutable_sso_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sso_url();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.ExternalIDP.sso_url)
  return _s;
}
inline const std::string& ExternalIDP::_internal_sso_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sso_url_.Get();
}
inline void ExternalIDP::_internal_set_sso_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sso_url_.Set(value, GetArena());
}
inline std::string* ExternalIDP::_internal_mutable_sso_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sso_url_.Mutable( GetArena());
}
inline std::string* ExternalIDP::release_sso_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.auth.v2.ExternalIDP.sso_url)
  return _impl_.sso_url_.Release();
}
inline void ExternalIDP::set_allocated_sso_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sso_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sso_url_.IsDefault()) {
          _impl_.sso_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.auth.v2.ExternalIDP.sso_url)
}

// string unique_id = 3 [json_name = "uniqueId"];
inline void ExternalIDP::clear_unique_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unique_id_.ClearToEmpty();
}
inline const std::string& ExternalIDP::unique_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:anduril.auth.v2.ExternalIDP.unique_id)
  return _internal_unique_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExternalIDP::set_unique_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unique_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:anduril.auth.v2.ExternalIDP.unique_id)
}
inline std::string* ExternalIDP::mutable_unique_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_unique_id();
  // @@protoc_insertion_point(field_mutable:anduril.auth.v2.ExternalIDP.unique_id)
  return _s;
}
inline const std::string& ExternalIDP::_internal_unique_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unique_id_.Get();
}
inline void ExternalIDP::_internal_set_unique_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unique_id_.Set(value, GetArena());
}
inline std::string* ExternalIDP::_internal_mutable_unique_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.unique_id_.Mutable( GetArena());
}
inline std::string* ExternalIDP::release_unique_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:anduril.auth.v2.ExternalIDP.unique_id)
  return _impl_.unique_id_.Release();
}
inline void ExternalIDP::set_allocated_unique_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unique_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.unique_id_.IsDefault()) {
          _impl_.unique_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:anduril.auth.v2.ExternalIDP.unique_id)
}

// -------------------------------------------------------------------

// PIV

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v2
}  // namespace auth
}  // namespace anduril


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_anduril_2fauth_2fv2_2fidp_2epub_2eproto_2epb_2eh
