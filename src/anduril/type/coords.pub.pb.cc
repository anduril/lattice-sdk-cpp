// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: anduril/type/coords.pub.proto

#include "anduril/type/coords.pub.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace anduril {
namespace type {

inline constexpr YawPitch::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : yaw_{0},
        pitch_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR YawPitch::YawPitch(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct YawPitchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR YawPitchDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~YawPitchDefaultTypeInternal() {}
  union {
    YawPitch _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 YawPitchDefaultTypeInternal _YawPitch_default_instance_;

inline constexpr YPR::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : yaw_{0},
        pitch_{0},
        roll_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR YPR::YPR(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct YPRDefaultTypeInternal {
  PROTOBUF_CONSTEXPR YPRDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~YPRDefaultTypeInternal() {}
  union {
    YPR _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 YPRDefaultTypeInternal _YPR_default_instance_;

inline constexpr Vec3f::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : x_{0},
        y_{0},
        z_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Vec3f::Vec3f(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Vec3fDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vec3fDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vec3fDefaultTypeInternal() {}
  union {
    Vec3f _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vec3fDefaultTypeInternal _Vec3f_default_instance_;

inline constexpr Vec3::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : x_{0},
        y_{0},
        z_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Vec3::Vec3(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Vec3DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vec3DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vec3DefaultTypeInternal() {}
  union {
    Vec3 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vec3DefaultTypeInternal _Vec3_default_instance_;

inline constexpr Vec2f::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : x_{0},
        y_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Vec2f::Vec2f(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Vec2fDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vec2fDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vec2fDefaultTypeInternal() {}
  union {
    Vec2f _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vec2fDefaultTypeInternal _Vec2f_default_instance_;

inline constexpr Vec2::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : x_{0},
        y_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Vec2::Vec2(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Vec2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vec2DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vec2DefaultTypeInternal() {}
  union {
    Vec2 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vec2DefaultTypeInternal _Vec2_default_instance_;

inline constexpr Uint64Range::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : min_{::uint64_t{0u}},
        max_{::uint64_t{0u}},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Uint64Range::Uint64Range(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Uint64RangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Uint64RangeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Uint64RangeDefaultTypeInternal() {}
  union {
    Uint64Range _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Uint64RangeDefaultTypeInternal _Uint64Range_default_instance_;

inline constexpr ThetaPhi::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : theta_{0},
        phi_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ThetaPhi::ThetaPhi(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct ThetaPhiDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThetaPhiDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThetaPhiDefaultTypeInternal() {}
  union {
    ThetaPhi _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThetaPhiDefaultTypeInternal _ThetaPhi_default_instance_;

inline constexpr TMat4f::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : m00_{0},
        m01_{0},
        m02_{0},
        m03_{0},
        m11_{0},
        m12_{0},
        m13_{0},
        m22_{0},
        m23_{0},
        m33_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TMat4f::TMat4f(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct TMat4fDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMat4fDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMat4fDefaultTypeInternal() {}
  union {
    TMat4f _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMat4fDefaultTypeInternal _TMat4f_default_instance_;

inline constexpr TMat3::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : mxx_{0},
        mxy_{0},
        mxz_{0},
        myy_{0},
        myz_{0},
        mzz_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TMat3::TMat3(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct TMat3DefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMat3DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMat3DefaultTypeInternal() {}
  union {
    TMat3 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMat3DefaultTypeInternal _TMat3_default_instance_;

inline constexpr TMat2::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : mxx_{0},
        mxy_{0},
        myy_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TMat2::TMat2(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct TMat2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMat2DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMat2DefaultTypeInternal() {}
  union {
    TMat2 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMat2DefaultTypeInternal _TMat2_default_instance_;

inline constexpr Spherical::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : az_{0},
        el_{0},
        range_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Spherical::Spherical(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SphericalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SphericalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SphericalDefaultTypeInternal() {}
  union {
    Spherical _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SphericalDefaultTypeInternal _Spherical_default_instance_;

inline constexpr Quaternion::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : x_{0},
        y_{0},
        z_{0},
        w_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Quaternion::Quaternion(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct QuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuaternionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuaternionDefaultTypeInternal() {}
  union {
    Quaternion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuaternionDefaultTypeInternal _Quaternion_default_instance_;

inline constexpr LLA::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : lon_{0},
        lat_{0},
        alt_{0},
        is2d_{false},
        altitude_reference_{static_cast< ::anduril::type::LLA_AltitudeReference >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LLA::LLA(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct LLADefaultTypeInternal {
  PROTOBUF_CONSTEXPR LLADefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LLADefaultTypeInternal() {}
  union {
    LLA _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LLADefaultTypeInternal _LLA_default_instance_;

inline constexpr ENU::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : e_{0},
        n_{0},
        u_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ENU::ENU(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct ENUDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENUDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENUDefaultTypeInternal() {}
  union {
    ENU _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENUDefaultTypeInternal _ENU_default_instance_;

inline constexpr ECI::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : x_{0},
        y_{0},
        z_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ECI::ECI(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct ECIDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ECIDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ECIDefaultTypeInternal() {}
  union {
    ECI _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ECIDefaultTypeInternal _ECI_default_instance_;

inline constexpr DoubleRange::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : min_{0},
        max_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR DoubleRange::DoubleRange(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct DoubleRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoubleRangeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoubleRangeDefaultTypeInternal() {}
  union {
    DoubleRange _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoubleRangeDefaultTypeInternal _DoubleRange_default_instance_;

inline constexpr RigidTransform::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        rotation_{nullptr},
        translation_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RigidTransform::RigidTransform(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RigidTransformDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RigidTransformDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RigidTransformDefaultTypeInternal() {}
  union {
    RigidTransform _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RigidTransformDefaultTypeInternal _RigidTransform_default_instance_;

inline constexpr Pose::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        pos_{nullptr},
        att_enu_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR Pose::Pose(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct PoseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PoseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PoseDefaultTypeInternal() {}
  union {
    Pose _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PoseDefaultTypeInternal _Pose_default_instance_;

inline constexpr LLAPolygon::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : points_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LLAPolygon::LLAPolygon(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct LLAPolygonDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LLAPolygonDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LLAPolygonDefaultTypeInternal() {}
  union {
    LLAPolygon _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LLAPolygonDefaultTypeInternal _LLAPolygon_default_instance_;

inline constexpr LLAPath::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : points_{},
        loop_{false},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LLAPath::LLAPath(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct LLAPathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LLAPathDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LLAPathDefaultTypeInternal() {}
  union {
    LLAPath _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LLAPathDefaultTypeInternal _LLAPath_default_instance_;

inline constexpr AERPolygon::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : points_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AERPolygon::AERPolygon(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct AERPolygonDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AERPolygonDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AERPolygonDefaultTypeInternal() {}
  union {
    AERPolygon _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AERPolygonDefaultTypeInternal _AERPolygon_default_instance_;
}  // namespace type
}  // namespace anduril
static ::_pb::Metadata file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[22];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_anduril_2ftype_2fcoords_2epub_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_anduril_2ftype_2fcoords_2epub_2eproto = nullptr;
const ::uint32_t TableStruct_anduril_2ftype_2fcoords_2epub_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::ThetaPhi, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::ThetaPhi, _impl_.theta_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::ThetaPhi, _impl_.phi_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLA, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLA, _impl_.lon_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLA, _impl_.lat_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLA, _impl_.alt_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLA, _impl_.is2d_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLA, _impl_.altitude_reference_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::ENU, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::ENU, _impl_.e_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::ENU, _impl_.n_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::ENU, _impl_.u_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::ECI, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::ECI, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::ECI, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::ECI, _impl_.z_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec2, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec2, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec2, _impl_.y_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec2f, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec2f, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec2f, _impl_.y_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec3, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec3, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec3, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec3, _impl_.z_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec3f, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec3f, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec3f, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Vec3f, _impl_.z_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::Quaternion, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::Quaternion, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Quaternion, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Quaternion, _impl_.z_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Quaternion, _impl_.w_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::YawPitch, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::YawPitch, _impl_.yaw_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::YawPitch, _impl_.pitch_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::YPR, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::YPR, _impl_.yaw_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::YPR, _impl_.pitch_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::YPR, _impl_.roll_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Pose, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Pose, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::Pose, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Pose, _impl_.att_enu_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLAPolygon, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLAPolygon, _impl_.points_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::AERPolygon, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::AERPolygon, _impl_.points_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLAPath, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLAPath, _impl_.points_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::LLAPath, _impl_.loop_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::Spherical, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::Spherical, _impl_.az_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Spherical, _impl_.el_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Spherical, _impl_.range_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::DoubleRange, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::DoubleRange, _impl_.min_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::DoubleRange, _impl_.max_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::Uint64Range, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::Uint64Range, _impl_.min_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::Uint64Range, _impl_.max_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _impl_.m00_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _impl_.m01_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _impl_.m02_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _impl_.m03_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _impl_.m11_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _impl_.m12_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _impl_.m13_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _impl_.m22_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _impl_.m23_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat4f, _impl_.m33_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat3, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat3, _impl_.mxx_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat3, _impl_.mxy_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat3, _impl_.mxz_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat3, _impl_.myy_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat3, _impl_.myz_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat3, _impl_.mzz_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat2, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat2, _impl_.mxx_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat2, _impl_.mxy_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::TMat2, _impl_.myy_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::RigidTransform, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::RigidTransform, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::anduril::type::RigidTransform, _impl_.rotation_),
    PROTOBUF_FIELD_OFFSET(::anduril::type::RigidTransform, _impl_.translation_),
    0,
    1,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, -1, -1, sizeof(::anduril::type::ThetaPhi)},
        {10, -1, -1, sizeof(::anduril::type::LLA)},
        {23, -1, -1, sizeof(::anduril::type::ENU)},
        {34, -1, -1, sizeof(::anduril::type::ECI)},
        {45, -1, -1, sizeof(::anduril::type::Vec2)},
        {55, -1, -1, sizeof(::anduril::type::Vec2f)},
        {65, -1, -1, sizeof(::anduril::type::Vec3)},
        {76, -1, -1, sizeof(::anduril::type::Vec3f)},
        {87, -1, -1, sizeof(::anduril::type::Quaternion)},
        {99, -1, -1, sizeof(::anduril::type::YawPitch)},
        {109, -1, -1, sizeof(::anduril::type::YPR)},
        {120, 130, -1, sizeof(::anduril::type::Pose)},
        {132, -1, -1, sizeof(::anduril::type::LLAPolygon)},
        {141, -1, -1, sizeof(::anduril::type::AERPolygon)},
        {150, -1, -1, sizeof(::anduril::type::LLAPath)},
        {160, -1, -1, sizeof(::anduril::type::Spherical)},
        {171, -1, -1, sizeof(::anduril::type::DoubleRange)},
        {181, -1, -1, sizeof(::anduril::type::Uint64Range)},
        {191, -1, -1, sizeof(::anduril::type::TMat4f)},
        {209, -1, -1, sizeof(::anduril::type::TMat3)},
        {223, -1, -1, sizeof(::anduril::type::TMat2)},
        {234, 244, -1, sizeof(::anduril::type::RigidTransform)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::anduril::type::_ThetaPhi_default_instance_._instance,
    &::anduril::type::_LLA_default_instance_._instance,
    &::anduril::type::_ENU_default_instance_._instance,
    &::anduril::type::_ECI_default_instance_._instance,
    &::anduril::type::_Vec2_default_instance_._instance,
    &::anduril::type::_Vec2f_default_instance_._instance,
    &::anduril::type::_Vec3_default_instance_._instance,
    &::anduril::type::_Vec3f_default_instance_._instance,
    &::anduril::type::_Quaternion_default_instance_._instance,
    &::anduril::type::_YawPitch_default_instance_._instance,
    &::anduril::type::_YPR_default_instance_._instance,
    &::anduril::type::_Pose_default_instance_._instance,
    &::anduril::type::_LLAPolygon_default_instance_._instance,
    &::anduril::type::_AERPolygon_default_instance_._instance,
    &::anduril::type::_LLAPath_default_instance_._instance,
    &::anduril::type::_Spherical_default_instance_._instance,
    &::anduril::type::_DoubleRange_default_instance_._instance,
    &::anduril::type::_Uint64Range_default_instance_._instance,
    &::anduril::type::_TMat4f_default_instance_._instance,
    &::anduril::type::_TMat3_default_instance_._instance,
    &::anduril::type::_TMat2_default_instance_._instance,
    &::anduril::type::_RigidTransform_default_instance_._instance,
};
const char descriptor_table_protodef_anduril_2ftype_2fcoords_2epub_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\035anduril/type/coords.pub.proto\022\014anduril"
    ".type\"2\n\010ThetaPhi\022\024\n\005theta\030\001 \001(\001R\005theta\022"
    "\020\n\003phi\030\002 \001(\001R\003phi\"\304\003\n\003LLA\022\020\n\003lon\030\001 \001(\001R\003"
    "lon\022\020\n\003lat\030\002 \001(\001R\003lat\022\020\n\003alt\030\003 \001(\001R\003alt\022"
    "\022\n\004is2d\030\004 \001(\010R\004is2d\022R\n\022altitude_referenc"
    "e\030\005 \001(\0162#.anduril.type.LLA.AltitudeRefer"
    "enceR\021altitudeReference\"\236\002\n\021AltitudeRefe"
    "rence\022\036\n\032ALTITUDE_REFERENCE_INVALID\020\000\022)\n"
    "%ALTITUDE_REFERENCE_HEIGHT_ABOVE_WGS84\020\001"
    "\022)\n%ALTITUDE_REFERENCE_HEIGHT_ABOVE_EGM9"
    "6\020\002\022\036\n\032ALTITUDE_REFERENCE_UNKNOWN\020\003\022!\n\035A"
    "LTITUDE_REFERENCE_BAROMETRIC\020\004\022&\n\"ALTITU"
    "DE_REFERENCE_ABOVE_SEA_FLOOR\020\005\022(\n$ALTITU"
    "DE_REFERENCE_BELOW_SEA_SURFACE\020\006\"/\n\003ENU\022"
    "\014\n\001e\030\001 \001(\001R\001e\022\014\n\001n\030\002 \001(\001R\001n\022\014\n\001u\030\003 \001(\001R\001"
    "u\"/\n\003ECI\022\014\n\001x\030\001 \001(\001R\001x\022\014\n\001y\030\002 \001(\001R\001y\022\014\n\001"
    "z\030\003 \001(\001R\001z\"\"\n\004Vec2\022\014\n\001x\030\001 \001(\001R\001x\022\014\n\001y\030\002 "
    "\001(\001R\001y\"#\n\005Vec2f\022\014\n\001x\030\001 \001(\002R\001x\022\014\n\001y\030\002 \001(\002"
    "R\001y\"0\n\004Vec3\022\014\n\001x\030\001 \001(\001R\001x\022\014\n\001y\030\002 \001(\001R\001y\022"
    "\014\n\001z\030\003 \001(\001R\001z\"1\n\005Vec3f\022\014\n\001x\030\001 \001(\002R\001x\022\014\n\001"
    "y\030\002 \001(\002R\001y\022\014\n\001z\030\003 \001(\002R\001z\"D\n\nQuaternion\022\014"
    "\n\001x\030\001 \001(\001R\001x\022\014\n\001y\030\002 \001(\001R\001y\022\014\n\001z\030\003 \001(\001R\001z"
    "\022\014\n\001w\030\004 \001(\001R\001w\"2\n\010YawPitch\022\020\n\003yaw\030\001 \001(\001R"
    "\003yaw\022\024\n\005pitch\030\002 \001(\001R\005pitch\"A\n\003YPR\022\020\n\003yaw"
    "\030\001 \001(\001R\003yaw\022\024\n\005pitch\030\002 \001(\001R\005pitch\022\022\n\004rol"
    "l\030\003 \001(\001R\004roll\"^\n\004Pose\022#\n\003pos\030\001 \001(\0132\021.and"
    "uril.type.LLAR\003pos\0221\n\007att_enu\030\002 \001(\0132\030.an"
    "duril.type.QuaternionR\006attEnu\"7\n\nLLAPoly"
    "gon\022)\n\006points\030\001 \003(\0132\021.anduril.type.LLAR\006"
    "points\"=\n\nAERPolygon\022/\n\006points\030\001 \003(\0132\027.a"
    "nduril.type.SphericalR\006points\"H\n\007LLAPath"
    "\022)\n\006points\030\001 \003(\0132\021.anduril.type.LLAR\006poi"
    "nts\022\022\n\004loop\030\002 \001(\010R\004loop\"A\n\tSpherical\022\016\n\002"
    "az\030\001 \001(\001R\002az\022\016\n\002el\030\002 \001(\001R\002el\022\024\n\005range\030\003 "
    "\001(\001R\005range\"1\n\013DoubleRange\022\020\n\003min\030\001 \001(\001R\003"
    "min\022\020\n\003max\030\002 \001(\001R\003max\"1\n\013Uint64Range\022\020\n\003"
    "min\030\001 \001(\004R\003min\022\020\n\003max\030\002 \001(\004R\003max\"\274\001\n\006TMa"
    "t4f\022\020\n\003m00\030\001 \001(\002R\003m00\022\020\n\003m01\030\002 \001(\002R\003m01\022"
    "\020\n\003m02\030\003 \001(\002R\003m02\022\020\n\003m03\030\004 \001(\002R\003m03\022\020\n\003m"
    "11\030\005 \001(\002R\003m11\022\020\n\003m12\030\006 \001(\002R\003m12\022\020\n\003m13\030\007"
    " \001(\002R\003m13\022\020\n\003m22\030\010 \001(\002R\003m22\022\020\n\003m23\030\t \001(\002"
    "R\003m23\022\020\n\003m33\030\n \001(\002R\003m33\"s\n\005TMat3\022\020\n\003mxx\030"
    "\001 \001(\001R\003mxx\022\020\n\003mxy\030\002 \001(\001R\003mxy\022\020\n\003mxz\030\003 \001("
    "\001R\003mxz\022\020\n\003myy\030\004 \001(\001R\003myy\022\020\n\003myz\030\005 \001(\001R\003m"
    "yz\022\020\n\003mzz\030\006 \001(\001R\003mzz\"=\n\005TMat2\022\020\n\003mxx\030\001 \001"
    "(\001R\003mxx\022\020\n\003mxy\030\002 \001(\001R\003mxy\022\020\n\003myy\030\003 \001(\001R\003"
    "myy\"|\n\016RigidTransform\0224\n\010rotation\030\003 \001(\0132"
    "\030.anduril.type.QuaternionR\010rotation\0224\n\013t"
    "ranslation\030\004 \001(\0132\022.anduril.type.Vec3R\013tr"
    "anslationB\257\001\n\020com.anduril.typeB\016CoordsPu"
    "bProtoP\001Z:ghe.anduril.dev/anduril/anduri"
    "lapis-go/anduril/type;atypes\242\002\003ATX\252\002\014And"
    "uril.Type\312\002\014Anduril\\Type\342\002\030Anduril\\Type\\"
    "GPBMetadata\352\002\rAnduril::Typeb\006proto3"
};
static ::absl::once_flag descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto = {
    false,
    false,
    2155,
    descriptor_table_protodef_anduril_2ftype_2fcoords_2epub_2eproto,
    "anduril/type/coords.pub.proto",
    &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
    nullptr,
    0,
    22,
    schemas,
    file_default_instances,
    TableStruct_anduril_2ftype_2fcoords_2epub_2eproto::offsets,
    file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto,
    file_level_enum_descriptors_anduril_2ftype_2fcoords_2epub_2eproto,
    file_level_service_descriptors_anduril_2ftype_2fcoords_2epub_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter() {
  return &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_anduril_2ftype_2fcoords_2epub_2eproto(&descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto);
namespace anduril {
namespace type {
const ::google::protobuf::EnumDescriptor* LLA_AltitudeReference_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto);
  return file_level_enum_descriptors_anduril_2ftype_2fcoords_2epub_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t LLA_AltitudeReference_internal_data_[] = {
    458752u, 0u, };
bool LLA_AltitudeReference_IsValid(int value) {
  return 0 <= value && value <= 6;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr LLA_AltitudeReference LLA::ALTITUDE_REFERENCE_INVALID;
constexpr LLA_AltitudeReference LLA::ALTITUDE_REFERENCE_HEIGHT_ABOVE_WGS84;
constexpr LLA_AltitudeReference LLA::ALTITUDE_REFERENCE_HEIGHT_ABOVE_EGM96;
constexpr LLA_AltitudeReference LLA::ALTITUDE_REFERENCE_UNKNOWN;
constexpr LLA_AltitudeReference LLA::ALTITUDE_REFERENCE_BAROMETRIC;
constexpr LLA_AltitudeReference LLA::ALTITUDE_REFERENCE_ABOVE_SEA_FLOOR;
constexpr LLA_AltitudeReference LLA::ALTITUDE_REFERENCE_BELOW_SEA_SURFACE;
constexpr LLA_AltitudeReference LLA::AltitudeReference_MIN;
constexpr LLA_AltitudeReference LLA::AltitudeReference_MAX;
constexpr int LLA::AltitudeReference_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class ThetaPhi::_Internal {
 public:
};

ThetaPhi::ThetaPhi(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.ThetaPhi)
}
ThetaPhi::ThetaPhi(
    ::google::protobuf::Arena* arena, const ThetaPhi& from)
    : ThetaPhi(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE ThetaPhi::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void ThetaPhi::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, theta_),
           0,
           offsetof(Impl_, phi_) -
               offsetof(Impl_, theta_) +
               sizeof(Impl_::phi_));
}
ThetaPhi::~ThetaPhi() {
  // @@protoc_insertion_point(destructor:anduril.type.ThetaPhi)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ThetaPhi::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void ThetaPhi::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.ThetaPhi)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.theta_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.phi_) -
      reinterpret_cast<char*>(&_impl_.theta_)) + sizeof(_impl_.phi_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ThetaPhi::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> ThetaPhi::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_ThetaPhi_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double phi = 2 [json_name = "phi"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(ThetaPhi, _impl_.phi_)}},
    // double theta = 1 [json_name = "theta"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(ThetaPhi, _impl_.theta_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double theta = 1 [json_name = "theta"];
    {PROTOBUF_FIELD_OFFSET(ThetaPhi, _impl_.theta_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double phi = 2 [json_name = "phi"];
    {PROTOBUF_FIELD_OFFSET(ThetaPhi, _impl_.phi_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* ThetaPhi::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.ThetaPhi)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double theta = 1 [json_name = "theta"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_theta = this->_internal_theta();
  ::uint64_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_theta(), target);
  }

  // double phi = 2 [json_name = "phi"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_phi = this->_internal_phi();
  ::uint64_t raw_phi;
  memcpy(&raw_phi, &tmp_phi, sizeof(tmp_phi));
  if (raw_phi != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_phi(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.ThetaPhi)
  return target;
}

::size_t ThetaPhi::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.ThetaPhi)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double theta = 1 [json_name = "theta"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_theta = this->_internal_theta();
  ::uint64_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    total_size += 9;
  }

  // double phi = 2 [json_name = "phi"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_phi = this->_internal_phi();
  ::uint64_t raw_phi;
  memcpy(&raw_phi, &tmp_phi, sizeof(tmp_phi));
  if (raw_phi != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ThetaPhi::_class_data_ = {
    ThetaPhi::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* ThetaPhi::GetClassData() const {
  return &_class_data_;
}

void ThetaPhi::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ThetaPhi*>(&to_msg);
  auto& from = static_cast<const ThetaPhi&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.ThetaPhi)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_theta = from._internal_theta();
  ::uint64_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    _this->_internal_set_theta(from._internal_theta());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_phi = from._internal_phi();
  ::uint64_t raw_phi;
  memcpy(&raw_phi, &tmp_phi, sizeof(tmp_phi));
  if (raw_phi != 0) {
    _this->_internal_set_phi(from._internal_phi());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ThetaPhi::CopyFrom(const ThetaPhi& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.ThetaPhi)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ThetaPhi::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* ThetaPhi::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void ThetaPhi::InternalSwap(ThetaPhi* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThetaPhi, _impl_.phi_)
      + sizeof(ThetaPhi::_impl_.phi_)
      - PROTOBUF_FIELD_OFFSET(ThetaPhi, _impl_.theta_)>(
          reinterpret_cast<char*>(&_impl_.theta_),
          reinterpret_cast<char*>(&other->_impl_.theta_));
}

::google::protobuf::Metadata ThetaPhi::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[0]);
}
// ===================================================================

class LLA::_Internal {
 public:
};

LLA::LLA(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.LLA)
}
LLA::LLA(
    ::google::protobuf::Arena* arena, const LLA& from)
    : LLA(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE LLA::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LLA::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, lon_),
           0,
           offsetof(Impl_, altitude_reference_) -
               offsetof(Impl_, lon_) +
               sizeof(Impl_::altitude_reference_));
}
LLA::~LLA() {
  // @@protoc_insertion_point(destructor:anduril.type.LLA)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LLA::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void LLA::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.LLA)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.lon_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.altitude_reference_) -
      reinterpret_cast<char*>(&_impl_.lon_)) + sizeof(_impl_.altitude_reference_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* LLA::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> LLA::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_LLA_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double lon = 1 [json_name = "lon"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(LLA, _impl_.lon_)}},
    // double lat = 2 [json_name = "lat"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(LLA, _impl_.lat_)}},
    // double alt = 3 [json_name = "alt"];
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(LLA, _impl_.alt_)}},
    // bool is2d = 4 [json_name = "is2d"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(LLA, _impl_.is2d_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(LLA, _impl_.is2d_)}},
    // .anduril.type.LLA.AltitudeReference altitude_reference = 5 [json_name = "altitudeReference"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(LLA, _impl_.altitude_reference_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(LLA, _impl_.altitude_reference_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double lon = 1 [json_name = "lon"];
    {PROTOBUF_FIELD_OFFSET(LLA, _impl_.lon_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double lat = 2 [json_name = "lat"];
    {PROTOBUF_FIELD_OFFSET(LLA, _impl_.lat_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double alt = 3 [json_name = "alt"];
    {PROTOBUF_FIELD_OFFSET(LLA, _impl_.alt_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // bool is2d = 4 [json_name = "is2d"];
    {PROTOBUF_FIELD_OFFSET(LLA, _impl_.is2d_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .anduril.type.LLA.AltitudeReference altitude_reference = 5 [json_name = "altitudeReference"];
    {PROTOBUF_FIELD_OFFSET(LLA, _impl_.altitude_reference_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* LLA::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.LLA)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double lon = 1 [json_name = "lon"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_lon = this->_internal_lon();
  ::uint64_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_lon(), target);
  }

  // double lat = 2 [json_name = "lat"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_lat = this->_internal_lat();
  ::uint64_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_lat(), target);
  }

  // double alt = 3 [json_name = "alt"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_alt = this->_internal_alt();
  ::uint64_t raw_alt;
  memcpy(&raw_alt, &tmp_alt, sizeof(tmp_alt));
  if (raw_alt != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_alt(), target);
  }

  // bool is2d = 4 [json_name = "is2d"];
  if (this->_internal_is2d() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_is2d(), target);
  }

  // .anduril.type.LLA.AltitudeReference altitude_reference = 5 [json_name = "altitudeReference"];
  if (this->_internal_altitude_reference() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_altitude_reference(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.LLA)
  return target;
}

::size_t LLA::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.LLA)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double lon = 1 [json_name = "lon"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_lon = this->_internal_lon();
  ::uint64_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    total_size += 9;
  }

  // double lat = 2 [json_name = "lat"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_lat = this->_internal_lat();
  ::uint64_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    total_size += 9;
  }

  // double alt = 3 [json_name = "alt"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_alt = this->_internal_alt();
  ::uint64_t raw_alt;
  memcpy(&raw_alt, &tmp_alt, sizeof(tmp_alt));
  if (raw_alt != 0) {
    total_size += 9;
  }

  // bool is2d = 4 [json_name = "is2d"];
  if (this->_internal_is2d() != 0) {
    total_size += 2;
  }

  // .anduril.type.LLA.AltitudeReference altitude_reference = 5 [json_name = "altitudeReference"];
  if (this->_internal_altitude_reference() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_altitude_reference());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData LLA::_class_data_ = {
    LLA::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* LLA::GetClassData() const {
  return &_class_data_;
}

void LLA::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<LLA*>(&to_msg);
  auto& from = static_cast<const LLA&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.LLA)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_lon = from._internal_lon();
  ::uint64_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    _this->_internal_set_lon(from._internal_lon());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_lat = from._internal_lat();
  ::uint64_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    _this->_internal_set_lat(from._internal_lat());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_alt = from._internal_alt();
  ::uint64_t raw_alt;
  memcpy(&raw_alt, &tmp_alt, sizeof(tmp_alt));
  if (raw_alt != 0) {
    _this->_internal_set_alt(from._internal_alt());
  }
  if (from._internal_is2d() != 0) {
    _this->_internal_set_is2d(from._internal_is2d());
  }
  if (from._internal_altitude_reference() != 0) {
    _this->_internal_set_altitude_reference(from._internal_altitude_reference());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LLA::CopyFrom(const LLA& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.LLA)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool LLA::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* LLA::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void LLA::InternalSwap(LLA* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LLA, _impl_.altitude_reference_)
      + sizeof(LLA::_impl_.altitude_reference_)
      - PROTOBUF_FIELD_OFFSET(LLA, _impl_.lon_)>(
          reinterpret_cast<char*>(&_impl_.lon_),
          reinterpret_cast<char*>(&other->_impl_.lon_));
}

::google::protobuf::Metadata LLA::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[1]);
}
// ===================================================================

class ENU::_Internal {
 public:
};

ENU::ENU(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.ENU)
}
ENU::ENU(
    ::google::protobuf::Arena* arena, const ENU& from)
    : ENU(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE ENU::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void ENU::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, e_),
           0,
           offsetof(Impl_, u_) -
               offsetof(Impl_, e_) +
               sizeof(Impl_::u_));
}
ENU::~ENU() {
  // @@protoc_insertion_point(destructor:anduril.type.ENU)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ENU::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void ENU::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.ENU)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.e_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.u_) -
      reinterpret_cast<char*>(&_impl_.e_)) + sizeof(_impl_.u_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ENU::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> ENU::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_ENU_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double e = 1 [json_name = "e"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(ENU, _impl_.e_)}},
    // double n = 2 [json_name = "n"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(ENU, _impl_.n_)}},
    // double u = 3 [json_name = "u"];
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(ENU, _impl_.u_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double e = 1 [json_name = "e"];
    {PROTOBUF_FIELD_OFFSET(ENU, _impl_.e_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double n = 2 [json_name = "n"];
    {PROTOBUF_FIELD_OFFSET(ENU, _impl_.n_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double u = 3 [json_name = "u"];
    {PROTOBUF_FIELD_OFFSET(ENU, _impl_.u_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* ENU::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.ENU)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double e = 1 [json_name = "e"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_e = this->_internal_e();
  ::uint64_t raw_e;
  memcpy(&raw_e, &tmp_e, sizeof(tmp_e));
  if (raw_e != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_e(), target);
  }

  // double n = 2 [json_name = "n"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_n = this->_internal_n();
  ::uint64_t raw_n;
  memcpy(&raw_n, &tmp_n, sizeof(tmp_n));
  if (raw_n != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_n(), target);
  }

  // double u = 3 [json_name = "u"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_u = this->_internal_u();
  ::uint64_t raw_u;
  memcpy(&raw_u, &tmp_u, sizeof(tmp_u));
  if (raw_u != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_u(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.ENU)
  return target;
}

::size_t ENU::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.ENU)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double e = 1 [json_name = "e"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_e = this->_internal_e();
  ::uint64_t raw_e;
  memcpy(&raw_e, &tmp_e, sizeof(tmp_e));
  if (raw_e != 0) {
    total_size += 9;
  }

  // double n = 2 [json_name = "n"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_n = this->_internal_n();
  ::uint64_t raw_n;
  memcpy(&raw_n, &tmp_n, sizeof(tmp_n));
  if (raw_n != 0) {
    total_size += 9;
  }

  // double u = 3 [json_name = "u"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_u = this->_internal_u();
  ::uint64_t raw_u;
  memcpy(&raw_u, &tmp_u, sizeof(tmp_u));
  if (raw_u != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ENU::_class_data_ = {
    ENU::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* ENU::GetClassData() const {
  return &_class_data_;
}

void ENU::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ENU*>(&to_msg);
  auto& from = static_cast<const ENU&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.ENU)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_e = from._internal_e();
  ::uint64_t raw_e;
  memcpy(&raw_e, &tmp_e, sizeof(tmp_e));
  if (raw_e != 0) {
    _this->_internal_set_e(from._internal_e());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_n = from._internal_n();
  ::uint64_t raw_n;
  memcpy(&raw_n, &tmp_n, sizeof(tmp_n));
  if (raw_n != 0) {
    _this->_internal_set_n(from._internal_n());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_u = from._internal_u();
  ::uint64_t raw_u;
  memcpy(&raw_u, &tmp_u, sizeof(tmp_u));
  if (raw_u != 0) {
    _this->_internal_set_u(from._internal_u());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ENU::CopyFrom(const ENU& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.ENU)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ENU::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* ENU::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void ENU::InternalSwap(ENU* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ENU, _impl_.u_)
      + sizeof(ENU::_impl_.u_)
      - PROTOBUF_FIELD_OFFSET(ENU, _impl_.e_)>(
          reinterpret_cast<char*>(&_impl_.e_),
          reinterpret_cast<char*>(&other->_impl_.e_));
}

::google::protobuf::Metadata ENU::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[2]);
}
// ===================================================================

class ECI::_Internal {
 public:
};

ECI::ECI(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.ECI)
}
ECI::ECI(
    ::google::protobuf::Arena* arena, const ECI& from)
    : ECI(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE ECI::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void ECI::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::z_));
}
ECI::~ECI() {
  // @@protoc_insertion_point(destructor:anduril.type.ECI)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ECI::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void ECI::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.ECI)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ECI::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> ECI::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_ECI_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double x = 1 [json_name = "x"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(ECI, _impl_.x_)}},
    // double y = 2 [json_name = "y"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(ECI, _impl_.y_)}},
    // double z = 3 [json_name = "z"];
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(ECI, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double x = 1 [json_name = "x"];
    {PROTOBUF_FIELD_OFFSET(ECI, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double y = 2 [json_name = "y"];
    {PROTOBUF_FIELD_OFFSET(ECI, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double z = 3 [json_name = "z"];
    {PROTOBUF_FIELD_OFFSET(ECI, _impl_.z_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* ECI::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.ECI)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_x(), target);
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_y(), target);
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.ECI)
  return target;
}

::size_t ECI::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.ECI)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 9;
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 9;
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ECI::_class_data_ = {
    ECI::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* ECI::GetClassData() const {
  return &_class_data_;
}

void ECI::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ECI*>(&to_msg);
  auto& from = static_cast<const ECI&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.ECI)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ECI::CopyFrom(const ECI& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.ECI)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ECI::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* ECI::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void ECI::InternalSwap(ECI* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ECI, _impl_.z_)
      + sizeof(ECI::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(ECI, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata ECI::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[3]);
}
// ===================================================================

class Vec2::_Internal {
 public:
};

Vec2::Vec2(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.Vec2)
}
Vec2::Vec2(
    ::google::protobuf::Arena* arena, const Vec2& from)
    : Vec2(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Vec2::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Vec2::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, y_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::y_));
}
Vec2::~Vec2() {
  // @@protoc_insertion_point(destructor:anduril.type.Vec2)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Vec2::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Vec2::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.Vec2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Vec2::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> Vec2::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Vec2_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double y = 2 [json_name = "y"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(Vec2, _impl_.y_)}},
    // double x = 1 [json_name = "x"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(Vec2, _impl_.x_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double x = 1 [json_name = "x"];
    {PROTOBUF_FIELD_OFFSET(Vec2, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double y = 2 [json_name = "y"];
    {PROTOBUF_FIELD_OFFSET(Vec2, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Vec2::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.Vec2)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_x(), target);
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.Vec2)
  return target;
}

::size_t Vec2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.Vec2)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 9;
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Vec2::_class_data_ = {
    Vec2::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Vec2::GetClassData() const {
  return &_class_data_;
}

void Vec2::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Vec2*>(&to_msg);
  auto& from = static_cast<const Vec2&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.Vec2)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Vec2::CopyFrom(const Vec2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.Vec2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Vec2::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Vec2::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Vec2::InternalSwap(Vec2* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vec2, _impl_.y_)
      + sizeof(Vec2::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Vec2, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata Vec2::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[4]);
}
// ===================================================================

class Vec2f::_Internal {
 public:
};

Vec2f::Vec2f(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.Vec2f)
}
Vec2f::Vec2f(
    ::google::protobuf::Arena* arena, const Vec2f& from)
    : Vec2f(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Vec2f::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Vec2f::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, y_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::y_));
}
Vec2f::~Vec2f() {
  // @@protoc_insertion_point(destructor:anduril.type.Vec2f)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Vec2f::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Vec2f::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.Vec2f)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Vec2f::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> Vec2f::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Vec2f_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float y = 2 [json_name = "y"];
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(Vec2f, _impl_.y_)}},
    // float x = 1 [json_name = "x"];
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(Vec2f, _impl_.x_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float x = 1 [json_name = "x"];
    {PROTOBUF_FIELD_OFFSET(Vec2f, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float y = 2 [json_name = "y"];
    {PROTOBUF_FIELD_OFFSET(Vec2f, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Vec2f::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.Vec2f)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float x = 1 [json_name = "x"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2 [json_name = "y"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.Vec2f)
  return target;
}

::size_t Vec2f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.Vec2f)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1 [json_name = "x"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2 [json_name = "y"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Vec2f::_class_data_ = {
    Vec2f::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Vec2f::GetClassData() const {
  return &_class_data_;
}

void Vec2f::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Vec2f*>(&to_msg);
  auto& from = static_cast<const Vec2f&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.Vec2f)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Vec2f::CopyFrom(const Vec2f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.Vec2f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Vec2f::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Vec2f::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Vec2f::InternalSwap(Vec2f* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vec2f, _impl_.y_)
      + sizeof(Vec2f::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Vec2f, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata Vec2f::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[5]);
}
// ===================================================================

class Vec3::_Internal {
 public:
};

Vec3::Vec3(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.Vec3)
}
Vec3::Vec3(
    ::google::protobuf::Arena* arena, const Vec3& from)
    : Vec3(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Vec3::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Vec3::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::z_));
}
Vec3::~Vec3() {
  // @@protoc_insertion_point(destructor:anduril.type.Vec3)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Vec3::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Vec3::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.Vec3)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Vec3::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> Vec3::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Vec3_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double x = 1 [json_name = "x"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(Vec3, _impl_.x_)}},
    // double y = 2 [json_name = "y"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(Vec3, _impl_.y_)}},
    // double z = 3 [json_name = "z"];
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(Vec3, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double x = 1 [json_name = "x"];
    {PROTOBUF_FIELD_OFFSET(Vec3, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double y = 2 [json_name = "y"];
    {PROTOBUF_FIELD_OFFSET(Vec3, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double z = 3 [json_name = "z"];
    {PROTOBUF_FIELD_OFFSET(Vec3, _impl_.z_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Vec3::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.Vec3)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_x(), target);
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_y(), target);
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.Vec3)
  return target;
}

::size_t Vec3::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.Vec3)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 9;
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 9;
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Vec3::_class_data_ = {
    Vec3::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Vec3::GetClassData() const {
  return &_class_data_;
}

void Vec3::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Vec3*>(&to_msg);
  auto& from = static_cast<const Vec3&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.Vec3)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Vec3::CopyFrom(const Vec3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.Vec3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Vec3::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Vec3::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Vec3::InternalSwap(Vec3* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vec3, _impl_.z_)
      + sizeof(Vec3::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Vec3, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata Vec3::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[6]);
}
// ===================================================================

class Vec3f::_Internal {
 public:
};

Vec3f::Vec3f(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.Vec3f)
}
Vec3f::Vec3f(
    ::google::protobuf::Arena* arena, const Vec3f& from)
    : Vec3f(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Vec3f::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Vec3f::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::z_));
}
Vec3f::~Vec3f() {
  // @@protoc_insertion_point(destructor:anduril.type.Vec3f)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Vec3f::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Vec3f::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.Vec3f)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Vec3f::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> Vec3f::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Vec3f_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // float x = 1 [json_name = "x"];
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(Vec3f, _impl_.x_)}},
    // float y = 2 [json_name = "y"];
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(Vec3f, _impl_.y_)}},
    // float z = 3 [json_name = "z"];
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(Vec3f, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float x = 1 [json_name = "x"];
    {PROTOBUF_FIELD_OFFSET(Vec3f, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float y = 2 [json_name = "y"];
    {PROTOBUF_FIELD_OFFSET(Vec3f, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float z = 3 [json_name = "z"];
    {PROTOBUF_FIELD_OFFSET(Vec3f, _impl_.z_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Vec3f::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.Vec3f)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float x = 1 [json_name = "x"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2 [json_name = "y"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  // float z = 3 [json_name = "z"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.Vec3f)
  return target;
}

::size_t Vec3f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.Vec3f)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1 [json_name = "x"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2 [json_name = "y"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  // float z = 3 [json_name = "z"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Vec3f::_class_data_ = {
    Vec3f::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Vec3f::GetClassData() const {
  return &_class_data_;
}

void Vec3f::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Vec3f*>(&to_msg);
  auto& from = static_cast<const Vec3f&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.Vec3f)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Vec3f::CopyFrom(const Vec3f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.Vec3f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Vec3f::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Vec3f::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Vec3f::InternalSwap(Vec3f* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vec3f, _impl_.z_)
      + sizeof(Vec3f::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Vec3f, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata Vec3f::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[7]);
}
// ===================================================================

class Quaternion::_Internal {
 public:
};

Quaternion::Quaternion(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.Quaternion)
}
Quaternion::Quaternion(
    ::google::protobuf::Arena* arena, const Quaternion& from)
    : Quaternion(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Quaternion::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Quaternion::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, w_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::w_));
}
Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:anduril.type.Quaternion)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Quaternion::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.Quaternion)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.w_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Quaternion::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> Quaternion::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Quaternion_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double w = 4 [json_name = "w"];
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.w_)}},
    // double x = 1 [json_name = "x"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.x_)}},
    // double y = 2 [json_name = "y"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.y_)}},
    // double z = 3 [json_name = "z"];
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double x = 1 [json_name = "x"];
    {PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double y = 2 [json_name = "y"];
    {PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double z = 3 [json_name = "z"];
    {PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.z_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double w = 4 [json_name = "w"];
    {PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.w_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Quaternion::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.Quaternion)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_x(), target);
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_y(), target);
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_z(), target);
  }

  // double w = 4 [json_name = "w"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_w = this->_internal_w();
  ::uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.Quaternion)
  return target;
}

::size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.Quaternion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 9;
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 9;
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 9;
  }

  // double w = 4 [json_name = "w"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_w = this->_internal_w();
  ::uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Quaternion::_class_data_ = {
    Quaternion::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Quaternion::GetClassData() const {
  return &_class_data_;
}

void Quaternion::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Quaternion*>(&to_msg);
  auto& from = static_cast<const Quaternion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.Quaternion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_w = from._internal_w();
  ::uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Quaternion::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Quaternion::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Quaternion::InternalSwap(Quaternion* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.w_)
      + sizeof(Quaternion::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata Quaternion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[8]);
}
// ===================================================================

class YawPitch::_Internal {
 public:
};

YawPitch::YawPitch(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.YawPitch)
}
YawPitch::YawPitch(
    ::google::protobuf::Arena* arena, const YawPitch& from)
    : YawPitch(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE YawPitch::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void YawPitch::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, yaw_),
           0,
           offsetof(Impl_, pitch_) -
               offsetof(Impl_, yaw_) +
               sizeof(Impl_::pitch_));
}
YawPitch::~YawPitch() {
  // @@protoc_insertion_point(destructor:anduril.type.YawPitch)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void YawPitch::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void YawPitch::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.YawPitch)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.yaw_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.pitch_) -
      reinterpret_cast<char*>(&_impl_.yaw_)) + sizeof(_impl_.pitch_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* YawPitch::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> YawPitch::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_YawPitch_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double pitch = 2 [json_name = "pitch"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(YawPitch, _impl_.pitch_)}},
    // double yaw = 1 [json_name = "yaw"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(YawPitch, _impl_.yaw_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double yaw = 1 [json_name = "yaw"];
    {PROTOBUF_FIELD_OFFSET(YawPitch, _impl_.yaw_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double pitch = 2 [json_name = "pitch"];
    {PROTOBUF_FIELD_OFFSET(YawPitch, _impl_.pitch_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* YawPitch::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.YawPitch)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double yaw = 1 [json_name = "yaw"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_yaw = this->_internal_yaw();
  ::uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_yaw(), target);
  }

  // double pitch = 2 [json_name = "pitch"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_pitch = this->_internal_pitch();
  ::uint64_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_pitch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.YawPitch)
  return target;
}

::size_t YawPitch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.YawPitch)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double yaw = 1 [json_name = "yaw"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_yaw = this->_internal_yaw();
  ::uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    total_size += 9;
  }

  // double pitch = 2 [json_name = "pitch"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_pitch = this->_internal_pitch();
  ::uint64_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData YawPitch::_class_data_ = {
    YawPitch::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* YawPitch::GetClassData() const {
  return &_class_data_;
}

void YawPitch::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<YawPitch*>(&to_msg);
  auto& from = static_cast<const YawPitch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.YawPitch)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_yaw = from._internal_yaw();
  ::uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    _this->_internal_set_yaw(from._internal_yaw());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_pitch = from._internal_pitch();
  ::uint64_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    _this->_internal_set_pitch(from._internal_pitch());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void YawPitch::CopyFrom(const YawPitch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.YawPitch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool YawPitch::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* YawPitch::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void YawPitch::InternalSwap(YawPitch* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(YawPitch, _impl_.pitch_)
      + sizeof(YawPitch::_impl_.pitch_)
      - PROTOBUF_FIELD_OFFSET(YawPitch, _impl_.yaw_)>(
          reinterpret_cast<char*>(&_impl_.yaw_),
          reinterpret_cast<char*>(&other->_impl_.yaw_));
}

::google::protobuf::Metadata YawPitch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[9]);
}
// ===================================================================

class YPR::_Internal {
 public:
};

YPR::YPR(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.YPR)
}
YPR::YPR(
    ::google::protobuf::Arena* arena, const YPR& from)
    : YPR(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE YPR::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void YPR::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, yaw_),
           0,
           offsetof(Impl_, roll_) -
               offsetof(Impl_, yaw_) +
               sizeof(Impl_::roll_));
}
YPR::~YPR() {
  // @@protoc_insertion_point(destructor:anduril.type.YPR)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void YPR::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void YPR::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.YPR)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.yaw_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.roll_) -
      reinterpret_cast<char*>(&_impl_.yaw_)) + sizeof(_impl_.roll_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* YPR::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> YPR::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_YPR_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double yaw = 1 [json_name = "yaw"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(YPR, _impl_.yaw_)}},
    // double pitch = 2 [json_name = "pitch"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(YPR, _impl_.pitch_)}},
    // double roll = 3 [json_name = "roll"];
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(YPR, _impl_.roll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double yaw = 1 [json_name = "yaw"];
    {PROTOBUF_FIELD_OFFSET(YPR, _impl_.yaw_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double pitch = 2 [json_name = "pitch"];
    {PROTOBUF_FIELD_OFFSET(YPR, _impl_.pitch_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double roll = 3 [json_name = "roll"];
    {PROTOBUF_FIELD_OFFSET(YPR, _impl_.roll_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* YPR::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.YPR)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double yaw = 1 [json_name = "yaw"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_yaw = this->_internal_yaw();
  ::uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_yaw(), target);
  }

  // double pitch = 2 [json_name = "pitch"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_pitch = this->_internal_pitch();
  ::uint64_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_pitch(), target);
  }

  // double roll = 3 [json_name = "roll"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_roll = this->_internal_roll();
  ::uint64_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_roll(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.YPR)
  return target;
}

::size_t YPR::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.YPR)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double yaw = 1 [json_name = "yaw"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_yaw = this->_internal_yaw();
  ::uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    total_size += 9;
  }

  // double pitch = 2 [json_name = "pitch"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_pitch = this->_internal_pitch();
  ::uint64_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    total_size += 9;
  }

  // double roll = 3 [json_name = "roll"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_roll = this->_internal_roll();
  ::uint64_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData YPR::_class_data_ = {
    YPR::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* YPR::GetClassData() const {
  return &_class_data_;
}

void YPR::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<YPR*>(&to_msg);
  auto& from = static_cast<const YPR&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.YPR)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_yaw = from._internal_yaw();
  ::uint64_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    _this->_internal_set_yaw(from._internal_yaw());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_pitch = from._internal_pitch();
  ::uint64_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    _this->_internal_set_pitch(from._internal_pitch());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_roll = from._internal_roll();
  ::uint64_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    _this->_internal_set_roll(from._internal_roll());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void YPR::CopyFrom(const YPR& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.YPR)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool YPR::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* YPR::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void YPR::InternalSwap(YPR* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(YPR, _impl_.roll_)
      + sizeof(YPR::_impl_.roll_)
      - PROTOBUF_FIELD_OFFSET(YPR, _impl_.yaw_)>(
          reinterpret_cast<char*>(&_impl_.yaw_),
          reinterpret_cast<char*>(&other->_impl_.yaw_));
}

::google::protobuf::Metadata YPR::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[10]);
}
// ===================================================================

class Pose::_Internal {
 public:
  using HasBits = decltype(std::declval<Pose>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Pose, _impl_._has_bits_);
  static const ::anduril::type::LLA& pos(const Pose* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::anduril::type::Quaternion& att_enu(const Pose* msg);
  static void set_has_att_enu(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::anduril::type::LLA& Pose::_Internal::pos(const Pose* msg) {
  return *msg->_impl_.pos_;
}
const ::anduril::type::Quaternion& Pose::_Internal::att_enu(const Pose* msg) {
  return *msg->_impl_.att_enu_;
}
Pose::Pose(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.Pose)
}
inline PROTOBUF_NDEBUG_INLINE Pose::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

Pose::Pose(
    ::google::protobuf::Arena* arena,
    const Pose& from)
    : ::google::protobuf::Message(arena) {
  Pose* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.pos_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::anduril::type::LLA>(arena, *from._impl_.pos_)
                : nullptr;
  _impl_.att_enu_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::anduril::type::Quaternion>(arena, *from._impl_.att_enu_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:anduril.type.Pose)
}
inline PROTOBUF_NDEBUG_INLINE Pose::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Pose::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, pos_),
           0,
           offsetof(Impl_, att_enu_) -
               offsetof(Impl_, pos_) +
               sizeof(Impl_::att_enu_));
}
Pose::~Pose() {
  // @@protoc_insertion_point(destructor:anduril.type.Pose)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Pose::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.pos_;
  delete _impl_.att_enu_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Pose::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.Pose)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.pos_ != nullptr);
      _impl_.pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.att_enu_ != nullptr);
      _impl_.att_enu_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Pose::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> Pose::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Pose, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Pose_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .anduril.type.Quaternion att_enu = 2 [json_name = "attEnu"];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(Pose, _impl_.att_enu_)}},
    // .anduril.type.LLA pos = 1 [json_name = "pos"];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Pose, _impl_.pos_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .anduril.type.LLA pos = 1 [json_name = "pos"];
    {PROTOBUF_FIELD_OFFSET(Pose, _impl_.pos_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .anduril.type.Quaternion att_enu = 2 [json_name = "attEnu"];
    {PROTOBUF_FIELD_OFFSET(Pose, _impl_.att_enu_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::anduril::type::LLA>()},
    {::_pbi::TcParser::GetTable<::anduril::type::Quaternion>()},
  }}, {{
  }},
};

::uint8_t* Pose::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.Pose)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .anduril.type.LLA pos = 1 [json_name = "pos"];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // .anduril.type.Quaternion att_enu = 2 [json_name = "attEnu"];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::att_enu(this),
        _Internal::att_enu(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.Pose)
  return target;
}

::size_t Pose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.Pose)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .anduril.type.LLA pos = 1 [json_name = "pos"];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.pos_);
    }

    // .anduril.type.Quaternion att_enu = 2 [json_name = "attEnu"];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.att_enu_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Pose::_class_data_ = {
    Pose::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Pose::GetClassData() const {
  return &_class_data_;
}

void Pose::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Pose*>(&to_msg);
  auto& from = static_cast<const Pose&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.Pose)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::anduril::type::LLA::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_att_enu()->::anduril::type::Quaternion::MergeFrom(
          from._internal_att_enu());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Pose::CopyFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Pose::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Pose::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Pose::InternalSwap(Pose* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Pose, _impl_.att_enu_)
      + sizeof(Pose::_impl_.att_enu_)
      - PROTOBUF_FIELD_OFFSET(Pose, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::google::protobuf::Metadata Pose::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[11]);
}
// ===================================================================

class LLAPolygon::_Internal {
 public:
};

LLAPolygon::LLAPolygon(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.LLAPolygon)
}
inline PROTOBUF_NDEBUG_INLINE LLAPolygon::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : points_{visibility, arena, from.points_},
        _cached_size_{0} {}

LLAPolygon::LLAPolygon(
    ::google::protobuf::Arena* arena,
    const LLAPolygon& from)
    : ::google::protobuf::Message(arena) {
  LLAPolygon* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:anduril.type.LLAPolygon)
}
inline PROTOBUF_NDEBUG_INLINE LLAPolygon::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : points_{visibility, arena},
        _cached_size_{0} {}

inline void LLAPolygon::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
LLAPolygon::~LLAPolygon() {
  // @@protoc_insertion_point(destructor:anduril.type.LLAPolygon)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LLAPolygon::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void LLAPolygon::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.LLAPolygon)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.points_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* LLAPolygon::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> LLAPolygon::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_LLAPolygon_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .anduril.type.LLA points = 1 [json_name = "points"];
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(LLAPolygon, _impl_.points_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .anduril.type.LLA points = 1 [json_name = "points"];
    {PROTOBUF_FIELD_OFFSET(LLAPolygon, _impl_.points_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::anduril::type::LLA>()},
  }}, {{
  }},
};

::uint8_t* LLAPolygon::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.LLAPolygon)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .anduril.type.LLA points = 1 [json_name = "points"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.LLAPolygon)
  return target;
}

::size_t LLAPolygon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.LLAPolygon)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .anduril.type.LLA points = 1 [json_name = "points"];
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_internal_points()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData LLAPolygon::_class_data_ = {
    LLAPolygon::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* LLAPolygon::GetClassData() const {
  return &_class_data_;
}

void LLAPolygon::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<LLAPolygon*>(&to_msg);
  auto& from = static_cast<const LLAPolygon&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.LLAPolygon)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_points()->MergeFrom(
      from._internal_points());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LLAPolygon::CopyFrom(const LLAPolygon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.LLAPolygon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool LLAPolygon::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* LLAPolygon::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void LLAPolygon::InternalSwap(LLAPolygon* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
}

::google::protobuf::Metadata LLAPolygon::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[12]);
}
// ===================================================================

class AERPolygon::_Internal {
 public:
};

AERPolygon::AERPolygon(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.AERPolygon)
}
inline PROTOBUF_NDEBUG_INLINE AERPolygon::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : points_{visibility, arena, from.points_},
        _cached_size_{0} {}

AERPolygon::AERPolygon(
    ::google::protobuf::Arena* arena,
    const AERPolygon& from)
    : ::google::protobuf::Message(arena) {
  AERPolygon* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:anduril.type.AERPolygon)
}
inline PROTOBUF_NDEBUG_INLINE AERPolygon::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : points_{visibility, arena},
        _cached_size_{0} {}

inline void AERPolygon::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AERPolygon::~AERPolygon() {
  // @@protoc_insertion_point(destructor:anduril.type.AERPolygon)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AERPolygon::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void AERPolygon::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.AERPolygon)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.points_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AERPolygon::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> AERPolygon::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_AERPolygon_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .anduril.type.Spherical points = 1 [json_name = "points"];
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AERPolygon, _impl_.points_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .anduril.type.Spherical points = 1 [json_name = "points"];
    {PROTOBUF_FIELD_OFFSET(AERPolygon, _impl_.points_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::anduril::type::Spherical>()},
  }}, {{
  }},
};

::uint8_t* AERPolygon::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.AERPolygon)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .anduril.type.Spherical points = 1 [json_name = "points"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.AERPolygon)
  return target;
}

::size_t AERPolygon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.AERPolygon)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .anduril.type.Spherical points = 1 [json_name = "points"];
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_internal_points()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AERPolygon::_class_data_ = {
    AERPolygon::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* AERPolygon::GetClassData() const {
  return &_class_data_;
}

void AERPolygon::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AERPolygon*>(&to_msg);
  auto& from = static_cast<const AERPolygon&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.AERPolygon)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_points()->MergeFrom(
      from._internal_points());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AERPolygon::CopyFrom(const AERPolygon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.AERPolygon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AERPolygon::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* AERPolygon::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void AERPolygon::InternalSwap(AERPolygon* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
}

::google::protobuf::Metadata AERPolygon::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[13]);
}
// ===================================================================

class LLAPath::_Internal {
 public:
};

LLAPath::LLAPath(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.LLAPath)
}
inline PROTOBUF_NDEBUG_INLINE LLAPath::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : points_{visibility, arena, from.points_},
        _cached_size_{0} {}

LLAPath::LLAPath(
    ::google::protobuf::Arena* arena,
    const LLAPath& from)
    : ::google::protobuf::Message(arena) {
  LLAPath* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  _impl_.loop_ = from._impl_.loop_;

  // @@protoc_insertion_point(copy_constructor:anduril.type.LLAPath)
}
inline PROTOBUF_NDEBUG_INLINE LLAPath::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : points_{visibility, arena},
        _cached_size_{0} {}

inline void LLAPath::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.loop_ = {};
}
LLAPath::~LLAPath() {
  // @@protoc_insertion_point(destructor:anduril.type.LLAPath)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LLAPath::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void LLAPath::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.LLAPath)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.points_.Clear();
  _impl_.loop_ = false;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* LLAPath::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> LLAPath::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_LLAPath_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // bool loop = 2 [json_name = "loop"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(LLAPath, _impl_.loop_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(LLAPath, _impl_.loop_)}},
    // repeated .anduril.type.LLA points = 1 [json_name = "points"];
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(LLAPath, _impl_.points_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .anduril.type.LLA points = 1 [json_name = "points"];
    {PROTOBUF_FIELD_OFFSET(LLAPath, _impl_.points_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool loop = 2 [json_name = "loop"];
    {PROTOBUF_FIELD_OFFSET(LLAPath, _impl_.loop_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::anduril::type::LLA>()},
  }}, {{
  }},
};

::uint8_t* LLAPath::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.LLAPath)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .anduril.type.LLA points = 1 [json_name = "points"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool loop = 2 [json_name = "loop"];
  if (this->_internal_loop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_loop(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.LLAPath)
  return target;
}

::size_t LLAPath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.LLAPath)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .anduril.type.LLA points = 1 [json_name = "points"];
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_internal_points()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // bool loop = 2 [json_name = "loop"];
  if (this->_internal_loop() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData LLAPath::_class_data_ = {
    LLAPath::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* LLAPath::GetClassData() const {
  return &_class_data_;
}

void LLAPath::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<LLAPath*>(&to_msg);
  auto& from = static_cast<const LLAPath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.LLAPath)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_points()->MergeFrom(
      from._internal_points());
  if (from._internal_loop() != 0) {
    _this->_internal_set_loop(from._internal_loop());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LLAPath::CopyFrom(const LLAPath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.LLAPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool LLAPath::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* LLAPath::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void LLAPath::InternalSwap(LLAPath* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
        swap(_impl_.loop_, other->_impl_.loop_);
}

::google::protobuf::Metadata LLAPath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[14]);
}
// ===================================================================

class Spherical::_Internal {
 public:
};

Spherical::Spherical(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.Spherical)
}
Spherical::Spherical(
    ::google::protobuf::Arena* arena, const Spherical& from)
    : Spherical(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Spherical::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Spherical::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, az_),
           0,
           offsetof(Impl_, range_) -
               offsetof(Impl_, az_) +
               sizeof(Impl_::range_));
}
Spherical::~Spherical() {
  // @@protoc_insertion_point(destructor:anduril.type.Spherical)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Spherical::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Spherical::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.Spherical)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.az_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.range_) -
      reinterpret_cast<char*>(&_impl_.az_)) + sizeof(_impl_.range_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Spherical::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> Spherical::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Spherical_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double az = 1 [json_name = "az"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(Spherical, _impl_.az_)}},
    // double el = 2 [json_name = "el"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(Spherical, _impl_.el_)}},
    // double range = 3 [json_name = "range"];
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(Spherical, _impl_.range_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double az = 1 [json_name = "az"];
    {PROTOBUF_FIELD_OFFSET(Spherical, _impl_.az_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double el = 2 [json_name = "el"];
    {PROTOBUF_FIELD_OFFSET(Spherical, _impl_.el_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double range = 3 [json_name = "range"];
    {PROTOBUF_FIELD_OFFSET(Spherical, _impl_.range_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Spherical::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.Spherical)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double az = 1 [json_name = "az"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_az = this->_internal_az();
  ::uint64_t raw_az;
  memcpy(&raw_az, &tmp_az, sizeof(tmp_az));
  if (raw_az != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_az(), target);
  }

  // double el = 2 [json_name = "el"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_el = this->_internal_el();
  ::uint64_t raw_el;
  memcpy(&raw_el, &tmp_el, sizeof(tmp_el));
  if (raw_el != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_el(), target);
  }

  // double range = 3 [json_name = "range"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_range = this->_internal_range();
  ::uint64_t raw_range;
  memcpy(&raw_range, &tmp_range, sizeof(tmp_range));
  if (raw_range != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_range(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.Spherical)
  return target;
}

::size_t Spherical::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.Spherical)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double az = 1 [json_name = "az"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_az = this->_internal_az();
  ::uint64_t raw_az;
  memcpy(&raw_az, &tmp_az, sizeof(tmp_az));
  if (raw_az != 0) {
    total_size += 9;
  }

  // double el = 2 [json_name = "el"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_el = this->_internal_el();
  ::uint64_t raw_el;
  memcpy(&raw_el, &tmp_el, sizeof(tmp_el));
  if (raw_el != 0) {
    total_size += 9;
  }

  // double range = 3 [json_name = "range"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_range = this->_internal_range();
  ::uint64_t raw_range;
  memcpy(&raw_range, &tmp_range, sizeof(tmp_range));
  if (raw_range != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Spherical::_class_data_ = {
    Spherical::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Spherical::GetClassData() const {
  return &_class_data_;
}

void Spherical::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Spherical*>(&to_msg);
  auto& from = static_cast<const Spherical&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.Spherical)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_az = from._internal_az();
  ::uint64_t raw_az;
  memcpy(&raw_az, &tmp_az, sizeof(tmp_az));
  if (raw_az != 0) {
    _this->_internal_set_az(from._internal_az());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_el = from._internal_el();
  ::uint64_t raw_el;
  memcpy(&raw_el, &tmp_el, sizeof(tmp_el));
  if (raw_el != 0) {
    _this->_internal_set_el(from._internal_el());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_range = from._internal_range();
  ::uint64_t raw_range;
  memcpy(&raw_range, &tmp_range, sizeof(tmp_range));
  if (raw_range != 0) {
    _this->_internal_set_range(from._internal_range());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Spherical::CopyFrom(const Spherical& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.Spherical)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Spherical::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Spherical::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Spherical::InternalSwap(Spherical* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Spherical, _impl_.range_)
      + sizeof(Spherical::_impl_.range_)
      - PROTOBUF_FIELD_OFFSET(Spherical, _impl_.az_)>(
          reinterpret_cast<char*>(&_impl_.az_),
          reinterpret_cast<char*>(&other->_impl_.az_));
}

::google::protobuf::Metadata Spherical::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[15]);
}
// ===================================================================

class DoubleRange::_Internal {
 public:
};

DoubleRange::DoubleRange(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.DoubleRange)
}
DoubleRange::DoubleRange(
    ::google::protobuf::Arena* arena, const DoubleRange& from)
    : DoubleRange(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE DoubleRange::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void DoubleRange::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_),
           0,
           offsetof(Impl_, max_) -
               offsetof(Impl_, min_) +
               sizeof(Impl_::max_));
}
DoubleRange::~DoubleRange() {
  // @@protoc_insertion_point(destructor:anduril.type.DoubleRange)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void DoubleRange::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void DoubleRange::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.DoubleRange)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.min_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.max_) -
      reinterpret_cast<char*>(&_impl_.min_)) + sizeof(_impl_.max_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* DoubleRange::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> DoubleRange::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_DoubleRange_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double max = 2 [json_name = "max"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(DoubleRange, _impl_.max_)}},
    // double min = 1 [json_name = "min"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(DoubleRange, _impl_.min_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double min = 1 [json_name = "min"];
    {PROTOBUF_FIELD_OFFSET(DoubleRange, _impl_.min_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double max = 2 [json_name = "max"];
    {PROTOBUF_FIELD_OFFSET(DoubleRange, _impl_.max_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* DoubleRange::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.DoubleRange)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double min = 1 [json_name = "min"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_min = this->_internal_min();
  ::uint64_t raw_min;
  memcpy(&raw_min, &tmp_min, sizeof(tmp_min));
  if (raw_min != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_min(), target);
  }

  // double max = 2 [json_name = "max"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_max = this->_internal_max();
  ::uint64_t raw_max;
  memcpy(&raw_max, &tmp_max, sizeof(tmp_max));
  if (raw_max != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.DoubleRange)
  return target;
}

::size_t DoubleRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.DoubleRange)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double min = 1 [json_name = "min"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_min = this->_internal_min();
  ::uint64_t raw_min;
  memcpy(&raw_min, &tmp_min, sizeof(tmp_min));
  if (raw_min != 0) {
    total_size += 9;
  }

  // double max = 2 [json_name = "max"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_max = this->_internal_max();
  ::uint64_t raw_max;
  memcpy(&raw_max, &tmp_max, sizeof(tmp_max));
  if (raw_max != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData DoubleRange::_class_data_ = {
    DoubleRange::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* DoubleRange::GetClassData() const {
  return &_class_data_;
}

void DoubleRange::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<DoubleRange*>(&to_msg);
  auto& from = static_cast<const DoubleRange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.DoubleRange)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_min = from._internal_min();
  ::uint64_t raw_min;
  memcpy(&raw_min, &tmp_min, sizeof(tmp_min));
  if (raw_min != 0) {
    _this->_internal_set_min(from._internal_min());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_max = from._internal_max();
  ::uint64_t raw_max;
  memcpy(&raw_max, &tmp_max, sizeof(tmp_max));
  if (raw_max != 0) {
    _this->_internal_set_max(from._internal_max());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DoubleRange::CopyFrom(const DoubleRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.DoubleRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DoubleRange::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* DoubleRange::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void DoubleRange::InternalSwap(DoubleRange* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleRange, _impl_.max_)
      + sizeof(DoubleRange::_impl_.max_)
      - PROTOBUF_FIELD_OFFSET(DoubleRange, _impl_.min_)>(
          reinterpret_cast<char*>(&_impl_.min_),
          reinterpret_cast<char*>(&other->_impl_.min_));
}

::google::protobuf::Metadata DoubleRange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[16]);
}
// ===================================================================

class Uint64Range::_Internal {
 public:
};

Uint64Range::Uint64Range(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.Uint64Range)
}
Uint64Range::Uint64Range(
    ::google::protobuf::Arena* arena, const Uint64Range& from)
    : Uint64Range(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Uint64Range::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Uint64Range::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_),
           0,
           offsetof(Impl_, max_) -
               offsetof(Impl_, min_) +
               sizeof(Impl_::max_));
}
Uint64Range::~Uint64Range() {
  // @@protoc_insertion_point(destructor:anduril.type.Uint64Range)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Uint64Range::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Uint64Range::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.Uint64Range)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.min_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.max_) -
      reinterpret_cast<char*>(&_impl_.min_)) + sizeof(_impl_.max_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Uint64Range::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> Uint64Range::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Uint64Range_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // uint64 max = 2 [json_name = "max"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Uint64Range, _impl_.max_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Uint64Range, _impl_.max_)}},
    // uint64 min = 1 [json_name = "min"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Uint64Range, _impl_.min_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(Uint64Range, _impl_.min_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 min = 1 [json_name = "min"];
    {PROTOBUF_FIELD_OFFSET(Uint64Range, _impl_.min_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // uint64 max = 2 [json_name = "max"];
    {PROTOBUF_FIELD_OFFSET(Uint64Range, _impl_.max_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Uint64Range::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.Uint64Range)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 min = 1 [json_name = "min"];
  if (this->_internal_min() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_min(), target);
  }

  // uint64 max = 2 [json_name = "max"];
  if (this->_internal_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.Uint64Range)
  return target;
}

::size_t Uint64Range::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.Uint64Range)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 min = 1 [json_name = "min"];
  if (this->_internal_min() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_min());
  }

  // uint64 max = 2 [json_name = "max"];
  if (this->_internal_max() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_max());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Uint64Range::_class_data_ = {
    Uint64Range::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Uint64Range::GetClassData() const {
  return &_class_data_;
}

void Uint64Range::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Uint64Range*>(&to_msg);
  auto& from = static_cast<const Uint64Range&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.Uint64Range)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_min() != 0) {
    _this->_internal_set_min(from._internal_min());
  }
  if (from._internal_max() != 0) {
    _this->_internal_set_max(from._internal_max());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Uint64Range::CopyFrom(const Uint64Range& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.Uint64Range)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Uint64Range::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Uint64Range::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Uint64Range::InternalSwap(Uint64Range* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Uint64Range, _impl_.max_)
      + sizeof(Uint64Range::_impl_.max_)
      - PROTOBUF_FIELD_OFFSET(Uint64Range, _impl_.min_)>(
          reinterpret_cast<char*>(&_impl_.min_),
          reinterpret_cast<char*>(&other->_impl_.min_));
}

::google::protobuf::Metadata Uint64Range::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[17]);
}
// ===================================================================

class TMat4f::_Internal {
 public:
};

TMat4f::TMat4f(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.TMat4f)
}
TMat4f::TMat4f(
    ::google::protobuf::Arena* arena, const TMat4f& from)
    : TMat4f(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE TMat4f::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TMat4f::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, m00_),
           0,
           offsetof(Impl_, m33_) -
               offsetof(Impl_, m00_) +
               sizeof(Impl_::m33_));
}
TMat4f::~TMat4f() {
  // @@protoc_insertion_point(destructor:anduril.type.TMat4f)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TMat4f::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void TMat4f::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.TMat4f)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.m00_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.m33_) -
      reinterpret_cast<char*>(&_impl_.m00_)) + sizeof(_impl_.m33_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* TMat4f::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 0, 0, 2> TMat4f::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TMat4f_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // float m00 = 1 [json_name = "m00"];
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m00_)}},
    // float m01 = 2 [json_name = "m01"];
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m01_)}},
    // float m02 = 3 [json_name = "m02"];
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m02_)}},
    // float m03 = 4 [json_name = "m03"];
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m03_)}},
    // float m11 = 5 [json_name = "m11"];
    {::_pbi::TcParser::FastF32S1,
     {45, 63, 0, PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m11_)}},
    // float m12 = 6 [json_name = "m12"];
    {::_pbi::TcParser::FastF32S1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m12_)}},
    // float m13 = 7 [json_name = "m13"];
    {::_pbi::TcParser::FastF32S1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m13_)}},
    // float m22 = 8 [json_name = "m22"];
    {::_pbi::TcParser::FastF32S1,
     {69, 63, 0, PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m22_)}},
    // float m23 = 9 [json_name = "m23"];
    {::_pbi::TcParser::FastF32S1,
     {77, 63, 0, PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m23_)}},
    // float m33 = 10 [json_name = "m33"];
    {::_pbi::TcParser::FastF32S1,
     {85, 63, 0, PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m33_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // float m00 = 1 [json_name = "m00"];
    {PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m00_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float m01 = 2 [json_name = "m01"];
    {PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m01_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float m02 = 3 [json_name = "m02"];
    {PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m02_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float m03 = 4 [json_name = "m03"];
    {PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m03_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float m11 = 5 [json_name = "m11"];
    {PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m11_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float m12 = 6 [json_name = "m12"];
    {PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m12_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float m13 = 7 [json_name = "m13"];
    {PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m13_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float m22 = 8 [json_name = "m22"];
    {PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m22_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float m23 = 9 [json_name = "m23"];
    {PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m23_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float m33 = 10 [json_name = "m33"];
    {PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m33_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* TMat4f::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.TMat4f)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float m00 = 1 [json_name = "m00"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m00 = this->_internal_m00();
  ::uint32_t raw_m00;
  memcpy(&raw_m00, &tmp_m00, sizeof(tmp_m00));
  if (raw_m00 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_m00(), target);
  }

  // float m01 = 2 [json_name = "m01"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m01 = this->_internal_m01();
  ::uint32_t raw_m01;
  memcpy(&raw_m01, &tmp_m01, sizeof(tmp_m01));
  if (raw_m01 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_m01(), target);
  }

  // float m02 = 3 [json_name = "m02"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m02 = this->_internal_m02();
  ::uint32_t raw_m02;
  memcpy(&raw_m02, &tmp_m02, sizeof(tmp_m02));
  if (raw_m02 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_m02(), target);
  }

  // float m03 = 4 [json_name = "m03"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m03 = this->_internal_m03();
  ::uint32_t raw_m03;
  memcpy(&raw_m03, &tmp_m03, sizeof(tmp_m03));
  if (raw_m03 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_m03(), target);
  }

  // float m11 = 5 [json_name = "m11"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m11 = this->_internal_m11();
  ::uint32_t raw_m11;
  memcpy(&raw_m11, &tmp_m11, sizeof(tmp_m11));
  if (raw_m11 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_m11(), target);
  }

  // float m12 = 6 [json_name = "m12"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m12 = this->_internal_m12();
  ::uint32_t raw_m12;
  memcpy(&raw_m12, &tmp_m12, sizeof(tmp_m12));
  if (raw_m12 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_m12(), target);
  }

  // float m13 = 7 [json_name = "m13"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m13 = this->_internal_m13();
  ::uint32_t raw_m13;
  memcpy(&raw_m13, &tmp_m13, sizeof(tmp_m13));
  if (raw_m13 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_m13(), target);
  }

  // float m22 = 8 [json_name = "m22"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m22 = this->_internal_m22();
  ::uint32_t raw_m22;
  memcpy(&raw_m22, &tmp_m22, sizeof(tmp_m22));
  if (raw_m22 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_m22(), target);
  }

  // float m23 = 9 [json_name = "m23"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m23 = this->_internal_m23();
  ::uint32_t raw_m23;
  memcpy(&raw_m23, &tmp_m23, sizeof(tmp_m23));
  if (raw_m23 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_m23(), target);
  }

  // float m33 = 10 [json_name = "m33"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m33 = this->_internal_m33();
  ::uint32_t raw_m33;
  memcpy(&raw_m33, &tmp_m33, sizeof(tmp_m33));
  if (raw_m33 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_m33(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.TMat4f)
  return target;
}

::size_t TMat4f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.TMat4f)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float m00 = 1 [json_name = "m00"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m00 = this->_internal_m00();
  ::uint32_t raw_m00;
  memcpy(&raw_m00, &tmp_m00, sizeof(tmp_m00));
  if (raw_m00 != 0) {
    total_size += 5;
  }

  // float m01 = 2 [json_name = "m01"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m01 = this->_internal_m01();
  ::uint32_t raw_m01;
  memcpy(&raw_m01, &tmp_m01, sizeof(tmp_m01));
  if (raw_m01 != 0) {
    total_size += 5;
  }

  // float m02 = 3 [json_name = "m02"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m02 = this->_internal_m02();
  ::uint32_t raw_m02;
  memcpy(&raw_m02, &tmp_m02, sizeof(tmp_m02));
  if (raw_m02 != 0) {
    total_size += 5;
  }

  // float m03 = 4 [json_name = "m03"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m03 = this->_internal_m03();
  ::uint32_t raw_m03;
  memcpy(&raw_m03, &tmp_m03, sizeof(tmp_m03));
  if (raw_m03 != 0) {
    total_size += 5;
  }

  // float m11 = 5 [json_name = "m11"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m11 = this->_internal_m11();
  ::uint32_t raw_m11;
  memcpy(&raw_m11, &tmp_m11, sizeof(tmp_m11));
  if (raw_m11 != 0) {
    total_size += 5;
  }

  // float m12 = 6 [json_name = "m12"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m12 = this->_internal_m12();
  ::uint32_t raw_m12;
  memcpy(&raw_m12, &tmp_m12, sizeof(tmp_m12));
  if (raw_m12 != 0) {
    total_size += 5;
  }

  // float m13 = 7 [json_name = "m13"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m13 = this->_internal_m13();
  ::uint32_t raw_m13;
  memcpy(&raw_m13, &tmp_m13, sizeof(tmp_m13));
  if (raw_m13 != 0) {
    total_size += 5;
  }

  // float m22 = 8 [json_name = "m22"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m22 = this->_internal_m22();
  ::uint32_t raw_m22;
  memcpy(&raw_m22, &tmp_m22, sizeof(tmp_m22));
  if (raw_m22 != 0) {
    total_size += 5;
  }

  // float m23 = 9 [json_name = "m23"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m23 = this->_internal_m23();
  ::uint32_t raw_m23;
  memcpy(&raw_m23, &tmp_m23, sizeof(tmp_m23));
  if (raw_m23 != 0) {
    total_size += 5;
  }

  // float m33 = 10 [json_name = "m33"];
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m33 = this->_internal_m33();
  ::uint32_t raw_m33;
  memcpy(&raw_m33, &tmp_m33, sizeof(tmp_m33));
  if (raw_m33 != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData TMat4f::_class_data_ = {
    TMat4f::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* TMat4f::GetClassData() const {
  return &_class_data_;
}

void TMat4f::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<TMat4f*>(&to_msg);
  auto& from = static_cast<const TMat4f&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.TMat4f)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m00 = from._internal_m00();
  ::uint32_t raw_m00;
  memcpy(&raw_m00, &tmp_m00, sizeof(tmp_m00));
  if (raw_m00 != 0) {
    _this->_internal_set_m00(from._internal_m00());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m01 = from._internal_m01();
  ::uint32_t raw_m01;
  memcpy(&raw_m01, &tmp_m01, sizeof(tmp_m01));
  if (raw_m01 != 0) {
    _this->_internal_set_m01(from._internal_m01());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m02 = from._internal_m02();
  ::uint32_t raw_m02;
  memcpy(&raw_m02, &tmp_m02, sizeof(tmp_m02));
  if (raw_m02 != 0) {
    _this->_internal_set_m02(from._internal_m02());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m03 = from._internal_m03();
  ::uint32_t raw_m03;
  memcpy(&raw_m03, &tmp_m03, sizeof(tmp_m03));
  if (raw_m03 != 0) {
    _this->_internal_set_m03(from._internal_m03());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m11 = from._internal_m11();
  ::uint32_t raw_m11;
  memcpy(&raw_m11, &tmp_m11, sizeof(tmp_m11));
  if (raw_m11 != 0) {
    _this->_internal_set_m11(from._internal_m11());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m12 = from._internal_m12();
  ::uint32_t raw_m12;
  memcpy(&raw_m12, &tmp_m12, sizeof(tmp_m12));
  if (raw_m12 != 0) {
    _this->_internal_set_m12(from._internal_m12());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m13 = from._internal_m13();
  ::uint32_t raw_m13;
  memcpy(&raw_m13, &tmp_m13, sizeof(tmp_m13));
  if (raw_m13 != 0) {
    _this->_internal_set_m13(from._internal_m13());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m22 = from._internal_m22();
  ::uint32_t raw_m22;
  memcpy(&raw_m22, &tmp_m22, sizeof(tmp_m22));
  if (raw_m22 != 0) {
    _this->_internal_set_m22(from._internal_m22());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m23 = from._internal_m23();
  ::uint32_t raw_m23;
  memcpy(&raw_m23, &tmp_m23, sizeof(tmp_m23));
  if (raw_m23 != 0) {
    _this->_internal_set_m23(from._internal_m23());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_m33 = from._internal_m33();
  ::uint32_t raw_m33;
  memcpy(&raw_m33, &tmp_m33, sizeof(tmp_m33));
  if (raw_m33 != 0) {
    _this->_internal_set_m33(from._internal_m33());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TMat4f::CopyFrom(const TMat4f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.TMat4f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TMat4f::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* TMat4f::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void TMat4f::InternalSwap(TMat4f* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m33_)
      + sizeof(TMat4f::_impl_.m33_)
      - PROTOBUF_FIELD_OFFSET(TMat4f, _impl_.m00_)>(
          reinterpret_cast<char*>(&_impl_.m00_),
          reinterpret_cast<char*>(&other->_impl_.m00_));
}

::google::protobuf::Metadata TMat4f::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[18]);
}
// ===================================================================

class TMat3::_Internal {
 public:
};

TMat3::TMat3(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.TMat3)
}
TMat3::TMat3(
    ::google::protobuf::Arena* arena, const TMat3& from)
    : TMat3(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE TMat3::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TMat3::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, mxx_),
           0,
           offsetof(Impl_, mzz_) -
               offsetof(Impl_, mxx_) +
               sizeof(Impl_::mzz_));
}
TMat3::~TMat3() {
  // @@protoc_insertion_point(destructor:anduril.type.TMat3)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TMat3::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void TMat3::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.TMat3)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.mxx_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.mzz_) -
      reinterpret_cast<char*>(&_impl_.mxx_)) + sizeof(_impl_.mzz_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* TMat3::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 0, 2> TMat3::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TMat3_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double mxx = 1 [json_name = "mxx"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(TMat3, _impl_.mxx_)}},
    // double mxy = 2 [json_name = "mxy"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(TMat3, _impl_.mxy_)}},
    // double mxz = 3 [json_name = "mxz"];
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(TMat3, _impl_.mxz_)}},
    // double myy = 4 [json_name = "myy"];
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(TMat3, _impl_.myy_)}},
    // double myz = 5 [json_name = "myz"];
    {::_pbi::TcParser::FastF64S1,
     {41, 63, 0, PROTOBUF_FIELD_OFFSET(TMat3, _impl_.myz_)}},
    // double mzz = 6 [json_name = "mzz"];
    {::_pbi::TcParser::FastF64S1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(TMat3, _impl_.mzz_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // double mxx = 1 [json_name = "mxx"];
    {PROTOBUF_FIELD_OFFSET(TMat3, _impl_.mxx_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double mxy = 2 [json_name = "mxy"];
    {PROTOBUF_FIELD_OFFSET(TMat3, _impl_.mxy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double mxz = 3 [json_name = "mxz"];
    {PROTOBUF_FIELD_OFFSET(TMat3, _impl_.mxz_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double myy = 4 [json_name = "myy"];
    {PROTOBUF_FIELD_OFFSET(TMat3, _impl_.myy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double myz = 5 [json_name = "myz"];
    {PROTOBUF_FIELD_OFFSET(TMat3, _impl_.myz_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double mzz = 6 [json_name = "mzz"];
    {PROTOBUF_FIELD_OFFSET(TMat3, _impl_.mzz_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* TMat3::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.TMat3)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double mxx = 1 [json_name = "mxx"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxx = this->_internal_mxx();
  ::uint64_t raw_mxx;
  memcpy(&raw_mxx, &tmp_mxx, sizeof(tmp_mxx));
  if (raw_mxx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_mxx(), target);
  }

  // double mxy = 2 [json_name = "mxy"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxy = this->_internal_mxy();
  ::uint64_t raw_mxy;
  memcpy(&raw_mxy, &tmp_mxy, sizeof(tmp_mxy));
  if (raw_mxy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_mxy(), target);
  }

  // double mxz = 3 [json_name = "mxz"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxz = this->_internal_mxz();
  ::uint64_t raw_mxz;
  memcpy(&raw_mxz, &tmp_mxz, sizeof(tmp_mxz));
  if (raw_mxz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_mxz(), target);
  }

  // double myy = 4 [json_name = "myy"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_myy = this->_internal_myy();
  ::uint64_t raw_myy;
  memcpy(&raw_myy, &tmp_myy, sizeof(tmp_myy));
  if (raw_myy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_myy(), target);
  }

  // double myz = 5 [json_name = "myz"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_myz = this->_internal_myz();
  ::uint64_t raw_myz;
  memcpy(&raw_myz, &tmp_myz, sizeof(tmp_myz));
  if (raw_myz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_myz(), target);
  }

  // double mzz = 6 [json_name = "mzz"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mzz = this->_internal_mzz();
  ::uint64_t raw_mzz;
  memcpy(&raw_mzz, &tmp_mzz, sizeof(tmp_mzz));
  if (raw_mzz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_mzz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.TMat3)
  return target;
}

::size_t TMat3::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.TMat3)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double mxx = 1 [json_name = "mxx"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxx = this->_internal_mxx();
  ::uint64_t raw_mxx;
  memcpy(&raw_mxx, &tmp_mxx, sizeof(tmp_mxx));
  if (raw_mxx != 0) {
    total_size += 9;
  }

  // double mxy = 2 [json_name = "mxy"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxy = this->_internal_mxy();
  ::uint64_t raw_mxy;
  memcpy(&raw_mxy, &tmp_mxy, sizeof(tmp_mxy));
  if (raw_mxy != 0) {
    total_size += 9;
  }

  // double mxz = 3 [json_name = "mxz"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxz = this->_internal_mxz();
  ::uint64_t raw_mxz;
  memcpy(&raw_mxz, &tmp_mxz, sizeof(tmp_mxz));
  if (raw_mxz != 0) {
    total_size += 9;
  }

  // double myy = 4 [json_name = "myy"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_myy = this->_internal_myy();
  ::uint64_t raw_myy;
  memcpy(&raw_myy, &tmp_myy, sizeof(tmp_myy));
  if (raw_myy != 0) {
    total_size += 9;
  }

  // double myz = 5 [json_name = "myz"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_myz = this->_internal_myz();
  ::uint64_t raw_myz;
  memcpy(&raw_myz, &tmp_myz, sizeof(tmp_myz));
  if (raw_myz != 0) {
    total_size += 9;
  }

  // double mzz = 6 [json_name = "mzz"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mzz = this->_internal_mzz();
  ::uint64_t raw_mzz;
  memcpy(&raw_mzz, &tmp_mzz, sizeof(tmp_mzz));
  if (raw_mzz != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData TMat3::_class_data_ = {
    TMat3::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* TMat3::GetClassData() const {
  return &_class_data_;
}

void TMat3::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<TMat3*>(&to_msg);
  auto& from = static_cast<const TMat3&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.TMat3)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxx = from._internal_mxx();
  ::uint64_t raw_mxx;
  memcpy(&raw_mxx, &tmp_mxx, sizeof(tmp_mxx));
  if (raw_mxx != 0) {
    _this->_internal_set_mxx(from._internal_mxx());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxy = from._internal_mxy();
  ::uint64_t raw_mxy;
  memcpy(&raw_mxy, &tmp_mxy, sizeof(tmp_mxy));
  if (raw_mxy != 0) {
    _this->_internal_set_mxy(from._internal_mxy());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxz = from._internal_mxz();
  ::uint64_t raw_mxz;
  memcpy(&raw_mxz, &tmp_mxz, sizeof(tmp_mxz));
  if (raw_mxz != 0) {
    _this->_internal_set_mxz(from._internal_mxz());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_myy = from._internal_myy();
  ::uint64_t raw_myy;
  memcpy(&raw_myy, &tmp_myy, sizeof(tmp_myy));
  if (raw_myy != 0) {
    _this->_internal_set_myy(from._internal_myy());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_myz = from._internal_myz();
  ::uint64_t raw_myz;
  memcpy(&raw_myz, &tmp_myz, sizeof(tmp_myz));
  if (raw_myz != 0) {
    _this->_internal_set_myz(from._internal_myz());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mzz = from._internal_mzz();
  ::uint64_t raw_mzz;
  memcpy(&raw_mzz, &tmp_mzz, sizeof(tmp_mzz));
  if (raw_mzz != 0) {
    _this->_internal_set_mzz(from._internal_mzz());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TMat3::CopyFrom(const TMat3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.TMat3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TMat3::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* TMat3::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void TMat3::InternalSwap(TMat3* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMat3, _impl_.mzz_)
      + sizeof(TMat3::_impl_.mzz_)
      - PROTOBUF_FIELD_OFFSET(TMat3, _impl_.mxx_)>(
          reinterpret_cast<char*>(&_impl_.mxx_),
          reinterpret_cast<char*>(&other->_impl_.mxx_));
}

::google::protobuf::Metadata TMat3::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[19]);
}
// ===================================================================

class TMat2::_Internal {
 public:
};

TMat2::TMat2(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.TMat2)
}
TMat2::TMat2(
    ::google::protobuf::Arena* arena, const TMat2& from)
    : TMat2(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE TMat2::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void TMat2::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, mxx_),
           0,
           offsetof(Impl_, myy_) -
               offsetof(Impl_, mxx_) +
               sizeof(Impl_::myy_));
}
TMat2::~TMat2() {
  // @@protoc_insertion_point(destructor:anduril.type.TMat2)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TMat2::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void TMat2::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.TMat2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.mxx_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.myy_) -
      reinterpret_cast<char*>(&_impl_.mxx_)) + sizeof(_impl_.myy_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* TMat2::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> TMat2::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TMat2_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double mxx = 1 [json_name = "mxx"];
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(TMat2, _impl_.mxx_)}},
    // double mxy = 2 [json_name = "mxy"];
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(TMat2, _impl_.mxy_)}},
    // double myy = 3 [json_name = "myy"];
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(TMat2, _impl_.myy_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double mxx = 1 [json_name = "mxx"];
    {PROTOBUF_FIELD_OFFSET(TMat2, _impl_.mxx_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double mxy = 2 [json_name = "mxy"];
    {PROTOBUF_FIELD_OFFSET(TMat2, _impl_.mxy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double myy = 3 [json_name = "myy"];
    {PROTOBUF_FIELD_OFFSET(TMat2, _impl_.myy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* TMat2::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.TMat2)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double mxx = 1 [json_name = "mxx"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxx = this->_internal_mxx();
  ::uint64_t raw_mxx;
  memcpy(&raw_mxx, &tmp_mxx, sizeof(tmp_mxx));
  if (raw_mxx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_mxx(), target);
  }

  // double mxy = 2 [json_name = "mxy"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxy = this->_internal_mxy();
  ::uint64_t raw_mxy;
  memcpy(&raw_mxy, &tmp_mxy, sizeof(tmp_mxy));
  if (raw_mxy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_mxy(), target);
  }

  // double myy = 3 [json_name = "myy"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_myy = this->_internal_myy();
  ::uint64_t raw_myy;
  memcpy(&raw_myy, &tmp_myy, sizeof(tmp_myy));
  if (raw_myy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_myy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.TMat2)
  return target;
}

::size_t TMat2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.TMat2)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double mxx = 1 [json_name = "mxx"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxx = this->_internal_mxx();
  ::uint64_t raw_mxx;
  memcpy(&raw_mxx, &tmp_mxx, sizeof(tmp_mxx));
  if (raw_mxx != 0) {
    total_size += 9;
  }

  // double mxy = 2 [json_name = "mxy"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxy = this->_internal_mxy();
  ::uint64_t raw_mxy;
  memcpy(&raw_mxy, &tmp_mxy, sizeof(tmp_mxy));
  if (raw_mxy != 0) {
    total_size += 9;
  }

  // double myy = 3 [json_name = "myy"];
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_myy = this->_internal_myy();
  ::uint64_t raw_myy;
  memcpy(&raw_myy, &tmp_myy, sizeof(tmp_myy));
  if (raw_myy != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData TMat2::_class_data_ = {
    TMat2::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* TMat2::GetClassData() const {
  return &_class_data_;
}

void TMat2::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<TMat2*>(&to_msg);
  auto& from = static_cast<const TMat2&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.TMat2)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxx = from._internal_mxx();
  ::uint64_t raw_mxx;
  memcpy(&raw_mxx, &tmp_mxx, sizeof(tmp_mxx));
  if (raw_mxx != 0) {
    _this->_internal_set_mxx(from._internal_mxx());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_mxy = from._internal_mxy();
  ::uint64_t raw_mxy;
  memcpy(&raw_mxy, &tmp_mxy, sizeof(tmp_mxy));
  if (raw_mxy != 0) {
    _this->_internal_set_mxy(from._internal_mxy());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_myy = from._internal_myy();
  ::uint64_t raw_myy;
  memcpy(&raw_myy, &tmp_myy, sizeof(tmp_myy));
  if (raw_myy != 0) {
    _this->_internal_set_myy(from._internal_myy());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TMat2::CopyFrom(const TMat2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.TMat2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TMat2::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* TMat2::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void TMat2::InternalSwap(TMat2* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMat2, _impl_.myy_)
      + sizeof(TMat2::_impl_.myy_)
      - PROTOBUF_FIELD_OFFSET(TMat2, _impl_.mxx_)>(
          reinterpret_cast<char*>(&_impl_.mxx_),
          reinterpret_cast<char*>(&other->_impl_.mxx_));
}

::google::protobuf::Metadata TMat2::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[20]);
}
// ===================================================================

class RigidTransform::_Internal {
 public:
  using HasBits = decltype(std::declval<RigidTransform>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RigidTransform, _impl_._has_bits_);
  static const ::anduril::type::Quaternion& rotation(const RigidTransform* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::anduril::type::Vec3& translation(const RigidTransform* msg);
  static void set_has_translation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::anduril::type::Quaternion& RigidTransform::_Internal::rotation(const RigidTransform* msg) {
  return *msg->_impl_.rotation_;
}
const ::anduril::type::Vec3& RigidTransform::_Internal::translation(const RigidTransform* msg) {
  return *msg->_impl_.translation_;
}
RigidTransform::RigidTransform(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:anduril.type.RigidTransform)
}
inline PROTOBUF_NDEBUG_INLINE RigidTransform::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RigidTransform::RigidTransform(
    ::google::protobuf::Arena* arena,
    const RigidTransform& from)
    : ::google::protobuf::Message(arena) {
  RigidTransform* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.rotation_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::anduril::type::Quaternion>(arena, *from._impl_.rotation_)
                : nullptr;
  _impl_.translation_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::anduril::type::Vec3>(arena, *from._impl_.translation_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:anduril.type.RigidTransform)
}
inline PROTOBUF_NDEBUG_INLINE RigidTransform::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void RigidTransform::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, rotation_),
           0,
           offsetof(Impl_, translation_) -
               offsetof(Impl_, rotation_) +
               sizeof(Impl_::translation_));
}
RigidTransform::~RigidTransform() {
  // @@protoc_insertion_point(destructor:anduril.type.RigidTransform)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RigidTransform::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.rotation_;
  delete _impl_.translation_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RigidTransform::Clear() {
// @@protoc_insertion_point(message_clear_start:anduril.type.RigidTransform)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.translation_ != nullptr);
      _impl_.translation_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RigidTransform::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> RigidTransform::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RigidTransform, _impl_._has_bits_),
    0, // no _extensions_
    4, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967283,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RigidTransform_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .anduril.type.Vec3 translation = 4 [json_name = "translation"];
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 1, PROTOBUF_FIELD_OFFSET(RigidTransform, _impl_.translation_)}},
    // .anduril.type.Quaternion rotation = 3 [json_name = "rotation"];
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(RigidTransform, _impl_.rotation_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .anduril.type.Quaternion rotation = 3 [json_name = "rotation"];
    {PROTOBUF_FIELD_OFFSET(RigidTransform, _impl_.rotation_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .anduril.type.Vec3 translation = 4 [json_name = "translation"];
    {PROTOBUF_FIELD_OFFSET(RigidTransform, _impl_.translation_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::anduril::type::Quaternion>()},
    {::_pbi::TcParser::GetTable<::anduril::type::Vec3>()},
  }}, {{
  }},
};

::uint8_t* RigidTransform::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:anduril.type.RigidTransform)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .anduril.type.Quaternion rotation = 3 [json_name = "rotation"];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // .anduril.type.Vec3 translation = 4 [json_name = "translation"];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::translation(this),
        _Internal::translation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:anduril.type.RigidTransform)
  return target;
}

::size_t RigidTransform::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:anduril.type.RigidTransform)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .anduril.type.Quaternion rotation = 3 [json_name = "rotation"];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.rotation_);
    }

    // .anduril.type.Vec3 translation = 4 [json_name = "translation"];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.translation_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RigidTransform::_class_data_ = {
    RigidTransform::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RigidTransform::GetClassData() const {
  return &_class_data_;
}

void RigidTransform::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RigidTransform*>(&to_msg);
  auto& from = static_cast<const RigidTransform&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:anduril.type.RigidTransform)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_rotation()->::anduril::type::Quaternion::MergeFrom(
          from._internal_rotation());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_translation()->::anduril::type::Vec3::MergeFrom(
          from._internal_translation());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RigidTransform::CopyFrom(const RigidTransform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:anduril.type.RigidTransform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RigidTransform::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RigidTransform::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RigidTransform::InternalSwap(RigidTransform* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RigidTransform, _impl_.translation_)
      + sizeof(RigidTransform::_impl_.translation_)
      - PROTOBUF_FIELD_OFFSET(RigidTransform, _impl_.rotation_)>(
          reinterpret_cast<char*>(&_impl_.rotation_),
          reinterpret_cast<char*>(&other->_impl_.rotation_));
}

::google::protobuf::Metadata RigidTransform::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_getter, &descriptor_table_anduril_2ftype_2fcoords_2epub_2eproto_once,
      file_level_metadata_anduril_2ftype_2fcoords_2epub_2eproto[21]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace type
}  // namespace anduril
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
